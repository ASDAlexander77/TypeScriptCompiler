#include "config.h"
#include "enums.h"
#include "types.h"

namespace ts
{
    namespace Diagnostics
    {
        static DiagnosticMessageStore Unterminated_string_literal = {1002, DiagnosticCategory::Error, S("Unterminated_string_literal_1002"), S("Unterminated string literal.")};
        static DiagnosticMessageStore Identifier_expected = {1003, DiagnosticCategory::Error, S("Identifier_expected_1003"), S("Identifier expected.")};
        static DiagnosticMessageStore _0_expected = {1005, DiagnosticCategory::Error, S("_0_expected_1005"), S("'{0}' expected.")};
        static DiagnosticMessageStore A_file_cannot_have_a_reference_to_itself = {1006, DiagnosticCategory::Error, S("A_file_cannot_have_a_reference_to_itself_1006"), S("A file cannot have a reference to itself.")};
        static DiagnosticMessageStore The_parser_expected_to_find_a_to_match_the_token_here = {1007, DiagnosticCategory::Error, S("The_parser_expected_to_find_a_to_match_the_token_here_1007"), S("The parser expected to find a '}' to match the '{' token here.")};
        static DiagnosticMessageStore Trailing_comma_not_allowed = {1009, DiagnosticCategory::Error, S("Trailing_comma_not_allowed_1009"), S("Trailing comma not allowed.")};
        static DiagnosticMessageStore Asterisk_Slash_expected = {1010, DiagnosticCategory::Error, S("Asterisk_Slash_expected_1010"), S("'*/' expected.")};
        static DiagnosticMessageStore An_element_access_expression_should_take_an_argument = {1011, DiagnosticCategory::Error, S("An_element_access_expression_should_take_an_argument_1011"), S("An element access expression should take an argument.")};
        static DiagnosticMessageStore Unexpected_token = {1012, DiagnosticCategory::Error, S("Unexpected_token_1012"), S("Unexpected token.")};
        static DiagnosticMessageStore A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma = {1013, DiagnosticCategory::Error, S("A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma_1013"), S("A rest parameter or binding pattern may not have a trailing comma.")};
        static DiagnosticMessageStore A_rest_parameter_must_be_last_in_a_parameter_list = {1014, DiagnosticCategory::Error, S("A_rest_parameter_must_be_last_in_a_parameter_list_1014"), S("A rest parameter must be last in a parameter list.")};
        static DiagnosticMessageStore Parameter_cannot_have_question_mark_and_initializer = {1015, DiagnosticCategory::Error, S("Parameter_cannot_have_question_mark_and_initializer_1015"), S("Parameter cannot have question mark and initializer.")};
        static DiagnosticMessageStore A_required_parameter_cannot_follow_an_optional_parameter = {1016, DiagnosticCategory::Error, S("A_required_parameter_cannot_follow_an_optional_parameter_1016"), S("A required parameter cannot follow an optional parameter.")};
        static DiagnosticMessageStore An_index_signature_cannot_have_a_rest_parameter = {1017, DiagnosticCategory::Error, S("An_index_signature_cannot_have_a_rest_parameter_1017"), S("An index signature cannot have a rest parameter.")};
        static DiagnosticMessageStore An_index_signature_parameter_cannot_have_an_accessibility_modifier = {1018, DiagnosticCategory::Error, S("An_index_signature_parameter_cannot_have_an_accessibility_modifier_1018"), S("An index signature parameter cannot have an accessibility modifier.")};
        static DiagnosticMessageStore An_index_signature_parameter_cannot_have_a_question_mark = {1019, DiagnosticCategory::Error, S("An_index_signature_parameter_cannot_have_a_question_mark_1019"), S("An index signature parameter cannot have a question mark.")};
        static DiagnosticMessageStore An_index_signature_parameter_cannot_have_an_initializer = {1020, DiagnosticCategory::Error, S("An_index_signature_parameter_cannot_have_an_initializer_1020"), S("An index signature parameter cannot have an initializer.")};
        static DiagnosticMessageStore An_index_signature_must_have_a_type_annotation = {1021, DiagnosticCategory::Error, S("An_index_signature_must_have_a_type_annotation_1021"), S("An index signature must have a type annotation.")};
        static DiagnosticMessageStore An_index_signature_parameter_must_have_a_type_annotation = {1022, DiagnosticCategory::Error, S("An_index_signature_parameter_must_have_a_type_annotation_1022"), S("An index signature parameter must have a type annotation.")};
        static DiagnosticMessageStore An_index_signature_parameter_type_must_be_either_string_or_number = {1023, DiagnosticCategory::Error, S("An_index_signature_parameter_type_must_be_either_string_or_number_1023"), S("An index signature parameter type must be either 'string' or 'number'.")};
        static DiagnosticMessageStore readonly_modifier_can_only_appear_on_a_property_declaration_or_index_signature = {1024, DiagnosticCategory::Error, S("readonly_modifier_can_only_appear_on_a_property_declaration_or_index_signature_1024"), S("'readonly' modifier can only appear on a property declaration or index signature.")};
        static DiagnosticMessageStore An_index_signature_cannot_have_a_trailing_comma = {1025, DiagnosticCategory::Error, S("An_index_signature_cannot_have_a_trailing_comma_1025"), S("An index signature cannot have a trailing comma.")};
        static DiagnosticMessageStore Accessibility_modifier_already_seen = {1028, DiagnosticCategory::Error, S("Accessibility_modifier_already_seen_1028"), S("Accessibility modifier already seen.")};
        static DiagnosticMessageStore _0_modifier_must_precede_1_modifier = {1029, DiagnosticCategory::Error, S("_0_modifier_must_precede_1_modifier_1029"), S("'{0}' modifier must precede '{1}' modifier.")};
        static DiagnosticMessageStore _0_modifier_already_seen = {1030, DiagnosticCategory::Error, S("_0_modifier_already_seen_1030"), S("'{0}' modifier already seen.")};
        static DiagnosticMessageStore _0_modifier_cannot_appear_on_class_elements_of_this_kind = {1031, DiagnosticCategory::Error, S("_0_modifier_cannot_appear_on_class_elements_of_this_kind_1031"), S("'{0}' modifier cannot appear on class elements of this kind.")};
        static DiagnosticMessageStore super_must_be_followed_by_an_argument_list_or_member_access = {1034, DiagnosticCategory::Error, S("super_must_be_followed_by_an_argument_list_or_member_access_1034"), S("'super' must be followed by an argument list or member access.")};
        static DiagnosticMessageStore Only_ambient_modules_can_use_quoted_names = {1035, DiagnosticCategory::Error, S("Only_ambient_modules_can_use_quoted_names_1035"), S("Only ambient modules can use quoted names.")};
        static DiagnosticMessageStore Statements_are_not_allowed_in_ambient_contexts = {1036, DiagnosticCategory::Error, S("Statements_are_not_allowed_in_ambient_contexts_1036"), S("Statements are not allowed in ambient contexts.")};
        static DiagnosticMessageStore A_declare_modifier_cannot_be_used_in_an_already_ambient_context = {1038, DiagnosticCategory::Error, S("A_declare_modifier_cannot_be_used_in_an_already_ambient_context_1038"), S("A 'declare' modifier cannot be used in an already ambient context.")};
        static DiagnosticMessageStore Initializers_are_not_allowed_in_ambient_contexts = {1039, DiagnosticCategory::Error, S("Initializers_are_not_allowed_in_ambient_contexts_1039"), S("Initializers are not allowed in ambient contexts.")};
        static DiagnosticMessageStore _0_modifier_cannot_be_used_in_an_ambient_context = {1040, DiagnosticCategory::Error, S("_0_modifier_cannot_be_used_in_an_ambient_context_1040"), S("'{0}' modifier cannot be used in an ambient context.")};
        static DiagnosticMessageStore _0_modifier_cannot_be_used_with_a_class_declaration = {1041, DiagnosticCategory::Error, S("_0_modifier_cannot_be_used_with_a_class_declaration_1041"), S("'{0}' modifier cannot be used with a class declaration.")};
        static DiagnosticMessageStore _0_modifier_cannot_be_used_here = {1042, DiagnosticCategory::Error, S("_0_modifier_cannot_be_used_here_1042"), S("'{0}' modifier cannot be used here.")};
        static DiagnosticMessageStore _0_modifier_cannot_appear_on_a_data_property = {1043, DiagnosticCategory::Error, S("_0_modifier_cannot_appear_on_a_data_property_1043"), S("'{0}' modifier cannot appear on a data property.")};
        static DiagnosticMessageStore _0_modifier_cannot_appear_on_a_module_or_namespace_element = {1044, DiagnosticCategory::Error, S("_0_modifier_cannot_appear_on_a_module_or_namespace_element_1044"), S("'{0}' modifier cannot appear on a module or namespace element.")};
        static DiagnosticMessageStore A_0_modifier_cannot_be_used_with_an_interface_declaration = {1045, DiagnosticCategory::Error, S("A_0_modifier_cannot_be_used_with_an_interface_declaration_1045"), S("A '{0}' modifier cannot be used with an interface declaration.")};
        static DiagnosticMessageStore Top_level_declarations_in_d_ts_files_must_start_with_either_a_declare_or_export_modifier = {1046, DiagnosticCategory::Error, S("Top_level_declarations_in_d_ts_files_must_start_with_either_a_declare_or_export_modifier_1046"), S("Top-level declarations in .d.ts files must start with either a 'declare' or 'export' modifier.")};
        static DiagnosticMessageStore A_rest_parameter_cannot_be_optional = {1047, DiagnosticCategory::Error, S("A_rest_parameter_cannot_be_optional_1047"), S("A rest parameter cannot be optional.")};
        static DiagnosticMessageStore A_rest_parameter_cannot_have_an_initializer = {1048, DiagnosticCategory::Error, S("A_rest_parameter_cannot_have_an_initializer_1048"), S("A rest parameter cannot have an initializer.")};
        static DiagnosticMessageStore A_set_accessor_must_have_exactly_one_parameter = {1049, DiagnosticCategory::Error, S("A_set_accessor_must_have_exactly_one_parameter_1049"), S("A 'set' accessor must have exactly one parameter.")};
        static DiagnosticMessageStore A_set_accessor_cannot_have_an_optional_parameter = {1051, DiagnosticCategory::Error, S("A_set_accessor_cannot_have_an_optional_parameter_1051"), S("A 'set' accessor cannot have an optional parameter.")};
        static DiagnosticMessageStore A_set_accessor_parameter_cannot_have_an_initializer = {1052, DiagnosticCategory::Error, S("A_set_accessor_parameter_cannot_have_an_initializer_1052"), S("A 'set' accessor parameter cannot have an initializer.")};
        static DiagnosticMessageStore A_set_accessor_cannot_have_rest_parameter = {1053, DiagnosticCategory::Error, S("A_set_accessor_cannot_have_rest_parameter_1053"), S("A 'set' accessor cannot have rest parameter.")};
        static DiagnosticMessageStore A_get_accessor_cannot_have_parameters = {1054, DiagnosticCategory::Error, S("A_get_accessor_cannot_have_parameters_1054"), S("A 'get' accessor cannot have parameters.")};
        static DiagnosticMessageStore Type_0_is_not_a_valid_async_function_return_type_in_ES5_SlashES3_because_it_does_not_refer_to_a_Promise_compatible_constructor_value = {1055, DiagnosticCategory::Error, S("Type_0_is_not_a_valid_async_function_return_type_in_ES5_SlashES3_because_it_does_not_refer_to_a_Prom_1055"), S("Type '{0}' is not a valid async function return type in ES5/ES3 because it does not refer to a Promise-compatible constructor value.")};
        static DiagnosticMessageStore Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher = {1056, DiagnosticCategory::Error, S("Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher_1056"), S("Accessors are only available when targeting ECMAScript 5 and higher.")};
        static DiagnosticMessageStore An_async_function_or_method_must_have_a_valid_awaitable_return_type = {1057, DiagnosticCategory::Error, S("An_async_function_or_method_must_have_a_valid_awaitable_return_type_1057"), S("An async function or method must have a valid awaitable return type.")};
        static DiagnosticMessageStore The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member = {1058, DiagnosticCategory::Error, S("The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_t_1058"), S("The return type of an async function must either be a valid promise or must not contain a callable 'then' member.")};
        static DiagnosticMessageStore A_promise_must_have_a_then_method = {1059, DiagnosticCategory::Error, S("A_promise_must_have_a_then_method_1059"), S("A promise must have a 'then' method.")};
        static DiagnosticMessageStore The_first_parameter_of_the_then_method_of_a_promise_must_be_a_callback = {1060, DiagnosticCategory::Error, S("The_first_parameter_of_the_then_method_of_a_promise_must_be_a_callback_1060"), S("The first parameter of the 'then' method of a promise must be a callback.")};
        static DiagnosticMessageStore Enum_member_must_have_initializer = {1061, DiagnosticCategory::Error, S("Enum_member_must_have_initializer_1061"), S("Enum member must have initializer.")};
        static DiagnosticMessageStore Type_is_referenced_directly_or_indirectly_in_the_fulfillment_callback_of_its_own_then_method = {1062, DiagnosticCategory::Error, S("Type_is_referenced_directly_or_indirectly_in_the_fulfillment_callback_of_its_own_then_method_1062"), S("Type is referenced directly or indirectly in the fulfillment callback of its own 'then' method.")};
        static DiagnosticMessageStore An_export_assignment_cannot_be_used_in_a_namespace = {1063, DiagnosticCategory::Error, S("An_export_assignment_cannot_be_used_in_a_namespace_1063"), S("An export assignment cannot be used in a namespace.")};
        static DiagnosticMessageStore The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type_Did_you_mean_to_write_Promise_0 = {1064, DiagnosticCategory::Error, S("The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type_Did_you_mean_to_wri_1064"), S("The return type of an async function or method must be the global Promise<T> type. Did you mean to write 'Promise<{0}>'?")};
        static DiagnosticMessageStore In_ambient_enum_declarations_member_initializer_must_be_constant_expression = {1066, DiagnosticCategory::Error, S("In_ambient_enum_declarations_member_initializer_must_be_constant_expression_1066"), S("In ambient enum declarations member initializer must be constant expression.")};
        static DiagnosticMessageStore Unexpected_token_A_constructor_method_accessor_or_property_was_expected = {1068, DiagnosticCategory::Error, S("Unexpected_token_A_constructor_method_accessor_or_property_was_expected_1068"), S("Unexpected token. A constructor, method, accessor, or property was expected.")};
        static DiagnosticMessageStore Unexpected_token_A_type_parameter_name_was_expected_without_curly_braces = {1069, DiagnosticCategory::Error, S("Unexpected_token_A_type_parameter_name_was_expected_without_curly_braces_1069"), S("Unexpected token. A type parameter name was expected without curly braces.")};
        static DiagnosticMessageStore _0_modifier_cannot_appear_on_a_type_member = {1070, DiagnosticCategory::Error, S("_0_modifier_cannot_appear_on_a_type_member_1070"), S("'{0}' modifier cannot appear on a type member.")};
        static DiagnosticMessageStore _0_modifier_cannot_appear_on_an_index_signature = {1071, DiagnosticCategory::Error, S("_0_modifier_cannot_appear_on_an_index_signature_1071"), S("'{0}' modifier cannot appear on an index signature.")};
        static DiagnosticMessageStore A_0_modifier_cannot_be_used_with_an_import_declaration = {1079, DiagnosticCategory::Error, S("A_0_modifier_cannot_be_used_with_an_import_declaration_1079"), S("A '{0}' modifier cannot be used with an import declaration.")};
        static DiagnosticMessageStore Invalid_reference_directive_syntax = {1084, DiagnosticCategory::Error, S("Invalid_reference_directive_syntax_1084"), S("Invalid 'reference' directive syntax.")};
        static DiagnosticMessageStore Octal_literals_are_not_available_when_targeting_ECMAScript_5_and_higher_Use_the_syntax_0 = {1085, DiagnosticCategory::Error, S("Octal_literals_are_not_available_when_targeting_ECMAScript_5_and_higher_Use_the_syntax_0_1085"), S("Octal literals are not available when targeting ECMAScript 5 and higher. Use the syntax '{0}'.")};
        static DiagnosticMessageStore _0_modifier_cannot_appear_on_a_constructor_declaration = {1089, DiagnosticCategory::Error, S("_0_modifier_cannot_appear_on_a_constructor_declaration_1089"), S("'{0}' modifier cannot appear on a constructor declaration.")};
        static DiagnosticMessageStore _0_modifier_cannot_appear_on_a_parameter = {1090, DiagnosticCategory::Error, S("_0_modifier_cannot_appear_on_a_parameter_1090"), S("'{0}' modifier cannot appear on a parameter.")};
        static DiagnosticMessageStore Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement = {1091, DiagnosticCategory::Error, S("Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement_1091"), S("Only a single variable declaration is allowed in a 'for...in' statement.")};
        static DiagnosticMessageStore Type_parameters_cannot_appear_on_a_constructor_declaration = {1092, DiagnosticCategory::Error, S("Type_parameters_cannot_appear_on_a_constructor_declaration_1092"), S("Type parameters cannot appear on a constructor declaration.")};
        static DiagnosticMessageStore Type_annotation_cannot_appear_on_a_constructor_declaration = {1093, DiagnosticCategory::Error, S("Type_annotation_cannot_appear_on_a_constructor_declaration_1093"), S("Type annotation cannot appear on a constructor declaration.")};
        static DiagnosticMessageStore An_accessor_cannot_have_type_parameters = {1094, DiagnosticCategory::Error, S("An_accessor_cannot_have_type_parameters_1094"), S("An accessor cannot have type parameters.")};
        static DiagnosticMessageStore A_set_accessor_cannot_have_a_return_type_annotation = {1095, DiagnosticCategory::Error, S("A_set_accessor_cannot_have_a_return_type_annotation_1095"), S("A 'set' accessor cannot have a return type annotation.")};
        static DiagnosticMessageStore An_index_signature_must_have_exactly_one_parameter = {1096, DiagnosticCategory::Error, S("An_index_signature_must_have_exactly_one_parameter_1096"), S("An index signature must have exactly one parameter.")};
        static DiagnosticMessageStore _0_list_cannot_be_empty = {1097, DiagnosticCategory::Error, S("_0_list_cannot_be_empty_1097"), S("'{0}' list cannot be empty.")};
        static DiagnosticMessageStore Type_parameter_list_cannot_be_empty = {1098, DiagnosticCategory::Error, S("Type_parameter_list_cannot_be_empty_1098"), S("Type parameter list cannot be empty.")};
        static DiagnosticMessageStore Type_argument_list_cannot_be_empty = {1099, DiagnosticCategory::Error, S("Type_argument_list_cannot_be_empty_1099"), S("Type argument list cannot be empty.")};
        static DiagnosticMessageStore Invalid_use_of_0_in_strict_mode = {1100, DiagnosticCategory::Error, S("Invalid_use_of_0_in_strict_mode_1100"), S("Invalid use of '{0}' in strict mode.")};
        static DiagnosticMessageStore with_statements_are_not_allowed_in_strict_mode = {1101, DiagnosticCategory::Error, S("with_statements_are_not_allowed_in_strict_mode_1101"), S("'with' statements are not allowed in strict mode.")};
        static DiagnosticMessageStore delete_cannot_be_called_on_an_identifier_in_strict_mode = {1102, DiagnosticCategory::Error, S("delete_cannot_be_called_on_an_identifier_in_strict_mode_1102"), S("'delete' cannot be called on an identifier in strict mode.")};
        static DiagnosticMessageStore A_for_await_of_statement_is_only_allowed_within_an_async_function_or_async_generator = {1103, DiagnosticCategory::Error, S("A_for_await_of_statement_is_only_allowed_within_an_async_function_or_async_generator_1103"), S("A 'for-await-of' statement is only allowed within an async function or async generator.")};
        static DiagnosticMessageStore A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement = {1104, DiagnosticCategory::Error, S("A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement_1104"), S("A 'continue' statement can only be used within an enclosing iteration statement.")};
        static DiagnosticMessageStore A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement = {1105, DiagnosticCategory::Error, S("A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement_1105"), S("A 'break' statement can only be used within an enclosing iteration or switch statement.")};
        static DiagnosticMessageStore Jump_target_cannot_cross_function_boundary = {1107, DiagnosticCategory::Error, S("Jump_target_cannot_cross_function_boundary_1107"), S("Jump target cannot cross function boundary.")};
        static DiagnosticMessageStore A_return_statement_can_only_be_used_within_a_function_body = {1108, DiagnosticCategory::Error, S("A_return_statement_can_only_be_used_within_a_function_body_1108"), S("A 'return' statement can only be used within a function body.")};
        static DiagnosticMessageStore Expression_expected = {1109, DiagnosticCategory::Error, S("Expression_expected_1109"), S("Expression expected.")};
        static DiagnosticMessageStore Type_expected = {1110, DiagnosticCategory::Error, S("Type_expected_1110"), S("Type expected.")};
        static DiagnosticMessageStore A_default_clause_cannot_appear_more_than_once_in_a_switch_statement = {1113, DiagnosticCategory::Error, S("A_default_clause_cannot_appear_more_than_once_in_a_switch_statement_1113"), S("A 'default' clause cannot appear more than once in a 'switch' statement.")};
        static DiagnosticMessageStore Duplicate_label_0 = {1114, DiagnosticCategory::Error, S("Duplicate_label_0_1114"), S("Duplicate label '{0}'.")};
        static DiagnosticMessageStore A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement = {1115, DiagnosticCategory::Error, S("A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement_1115"), S("A 'continue' statement can only jump to a label of an enclosing iteration statement.")};
        static DiagnosticMessageStore A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement = {1116, DiagnosticCategory::Error, S("A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement_1116"), S("A 'break' statement can only jump to a label of an enclosing statement.")};
        static DiagnosticMessageStore An_object_literal_cannot_have_multiple_properties_with_the_same_name_in_strict_mode = {1117, DiagnosticCategory::Error, S("An_object_literal_cannot_have_multiple_properties_with_the_same_name_in_strict_mode_1117"), S("An object literal cannot have multiple properties with the same name in strict mode.")};
        static DiagnosticMessageStore An_object_literal_cannot_have_multiple_get_Slashset_accessors_with_the_same_name = {1118, DiagnosticCategory::Error, S("An_object_literal_cannot_have_multiple_get_Slashset_accessors_with_the_same_name_1118"), S("An object literal cannot have multiple get/set accessors with the same name.")};
        static DiagnosticMessageStore An_object_literal_cannot_have_property_and_accessor_with_the_same_name = {1119, DiagnosticCategory::Error, S("An_object_literal_cannot_have_property_and_accessor_with_the_same_name_1119"), S("An object literal cannot have property and accessor with the same name.")};
        static DiagnosticMessageStore An_export_assignment_cannot_have_modifiers = {1120, DiagnosticCategory::Error, S("An_export_assignment_cannot_have_modifiers_1120"), S("An export assignment cannot have modifiers.")};
        static DiagnosticMessageStore Octal_literals_are_not_allowed_in_strict_mode = {1121, DiagnosticCategory::Error, S("Octal_literals_are_not_allowed_in_strict_mode_1121"), S("Octal literals are not allowed in strict mode.")};
        static DiagnosticMessageStore Variable_declaration_list_cannot_be_empty = {1123, DiagnosticCategory::Error, S("Variable_declaration_list_cannot_be_empty_1123"), S("Variable declaration list cannot be empty.")};
        static DiagnosticMessageStore Digit_expected = {1124, DiagnosticCategory::Error, S("Digit_expected_1124"), S("Digit expected.")};
        static DiagnosticMessageStore Hexadecimal_digit_expected = {1125, DiagnosticCategory::Error, S("Hexadecimal_digit_expected_1125"), S("Hexadecimal digit expected.")};
        static DiagnosticMessageStore Unexpected_end_of_text = {1126, DiagnosticCategory::Error, S("Unexpected_end_of_text_1126"), S("Unexpected end of text.")};
        static DiagnosticMessageStore Invalid_character = {1127, DiagnosticCategory::Error, S("Invalid_character_1127"), S("Invalid character.")};
        static DiagnosticMessageStore Declaration_or_statement_expected = {1128, DiagnosticCategory::Error, S("Declaration_or_statement_expected_1128"), S("Declaration or statement expected.")};
        static DiagnosticMessageStore Statement_expected = {1129, DiagnosticCategory::Error, S("Statement_expected_1129"), S("Statement expected.")};
        static DiagnosticMessageStore case_or_default_expected = {1130, DiagnosticCategory::Error, S("case_or_default_expected_1130"), S("'case' or 'default' expected.")};
        static DiagnosticMessageStore Property_or_signature_expected = {1131, DiagnosticCategory::Error, S("Property_or_signature_expected_1131"), S("Property or signature expected.")};
        static DiagnosticMessageStore Enum_member_expected = {1132, DiagnosticCategory::Error, S("Enum_member_expected_1132"), S("Enum member expected.")};
        static DiagnosticMessageStore Variable_declaration_expected = {1134, DiagnosticCategory::Error, S("Variable_declaration_expected_1134"), S("Variable declaration expected.")};
        static DiagnosticMessageStore Argument_expression_expected = {1135, DiagnosticCategory::Error, S("Argument_expression_expected_1135"), S("Argument expression expected.")};
        static DiagnosticMessageStore Property_assignment_expected = {1136, DiagnosticCategory::Error, S("Property_assignment_expected_1136"), S("Property assignment expected.")};
        static DiagnosticMessageStore Expression_or_comma_expected = {1137, DiagnosticCategory::Error, S("Expression_or_comma_expected_1137"), S("Expression or comma expected.")};
        static DiagnosticMessageStore Parameter_declaration_expected = {1138, DiagnosticCategory::Error, S("Parameter_declaration_expected_1138"), S("Parameter declaration expected.")};
        static DiagnosticMessageStore Type_parameter_declaration_expected = {1139, DiagnosticCategory::Error, S("Type_parameter_declaration_expected_1139"), S("Type parameter declaration expected.")};
        static DiagnosticMessageStore Type_argument_expected = {1140, DiagnosticCategory::Error, S("Type_argument_expected_1140"), S("Type argument expected.")};
        static DiagnosticMessageStore String_literal_expected = {1141, DiagnosticCategory::Error, S("String_literal_expected_1141"), S("String literal expected.")};
        static DiagnosticMessageStore Line_break_not_permitted_here = {1142, DiagnosticCategory::Error, S("Line_break_not_permitted_here_1142"), S("Line break not permitted here.")};
        static DiagnosticMessageStore or_expected = {1144, DiagnosticCategory::Error, S("or_expected_1144"), S("'{' or ';' expected.")};
        static DiagnosticMessageStore Declaration_expected = {1146, DiagnosticCategory::Error, S("Declaration_expected_1146"), S("Declaration expected.")};
        static DiagnosticMessageStore Import_declarations_in_a_namespace_cannot_reference_a_module = {1147, DiagnosticCategory::Error, S("Import_declarations_in_a_namespace_cannot_reference_a_module_1147"), S("Import declarations in a namespace cannot reference a module.")};
        static DiagnosticMessageStore Cannot_use_imports_exports_or_module_augmentations_when_module_is_none = {1148, DiagnosticCategory::Error, S("Cannot_use_imports_exports_or_module_augmentations_when_module_is_none_1148"), S("Cannot use imports, exports, or module augmentations when '--module' is 'none'.")};
        static DiagnosticMessageStore File_name_0_differs_from_already_included_file_name_1_only_in_casing = {1149, DiagnosticCategory::Error, S("File_name_0_differs_from_already_included_file_name_1_only_in_casing_1149"), S("File name '{0}' differs from already included file name '{1}' only in casing.")};
        static DiagnosticMessageStore const_declarations_must_be_initialized = {1155, DiagnosticCategory::Error, S("const_declarations_must_be_initialized_1155"), S("'const' declarations must be initialized.")};
        static DiagnosticMessageStore const_declarations_can_only_be_declared_inside_a_block = {1156, DiagnosticCategory::Error, S("const_declarations_can_only_be_declared_inside_a_block_1156"), S("'const' declarations can only be declared inside a block.")};
        static DiagnosticMessageStore let_declarations_can_only_be_declared_inside_a_block = {1157, DiagnosticCategory::Error, S("let_declarations_can_only_be_declared_inside_a_block_1157"), S("'let' declarations can only be declared inside a block.")};
        static DiagnosticMessageStore Unterminated_template_literal = {1160, DiagnosticCategory::Error, S("Unterminated_template_literal_1160"), S("Unterminated template literal.")};
        static DiagnosticMessageStore Unterminated_regular_expression_literal = {1161, DiagnosticCategory::Error, S("Unterminated_regular_expression_literal_1161"), S("Unterminated regular expression literal.")};
        static DiagnosticMessageStore An_object_member_cannot_be_declared_optional = {1162, DiagnosticCategory::Error, S("An_object_member_cannot_be_declared_optional_1162"), S("An object member cannot be declared optional.")};
        static DiagnosticMessageStore A_yield_expression_is_only_allowed_in_a_generator_body = {1163, DiagnosticCategory::Error, S("A_yield_expression_is_only_allowed_in_a_generator_body_1163"), S("A 'yield' expression is only allowed in a generator body.")};
        static DiagnosticMessageStore Computed_property_names_are_not_allowed_in_enums = {1164, DiagnosticCategory::Error, S("Computed_property_names_are_not_allowed_in_enums_1164"), S("Computed property names are not allowed in enums.")};
        static DiagnosticMessageStore A_computed_property_name_in_an_ambient_context_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type = {1165, DiagnosticCategory::Error, S("A_computed_property_name_in_an_ambient_context_must_refer_to_an_expression_whose_type_is_a_literal_t_1165"), S("A computed property name in an ambient context must refer to an expression whose type is a literal type or a 'unique symbol' type.")};
        static DiagnosticMessageStore A_computed_property_name_in_a_class_property_declaration_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type = {1166, DiagnosticCategory::Error, S("A_computed_property_name_in_a_class_property_declaration_must_refer_to_an_expression_whose_type_is_a_1166"), S("A computed property name in a class property declaration must refer to an expression whose type is a literal type or a 'unique symbol' type.")};
        static DiagnosticMessageStore A_computed_property_name_in_a_method_overload_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type = {1168, DiagnosticCategory::Error, S("A_computed_property_name_in_a_method_overload_must_refer_to_an_expression_whose_type_is_a_literal_ty_1168"), S("A computed property name in a method overload must refer to an expression whose type is a literal type or a 'unique symbol' type.")};
        static DiagnosticMessageStore A_computed_property_name_in_an_interface_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type = {1169, DiagnosticCategory::Error, S("A_computed_property_name_in_an_interface_must_refer_to_an_expression_whose_type_is_a_literal_type_or_1169"), S("A computed property name in an interface must refer to an expression whose type is a literal type or a 'unique symbol' type.")};
        static DiagnosticMessageStore A_computed_property_name_in_a_type_literal_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type = {1170, DiagnosticCategory::Error, S("A_computed_property_name_in_a_type_literal_must_refer_to_an_expression_whose_type_is_a_literal_type__1170"), S("A computed property name in a type literal must refer to an expression whose type is a literal type or a 'unique symbol' type.")};
        static DiagnosticMessageStore A_comma_expression_is_not_allowed_in_a_computed_property_name = {1171, DiagnosticCategory::Error, S("A_comma_expression_is_not_allowed_in_a_computed_property_name_1171"), S("A comma expression is not allowed in a computed property name.")};
        static DiagnosticMessageStore extends_clause_already_seen = {1172, DiagnosticCategory::Error, S("extends_clause_already_seen_1172"), S("'extends' clause already seen.")};
        static DiagnosticMessageStore extends_clause_must_precede_implements_clause = {1173, DiagnosticCategory::Error, S("extends_clause_must_precede_implements_clause_1173"), S("'extends' clause must precede 'implements' clause.")};
        static DiagnosticMessageStore Classes_can_only_extend_a_single_class = {1174, DiagnosticCategory::Error, S("Classes_can_only_extend_a_single_class_1174"), S("Classes can only extend a single class.")};
        static DiagnosticMessageStore implements_clause_already_seen = {1175, DiagnosticCategory::Error, S("implements_clause_already_seen_1175"), S("'implements' clause already seen.")};
        static DiagnosticMessageStore Interface_declaration_cannot_have_implements_clause = {1176, DiagnosticCategory::Error, S("Interface_declaration_cannot_have_implements_clause_1176"), S("Interface declaration cannot have 'implements' clause.")};
        static DiagnosticMessageStore Binary_digit_expected = {1177, DiagnosticCategory::Error, S("Binary_digit_expected_1177"), S("Binary digit expected.")};
        static DiagnosticMessageStore Octal_digit_expected = {1178, DiagnosticCategory::Error, S("Octal_digit_expected_1178"), S("Octal digit expected.")};
        static DiagnosticMessageStore Unexpected_token_expected = {1179, DiagnosticCategory::Error, S("Unexpected_token_expected_1179"), S("Unexpected token. '{' expected.")};
        static DiagnosticMessageStore Property_destructuring_pattern_expected = {1180, DiagnosticCategory::Error, S("Property_destructuring_pattern_expected_1180"), S("Property destructuring pattern expected.")};
        static DiagnosticMessageStore Array_element_destructuring_pattern_expected = {1181, DiagnosticCategory::Error, S("Array_element_destructuring_pattern_expected_1181"), S("Array element destructuring pattern expected.")};
        static DiagnosticMessageStore A_destructuring_declaration_must_have_an_initializer = {1182, DiagnosticCategory::Error, S("A_destructuring_declaration_must_have_an_initializer_1182"), S("A destructuring declaration must have an initializer.")};
        static DiagnosticMessageStore An_implementation_cannot_be_declared_in_ambient_contexts = {1183, DiagnosticCategory::Error, S("An_implementation_cannot_be_declared_in_ambient_contexts_1183"), S("An implementation cannot be declared in ambient contexts.")};
        static DiagnosticMessageStore Modifiers_cannot_appear_here = {1184, DiagnosticCategory::Error, S("Modifiers_cannot_appear_here_1184"), S("Modifiers cannot appear here.")};
        static DiagnosticMessageStore Merge_conflict_marker_encountered = {1185, DiagnosticCategory::Error, S("Merge_conflict_marker_encountered_1185"), S("Merge conflict marker encountered.")};
        static DiagnosticMessageStore A_rest_element_cannot_have_an_initializer = {1186, DiagnosticCategory::Error, S("A_rest_element_cannot_have_an_initializer_1186"), S("A rest element cannot have an initializer.")};
        static DiagnosticMessageStore A_parameter_property_may_not_be_declared_using_a_binding_pattern = {1187, DiagnosticCategory::Error, S("A_parameter_property_may_not_be_declared_using_a_binding_pattern_1187"), S("A parameter property may not be declared using a binding pattern.")};
        static DiagnosticMessageStore Only_a_single_variable_declaration_is_allowed_in_a_for_of_statement = {1188, DiagnosticCategory::Error, S("Only_a_single_variable_declaration_is_allowed_in_a_for_of_statement_1188"), S("Only a single variable declaration is allowed in a 'for...of' statement.")};
        static DiagnosticMessageStore The_variable_declaration_of_a_for_in_statement_cannot_have_an_initializer = {1189, DiagnosticCategory::Error, S("The_variable_declaration_of_a_for_in_statement_cannot_have_an_initializer_1189"), S("The variable declaration of a 'for...in' statement cannot have an initializer.")};
        static DiagnosticMessageStore The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer = {1190, DiagnosticCategory::Error, S("The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer_1190"), S("The variable declaration of a 'for...of' statement cannot have an initializer.")};
        static DiagnosticMessageStore An_import_declaration_cannot_have_modifiers = {1191, DiagnosticCategory::Error, S("An_import_declaration_cannot_have_modifiers_1191"), S("An import declaration cannot have modifiers.")};
        static DiagnosticMessageStore Module_0_has_no_default_export = {1192, DiagnosticCategory::Error, S("Module_0_has_no_default_export_1192"), S("Module '{0}' has no default export.")};
        static DiagnosticMessageStore An_export_declaration_cannot_have_modifiers = {1193, DiagnosticCategory::Error, S("An_export_declaration_cannot_have_modifiers_1193"), S("An export declaration cannot have modifiers.")};
        static DiagnosticMessageStore Export_declarations_are_not_permitted_in_a_namespace = {1194, DiagnosticCategory::Error, S("Export_declarations_are_not_permitted_in_a_namespace_1194"), S("Export declarations are not permitted in a namespace.")};
        static DiagnosticMessageStore export_Asterisk_does_not_re_export_a_default = {1195, DiagnosticCategory::Error, S("export_Asterisk_does_not_re_export_a_default_1195"), S("'export *' does not re-export a default.")};
        static DiagnosticMessageStore Catch_clause_variable_type_annotation_must_be_any_or_unknown_if_specified = {1196, DiagnosticCategory::Error, S("Catch_clause_variable_type_annotation_must_be_any_or_unknown_if_specified_1196"), S("Catch clause variable type annotation must be 'any' or 'unknown' if specified.")};
        static DiagnosticMessageStore Catch_clause_variable_cannot_have_an_initializer = {1197, DiagnosticCategory::Error, S("Catch_clause_variable_cannot_have_an_initializer_1197"), S("Catch clause variable cannot have an initializer.")};
        static DiagnosticMessageStore An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive = {1198, DiagnosticCategory::Error, S("An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive_1198"), S("An extended Unicode escape value must be between 0x0 and 0x10FFFF inclusive.")};
        static DiagnosticMessageStore Unterminated_Unicode_escape_sequence = {1199, DiagnosticCategory::Error, S("Unterminated_Unicode_escape_sequence_1199"), S("Unterminated Unicode escape sequence.")};
        static DiagnosticMessageStore Line_terminator_not_permitted_before_arrow = {1200, DiagnosticCategory::Error, S("Line_terminator_not_permitted_before_arrow_1200"), S("Line terminator not permitted before arrow.")};
        static DiagnosticMessageStore Import_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_import_Asterisk_as_ns_from_mod_import_a_from_mod_import_d_from_mod_or_another_module_format_instead = {1202, DiagnosticCategory::Error, S("Import_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_import_Asterisk_as_1202"), S("Import assignment cannot be used when targeting ECMAScript modules. Consider using 'import * as ns from \")mod\"', 'import {a} from \")mod\"', 'import d from \")mod\"', or another module format instead.")};
        static DiagnosticMessageStore Export_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_export_default_or_another_module_format_instead = {1203, DiagnosticCategory::Error, S("Export_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_export_default_or__1203"), S("Export assignment cannot be used when targeting ECMAScript modules. Consider using 'export default' or another module format instead.")};
        static DiagnosticMessageStore Re_exporting_a_type_when_the_isolatedModules_flag_is_provided_requires_using_export_type = {1205, DiagnosticCategory::Error, S("Re_exporting_a_type_when_the_isolatedModules_flag_is_provided_requires_using_export_type_1205"), S("Re-exporting a type when the '--isolatedModules' flag is provided requires using 'export type'.")};
        static DiagnosticMessageStore Decorators_are_not_valid_here = {1206, DiagnosticCategory::Error, S("Decorators_are_not_valid_here_1206"), S("Decorators are not valid here.")};
        static DiagnosticMessageStore Decorators_cannot_be_applied_to_multiple_get_Slashset_accessors_of_the_same_name = {1207, DiagnosticCategory::Error, S("Decorators_cannot_be_applied_to_multiple_get_Slashset_accessors_of_the_same_name_1207"), S("Decorators cannot be applied to multiple get/set accessors of the same name.")};
        static DiagnosticMessageStore _0_cannot_be_compiled_under_isolatedModules_because_it_is_considered_a_global_script_file_Add_an_import_export_or_an_empty_export_statement_to_make_it_a_module = {1208, DiagnosticCategory::Error, S("_0_cannot_be_compiled_under_isolatedModules_because_it_is_considered_a_global_script_file_Add_an_imp_1208"), S("'{0}' cannot be compiled under '--isolatedModules' because it is considered a global script file. Add an import, export, or an empty 'export {}' statement to make it a module.")};
        static DiagnosticMessageStore Invalid_use_of_0_Class_definitions_are_automatically_in_strict_mode = {1210, DiagnosticCategory::Error, S("Invalid_use_of_0_Class_definitions_are_automatically_in_strict_mode_1210"), S("Invalid use of '{0}'. Class definitions are automatically in strict mode.")};
        static DiagnosticMessageStore A_class_declaration_without_the_default_modifier_must_have_a_name = {1211, DiagnosticCategory::Error, S("A_class_declaration_without_the_default_modifier_must_have_a_name_1211"), S("A class declaration without the 'default' modifier must have a name.")};
        static DiagnosticMessageStore Identifier_expected_0_is_a_reserved_word_in_strict_mode = {1212, DiagnosticCategory::Error, S("Identifier_expected_0_is_a_reserved_word_in_strict_mode_1212"), S("Identifier expected. '{0}' is a reserved word in strict mode.")};
        static DiagnosticMessageStore Identifier_expected_0_is_a_reserved_word_in_strict_mode_Class_definitions_are_automatically_in_strict_mode = {1213, DiagnosticCategory::Error, S("Identifier_expected_0_is_a_reserved_word_in_strict_mode_Class_definitions_are_automatically_in_stric_1213"), S("Identifier expected. '{0}' is a reserved word in strict mode. Class definitions are automatically in strict mode.")};
        static DiagnosticMessageStore Identifier_expected_0_is_a_reserved_word_in_strict_mode_Modules_are_automatically_in_strict_mode = {1214, DiagnosticCategory::Error, S("Identifier_expected_0_is_a_reserved_word_in_strict_mode_Modules_are_automatically_in_strict_mode_1214"), S("Identifier expected. '{0}' is a reserved word in strict mode. Modules are automatically in strict mode.")};
        static DiagnosticMessageStore Invalid_use_of_0_Modules_are_automatically_in_strict_mode = {1215, DiagnosticCategory::Error, S("Invalid_use_of_0_Modules_are_automatically_in_strict_mode_1215"), S("Invalid use of '{0}'. Modules are automatically in strict mode.")};
        static DiagnosticMessageStore Identifier_expected_esModule_is_reserved_as_an_exported_marker_when_transforming_ECMAScript_modules = {1216, DiagnosticCategory::Error, S("Identifier_expected_esModule_is_reserved_as_an_exported_marker_when_transforming_ECMAScript_modules_1216"), S("Identifier expected. '__esModule' is reserved as an exported marker when transforming ECMAScript modules.")};
        static DiagnosticMessageStore Export_assignment_is_not_supported_when_module_flag_is_system = {1218, DiagnosticCategory::Error, S("Export_assignment_is_not_supported_when_module_flag_is_system_1218"), S("Export assignment is not supported when '--module' flag is 'system'.")};
        static DiagnosticMessageStore Experimental_support_for_decorators_is_a_feature_that_is_subject_to_change_in_a_future_release_Set_the_experimentalDecorators_option_in_your_tsconfig_or_jsconfig_to_remove_this_warning = {1219, DiagnosticCategory::Error, S("Experimental_support_for_decorators_is_a_feature_that_is_subject_to_change_in_a_future_release_Set_t_1219"), S("Experimental support for decorators is a feature that is subject to change in a future release. Set the 'experimentalDecorators' option in your 'tsconfig' or 'jsconfig' to remove this warning.")};
        static DiagnosticMessageStore Generators_are_only_available_when_targeting_ECMAScript_2015_or_higher = {1220, DiagnosticCategory::Error, S("Generators_are_only_available_when_targeting_ECMAScript_2015_or_higher_1220"), S("Generators are only available when targeting ECMAScript 2015 or higher.")};
        static DiagnosticMessageStore Generators_are_not_allowed_in_an_ambient_context = {1221, DiagnosticCategory::Error, S("Generators_are_not_allowed_in_an_ambient_context_1221"), S("Generators are not allowed in an ambient context.")};
        static DiagnosticMessageStore An_overload_signature_cannot_be_declared_as_a_generator = {1222, DiagnosticCategory::Error, S("An_overload_signature_cannot_be_declared_as_a_generator_1222"), S("An overload signature cannot be declared as a generator.")};
        static DiagnosticMessageStore _0_tag_already_specified = {1223, DiagnosticCategory::Error, S("_0_tag_already_specified_1223"), S("'{0}' tag already specified.")};
        static DiagnosticMessageStore Signature_0_must_be_a_type_predicate = {1224, DiagnosticCategory::Error, S("Signature_0_must_be_a_type_predicate_1224"), S("Signature '{0}' must be a type predicate.")};
        static DiagnosticMessageStore Cannot_find_parameter_0 = {1225, DiagnosticCategory::Error, S("Cannot_find_parameter_0_1225"), S("Cannot find parameter '{0}'.")};
        static DiagnosticMessageStore Type_predicate_0_is_not_assignable_to_1 = {1226, DiagnosticCategory::Error, S("Type_predicate_0_is_not_assignable_to_1_1226"), S("Type predicate '{0}' is not assignable to '{1}'.")};
        static DiagnosticMessageStore Parameter_0_is_not_in_the_same_position_as_parameter_1 = {1227, DiagnosticCategory::Error, S("Parameter_0_is_not_in_the_same_position_as_parameter_1_1227"), S("Parameter '{0}' is not in the same position as parameter '{1}'.")};
        static DiagnosticMessageStore A_type_predicate_is_only_allowed_in_return_type_position_for_functions_and_methods = {1228, DiagnosticCategory::Error, S("A_type_predicate_is_only_allowed_in_return_type_position_for_functions_and_methods_1228"), S("A type predicate is only allowed in return type position for functions and methods.")};
        static DiagnosticMessageStore A_type_predicate_cannot_reference_a_rest_parameter = {1229, DiagnosticCategory::Error, S("A_type_predicate_cannot_reference_a_rest_parameter_1229"), S("A type predicate cannot reference a rest parameter.")};
        static DiagnosticMessageStore A_type_predicate_cannot_reference_element_0_in_a_binding_pattern = {1230, DiagnosticCategory::Error, S("A_type_predicate_cannot_reference_element_0_in_a_binding_pattern_1230"), S("A type predicate cannot reference element '{0}' in a binding pattern.")};
        static DiagnosticMessageStore An_export_assignment_can_only_be_used_in_a_module = {1231, DiagnosticCategory::Error, S("An_export_assignment_can_only_be_used_in_a_module_1231"), S("An export assignment can only be used in a module.")};
        static DiagnosticMessageStore An_import_declaration_can_only_be_used_in_a_namespace_or_module = {1232, DiagnosticCategory::Error, S("An_import_declaration_can_only_be_used_in_a_namespace_or_module_1232"), S("An import declaration can only be used in a namespace or module.")};
        static DiagnosticMessageStore An_export_declaration_can_only_be_used_in_a_module = {1233, DiagnosticCategory::Error, S("An_export_declaration_can_only_be_used_in_a_module_1233"), S("An export declaration can only be used in a module.")};
        static DiagnosticMessageStore An_ambient_module_declaration_is_only_allowed_at_the_top_level_in_a_file = {1234, DiagnosticCategory::Error, S("An_ambient_module_declaration_is_only_allowed_at_the_top_level_in_a_file_1234"), S("An ambient module declaration is only allowed at the top level in a file.")};
        static DiagnosticMessageStore A_namespace_declaration_is_only_allowed_in_a_namespace_or_module = {1235, DiagnosticCategory::Error, S("A_namespace_declaration_is_only_allowed_in_a_namespace_or_module_1235"), S("A namespace declaration is only allowed in a namespace or module.")};
        static DiagnosticMessageStore The_return_type_of_a_property_decorator_function_must_be_either_void_or_any = {1236, DiagnosticCategory::Error, S("The_return_type_of_a_property_decorator_function_must_be_either_void_or_any_1236"), S("The return type of a property decorator function must be either 'void' or 'any'.")};
        static DiagnosticMessageStore The_return_type_of_a_parameter_decorator_function_must_be_either_void_or_any = {1237, DiagnosticCategory::Error, S("The_return_type_of_a_parameter_decorator_function_must_be_either_void_or_any_1237"), S("The return type of a parameter decorator function must be either 'void' or 'any'.")};
        static DiagnosticMessageStore Unable_to_resolve_signature_of_class_decorator_when_called_as_an_expression = {1238, DiagnosticCategory::Error, S("Unable_to_resolve_signature_of_class_decorator_when_called_as_an_expression_1238"), S("Unable to resolve signature of class decorator when called as an expression.")};
        static DiagnosticMessageStore Unable_to_resolve_signature_of_parameter_decorator_when_called_as_an_expression = {1239, DiagnosticCategory::Error, S("Unable_to_resolve_signature_of_parameter_decorator_when_called_as_an_expression_1239"), S("Unable to resolve signature of parameter decorator when called as an expression.")};
        static DiagnosticMessageStore Unable_to_resolve_signature_of_property_decorator_when_called_as_an_expression = {1240, DiagnosticCategory::Error, S("Unable_to_resolve_signature_of_property_decorator_when_called_as_an_expression_1240"), S("Unable to resolve signature of property decorator when called as an expression.")};
        static DiagnosticMessageStore Unable_to_resolve_signature_of_method_decorator_when_called_as_an_expression = {1241, DiagnosticCategory::Error, S("Unable_to_resolve_signature_of_method_decorator_when_called_as_an_expression_1241"), S("Unable to resolve signature of method decorator when called as an expression.")};
        static DiagnosticMessageStore abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration = {1242, DiagnosticCategory::Error, S("abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration_1242"), S("'abstract' modifier can only appear on a class, method, or property declaration.")};
        static DiagnosticMessageStore _0_modifier_cannot_be_used_with_1_modifier = {1243, DiagnosticCategory::Error, S("_0_modifier_cannot_be_used_with_1_modifier_1243"), S("'{0}' modifier cannot be used with '{1}' modifier.")};
        static DiagnosticMessageStore Abstract_methods_can_only_appear_within_an_abstract_class = {1244, DiagnosticCategory::Error, S("Abstract_methods_can_only_appear_within_an_abstract_class_1244"), S("Abstract methods can only appear within an abstract class.")};
        static DiagnosticMessageStore Method_0_cannot_have_an_implementation_because_it_is_marked_abstract = {1245, DiagnosticCategory::Error, S("Method_0_cannot_have_an_implementation_because_it_is_marked_abstract_1245"), S("Method '{0}' cannot have an implementation because it is marked abstract.")};
        static DiagnosticMessageStore An_interface_property_cannot_have_an_initializer = {1246, DiagnosticCategory::Error, S("An_interface_property_cannot_have_an_initializer_1246"), S("An interface property cannot have an initializer.")};
        static DiagnosticMessageStore A_type_literal_property_cannot_have_an_initializer = {1247, DiagnosticCategory::Error, S("A_type_literal_property_cannot_have_an_initializer_1247"), S("A type literal property cannot have an initializer.")};
        static DiagnosticMessageStore A_class_member_cannot_have_the_0_keyword = {1248, DiagnosticCategory::Error, S("A_class_member_cannot_have_the_0_keyword_1248"), S("A class member cannot have the '{0}' keyword.")};
        static DiagnosticMessageStore A_decorator_can_only_decorate_a_method_implementation_not_an_overload = {1249, DiagnosticCategory::Error, S("A_decorator_can_only_decorate_a_method_implementation_not_an_overload_1249"), S("A decorator can only decorate a method implementation, not an overload.")};
        static DiagnosticMessageStore Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5 = {1250, DiagnosticCategory::Error, S("Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5_1250"), S("Function declarations are not allowed inside blocks in strict mode when targeting 'ES3' or 'ES5'.")};
        static DiagnosticMessageStore Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5_Class_definitions_are_automatically_in_strict_mode = {1251, DiagnosticCategory::Error, S("Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5_Class_d_1251"), S("Function declarations are not allowed inside blocks in strict mode when targeting 'ES3' or 'ES5'. Class definitions are automatically in strict mode.")};
        static DiagnosticMessageStore Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5_Modules_are_automatically_in_strict_mode = {1252, DiagnosticCategory::Error, S("Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5_Modules_1252"), S("Function declarations are not allowed inside blocks in strict mode when targeting 'ES3' or 'ES5'. Modules are automatically in strict mode.")};
        static DiagnosticMessageStore _0_tag_cannot_be_used_independently_as_a_top_level_JSDoc_tag = {1253, DiagnosticCategory::Error, S("_0_tag_cannot_be_used_independently_as_a_top_level_JSDoc_tag_1253"), S("'{0}' tag cannot be used independently as a top level JSDoc tag.")};
        static DiagnosticMessageStore A_const_initializer_in_an_ambient_context_must_be_a_string_or_numeric_literal_or_literal_enum_reference = {1254, DiagnosticCategory::Error, S("A_const_initializer_in_an_ambient_context_must_be_a_string_or_numeric_literal_or_literal_enum_refere_1254"), S("A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.")};
        static DiagnosticMessageStore A_definite_assignment_assertion_is_not_permitted_in_this_context = {1255, DiagnosticCategory::Error, S("A_definite_assignment_assertion_is_not_permitted_in_this_context_1255"), S("A definite assignment assertion '!' is not permitted in this context.")};
        static DiagnosticMessageStore A_required_element_cannot_follow_an_optional_element = {1257, DiagnosticCategory::Error, S("A_required_element_cannot_follow_an_optional_element_1257"), S("A required element cannot follow an optional element.")};
        static DiagnosticMessageStore Module_0_can_only_be_default_imported_using_the_1_flag = {1259, DiagnosticCategory::Error, S("Module_0_can_only_be_default_imported_using_the_1_flag_1259"), S("Module '{0}' can only be default-imported using the '{1}' flag")};
        static DiagnosticMessageStore Keywords_cannot_contain_escape_characters = {1260, DiagnosticCategory::Error, S("Keywords_cannot_contain_escape_characters_1260"), S("Keywords cannot contain escape characters.")};
        static DiagnosticMessageStore Already_included_file_name_0_differs_from_file_name_1_only_in_casing = {1261, DiagnosticCategory::Error, S("Already_included_file_name_0_differs_from_file_name_1_only_in_casing_1261"), S("Already included file name '{0}' differs from file name '{1}' only in casing.")};
        static DiagnosticMessageStore Identifier_expected_0_is_a_reserved_word_at_the_top_level_of_a_module = {1262, DiagnosticCategory::Error, S("Identifier_expected_0_is_a_reserved_word_at_the_top_level_of_a_module_1262"), S("Identifier expected. '{0}' is a reserved word at the top-level of a module.")};
        static DiagnosticMessageStore Declarations_with_initializers_cannot_also_have_definite_assignment_assertions = {1263, DiagnosticCategory::Error, S("Declarations_with_initializers_cannot_also_have_definite_assignment_assertions_1263"), S("Declarations with initializers cannot also have definite assignment assertions.")};
        static DiagnosticMessageStore Declarations_with_definite_assignment_assertions_must_also_have_type_annotations = {1264, DiagnosticCategory::Error, S("Declarations_with_definite_assignment_assertions_must_also_have_type_annotations_1264"), S("Declarations with definite assignment assertions must also have type annotations.")};
        static DiagnosticMessageStore A_rest_element_cannot_follow_another_rest_element = {1265, DiagnosticCategory::Error, S("A_rest_element_cannot_follow_another_rest_element_1265"), S("A rest element cannot follow another rest element.")};
        static DiagnosticMessageStore An_optional_element_cannot_follow_a_rest_element = {1266, DiagnosticCategory::Error, S("An_optional_element_cannot_follow_a_rest_element_1266"), S("An optional element cannot follow a rest element.")};
        static DiagnosticMessageStore with_statements_are_not_allowed_in_an_async_function_block = {1300, DiagnosticCategory::Error, S("with_statements_are_not_allowed_in_an_async_function_block_1300"), S("'with' statements are not allowed in an async function block.")};
        static DiagnosticMessageStore await_expressions_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules = {1308, DiagnosticCategory::Error, S("await_expressions_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules_1308"), S("'await' expressions are only allowed within async functions and at the top levels of modules.")};
        static DiagnosticMessageStore Did_you_mean_to_use_a_Colon_An_can_only_follow_a_property_name_when_the_containing_object_literal_is_part_of_a_destructuring_pattern = {1312, DiagnosticCategory::Error, S("Did_you_mean_to_use_a_Colon_An_can_only_follow_a_property_name_when_the_containing_object_literal_is_1312"), S("Did you mean to use a ':'? An '=' can only follow a property name when the containing object literal is part of a destructuring pattern.")};
        static DiagnosticMessageStore The_body_of_an_if_statement_cannot_be_the_empty_statement = {1313, DiagnosticCategory::Error, S("The_body_of_an_if_statement_cannot_be_the_empty_statement_1313"), S("The body of an 'if' statement cannot be the empty statement.")};
        static DiagnosticMessageStore Global_module_exports_may_only_appear_in_module_files = {1314, DiagnosticCategory::Error, S("Global_module_exports_may_only_appear_in_module_files_1314"), S("Global module exports may only appear in module files.")};
        static DiagnosticMessageStore Global_module_exports_may_only_appear_in_declaration_files = {1315, DiagnosticCategory::Error, S("Global_module_exports_may_only_appear_in_declaration_files_1315"), S("Global module exports may only appear in declaration files.")};
        static DiagnosticMessageStore Global_module_exports_may_only_appear_at_top_level = {1316, DiagnosticCategory::Error, S("Global_module_exports_may_only_appear_at_top_level_1316"), S("Global module exports may only appear at top level.")};
        static DiagnosticMessageStore A_parameter_property_cannot_be_declared_using_a_rest_parameter = {1317, DiagnosticCategory::Error, S("A_parameter_property_cannot_be_declared_using_a_rest_parameter_1317"), S("A parameter property cannot be declared using a rest parameter.")};
        static DiagnosticMessageStore An_abstract_accessor_cannot_have_an_implementation = {1318, DiagnosticCategory::Error, S("An_abstract_accessor_cannot_have_an_implementation_1318"), S("An abstract accessor cannot have an implementation.")};
        static DiagnosticMessageStore A_default_export_can_only_be_used_in_an_ECMAScript_style_module = {1319, DiagnosticCategory::Error, S("A_default_export_can_only_be_used_in_an_ECMAScript_style_module_1319"), S("A default export can only be used in an ECMAScript-style module.")};
        static DiagnosticMessageStore Type_of_await_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member = {1320, DiagnosticCategory::Error, S("Type_of_await_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member_1320"), S("Type of 'await' operand must either be a valid promise or must not contain a callable 'then' member.")};
        static DiagnosticMessageStore Type_of_yield_operand_in_an_async_generator_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member = {1321, DiagnosticCategory::Error, S("Type_of_yield_operand_in_an_async_generator_must_either_be_a_valid_promise_or_must_not_contain_a_cal_1321"), S("Type of 'yield' operand in an async generator must either be a valid promise or must not contain a callable 'then' member.")};
        static DiagnosticMessageStore Type_of_iterated_elements_of_a_yield_Asterisk_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member = {1322, DiagnosticCategory::Error, S("Type_of_iterated_elements_of_a_yield_Asterisk_operand_must_either_be_a_valid_promise_or_must_not_con_1322"), S("Type of iterated elements of a 'yield*' operand must either be a valid promise or must not contain a callable 'then' member.")};
        static DiagnosticMessageStore Dynamic_imports_are_only_supported_when_the_module_flag_is_set_to_es2020_esnext_commonjs_amd_system_or_umd = {1323, DiagnosticCategory::Error, S("Dynamic_imports_are_only_supported_when_the_module_flag_is_set_to_es2020_esnext_commonjs_amd_system__1323"), S("Dynamic imports are only supported when the '--module' flag is set to 'es2020', 'esnext', 'commonjs', 'amd', 'system', or 'umd'.")};
        static DiagnosticMessageStore Dynamic_import_must_have_one_specifier_as_an_argument = {1324, DiagnosticCategory::Error, S("Dynamic_import_must_have_one_specifier_as_an_argument_1324"), S("Dynamic import must have one specifier as an argument.")};
        static DiagnosticMessageStore Specifier_of_dynamic_import_cannot_be_spread_element = {1325, DiagnosticCategory::Error, S("Specifier_of_dynamic_import_cannot_be_spread_element_1325"), S("Specifier of dynamic import cannot be spread element.")};
        static DiagnosticMessageStore Dynamic_import_cannot_have_type_arguments = {1326, DiagnosticCategory::Error, S("Dynamic_import_cannot_have_type_arguments_1326"), S("Dynamic import cannot have type arguments.")};
        static DiagnosticMessageStore String_literal_with_double_quotes_expected = {1327, DiagnosticCategory::Error, S("String_literal_with_double_quotes_expected_1327"), S("String literal with double quotes expected.")};
        static DiagnosticMessageStore Property_value_can_only_be_string_literal_numeric_literal_true_false_null_object_literal_or_array_literal = {1328, DiagnosticCategory::Error, S("Property_value_can_only_be_string_literal_numeric_literal_true_false_null_object_literal_or_array_li_1328"), S("Property value can only be string literal, numeric literal, 'true', 'false', 'null', object literal or array literal.")};
        static DiagnosticMessageStore _0_accepts_too_few_arguments_to_be_used_as_a_decorator_here_Did_you_mean_to_call_it_first_and_write_0 = {1329, DiagnosticCategory::Error, S("_0_accepts_too_few_arguments_to_be_used_as_a_decorator_here_Did_you_mean_to_call_it_first_and_write__1329"), S("'{0}' accepts too few arguments to be used as a decorator here. Did you mean to call it first and write '@{0}()'?")};
        static DiagnosticMessageStore A_property_of_an_interface_or_type_literal_whose_type_is_a_unique_symbol_type_must_be_readonly = {1330, DiagnosticCategory::Error, S("A_property_of_an_interface_or_type_literal_whose_type_is_a_unique_symbol_type_must_be_readonly_1330"), S("A property of an interface or type literal whose type is a 'unique symbol' type must be 'readonly'.")};
        static DiagnosticMessageStore A_property_of_a_class_whose_type_is_a_unique_symbol_type_must_be_both_static_and_readonly = {1331, DiagnosticCategory::Error, S("A_property_of_a_class_whose_type_is_a_unique_symbol_type_must_be_both_static_and_readonly_1331"), S("A property of a class whose type is a 'unique symbol' type must be both 'static' and 'readonly'.")};
        static DiagnosticMessageStore A_variable_whose_type_is_a_unique_symbol_type_must_be_const = {1332, DiagnosticCategory::Error, S("A_variable_whose_type_is_a_unique_symbol_type_must_be_const_1332"), S("A variable whose type is a 'unique symbol' type must be 'const'.")};
        static DiagnosticMessageStore unique_symbol_types_may_not_be_used_on_a_variable_declaration_with_a_binding_name = {1333, DiagnosticCategory::Error, S("unique_symbol_types_may_not_be_used_on_a_variable_declaration_with_a_binding_name_1333"), S("'unique symbol' types may not be used on a variable declaration with a binding name.")};
        static DiagnosticMessageStore unique_symbol_types_are_only_allowed_on_variables_in_a_variable_statement = {1334, DiagnosticCategory::Error, S("unique_symbol_types_are_only_allowed_on_variables_in_a_variable_statement_1334"), S("'unique symbol' types are only allowed on variables in a variable statement.")};
        static DiagnosticMessageStore unique_symbol_types_are_not_allowed_here = {1335, DiagnosticCategory::Error, S("unique_symbol_types_are_not_allowed_here_1335"), S("'unique symbol' types are not allowed here.")};
        static DiagnosticMessageStore An_index_signature_parameter_type_cannot_be_a_type_alias_Consider_writing_0_Colon_1_Colon_2_instead = {1336, DiagnosticCategory::Error, S("An_index_signature_parameter_type_cannot_be_a_type_alias_Consider_writing_0_Colon_1_Colon_2_instead_1336"), S("An index signature parameter type cannot be a type alias. Consider writing '[{0}: {1}]: {2}' instead.")};
        static DiagnosticMessageStore An_index_signature_parameter_type_cannot_be_a_union_type_Consider_using_a_mapped_object_type_instead = {1337, DiagnosticCategory::Error, S("An_index_signature_parameter_type_cannot_be_a_union_type_Consider_using_a_mapped_object_type_instead_1337"), S("An index signature parameter type cannot be a union type. Consider using a mapped object type instead.")};
        static DiagnosticMessageStore infer_declarations_are_only_permitted_in_the_extends_clause_of_a_conditional_type = {1338, DiagnosticCategory::Error, S("infer_declarations_are_only_permitted_in_the_extends_clause_of_a_conditional_type_1338"), S("'infer' declarations are only permitted in the 'extends' clause of a conditional type.")};
        static DiagnosticMessageStore Module_0_does_not_refer_to_a_value_but_is_used_as_a_value_here = {1339, DiagnosticCategory::Error, S("Module_0_does_not_refer_to_a_value_but_is_used_as_a_value_here_1339"), S("Module '{0}' does not refer to a value, but is used as a value here.")};
        static DiagnosticMessageStore Module_0_does_not_refer_to_a_type_but_is_used_as_a_type_here_Did_you_mean_typeof_import_0 = {1340, DiagnosticCategory::Error, S("Module_0_does_not_refer_to_a_type_but_is_used_as_a_type_here_Did_you_mean_typeof_import_0_1340"), S("Module '{0}' does not refer to a type, but is used as a type here. Did you mean 'typeof import('{0}')'?")};
        static DiagnosticMessageStore Type_arguments_cannot_be_used_here = {1342, DiagnosticCategory::Error, S("Type_arguments_cannot_be_used_here_1342"), S("Type arguments cannot be used here.")};
        static DiagnosticMessageStore The_import_meta_meta_property_is_only_allowed_when_the_module_option_is_es2020_esnext_or_system = {1343, DiagnosticCategory::Error, S("The_import_meta_meta_property_is_only_allowed_when_the_module_option_is_es2020_esnext_or_system_1343"), S("The 'import.meta' meta-property is only allowed when the '--module' option is 'es2020', 'esnext', or 'system'.")};
        static DiagnosticMessageStore A_label_is_not_allowed_here = {1344, DiagnosticCategory::Error, S("A_label_is_not_allowed_here_1344"), S("'A label is not allowed here.")};
        static DiagnosticMessageStore An_expression_of_type_void_cannot_be_tested_for_truthiness = {1345, DiagnosticCategory::Error, S("An_expression_of_type_void_cannot_be_tested_for_truthiness_1345"), S("An expression of type 'void' cannot be tested for truthiness.")};
        static DiagnosticMessageStore This_parameter_is_not_allowed_with_use_strict_directive = {1346, DiagnosticCategory::Error, S("This_parameter_is_not_allowed_with_use_strict_directive_1346"), S("This parameter is not allowed with 'use strict' directive.")};
        static DiagnosticMessageStore use_strict_directive_cannot_be_used_with_non_simple_parameter_list = {1347, DiagnosticCategory::Error, S("use_strict_directive_cannot_be_used_with_non_simple_parameter_list_1347"), S("'use strict' directive cannot be used with non-simple parameter list.")};
        static DiagnosticMessageStore Non_simple_parameter_declared_here = {1348, DiagnosticCategory::Error, S("Non_simple_parameter_declared_here_1348"), S("Non-simple parameter declared here.")};
        static DiagnosticMessageStore use_strict_directive_used_here = {1349, DiagnosticCategory::Error, S("use_strict_directive_used_here_1349"), S("'use strict' directive used here.")};
        static DiagnosticMessageStore Print_the_final_configuration_instead_of_building = {1350, DiagnosticCategory::Message, S("Print_the_final_configuration_instead_of_building_1350"), S("Print the final configuration instead of building.")};
        static DiagnosticMessageStore An_identifier_or_keyword_cannot_immediately_follow_a_numeric_literal = {1351, DiagnosticCategory::Error, S("An_identifier_or_keyword_cannot_immediately_follow_a_numeric_literal_1351"), S("An identifier or keyword cannot immediately follow a numeric literal.")};
        static DiagnosticMessageStore A_bigint_literal_cannot_use_exponential_notation = {1352, DiagnosticCategory::Error, S("A_bigint_literal_cannot_use_exponential_notation_1352"), S("A bigint literal cannot use exponential notation.")};
        static DiagnosticMessageStore A_bigint_literal_must_be_an_integer = {1353, DiagnosticCategory::Error, S("A_bigint_literal_must_be_an_integer_1353"), S("A bigint literal must be an integer.")};
        static DiagnosticMessageStore readonly_type_modifier_is_only_permitted_on_array_and_tuple_literal_types = {1354, DiagnosticCategory::Error, S("readonly_type_modifier_is_only_permitted_on_array_and_tuple_literal_types_1354"), S("'readonly' type modifier is only permitted on array and tuple literal types.")};
        static DiagnosticMessageStore A_const_assertions_can_only_be_applied_to_references_to_enum_members_or_string_number_boolean_array_or_object_literals = {1355, DiagnosticCategory::Error, S("A_const_assertions_can_only_be_applied_to_references_to_enum_members_or_string_number_boolean_array__1355"), S("A 'const' assertions can only be applied to references to enum members, or string, number, boolean, array, or object literals.")};
        static DiagnosticMessageStore Did_you_mean_to_mark_this_function_as_async = {1356, DiagnosticCategory::Error, S("Did_you_mean_to_mark_this_function_as_async_1356"), S("Did you mean to mark this function as 'async'?")};
        static DiagnosticMessageStore An_enum_member_name_must_be_followed_by_a_or = {1357, DiagnosticCategory::Error, S("An_enum_member_name_must_be_followed_by_a_or_1357"), S("An enum member name must be followed by a ',', '=', or '}'.")};
        static DiagnosticMessageStore Tagged_template_expressions_are_not_permitted_in_an_optional_chain = {1358, DiagnosticCategory::Error, S("Tagged_template_expressions_are_not_permitted_in_an_optional_chain_1358"), S("Tagged template expressions are not permitted in an optional chain.")};
        static DiagnosticMessageStore Identifier_expected_0_is_a_reserved_word_that_cannot_be_used_here = {1359, DiagnosticCategory::Error, S("Identifier_expected_0_is_a_reserved_word_that_cannot_be_used_here_1359"), S("Identifier expected. '{0}' is a reserved word that cannot be used here.")};
        static DiagnosticMessageStore Did_you_mean_to_parenthesize_this_function_type = {1360, DiagnosticCategory::Error, S("Did_you_mean_to_parenthesize_this_function_type_1360"), S("Did you mean to parenthesize this function type?")};
        static DiagnosticMessageStore _0_cannot_be_used_as_a_value_because_it_was_imported_using_import_type = {1361, DiagnosticCategory::Error, S("_0_cannot_be_used_as_a_value_because_it_was_imported_using_import_type_1361"), S("'{0}' cannot be used as a value because it was imported using 'import type'.")};
        static DiagnosticMessageStore _0_cannot_be_used_as_a_value_because_it_was_exported_using_export_type = {1362, DiagnosticCategory::Error, S("_0_cannot_be_used_as_a_value_because_it_was_exported_using_export_type_1362"), S("'{0}' cannot be used as a value because it was exported using 'export type'.")};
        static DiagnosticMessageStore A_type_only_import_can_specify_a_default_import_or_named_bindings_but_not_both = {1363, DiagnosticCategory::Error, S("A_type_only_import_can_specify_a_default_import_or_named_bindings_but_not_both_1363"), S("A type-only import can specify a default import or named bindings, but not both.")};
        static DiagnosticMessageStore Convert_to_type_only_export = {1364, DiagnosticCategory::Message, S("Convert_to_type_only_export_1364"), S("Convert to type-only export")};
        static DiagnosticMessageStore Convert_all_re_exported_types_to_type_only_exports = {1365, DiagnosticCategory::Message, S("Convert_all_re_exported_types_to_type_only_exports_1365"), S("Convert all re-exported types to type-only exports")};
        static DiagnosticMessageStore Split_into_two_separate_import_declarations = {1366, DiagnosticCategory::Message, S("Split_into_two_separate_import_declarations_1366"), S("Split into two separate import declarations")};
        static DiagnosticMessageStore Split_all_invalid_type_only_imports = {1367, DiagnosticCategory::Message, S("Split_all_invalid_type_only_imports_1367"), S("Split all invalid type-only imports")};
        static DiagnosticMessageStore Specify_emit_Slashchecking_behavior_for_imports_that_are_only_used_for_types = {1368, DiagnosticCategory::Message, S("Specify_emit_Slashchecking_behavior_for_imports_that_are_only_used_for_types_1368"), S("Specify emit/checking behavior for imports that are only used for types")};
        static DiagnosticMessageStore Did_you_mean_0 = {1369, DiagnosticCategory::Message, S("Did_you_mean_0_1369"), S("Did you mean '{0}'?")};
        static DiagnosticMessageStore This_import_is_never_used_as_a_value_and_must_use_import_type_because_importsNotUsedAsValues_is_set_to_error = {1371, DiagnosticCategory::Error, S("This_import_is_never_used_as_a_value_and_must_use_import_type_because_importsNotUsedAsValues_is_set__1371"), S("This import is never used as a value and must use 'import type' because 'importsNotUsedAsValues' is set to 'error'.")};
        static DiagnosticMessageStore Convert_to_type_only_import = {1373, DiagnosticCategory::Message, S("Convert_to_type_only_import_1373"), S("Convert to type-only import")};
        static DiagnosticMessageStore Convert_all_imports_not_used_as_a_value_to_type_only_imports = {1374, DiagnosticCategory::Message, S("Convert_all_imports_not_used_as_a_value_to_type_only_imports_1374"), S("Convert all imports not used as a value to type-only imports")};
        static DiagnosticMessageStore await_expressions_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module = {1375, DiagnosticCategory::Error, S("await_expressions_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_fi_1375"), S("'await' expressions are only allowed at the top level of a file when that file is a module, but this file has no imports or exports. Consider adding an empty 'export {}' to make this file a module.")};
        static DiagnosticMessageStore _0_was_imported_here = {1376, DiagnosticCategory::Message, S("_0_was_imported_here_1376"), S("'{0}' was imported here.")};
        static DiagnosticMessageStore _0_was_exported_here = {1377, DiagnosticCategory::Message, S("_0_was_exported_here_1377"), S("'{0}' was exported here.")};
        static DiagnosticMessageStore Top_level_await_expressions_are_only_allowed_when_the_module_option_is_set_to_esnext_or_system_and_the_target_option_is_set_to_es2017_or_higher = {1378, DiagnosticCategory::Error, S("Top_level_await_expressions_are_only_allowed_when_the_module_option_is_set_to_esnext_or_system_and_t_1378"), S("Top-level 'await' expressions are only allowed when the 'module' option is set to 'esnext' or 'system', and the 'target' option is set to 'es2017' or higher.")};
        static DiagnosticMessageStore An_import_alias_cannot_reference_a_declaration_that_was_exported_using_export_type = {1379, DiagnosticCategory::Error, S("An_import_alias_cannot_reference_a_declaration_that_was_exported_using_export_type_1379"), S("An import alias cannot reference a declaration that was exported using 'export type'.")};
        static DiagnosticMessageStore An_import_alias_cannot_reference_a_declaration_that_was_imported_using_import_type = {1380, DiagnosticCategory::Error, S("An_import_alias_cannot_reference_a_declaration_that_was_imported_using_import_type_1380"), S("An import alias cannot reference a declaration that was imported using 'import type'.")};
        static DiagnosticMessageStore Unexpected_token_Did_you_mean_or_rbrace = {1381, DiagnosticCategory::Error, S("Unexpected_token_Did_you_mean_or_rbrace_1381"), S("Unexpected token. Did you mean `{'}'}` or `&rbrace;`?")};
        static DiagnosticMessageStore Unexpected_token_Did_you_mean_or_gt = {1382, DiagnosticCategory::Error, S("Unexpected_token_Did_you_mean_or_gt_1382"), S("Unexpected token. Did you mean `{'>'}` or `&gt;`?")};
        static DiagnosticMessageStore Only_named_exports_may_use_export_type = {1383, DiagnosticCategory::Error, S("Only_named_exports_may_use_export_type_1383"), S("Only named exports may use 'export type'.")};
        static DiagnosticMessageStore A_new_expression_with_type_arguments_must_always_be_followed_by_a_parenthesized_argument_list = {1384, DiagnosticCategory::Error, S("A_new_expression_with_type_arguments_must_always_be_followed_by_a_parenthesized_argument_list_1384"), S("A 'new' expression with type arguments must always be followed by a parenthesized argument list.")};
        static DiagnosticMessageStore Function_type_notation_must_be_parenthesized_when_used_in_a_union_type = {1385, DiagnosticCategory::Error, S("Function_type_notation_must_be_parenthesized_when_used_in_a_union_type_1385"), S("Function type notation must be parenthesized when used in a union type.")};
        static DiagnosticMessageStore Constructor_type_notation_must_be_parenthesized_when_used_in_a_union_type = {1386, DiagnosticCategory::Error, S("Constructor_type_notation_must_be_parenthesized_when_used_in_a_union_type_1386"), S("Constructor type notation must be parenthesized when used in a union type.")};
        static DiagnosticMessageStore Function_type_notation_must_be_parenthesized_when_used_in_an_intersection_type = {1387, DiagnosticCategory::Error, S("Function_type_notation_must_be_parenthesized_when_used_in_an_intersection_type_1387"), S("Function type notation must be parenthesized when used in an intersection type.")};
        static DiagnosticMessageStore Constructor_type_notation_must_be_parenthesized_when_used_in_an_intersection_type = {1388, DiagnosticCategory::Error, S("Constructor_type_notation_must_be_parenthesized_when_used_in_an_intersection_type_1388"), S("Constructor type notation must be parenthesized when used in an intersection type.")};
        static DiagnosticMessageStore _0_is_not_allowed_as_a_variable_declaration_name = {1389, DiagnosticCategory::Error, S("_0_is_not_allowed_as_a_variable_declaration_name_1389"), S("'{0}' is not allowed as a variable declaration name.")};
        static DiagnosticMessageStore Provides_a_root_package_name_when_using_outFile_with_declarations = {1390, DiagnosticCategory::Message, S("Provides_a_root_package_name_when_using_outFile_with_declarations_1390"), S("Provides a root package name when using outFile with declarations.")};
        static DiagnosticMessageStore The_bundledPackageName_option_must_be_provided_when_using_outFile_and_node_module_resolution_with_declaration_emit = {1391, DiagnosticCategory::Error, S("The_bundledPackageName_option_must_be_provided_when_using_outFile_and_node_module_resolution_with_de_1391"), S("The `bundledPackageName` option must be provided when using outFile and node module resolution with declaration emit.")};
        static DiagnosticMessageStore An_import_alias_cannot_use_import_type = {1392, DiagnosticCategory::Error, S("An_import_alias_cannot_use_import_type_1392"), S("An import alias cannot use 'import type'")};
        static DiagnosticMessageStore Imported_via_0_from_file_1 = {1393, DiagnosticCategory::Message, S("Imported_via_0_from_file_1_1393"), S("Imported via {0} from file '{1}'")};
        static DiagnosticMessageStore Imported_via_0_from_file_1_with_packageId_2 = {1394, DiagnosticCategory::Message, S("Imported_via_0_from_file_1_with_packageId_2_1394"), S("Imported via {0} from file '{1}' with packageId '{2}'")};
        static DiagnosticMessageStore Imported_via_0_from_file_1_to_import_importHelpers_as_specified_in_compilerOptions = {1395, DiagnosticCategory::Message, S("Imported_via_0_from_file_1_to_import_importHelpers_as_specified_in_compilerOptions_1395"), S("Imported via {0} from file '{1}' to import 'importHelpers' as specified in compilerOptions")};
        static DiagnosticMessageStore Imported_via_0_from_file_1_with_packageId_2_to_import_importHelpers_as_specified_in_compilerOptions = {1396, DiagnosticCategory::Message, S("Imported_via_0_from_file_1_with_packageId_2_to_import_importHelpers_as_specified_in_compilerOptions_1396"), S("Imported via {0} from file '{1}' with packageId '{2}' to import 'importHelpers' as specified in compilerOptions")};
        static DiagnosticMessageStore Imported_via_0_from_file_1_to_import_jsx_and_jsxs_factory_functions = {1397, DiagnosticCategory::Message, S("Imported_via_0_from_file_1_to_import_jsx_and_jsxs_factory_functions_1397"), S("Imported via {0} from file '{1}' to import 'jsx' and 'jsxs' factory functions")};
        static DiagnosticMessageStore Imported_via_0_from_file_1_with_packageId_2_to_import_jsx_and_jsxs_factory_functions = {1398, DiagnosticCategory::Message, S("Imported_via_0_from_file_1_with_packageId_2_to_import_jsx_and_jsxs_factory_functions_1398"), S("Imported via {0} from file '{1}' with packageId '{2}' to import 'jsx' and 'jsxs' factory functions")};
        static DiagnosticMessageStore File_is_included_via_import_here = {1399, DiagnosticCategory::Message, S("File_is_included_via_import_here_1399"), S("File is included via import here.")};
        static DiagnosticMessageStore Referenced_via_0_from_file_1 = {1400, DiagnosticCategory::Message, S("Referenced_via_0_from_file_1_1400"), S("Referenced via '{0}' from file '{1}'")};
        static DiagnosticMessageStore File_is_included_via_reference_here = {1401, DiagnosticCategory::Message, S("File_is_included_via_reference_here_1401"), S("File is included via reference here.")};
        static DiagnosticMessageStore Type_library_referenced_via_0_from_file_1 = {1402, DiagnosticCategory::Message, S("Type_library_referenced_via_0_from_file_1_1402"), S("Type library referenced via '{0}' from file '{1}'")};
        static DiagnosticMessageStore Type_library_referenced_via_0_from_file_1_with_packageId_2 = {1403, DiagnosticCategory::Message, S("Type_library_referenced_via_0_from_file_1_with_packageId_2_1403"), S("Type library referenced via '{0}' from file '{1}' with packageId '{2}'")};
        static DiagnosticMessageStore File_is_included_via_type_library_reference_here = {1404, DiagnosticCategory::Message, S("File_is_included_via_type_library_reference_here_1404"), S("File is included via type library reference here.")};
        static DiagnosticMessageStore Library_referenced_via_0_from_file_1 = {1405, DiagnosticCategory::Message, S("Library_referenced_via_0_from_file_1_1405"), S("Library referenced via '{0}' from file '{1}'")};
        static DiagnosticMessageStore File_is_included_via_library_reference_here = {1406, DiagnosticCategory::Message, S("File_is_included_via_library_reference_here_1406"), S("File is included via library reference here.")};
        static DiagnosticMessageStore Matched_by_include_pattern_0_in_1 = {1407, DiagnosticCategory::Message, S("Matched_by_include_pattern_0_in_1_1407"), S("Matched by include pattern '{0}' in '{1}'")};
        static DiagnosticMessageStore File_is_matched_by_include_pattern_specified_here = {1408, DiagnosticCategory::Message, S("File_is_matched_by_include_pattern_specified_here_1408"), S("File is matched by include pattern specified here.")};
        static DiagnosticMessageStore Part_of_files_list_in_tsconfig_json = {1409, DiagnosticCategory::Message, S("Part_of_files_list_in_tsconfig_json_1409"), S("Part of 'files' list in tsconfig.json")};
        static DiagnosticMessageStore File_is_matched_by_files_list_specified_here = {1410, DiagnosticCategory::Message, S("File_is_matched_by_files_list_specified_here_1410"), S("File is matched by 'files' list specified here.")};
        static DiagnosticMessageStore Output_from_referenced_project_0_included_because_1_specified = {1411, DiagnosticCategory::Message, S("Output_from_referenced_project_0_included_because_1_specified_1411"), S("Output from referenced project '{0}' included because '{1}' specified")};
        static DiagnosticMessageStore Output_from_referenced_project_0_included_because_module_is_specified_as_none = {1412, DiagnosticCategory::Message, S("Output_from_referenced_project_0_included_because_module_is_specified_as_none_1412"), S("Output from referenced project '{0}' included because '--module' is specified as 'none'")};
        static DiagnosticMessageStore File_is_output_from_referenced_project_specified_here = {1413, DiagnosticCategory::Message, S("File_is_output_from_referenced_project_specified_here_1413"), S("File is output from referenced project specified here.")};
        static DiagnosticMessageStore Source_from_referenced_project_0_included_because_1_specified = {1414, DiagnosticCategory::Message, S("Source_from_referenced_project_0_included_because_1_specified_1414"), S("Source from referenced project '{0}' included because '{1}' specified")};
        static DiagnosticMessageStore Source_from_referenced_project_0_included_because_module_is_specified_as_none = {1415, DiagnosticCategory::Message, S("Source_from_referenced_project_0_included_because_module_is_specified_as_none_1415"), S("Source from referenced project '{0}' included because '--module' is specified as 'none'")};
        static DiagnosticMessageStore File_is_source_from_referenced_project_specified_here = {1416, DiagnosticCategory::Message, S("File_is_source_from_referenced_project_specified_here_1416"), S("File is source from referenced project specified here.")};
        static DiagnosticMessageStore Entry_point_of_type_library_0_specified_in_compilerOptions = {1417, DiagnosticCategory::Message, S("Entry_point_of_type_library_0_specified_in_compilerOptions_1417"), S("Entry point of type library '{0}' specified in compilerOptions")};
        static DiagnosticMessageStore Entry_point_of_type_library_0_specified_in_compilerOptions_with_packageId_1 = {1418, DiagnosticCategory::Message, S("Entry_point_of_type_library_0_specified_in_compilerOptions_with_packageId_1_1418"), S("Entry point of type library '{0}' specified in compilerOptions with packageId '{1}'")};
        static DiagnosticMessageStore File_is_entry_point_of_type_library_specified_here = {1419, DiagnosticCategory::Message, S("File_is_entry_point_of_type_library_specified_here_1419"), S("File is entry point of type library specified here.")};
        static DiagnosticMessageStore Entry_point_for_implicit_type_library_0 = {1420, DiagnosticCategory::Message, S("Entry_point_for_implicit_type_library_0_1420"), S("Entry point for implicit type library '{0}'")};
        static DiagnosticMessageStore Entry_point_for_implicit_type_library_0_with_packageId_1 = {1421, DiagnosticCategory::Message, S("Entry_point_for_implicit_type_library_0_with_packageId_1_1421"), S("Entry point for implicit type library '{0}' with packageId '{1}'")};
        static DiagnosticMessageStore Library_0_specified_in_compilerOptions = {1422, DiagnosticCategory::Message, S("Library_0_specified_in_compilerOptions_1422"), S("Library '{0}' specified in compilerOptions")};
        static DiagnosticMessageStore File_is_library_specified_here = {1423, DiagnosticCategory::Message, S("File_is_library_specified_here_1423"), S("File is library specified here.")};
        static DiagnosticMessageStore Default_library = {1424, DiagnosticCategory::Message, S("Default_library_1424"), S("Default library")};
        static DiagnosticMessageStore Default_library_for_target_0 = {1425, DiagnosticCategory::Message, S("Default_library_for_target_0_1425"), S("Default library for target '{0}'")};
        static DiagnosticMessageStore File_is_default_library_for_target_specified_here = {1426, DiagnosticCategory::Message, S("File_is_default_library_for_target_specified_here_1426"), S("File is default library for target specified here.")};
        static DiagnosticMessageStore Root_file_specified_for_compilation = {1427, DiagnosticCategory::Message, S("Root_file_specified_for_compilation_1427"), S("Root file specified for compilation")};
        static DiagnosticMessageStore File_is_output_of_project_reference_source_0 = {1428, DiagnosticCategory::Message, S("File_is_output_of_project_reference_source_0_1428"), S("File is output of project reference source '{0}'")};
        static DiagnosticMessageStore File_redirects_to_file_0 = {1429, DiagnosticCategory::Message, S("File_redirects_to_file_0_1429"), S("File redirects to file '{0}'")};
        static DiagnosticMessageStore The_file_is_in_the_program_because_Colon = {1430, DiagnosticCategory::Message, S("The_file_is_in_the_program_because_Colon_1430"), S("The file is in the program because:")};
        static DiagnosticMessageStore The_types_of_0_are_incompatible_between_these_types = {2200, DiagnosticCategory::Error, S("The_types_of_0_are_incompatible_between_these_types_2200"), S("The types of '{0}' are incompatible between these types.")};
        static DiagnosticMessageStore The_types_returned_by_0_are_incompatible_between_these_types = {2201, DiagnosticCategory::Error, S("The_types_returned_by_0_are_incompatible_between_these_types_2201"), S("The types returned by '{0}' are incompatible between these types.")};
        static DiagnosticMessageStore Call_signature_return_types_0_and_1_are_incompatible = {2202, DiagnosticCategory::Error, S("Call_signature_return_types_0_and_1_are_incompatible_2202"), S("Call signature return types '{0}' and '{1}' are incompatible.")};
        static DiagnosticMessageStore Construct_signature_return_types_0_and_1_are_incompatible = {2203, DiagnosticCategory::Error, S("Construct_signature_return_types_0_and_1_are_incompatible_2203"), S("Construct signature return types '{0}' and '{1}' are incompatible.")};
        static DiagnosticMessageStore Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1 = {2204, DiagnosticCategory::Error, S("Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1_2204"), S("Call signatures with no arguments have incompatible return types '{0}' and '{1}'.")};
        static DiagnosticMessageStore Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1 = {2205, DiagnosticCategory::Error, S("Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1_2205"), S("Construct signatures with no arguments have incompatible return types '{0}' and '{1}'.")};
        static DiagnosticMessageStore Duplicate_identifier_0 = {2300, DiagnosticCategory::Error, S("Duplicate_identifier_0_2300"), S("Duplicate identifier '{0}'.")};
        static DiagnosticMessageStore Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor = {2301, DiagnosticCategory::Error, S("Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor_2301"), S("Initializer of instance member variable '{0}' cannot reference identifier '{1}' declared in the constructor.")};
        static DiagnosticMessageStore Static_members_cannot_reference_class_type_parameters = {2302, DiagnosticCategory::Error, S("Static_members_cannot_reference_class_type_parameters_2302"), S("Static members cannot reference class type parameters.")};
        static DiagnosticMessageStore Circular_definition_of_import_alias_0 = {2303, DiagnosticCategory::Error, S("Circular_definition_of_import_alias_0_2303"), S("Circular definition of import alias '{0}'.")};
        static DiagnosticMessageStore Cannot_find_name_0 = {2304, DiagnosticCategory::Error, S("Cannot_find_name_0_2304"), S("Cannot find name '{0}'.")};
        static DiagnosticMessageStore Module_0_has_no_exported_member_1 = {2305, DiagnosticCategory::Error, S("Module_0_has_no_exported_member_1_2305"), S("Module '{0}' has no exported member '{1}'.")};
        static DiagnosticMessageStore File_0_is_not_a_module = {2306, DiagnosticCategory::Error, S("File_0_is_not_a_module_2306"), S("File '{0}' is not a module.")};
        static DiagnosticMessageStore Cannot_find_module_0_or_its_corresponding_type_declarations = {2307, DiagnosticCategory::Error, S("Cannot_find_module_0_or_its_corresponding_type_declarations_2307"), S("Cannot find module '{0}' or its corresponding type declarations.")};
        static DiagnosticMessageStore Module_0_has_already_exported_a_member_named_1_Consider_explicitly_re_exporting_to_resolve_the_ambiguity = {2308, DiagnosticCategory::Error, S("Module_0_has_already_exported_a_member_named_1_Consider_explicitly_re_exporting_to_resolve_the_ambig_2308"), S("Module {0} has already exported a member named '{1}'. Consider explicitly re-exporting to resolve the ambiguity.")};
        static DiagnosticMessageStore An_export_assignment_cannot_be_used_in_a_module_with_other_exported_elements = {2309, DiagnosticCategory::Error, S("An_export_assignment_cannot_be_used_in_a_module_with_other_exported_elements_2309"), S("An export assignment cannot be used in a module with other exported elements.")};
        static DiagnosticMessageStore Type_0_recursively_references_itself_as_a_base_type = {2310, DiagnosticCategory::Error, S("Type_0_recursively_references_itself_as_a_base_type_2310"), S("Type '{0}' recursively references itself as a base type.")};
        static DiagnosticMessageStore A_class_may_only_extend_another_class = {2311, DiagnosticCategory::Error, S("A_class_may_only_extend_another_class_2311"), S("A class may only extend another class.")};
        static DiagnosticMessageStore An_interface_can_only_extend_an_object_type_or_intersection_of_object_types_with_statically_known_members = {2312, DiagnosticCategory::Error, S("An_interface_can_only_extend_an_object_type_or_intersection_of_object_types_with_statically_known_me_2312"), S("An interface can only extend an object type or intersection of object types with statically known members.")};
        static DiagnosticMessageStore Type_parameter_0_has_a_circular_constraint = {2313, DiagnosticCategory::Error, S("Type_parameter_0_has_a_circular_constraint_2313"), S("Type parameter '{0}' has a circular constraint.")};
        static DiagnosticMessageStore Generic_type_0_requires_1_type_argument_s = {2314, DiagnosticCategory::Error, S("Generic_type_0_requires_1_type_argument_s_2314"), S("Generic type '{0}' requires {1} type argument(s).")};
        static DiagnosticMessageStore Type_0_is_not_generic = {2315, DiagnosticCategory::Error, S("Type_0_is_not_generic_2315"), S("Type '{0}' is not generic.")};
        static DiagnosticMessageStore Global_type_0_must_be_a_class_or_interface_type = {2316, DiagnosticCategory::Error, S("Global_type_0_must_be_a_class_or_interface_type_2316"), S("Global type '{0}' must be a class or interface type.")};
        static DiagnosticMessageStore Global_type_0_must_have_1_type_parameter_s = {2317, DiagnosticCategory::Error, S("Global_type_0_must_have_1_type_parameter_s_2317"), S("Global type '{0}' must have {1} type parameter(s).")};
        static DiagnosticMessageStore Cannot_find_global_type_0 = {2318, DiagnosticCategory::Error, S("Cannot_find_global_type_0_2318"), S("Cannot find global type '{0}'.")};
        static DiagnosticMessageStore Named_property_0_of_types_1_and_2_are_not_identical = {2319, DiagnosticCategory::Error, S("Named_property_0_of_types_1_and_2_are_not_identical_2319"), S("Named property '{0}' of types '{1}' and '{2}' are not identical.")};
        static DiagnosticMessageStore Interface_0_cannot_simultaneously_extend_types_1_and_2 = {2320, DiagnosticCategory::Error, S("Interface_0_cannot_simultaneously_extend_types_1_and_2_2320"), S("Interface '{0}' cannot simultaneously extend types '{1}' and '{2}'.")};
        static DiagnosticMessageStore Excessive_stack_depth_comparing_types_0_and_1 = {2321, DiagnosticCategory::Error, S("Excessive_stack_depth_comparing_types_0_and_1_2321"), S("Excessive stack depth comparing types '{0}' and '{1}'.")};
        static DiagnosticMessageStore Type_0_is_not_assignable_to_type_1 = {2322, DiagnosticCategory::Error, S("Type_0_is_not_assignable_to_type_1_2322"), S("Type '{0}' is not assignable to type '{1}'.")};
        static DiagnosticMessageStore Cannot_redeclare_exported_variable_0 = {2323, DiagnosticCategory::Error, S("Cannot_redeclare_exported_variable_0_2323"), S("Cannot redeclare exported variable '{0}'.")};
        static DiagnosticMessageStore Property_0_is_missing_in_type_1 = {2324, DiagnosticCategory::Error, S("Property_0_is_missing_in_type_1_2324"), S("Property '{0}' is missing in type '{1}'.")};
        static DiagnosticMessageStore Property_0_is_private_in_type_1_but_not_in_type_2 = {2325, DiagnosticCategory::Error, S("Property_0_is_private_in_type_1_but_not_in_type_2_2325"), S("Property '{0}' is private in type '{1}' but not in type '{2}'.")};
        static DiagnosticMessageStore Types_of_property_0_are_incompatible = {2326, DiagnosticCategory::Error, S("Types_of_property_0_are_incompatible_2326"), S("Types of property '{0}' are incompatible.")};
        static DiagnosticMessageStore Property_0_is_optional_in_type_1_but_required_in_type_2 = {2327, DiagnosticCategory::Error, S("Property_0_is_optional_in_type_1_but_required_in_type_2_2327"), S("Property '{0}' is optional in type '{1}' but required in type '{2}'.")};
        static DiagnosticMessageStore Types_of_parameters_0_and_1_are_incompatible = {2328, DiagnosticCategory::Error, S("Types_of_parameters_0_and_1_are_incompatible_2328"), S("Types of parameters '{0}' and '{1}' are incompatible.")};
        static DiagnosticMessageStore Index_signature_is_missing_in_type_0 = {2329, DiagnosticCategory::Error, S("Index_signature_is_missing_in_type_0_2329"), S("Index signature is missing in type '{0}'.")};
        static DiagnosticMessageStore Index_signatures_are_incompatible = {2330, DiagnosticCategory::Error, S("Index_signatures_are_incompatible_2330"), S("Index signatures are incompatible.")};
        static DiagnosticMessageStore this_cannot_be_referenced_in_a_module_or_namespace_body = {2331, DiagnosticCategory::Error, S("this_cannot_be_referenced_in_a_module_or_namespace_body_2331"), S("'this' cannot be referenced in a module or namespace body.")};
        static DiagnosticMessageStore this_cannot_be_referenced_in_current_location = {2332, DiagnosticCategory::Error, S("this_cannot_be_referenced_in_current_location_2332"), S("'this' cannot be referenced in current location.")};
        static DiagnosticMessageStore this_cannot_be_referenced_in_constructor_arguments = {2333, DiagnosticCategory::Error, S("this_cannot_be_referenced_in_constructor_arguments_2333"), S("'this' cannot be referenced in constructor arguments.")};
        static DiagnosticMessageStore this_cannot_be_referenced_in_a_static_property_initializer = {2334, DiagnosticCategory::Error, S("this_cannot_be_referenced_in_a_static_property_initializer_2334"), S("'this' cannot be referenced in a static property initializer.")};
        static DiagnosticMessageStore super_can_only_be_referenced_in_a_derived_class = {2335, DiagnosticCategory::Error, S("super_can_only_be_referenced_in_a_derived_class_2335"), S("'super' can only be referenced in a derived class.")};
        static DiagnosticMessageStore super_cannot_be_referenced_in_constructor_arguments = {2336, DiagnosticCategory::Error, S("super_cannot_be_referenced_in_constructor_arguments_2336"), S("'super' cannot be referenced in constructor arguments.")};
        static DiagnosticMessageStore Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors = {2337, DiagnosticCategory::Error, S("Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors_2337"), S("Super calls are not permitted outside constructors or in nested functions inside constructors.")};
        static DiagnosticMessageStore super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_derived_class = {2338, DiagnosticCategory::Error, S("super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_der_2338"), S("'super' property access is permitted only in a constructor, member function, or member accessor of a derived class.")};
        static DiagnosticMessageStore Property_0_does_not_exist_on_type_1 = {2339, DiagnosticCategory::Error, S("Property_0_does_not_exist_on_type_1_2339"), S("Property '{0}' does not exist on type '{1}'.")};
        static DiagnosticMessageStore Only_public_and_protected_methods_of_the_base_class_are_accessible_via_the_super_keyword = {2340, DiagnosticCategory::Error, S("Only_public_and_protected_methods_of_the_base_class_are_accessible_via_the_super_keyword_2340"), S("Only public and protected methods of the base class are accessible via the 'super' keyword.")};
        static DiagnosticMessageStore Property_0_is_private_and_only_accessible_within_class_1 = {2341, DiagnosticCategory::Error, S("Property_0_is_private_and_only_accessible_within_class_1_2341"), S("Property '{0}' is private and only accessible within class '{1}'.")};
        static DiagnosticMessageStore An_index_expression_argument_must_be_of_type_string_number_symbol_or_any = {2342, DiagnosticCategory::Error, S("An_index_expression_argument_must_be_of_type_string_number_symbol_or_any_2342"), S("An index expression argument must be of type 'string', 'number', 'symbol', or 'any'.")};
        static DiagnosticMessageStore This_syntax_requires_an_imported_helper_named_1_which_does_not_exist_in_0_Consider_upgrading_your_version_of_0 = {2343, DiagnosticCategory::Error, S("This_syntax_requires_an_imported_helper_named_1_which_does_not_exist_in_0_Consider_upgrading_your_ve_2343"), S("This syntax requires an imported helper named '{1}' which does not exist in '{0}'. Consider upgrading your version of '{0}'.")};
        static DiagnosticMessageStore Type_0_does_not_satisfy_the_constraint_1 = {2344, DiagnosticCategory::Error, S("Type_0_does_not_satisfy_the_constraint_1_2344"), S("Type '{0}' does not satisfy the constraint '{1}'.")};
        static DiagnosticMessageStore Argument_of_type_0_is_not_assignable_to_parameter_of_type_1 = {2345, DiagnosticCategory::Error, S("Argument_of_type_0_is_not_assignable_to_parameter_of_type_1_2345"), S("Argument of type '{0}' is not assignable to parameter of type '{1}'.")};
        static DiagnosticMessageStore Call_target_does_not_contain_any_signatures = {2346, DiagnosticCategory::Error, S("Call_target_does_not_contain_any_signatures_2346"), S("Call target does not contain any signatures.")};
        static DiagnosticMessageStore Untyped_function_calls_may_not_accept_type_arguments = {2347, DiagnosticCategory::Error, S("Untyped_function_calls_may_not_accept_type_arguments_2347"), S("Untyped function calls may not accept type arguments.")};
        static DiagnosticMessageStore Value_of_type_0_is_not_callable_Did_you_mean_to_include_new = {2348, DiagnosticCategory::Error, S("Value_of_type_0_is_not_callable_Did_you_mean_to_include_new_2348"), S("Value of type '{0}' is not callable. Did you mean to include 'new'?")};
        static DiagnosticMessageStore This_expression_is_not_callable = {2349, DiagnosticCategory::Error, S("This_expression_is_not_callable_2349"), S("This expression is not callable.")};
        static DiagnosticMessageStore Only_a_void_function_can_be_called_with_the_new_keyword = {2350, DiagnosticCategory::Error, S("Only_a_void_function_can_be_called_with_the_new_keyword_2350"), S("Only a void function can be called with the 'new' keyword.")};
        static DiagnosticMessageStore This_expression_is_not_constructable = {2351, DiagnosticCategory::Error, S("This_expression_is_not_constructable_2351"), S("This expression is not constructable.")};
        static DiagnosticMessageStore Conversion_of_type_0_to_type_1_may_be_a_mistake_because_neither_type_sufficiently_overlaps_with_the_other_If_this_was_intentional_convert_the_expression_to_unknown_first = {2352, DiagnosticCategory::Error, S("Conversion_of_type_0_to_type_1_may_be_a_mistake_because_neither_type_sufficiently_overlaps_with_the__2352"), S("Conversion of type '{0}' to type '{1}' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.")};
        static DiagnosticMessageStore Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1 = {2353, DiagnosticCategory::Error, S("Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1_2353"), S("Object literal may only specify known properties, and '{0}' does not exist in type '{1}'.")};
        static DiagnosticMessageStore This_syntax_requires_an_imported_helper_but_module_0_cannot_be_found = {2354, DiagnosticCategory::Error, S("This_syntax_requires_an_imported_helper_but_module_0_cannot_be_found_2354"), S("This syntax requires an imported helper but module '{0}' cannot be found.")};
        static DiagnosticMessageStore A_function_whose_declared_type_is_neither_void_nor_any_must_return_a_value = {2355, DiagnosticCategory::Error, S("A_function_whose_declared_type_is_neither_void_nor_any_must_return_a_value_2355"), S("A function whose declared type is neither 'void' nor 'any' must return a value.")};
        static DiagnosticMessageStore An_arithmetic_operand_must_be_of_type_any_number_bigint_or_an_enum_type = {2356, DiagnosticCategory::Error, S("An_arithmetic_operand_must_be_of_type_any_number_bigint_or_an_enum_type_2356"), S("An arithmetic operand must be of type 'any', 'number', 'bigint' or an enum type.")};
        static DiagnosticMessageStore The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access = {2357, DiagnosticCategory::Error, S("The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access_2357"), S("The operand of an increment or decrement operator must be a variable or a property access.")};
        static DiagnosticMessageStore The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter = {2358, DiagnosticCategory::Error, S("The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_paramete_2358"), S("The left-hand side of an 'instanceof' expression must be of type 'any', an object type or a type parameter.")};
        static DiagnosticMessageStore The_right_hand_side_of_an_instanceof_expression_must_be_of_type_any_or_of_a_type_assignable_to_the_Function_interface_type = {2359, DiagnosticCategory::Error, S("The_right_hand_side_of_an_instanceof_expression_must_be_of_type_any_or_of_a_type_assignable_to_the_F_2359"), S("The right-hand side of an 'instanceof' expression must be of type 'any' or of a type assignable to the 'Function' interface type.")};
        static DiagnosticMessageStore The_left_hand_side_of_an_in_expression_must_be_of_type_any_string_number_or_symbol = {2360, DiagnosticCategory::Error, S("The_left_hand_side_of_an_in_expression_must_be_of_type_any_string_number_or_symbol_2360"), S("The left-hand side of an 'in' expression must be of type 'any', 'string', 'number', or 'symbol'.")};
        static DiagnosticMessageStore The_right_hand_side_of_an_in_expression_must_be_of_type_any_an_object_type_or_a_type_parameter = {2361, DiagnosticCategory::Error, S("The_right_hand_side_of_an_in_expression_must_be_of_type_any_an_object_type_or_a_type_parameter_2361"), S("The right-hand side of an 'in' expression must be of type 'any', an object type or a type parameter.")};
        static DiagnosticMessageStore The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type = {2362, DiagnosticCategory::Error, S("The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type_2362"), S("The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.")};
        static DiagnosticMessageStore The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type = {2363, DiagnosticCategory::Error, S("The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type_2363"), S("The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.")};
        static DiagnosticMessageStore The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access = {2364, DiagnosticCategory::Error, S("The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access_2364"), S("The left-hand side of an assignment expression must be a variable or a property access.")};
        static DiagnosticMessageStore Operator_0_cannot_be_applied_to_types_1_and_2 = {2365, DiagnosticCategory::Error, S("Operator_0_cannot_be_applied_to_types_1_and_2_2365"), S("Operator '{0}' cannot be applied to types '{1}' and '{2}'.")};
        static DiagnosticMessageStore Function_lacks_ending_return_statement_and_return_type_does_not_include_undefined = {2366, DiagnosticCategory::Error, S("Function_lacks_ending_return_statement_and_return_type_does_not_include_undefined_2366"), S("Function lacks ending return statement and return type does not include 'undefined'.")};
        static DiagnosticMessageStore This_condition_will_always_return_0_since_the_types_1_and_2_have_no_overlap = {2367, DiagnosticCategory::Error, S("This_condition_will_always_return_0_since_the_types_1_and_2_have_no_overlap_2367"), S("This condition will always return '{0}' since the types '{1}' and '{2}' have no overlap.")};
        static DiagnosticMessageStore Type_parameter_name_cannot_be_0 = {2368, DiagnosticCategory::Error, S("Type_parameter_name_cannot_be_0_2368"), S("Type parameter name cannot be '{0}'.")};
        static DiagnosticMessageStore A_parameter_property_is_only_allowed_in_a_constructor_implementation = {2369, DiagnosticCategory::Error, S("A_parameter_property_is_only_allowed_in_a_constructor_implementation_2369"), S("A parameter property is only allowed in a constructor implementation.")};
        static DiagnosticMessageStore A_rest_parameter_must_be_of_an_array_type = {2370, DiagnosticCategory::Error, S("A_rest_parameter_must_be_of_an_array_type_2370"), S("A rest parameter must be of an array type.")};
        static DiagnosticMessageStore A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation = {2371, DiagnosticCategory::Error, S("A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation_2371"), S("A parameter initializer is only allowed in a function or constructor implementation.")};
        static DiagnosticMessageStore Parameter_0_cannot_reference_itself = {2372, DiagnosticCategory::Error, S("Parameter_0_cannot_reference_itself_2372"), S("Parameter '{0}' cannot reference itself.")};
        static DiagnosticMessageStore Parameter_0_cannot_reference_identifier_1_declared_after_it = {2373, DiagnosticCategory::Error, S("Parameter_0_cannot_reference_identifier_1_declared_after_it_2373"), S("Parameter '{0}' cannot reference identifier '{1}' declared after it.")};
        static DiagnosticMessageStore Duplicate_string_index_signature = {2374, DiagnosticCategory::Error, S("Duplicate_string_index_signature_2374"), S("Duplicate string index signature.")};
        static DiagnosticMessageStore Duplicate_number_index_signature = {2375, DiagnosticCategory::Error, S("Duplicate_number_index_signature_2375"), S("Duplicate number index signature.")};
        static DiagnosticMessageStore A_super_call_must_be_the_first_statement_in_the_constructor_when_a_class_contains_initialized_properties_parameter_properties_or_private_identifiers = {2376, DiagnosticCategory::Error, S("A_super_call_must_be_the_first_statement_in_the_constructor_when_a_class_contains_initialized_proper_2376"), S("A 'super' call must be the first statement in the constructor when a class contains initialized properties, parameter properties, or private identifiers.")};
        static DiagnosticMessageStore Constructors_for_derived_classes_must_contain_a_super_call = {2377, DiagnosticCategory::Error, S("Constructors_for_derived_classes_must_contain_a_super_call_2377"), S("Constructors for derived classes must contain a 'super' call.")};
        static DiagnosticMessageStore A_get_accessor_must_return_a_value = {2378, DiagnosticCategory::Error, S("A_get_accessor_must_return_a_value_2378"), S("A 'get' accessor must return a value.")};
        static DiagnosticMessageStore Getter_and_setter_accessors_do_not_agree_in_visibility = {2379, DiagnosticCategory::Error, S("Getter_and_setter_accessors_do_not_agree_in_visibility_2379"), S("Getter and setter accessors do not agree in visibility.")};
        static DiagnosticMessageStore get_and_set_accessor_must_have_the_same_type = {2380, DiagnosticCategory::Error, S("get_and_set_accessor_must_have_the_same_type_2380"), S("'get' and 'set' accessor must have the same type.")};
        static DiagnosticMessageStore A_signature_with_an_implementation_cannot_use_a_string_literal_type = {2381, DiagnosticCategory::Error, S("A_signature_with_an_implementation_cannot_use_a_string_literal_type_2381"), S("A signature with an implementation cannot use a string literal type.")};
        static DiagnosticMessageStore Specialized_overload_signature_is_not_assignable_to_any_non_specialized_signature = {2382, DiagnosticCategory::Error, S("Specialized_overload_signature_is_not_assignable_to_any_non_specialized_signature_2382"), S("Specialized overload signature is not assignable to any non-specialized signature.")};
        static DiagnosticMessageStore Overload_signatures_must_all_be_exported_or_non_exported = {2383, DiagnosticCategory::Error, S("Overload_signatures_must_all_be_exported_or_non_exported_2383"), S("Overload signatures must all be exported or non-exported.")};
        static DiagnosticMessageStore Overload_signatures_must_all_be_ambient_or_non_ambient = {2384, DiagnosticCategory::Error, S("Overload_signatures_must_all_be_ambient_or_non_ambient_2384"), S("Overload signatures must all be ambient or non-ambient.")};
        static DiagnosticMessageStore Overload_signatures_must_all_be_public_private_or_protected = {2385, DiagnosticCategory::Error, S("Overload_signatures_must_all_be_public_private_or_protected_2385"), S("Overload signatures must all be public, private or protected.")};
        static DiagnosticMessageStore Overload_signatures_must_all_be_optional_or_required = {2386, DiagnosticCategory::Error, S("Overload_signatures_must_all_be_optional_or_required_2386"), S("Overload signatures must all be optional or required.")};
        static DiagnosticMessageStore Function_overload_must_be_static = {2387, DiagnosticCategory::Error, S("Function_overload_must_be_static_2387"), S("Function overload must be static.")};
        static DiagnosticMessageStore Function_overload_must_not_be_static = {2388, DiagnosticCategory::Error, S("Function_overload_must_not_be_static_2388"), S("Function overload must not be static.")};
        static DiagnosticMessageStore Function_implementation_name_must_be_0 = {2389, DiagnosticCategory::Error, S("Function_implementation_name_must_be_0_2389"), S("Function implementation name must be '{0}'.")};
        static DiagnosticMessageStore Constructor_implementation_is_missing = {2390, DiagnosticCategory::Error, S("Constructor_implementation_is_missing_2390"), S("Constructor implementation is missing.")};
        static DiagnosticMessageStore Function_implementation_is_missing_or_not_immediately_following_the_declaration = {2391, DiagnosticCategory::Error, S("Function_implementation_is_missing_or_not_immediately_following_the_declaration_2391"), S("Function implementation is missing or not immediately following the declaration.")};
        static DiagnosticMessageStore Multiple_constructor_implementations_are_not_allowed = {2392, DiagnosticCategory::Error, S("Multiple_constructor_implementations_are_not_allowed_2392"), S("Multiple constructor implementations are not allowed.")};
        static DiagnosticMessageStore Duplicate_function_implementation = {2393, DiagnosticCategory::Error, S("Duplicate_function_implementation_2393"), S("Duplicate function implementation.")};
        static DiagnosticMessageStore This_overload_signature_is_not_compatible_with_its_implementation_signature = {2394, DiagnosticCategory::Error, S("This_overload_signature_is_not_compatible_with_its_implementation_signature_2394"), S("This overload signature is not compatible with its implementation signature.")};
        static DiagnosticMessageStore Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local = {2395, DiagnosticCategory::Error, S("Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local_2395"), S("Individual declarations in merged declaration '{0}' must be all exported or all local.")};
        static DiagnosticMessageStore Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters = {2396, DiagnosticCategory::Error, S("Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters_2396"), S("Duplicate identifier 'arguments'. Compiler uses 'arguments' to initialize rest parameters.")};
        static DiagnosticMessageStore Declaration_name_conflicts_with_built_in_global_identifier_0 = {2397, DiagnosticCategory::Error, S("Declaration_name_conflicts_with_built_in_global_identifier_0_2397"), S("Declaration name conflicts with built-in global identifier '{0}'.")};
        static DiagnosticMessageStore constructor_cannot_be_used_as_a_parameter_property_name = {2398, DiagnosticCategory::Error, S("constructor_cannot_be_used_as_a_parameter_property_name_2398"), S("'constructor' cannot be used as a parameter property name.")};
        static DiagnosticMessageStore Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference = {2399, DiagnosticCategory::Error, S("Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference_2399"), S("Duplicate identifier '_this'. Compiler uses variable declaration '_this' to capture 'this' reference.")};
        static DiagnosticMessageStore Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference = {2400, DiagnosticCategory::Error, S("Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference_2400"), S("Expression resolves to variable declaration '_this' that compiler uses to capture 'this' reference.")};
        static DiagnosticMessageStore Duplicate_identifier_super_Compiler_uses_super_to_capture_base_class_reference = {2401, DiagnosticCategory::Error, S("Duplicate_identifier_super_Compiler_uses_super_to_capture_base_class_reference_2401"), S("Duplicate identifier '_super'. Compiler uses '_super' to capture base class reference.")};
        static DiagnosticMessageStore Expression_resolves_to_super_that_compiler_uses_to_capture_base_class_reference = {2402, DiagnosticCategory::Error, S("Expression_resolves_to_super_that_compiler_uses_to_capture_base_class_reference_2402"), S("Expression resolves to '_super' that compiler uses to capture base class reference.")};
        static DiagnosticMessageStore Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2 = {2403, DiagnosticCategory::Error, S("Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_t_2403"), S("Subsequent variable declarations must have the same type.  Variable '{0}' must be of type '{1}', but here has type '{2}'.")};
        static DiagnosticMessageStore The_left_hand_side_of_a_for_in_statement_cannot_use_a_type_annotation = {2404, DiagnosticCategory::Error, S("The_left_hand_side_of_a_for_in_statement_cannot_use_a_type_annotation_2404"), S("The left-hand side of a 'for...in' statement cannot use a type annotation.")};
        static DiagnosticMessageStore The_left_hand_side_of_a_for_in_statement_must_be_of_type_string_or_any = {2405, DiagnosticCategory::Error, S("The_left_hand_side_of_a_for_in_statement_must_be_of_type_string_or_any_2405"), S("The left-hand side of a 'for...in' statement must be of type 'string' or 'any'.")};
        static DiagnosticMessageStore The_left_hand_side_of_a_for_in_statement_must_be_a_variable_or_a_property_access = {2406, DiagnosticCategory::Error, S("The_left_hand_side_of_a_for_in_statement_must_be_a_variable_or_a_property_access_2406"), S("The left-hand side of a 'for...in' statement must be a variable or a property access.")};
        static DiagnosticMessageStore The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter_but_here_has_type_0 = {2407, DiagnosticCategory::Error, S("The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter_but_2407"), S("The right-hand side of a 'for...in' statement must be of type 'any', an object type or a type parameter, but here has type '{0}'.")};
        static DiagnosticMessageStore Setters_cannot_return_a_value = {2408, DiagnosticCategory::Error, S("Setters_cannot_return_a_value_2408"), S("Setters cannot return a value.")};
        static DiagnosticMessageStore Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class = {2409, DiagnosticCategory::Error, S("Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class_2409"), S("Return type of constructor signature must be assignable to the instance type of the class.")};
        static DiagnosticMessageStore The_with_statement_is_not_supported_All_symbols_in_a_with_block_will_have_type_any = {2410, DiagnosticCategory::Error, S("The_with_statement_is_not_supported_All_symbols_in_a_with_block_will_have_type_any_2410"), S("The 'with' statement is not supported. All symbols in a 'with' block will have type 'any'.")};
        static DiagnosticMessageStore Property_0_of_type_1_is_not_assignable_to_string_index_type_2 = {2411, DiagnosticCategory::Error, S("Property_0_of_type_1_is_not_assignable_to_string_index_type_2_2411"), S("Property '{0}' of type '{1}' is not assignable to string index type '{2}'.")};
        static DiagnosticMessageStore Property_0_of_type_1_is_not_assignable_to_numeric_index_type_2 = {2412, DiagnosticCategory::Error, S("Property_0_of_type_1_is_not_assignable_to_numeric_index_type_2_2412"), S("Property '{0}' of type '{1}' is not assignable to numeric index type '{2}'.")};
        static DiagnosticMessageStore Numeric_index_type_0_is_not_assignable_to_string_index_type_1 = {2413, DiagnosticCategory::Error, S("Numeric_index_type_0_is_not_assignable_to_string_index_type_1_2413"), S("Numeric index type '{0}' is not assignable to string index type '{1}'.")};
        static DiagnosticMessageStore Class_name_cannot_be_0 = {2414, DiagnosticCategory::Error, S("Class_name_cannot_be_0_2414"), S("Class name cannot be '{0}'.")};
        static DiagnosticMessageStore Class_0_incorrectly_extends_base_class_1 = {2415, DiagnosticCategory::Error, S("Class_0_incorrectly_extends_base_class_1_2415"), S("Class '{0}' incorrectly extends base class '{1}'.")};
        static DiagnosticMessageStore Property_0_in_type_1_is_not_assignable_to_the_same_property_in_base_type_2 = {2416, DiagnosticCategory::Error, S("Property_0_in_type_1_is_not_assignable_to_the_same_property_in_base_type_2_2416"), S("Property '{0}' in type '{1}' is not assignable to the same property in base type '{2}'.")};
        static DiagnosticMessageStore Class_static_side_0_incorrectly_extends_base_class_static_side_1 = {2417, DiagnosticCategory::Error, S("Class_static_side_0_incorrectly_extends_base_class_static_side_1_2417"), S("Class static side '{0}' incorrectly extends base class static side '{1}'.")};
        static DiagnosticMessageStore Type_of_computed_property_s_value_is_0_which_is_not_assignable_to_type_1 = {2418, DiagnosticCategory::Error, S("Type_of_computed_property_s_value_is_0_which_is_not_assignable_to_type_1_2418"), S("Type of computed property's value is '{0}', which is not assignable to type '{1}'.")};
        static DiagnosticMessageStore Types_of_construct_signatures_are_incompatible = {2419, DiagnosticCategory::Error, S("Types_of_construct_signatures_are_incompatible_2419"), S("Types of construct signatures are incompatible.")};
        static DiagnosticMessageStore Class_0_incorrectly_implements_interface_1 = {2420, DiagnosticCategory::Error, S("Class_0_incorrectly_implements_interface_1_2420"), S("Class '{0}' incorrectly implements interface '{1}'.")};
        static DiagnosticMessageStore A_class_can_only_implement_an_object_type_or_intersection_of_object_types_with_statically_known_members = {2422, DiagnosticCategory::Error, S("A_class_can_only_implement_an_object_type_or_intersection_of_object_types_with_statically_known_memb_2422"), S("A class can only implement an object type or intersection of object types with statically known members.")};
        static DiagnosticMessageStore Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor = {2423, DiagnosticCategory::Error, S("Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_access_2423"), S("Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member accessor.")};
        static DiagnosticMessageStore Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function = {2425, DiagnosticCategory::Error, S("Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_functi_2425"), S("Class '{0}' defines instance member property '{1}', but extended class '{2}' defines it as instance member function.")};
        static DiagnosticMessageStore Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function = {2426, DiagnosticCategory::Error, S("Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_functi_2426"), S("Class '{0}' defines instance member accessor '{1}', but extended class '{2}' defines it as instance member function.")};
        static DiagnosticMessageStore Interface_name_cannot_be_0 = {2427, DiagnosticCategory::Error, S("Interface_name_cannot_be_0_2427"), S("Interface name cannot be '{0}'.")};
        static DiagnosticMessageStore All_declarations_of_0_must_have_identical_type_parameters = {2428, DiagnosticCategory::Error, S("All_declarations_of_0_must_have_identical_type_parameters_2428"), S("All declarations of '{0}' must have identical type parameters.")};
        static DiagnosticMessageStore Interface_0_incorrectly_extends_interface_1 = {2430, DiagnosticCategory::Error, S("Interface_0_incorrectly_extends_interface_1_2430"), S("Interface '{0}' incorrectly extends interface '{1}'.")};
        static DiagnosticMessageStore Enum_name_cannot_be_0 = {2431, DiagnosticCategory::Error, S("Enum_name_cannot_be_0_2431"), S("Enum name cannot be '{0}'.")};
        static DiagnosticMessageStore In_an_enum_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_its_first_enum_element = {2432, DiagnosticCategory::Error, S("In_an_enum_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_its_first_enu_2432"), S("In an enum with multiple declarations, only one declaration can omit an initializer for its first enum element.")};
        static DiagnosticMessageStore A_namespace_declaration_cannot_be_in_a_different_file_from_a_class_or_function_with_which_it_is_merged = {2433, DiagnosticCategory::Error, S("A_namespace_declaration_cannot_be_in_a_different_file_from_a_class_or_function_with_which_it_is_merg_2433"), S("A namespace declaration cannot be in a different file from a class or function with which it is merged.")};
        static DiagnosticMessageStore A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged = {2434, DiagnosticCategory::Error, S("A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged_2434"), S("A namespace declaration cannot be located prior to a class or function with which it is merged.")};
        static DiagnosticMessageStore Ambient_modules_cannot_be_nested_in_other_modules_or_namespaces = {2435, DiagnosticCategory::Error, S("Ambient_modules_cannot_be_nested_in_other_modules_or_namespaces_2435"), S("Ambient modules cannot be nested in other modules or namespaces.")};
        static DiagnosticMessageStore Ambient_module_declaration_cannot_specify_relative_module_name = {2436, DiagnosticCategory::Error, S("Ambient_module_declaration_cannot_specify_relative_module_name_2436"), S("Ambient module declaration cannot specify relative module name.")};
        static DiagnosticMessageStore Module_0_is_hidden_by_a_local_declaration_with_the_same_name = {2437, DiagnosticCategory::Error, S("Module_0_is_hidden_by_a_local_declaration_with_the_same_name_2437"), S("Module '{0}' is hidden by a local declaration with the same name.")};
        static DiagnosticMessageStore Import_name_cannot_be_0 = {2438, DiagnosticCategory::Error, S("Import_name_cannot_be_0_2438"), S("Import name cannot be '{0}'.")};
        static DiagnosticMessageStore Import_or_export_declaration_in_an_ambient_module_declaration_cannot_reference_module_through_relative_module_name = {2439, DiagnosticCategory::Error, S("Import_or_export_declaration_in_an_ambient_module_declaration_cannot_reference_module_through_relati_2439"), S("Import or export declaration in an ambient module declaration cannot reference module through relative module name.")};
        static DiagnosticMessageStore Import_declaration_conflicts_with_local_declaration_of_0 = {2440, DiagnosticCategory::Error, S("Import_declaration_conflicts_with_local_declaration_of_0_2440"), S("Import declaration conflicts with local declaration of '{0}'.")};
        static DiagnosticMessageStore Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module = {2441, DiagnosticCategory::Error, S("Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module_2441"), S("Duplicate identifier '{0}'. Compiler reserves name '{1}' in top level scope of a module.")};
        static DiagnosticMessageStore Types_have_separate_declarations_of_a_private_property_0 = {2442, DiagnosticCategory::Error, S("Types_have_separate_declarations_of_a_private_property_0_2442"), S("Types have separate declarations of a private property '{0}'.")};
        static DiagnosticMessageStore Property_0_is_protected_but_type_1_is_not_a_class_derived_from_2 = {2443, DiagnosticCategory::Error, S("Property_0_is_protected_but_type_1_is_not_a_class_derived_from_2_2443"), S("Property '{0}' is protected but type '{1}' is not a class derived from '{2}'.")};
        static DiagnosticMessageStore Property_0_is_protected_in_type_1_but_public_in_type_2 = {2444, DiagnosticCategory::Error, S("Property_0_is_protected_in_type_1_but_public_in_type_2_2444"), S("Property '{0}' is protected in type '{1}' but public in type '{2}'.")};
        static DiagnosticMessageStore Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses = {2445, DiagnosticCategory::Error, S("Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses_2445"), S("Property '{0}' is protected and only accessible within class '{1}' and its subclasses.")};
        static DiagnosticMessageStore Property_0_is_protected_and_only_accessible_through_an_instance_of_class_1 = {2446, DiagnosticCategory::Error, S("Property_0_is_protected_and_only_accessible_through_an_instance_of_class_1_2446"), S("Property '{0}' is protected and only accessible through an instance of class '{1}'.")};
        static DiagnosticMessageStore The_0_operator_is_not_allowed_for_boolean_types_Consider_using_1_instead = {2447, DiagnosticCategory::Error, S("The_0_operator_is_not_allowed_for_boolean_types_Consider_using_1_instead_2447"), S("The '{0}' operator is not allowed for boolean types. Consider using '{1}' instead.")};
        static DiagnosticMessageStore Block_scoped_variable_0_used_before_its_declaration = {2448, DiagnosticCategory::Error, S("Block_scoped_variable_0_used_before_its_declaration_2448"), S("Block-scoped variable '{0}' used before its declaration.")};
        static DiagnosticMessageStore Class_0_used_before_its_declaration = {2449, DiagnosticCategory::Error, S("Class_0_used_before_its_declaration_2449"), S("Class '{0}' used before its declaration.")};
        static DiagnosticMessageStore Enum_0_used_before_its_declaration = {2450, DiagnosticCategory::Error, S("Enum_0_used_before_its_declaration_2450"), S("Enum '{0}' used before its declaration.")};
        static DiagnosticMessageStore Cannot_redeclare_block_scoped_variable_0 = {2451, DiagnosticCategory::Error, S("Cannot_redeclare_block_scoped_variable_0_2451"), S("Cannot redeclare block-scoped variable '{0}'.")};
        static DiagnosticMessageStore An_enum_member_cannot_have_a_numeric_name = {2452, DiagnosticCategory::Error, S("An_enum_member_cannot_have_a_numeric_name_2452"), S("An enum member cannot have a numeric name.")};
        static DiagnosticMessageStore The_type_argument_for_type_parameter_0_cannot_be_inferred_from_the_usage_Consider_specifying_the_type_arguments_explicitly = {2453, DiagnosticCategory::Error, S("The_type_argument_for_type_parameter_0_cannot_be_inferred_from_the_usage_Consider_specifying_the_typ_2453"), S("The type argument for type parameter '{0}' cannot be inferred from the usage. Consider specifying the type arguments explicitly.")};
        static DiagnosticMessageStore Variable_0_is_used_before_being_assigned = {2454, DiagnosticCategory::Error, S("Variable_0_is_used_before_being_assigned_2454"), S("Variable '{0}' is used before being assigned.")};
        static DiagnosticMessageStore Type_argument_candidate_1_is_not_a_valid_type_argument_because_it_is_not_a_supertype_of_candidate_0 = {2455, DiagnosticCategory::Error, S("Type_argument_candidate_1_is_not_a_valid_type_argument_because_it_is_not_a_supertype_of_candidate_0_2455"), S("Type argument candidate '{1}' is not a valid type argument because it is not a supertype of candidate '{0}'.")};
        static DiagnosticMessageStore Type_alias_0_circularly_references_itself = {2456, DiagnosticCategory::Error, S("Type_alias_0_circularly_references_itself_2456"), S("Type alias '{0}' circularly references itself.")};
        static DiagnosticMessageStore Type_alias_name_cannot_be_0 = {2457, DiagnosticCategory::Error, S("Type_alias_name_cannot_be_0_2457"), S("Type alias name cannot be '{0}'.")};
        static DiagnosticMessageStore An_AMD_module_cannot_have_multiple_name_assignments = {2458, DiagnosticCategory::Error, S("An_AMD_module_cannot_have_multiple_name_assignments_2458"), S("An AMD module cannot have multiple name assignments.")};
        static DiagnosticMessageStore Module_0_declares_1_locally_but_it_is_not_exported = {2459, DiagnosticCategory::Error, S("Module_0_declares_1_locally_but_it_is_not_exported_2459"), S("Module '{0}' declares '{1}' locally, but it is not exported.")};
        static DiagnosticMessageStore Module_0_declares_1_locally_but_it_is_exported_as_2 = {2460, DiagnosticCategory::Error, S("Module_0_declares_1_locally_but_it_is_exported_as_2_2460"), S("Module '{0}' declares '{1}' locally, but it is exported as '{2}'.")};
        static DiagnosticMessageStore Type_0_is_not_an_array_type = {2461, DiagnosticCategory::Error, S("Type_0_is_not_an_array_type_2461"), S("Type '{0}' is not an array type.")};
        static DiagnosticMessageStore A_rest_element_must_be_last_in_a_destructuring_pattern = {2462, DiagnosticCategory::Error, S("A_rest_element_must_be_last_in_a_destructuring_pattern_2462"), S("A rest element must be last in a destructuring pattern.")};
        static DiagnosticMessageStore A_binding_pattern_parameter_cannot_be_optional_in_an_implementation_signature = {2463, DiagnosticCategory::Error, S("A_binding_pattern_parameter_cannot_be_optional_in_an_implementation_signature_2463"), S("A binding pattern parameter cannot be optional in an implementation signature.")};
        static DiagnosticMessageStore A_computed_property_name_must_be_of_type_string_number_symbol_or_any = {2464, DiagnosticCategory::Error, S("A_computed_property_name_must_be_of_type_string_number_symbol_or_any_2464"), S("A computed property name must be of type 'string', 'number', 'symbol', or 'any'.")};
        static DiagnosticMessageStore this_cannot_be_referenced_in_a_computed_property_name = {2465, DiagnosticCategory::Error, S("this_cannot_be_referenced_in_a_computed_property_name_2465"), S("'this' cannot be referenced in a computed property name.")};
        static DiagnosticMessageStore super_cannot_be_referenced_in_a_computed_property_name = {2466, DiagnosticCategory::Error, S("super_cannot_be_referenced_in_a_computed_property_name_2466"), S("'super' cannot be referenced in a computed property name.")};
        static DiagnosticMessageStore A_computed_property_name_cannot_reference_a_type_parameter_from_its_containing_type = {2467, DiagnosticCategory::Error, S("A_computed_property_name_cannot_reference_a_type_parameter_from_its_containing_type_2467"), S("A computed property name cannot reference a type parameter from its containing type.")};
        static DiagnosticMessageStore Cannot_find_global_value_0 = {2468, DiagnosticCategory::Error, S("Cannot_find_global_value_0_2468"), S("Cannot find global value '{0}'.")};
        static DiagnosticMessageStore The_0_operator_cannot_be_applied_to_type_symbol = {2469, DiagnosticCategory::Error, S("The_0_operator_cannot_be_applied_to_type_symbol_2469"), S("The '{0}' operator cannot be applied to type 'symbol'.")};
        static DiagnosticMessageStore Symbol_reference_does_not_refer_to_the_global_Symbol_constructor_object = {2470, DiagnosticCategory::Error, S("Symbol_reference_does_not_refer_to_the_global_Symbol_constructor_object_2470"), S("'Symbol' reference does not refer to the global Symbol constructor object.")};
        static DiagnosticMessageStore A_computed_property_name_of_the_form_0_must_be_of_type_symbol = {2471, DiagnosticCategory::Error, S("A_computed_property_name_of_the_form_0_must_be_of_type_symbol_2471"), S("A computed property name of the form '{0}' must be of type 'symbol'.")};
        static DiagnosticMessageStore Spread_operator_in_new_expressions_is_only_available_when_targeting_ECMAScript_5_and_higher = {2472, DiagnosticCategory::Error, S("Spread_operator_in_new_expressions_is_only_available_when_targeting_ECMAScript_5_and_higher_2472"), S("Spread operator in 'new' expressions is only available when targeting ECMAScript 5 and higher.")};
        static DiagnosticMessageStore Enum_declarations_must_all_be_const_or_non_const = {2473, DiagnosticCategory::Error, S("Enum_declarations_must_all_be_const_or_non_const_2473"), S("Enum declarations must all be const or non-const.")};
        static DiagnosticMessageStore const_enum_member_initializers_can_only_contain_literal_values_and_other_computed_enum_values = {2474, DiagnosticCategory::Error, S("const_enum_member_initializers_can_only_contain_literal_values_and_other_computed_enum_values_2474"), S("const enum member initializers can only contain literal values and other computed enum values.")};
        static DiagnosticMessageStore const_enums_can_only_be_used_in_property_or_index_access_expressions_or_the_right_hand_side_of_an_import_declaration_or_export_assignment_or_type_query = {2475, DiagnosticCategory::Error, S("const_enums_can_only_be_used_in_property_or_index_access_expressions_or_the_right_hand_side_of_an_im_2475"), S("'const' enums can only be used in property or index access expressions or the right hand side of an import declaration or export assignment or type query.")};
        static DiagnosticMessageStore A_const_enum_member_can_only_be_accessed_using_a_string_literal = {2476, DiagnosticCategory::Error, S("A_const_enum_member_can_only_be_accessed_using_a_string_literal_2476"), S("A const enum member can only be accessed using a string literal.")};
        static DiagnosticMessageStore const_enum_member_initializer_was_evaluated_to_a_non_finite_value = {2477, DiagnosticCategory::Error, S("const_enum_member_initializer_was_evaluated_to_a_non_finite_value_2477"), S("'const' enum member initializer was evaluated to a non-finite value.")};
        static DiagnosticMessageStore const_enum_member_initializer_was_evaluated_to_disallowed_value_NaN = {2478, DiagnosticCategory::Error, S("const_enum_member_initializer_was_evaluated_to_disallowed_value_NaN_2478"), S("'const' enum member initializer was evaluated to disallowed value 'NaN'.")};
        static DiagnosticMessageStore Property_0_does_not_exist_on_const_enum_1 = {2479, DiagnosticCategory::Error, S("Property_0_does_not_exist_on_const_enum_1_2479"), S("Property '{0}' does not exist on 'const' enum '{1}'.")};
        static DiagnosticMessageStore let_is_not_allowed_to_be_used_as_a_name_in_let_or_const_declarations = {2480, DiagnosticCategory::Error, S("let_is_not_allowed_to_be_used_as_a_name_in_let_or_const_declarations_2480"), S("'let' is not allowed to be used as a name in 'let' or 'const' declarations.")};
        static DiagnosticMessageStore Cannot_initialize_outer_scoped_variable_0_in_the_same_scope_as_block_scoped_declaration_1 = {2481, DiagnosticCategory::Error, S("Cannot_initialize_outer_scoped_variable_0_in_the_same_scope_as_block_scoped_declaration_1_2481"), S("Cannot initialize outer scoped variable '{0}' in the same scope as block scoped declaration '{1}'.")};
        static DiagnosticMessageStore The_left_hand_side_of_a_for_of_statement_cannot_use_a_type_annotation = {2483, DiagnosticCategory::Error, S("The_left_hand_side_of_a_for_of_statement_cannot_use_a_type_annotation_2483"), S("The left-hand side of a 'for...of' statement cannot use a type annotation.")};
        static DiagnosticMessageStore Export_declaration_conflicts_with_exported_declaration_of_0 = {2484, DiagnosticCategory::Error, S("Export_declaration_conflicts_with_exported_declaration_of_0_2484"), S("Export declaration conflicts with exported declaration of '{0}'.")};
        static DiagnosticMessageStore The_left_hand_side_of_a_for_of_statement_must_be_a_variable_or_a_property_access = {2487, DiagnosticCategory::Error, S("The_left_hand_side_of_a_for_of_statement_must_be_a_variable_or_a_property_access_2487"), S("The left-hand side of a 'for...of' statement must be a variable or a property access.")};
        static DiagnosticMessageStore Type_0_must_have_a_Symbol_iterator_method_that_returns_an_iterator = {2488, DiagnosticCategory::Error, S("Type_0_must_have_a_Symbol_iterator_method_that_returns_an_iterator_2488"), S("Type '{0}' must have a '[Symbol.iterator]()' method that returns an iterator.")};
        static DiagnosticMessageStore An_iterator_must_have_a_next_method = {2489, DiagnosticCategory::Error, S("An_iterator_must_have_a_next_method_2489"), S("An iterator must have a 'next()' method.")};
        static DiagnosticMessageStore The_type_returned_by_the_0_method_of_an_iterator_must_have_a_value_property = {2490, DiagnosticCategory::Error, S("The_type_returned_by_the_0_method_of_an_iterator_must_have_a_value_property_2490"), S("The type returned by the '{0}()' method of an iterator must have a 'value' property.")};
        static DiagnosticMessageStore The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern = {2491, DiagnosticCategory::Error, S("The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern_2491"), S("The left-hand side of a 'for...in' statement cannot be a destructuring pattern.")};
        static DiagnosticMessageStore Cannot_redeclare_identifier_0_in_catch_clause = {2492, DiagnosticCategory::Error, S("Cannot_redeclare_identifier_0_in_catch_clause_2492"), S("Cannot redeclare identifier '{0}' in catch clause.")};
        static DiagnosticMessageStore Tuple_type_0_of_length_1_has_no_element_at_index_2 = {2493, DiagnosticCategory::Error, S("Tuple_type_0_of_length_1_has_no_element_at_index_2_2493"), S("Tuple type '{0}' of length '{1}' has no element at index '{2}'.")};
        static DiagnosticMessageStore Using_a_string_in_a_for_of_statement_is_only_supported_in_ECMAScript_5_and_higher = {2494, DiagnosticCategory::Error, S("Using_a_string_in_a_for_of_statement_is_only_supported_in_ECMAScript_5_and_higher_2494"), S("Using a string in a 'for...of' statement is only supported in ECMAScript 5 and higher.")};
        static DiagnosticMessageStore Type_0_is_not_an_array_type_or_a_string_type = {2495, DiagnosticCategory::Error, S("Type_0_is_not_an_array_type_or_a_string_type_2495"), S("Type '{0}' is not an array type or a string type.")};
        static DiagnosticMessageStore The_arguments_object_cannot_be_referenced_in_an_arrow_function_in_ES3_and_ES5_Consider_using_a_standard_function_expression = {2496, DiagnosticCategory::Error, S("The_arguments_object_cannot_be_referenced_in_an_arrow_function_in_ES3_and_ES5_Consider_using_a_stand_2496"), S("The 'arguments' object cannot be referenced in an arrow function in ES3 and ES5. Consider using a standard function expression.")};
        static DiagnosticMessageStore This_module_can_only_be_referenced_with_ECMAScript_imports_Slashexports_by_turning_on_the_0_flag_and_referencing_its_default_export = {2497, DiagnosticCategory::Error, S("This_module_can_only_be_referenced_with_ECMAScript_imports_Slashexports_by_turning_on_the_0_flag_and_2497"), S("This module can only be referenced with ECMAScript imports/exports by turning on the '{0}' flag and referencing its default export.")};
        static DiagnosticMessageStore Module_0_uses_export_and_cannot_be_used_with_export_Asterisk = {2498, DiagnosticCategory::Error, S("Module_0_uses_export_and_cannot_be_used_with_export_Asterisk_2498"), S("Module '{0}' uses 'export =' and cannot be used with 'export *'.")};
        static DiagnosticMessageStore An_interface_can_only_extend_an_identifier_Slashqualified_name_with_optional_type_arguments = {2499, DiagnosticCategory::Error, S("An_interface_can_only_extend_an_identifier_Slashqualified_name_with_optional_type_arguments_2499"), S("An interface can only extend an identifier/qualified-name with optional type arguments.")};
        static DiagnosticMessageStore A_class_can_only_implement_an_identifier_Slashqualified_name_with_optional_type_arguments = {2500, DiagnosticCategory::Error, S("A_class_can_only_implement_an_identifier_Slashqualified_name_with_optional_type_arguments_2500"), S("A class can only implement an identifier/qualified-name with optional type arguments.")};
        static DiagnosticMessageStore A_rest_element_cannot_contain_a_binding_pattern = {2501, DiagnosticCategory::Error, S("A_rest_element_cannot_contain_a_binding_pattern_2501"), S("A rest element cannot contain a binding pattern.")};
        static DiagnosticMessageStore _0_is_referenced_directly_or_indirectly_in_its_own_type_annotation = {2502, DiagnosticCategory::Error, S("_0_is_referenced_directly_or_indirectly_in_its_own_type_annotation_2502"), S("'{0}' is referenced directly or indirectly in its own type annotation.")};
        static DiagnosticMessageStore Cannot_find_namespace_0 = {2503, DiagnosticCategory::Error, S("Cannot_find_namespace_0_2503"), S("Cannot find namespace '{0}'.")};
        static DiagnosticMessageStore Type_0_must_have_a_Symbol_asyncIterator_method_that_returns_an_async_iterator = {2504, DiagnosticCategory::Error, S("Type_0_must_have_a_Symbol_asyncIterator_method_that_returns_an_async_iterator_2504"), S("Type '{0}' must have a '[Symbol.asyncIterator]()' method that returns an async iterator.")};
        static DiagnosticMessageStore A_generator_cannot_have_a_void_type_annotation = {2505, DiagnosticCategory::Error, S("A_generator_cannot_have_a_void_type_annotation_2505"), S("A generator cannot have a 'void' type annotation.")};
        static DiagnosticMessageStore _0_is_referenced_directly_or_indirectly_in_its_own_base_expression = {2506, DiagnosticCategory::Error, S("_0_is_referenced_directly_or_indirectly_in_its_own_base_expression_2506"), S("'{0}' is referenced directly or indirectly in its own base expression.")};
        static DiagnosticMessageStore Type_0_is_not_a_constructor_function_type = {2507, DiagnosticCategory::Error, S("Type_0_is_not_a_constructor_function_type_2507"), S("Type '{0}' is not a constructor function type.")};
        static DiagnosticMessageStore No_base_constructor_has_the_specified_number_of_type_arguments = {2508, DiagnosticCategory::Error, S("No_base_constructor_has_the_specified_number_of_type_arguments_2508"), S("No base constructor has the specified number of type arguments.")};
        static DiagnosticMessageStore Base_constructor_return_type_0_is_not_an_object_type_or_intersection_of_object_types_with_statically_known_members = {2509, DiagnosticCategory::Error, S("Base_constructor_return_type_0_is_not_an_object_type_or_intersection_of_object_types_with_statically_2509"), S("Base constructor return type '{0}' is not an object type or intersection of object types with statically known members.")};
        static DiagnosticMessageStore Base_constructors_must_all_have_the_same_return_type = {2510, DiagnosticCategory::Error, S("Base_constructors_must_all_have_the_same_return_type_2510"), S("Base constructors must all have the same return type.")};
        static DiagnosticMessageStore Cannot_create_an_instance_of_an_abstract_class = {2511, DiagnosticCategory::Error, S("Cannot_create_an_instance_of_an_abstract_class_2511"), S("Cannot create an instance of an abstract class.")};
        static DiagnosticMessageStore Overload_signatures_must_all_be_abstract_or_non_abstract = {2512, DiagnosticCategory::Error, S("Overload_signatures_must_all_be_abstract_or_non_abstract_2512"), S("Overload signatures must all be abstract or non-abstract.")};
        static DiagnosticMessageStore Abstract_method_0_in_class_1_cannot_be_accessed_via_super_expression = {2513, DiagnosticCategory::Error, S("Abstract_method_0_in_class_1_cannot_be_accessed_via_super_expression_2513"), S("Abstract method '{0}' in class '{1}' cannot be accessed via super expression.")};
        static DiagnosticMessageStore Classes_containing_abstract_methods_must_be_marked_abstract = {2514, DiagnosticCategory::Error, S("Classes_containing_abstract_methods_must_be_marked_abstract_2514"), S("Classes containing abstract methods must be marked abstract.")};
        static DiagnosticMessageStore Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_class_2 = {2515, DiagnosticCategory::Error, S("Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_class_2_2515"), S("Non-abstract class '{0}' does not implement inherited abstract member '{1}' from class '{2}'.")};
        static DiagnosticMessageStore All_declarations_of_an_abstract_method_must_be_consecutive = {2516, DiagnosticCategory::Error, S("All_declarations_of_an_abstract_method_must_be_consecutive_2516"), S("All declarations of an abstract method must be consecutive.")};
        static DiagnosticMessageStore Cannot_assign_an_abstract_constructor_type_to_a_non_abstract_constructor_type = {2517, DiagnosticCategory::Error, S("Cannot_assign_an_abstract_constructor_type_to_a_non_abstract_constructor_type_2517"), S("Cannot assign an abstract constructor type to a non-abstract constructor type.")};
        static DiagnosticMessageStore A_this_based_type_guard_is_not_compatible_with_a_parameter_based_type_guard = {2518, DiagnosticCategory::Error, S("A_this_based_type_guard_is_not_compatible_with_a_parameter_based_type_guard_2518"), S("A 'this'-based type guard is not compatible with a parameter-based type guard.")};
        static DiagnosticMessageStore An_async_iterator_must_have_a_next_method = {2519, DiagnosticCategory::Error, S("An_async_iterator_must_have_a_next_method_2519"), S("An async iterator must have a 'next()' method.")};
        static DiagnosticMessageStore Duplicate_identifier_0_Compiler_uses_declaration_1_to_support_async_functions = {2520, DiagnosticCategory::Error, S("Duplicate_identifier_0_Compiler_uses_declaration_1_to_support_async_functions_2520"), S("Duplicate identifier '{0}'. Compiler uses declaration '{1}' to support async functions.")};
        static DiagnosticMessageStore Expression_resolves_to_variable_declaration_0_that_compiler_uses_to_support_async_functions = {2521, DiagnosticCategory::Error, S("Expression_resolves_to_variable_declaration_0_that_compiler_uses_to_support_async_functions_2521"), S("Expression resolves to variable declaration '{0}' that compiler uses to support async functions.")};
        static DiagnosticMessageStore The_arguments_object_cannot_be_referenced_in_an_async_function_or_method_in_ES3_and_ES5_Consider_using_a_standard_function_or_method = {2522, DiagnosticCategory::Error, S("The_arguments_object_cannot_be_referenced_in_an_async_function_or_method_in_ES3_and_ES5_Consider_usi_2522"), S("The 'arguments' object cannot be referenced in an async function or method in ES3 and ES5. Consider using a standard function or method.")};
        static DiagnosticMessageStore yield_expressions_cannot_be_used_in_a_parameter_initializer = {2523, DiagnosticCategory::Error, S("yield_expressions_cannot_be_used_in_a_parameter_initializer_2523"), S("'yield' expressions cannot be used in a parameter initializer.")};
        static DiagnosticMessageStore await_expressions_cannot_be_used_in_a_parameter_initializer = {2524, DiagnosticCategory::Error, S("await_expressions_cannot_be_used_in_a_parameter_initializer_2524"), S("'await' expressions cannot be used in a parameter initializer.")};
        static DiagnosticMessageStore Initializer_provides_no_value_for_this_binding_element_and_the_binding_element_has_no_default_value = {2525, DiagnosticCategory::Error, S("Initializer_provides_no_value_for_this_binding_element_and_the_binding_element_has_no_default_value_2525"), S("Initializer provides no value for this binding element and the binding element has no default value.")};
        static DiagnosticMessageStore A_this_type_is_available_only_in_a_non_static_member_of_a_class_or_interface = {2526, DiagnosticCategory::Error, S("A_this_type_is_available_only_in_a_non_static_member_of_a_class_or_interface_2526"), S("A 'this' type is available only in a non-static member of a class or interface.")};
        static DiagnosticMessageStore The_inferred_type_of_0_references_an_inaccessible_1_type_A_type_annotation_is_necessary = {2527, DiagnosticCategory::Error, S("The_inferred_type_of_0_references_an_inaccessible_1_type_A_type_annotation_is_necessary_2527"), S("The inferred type of '{0}' references an inaccessible '{1}' type. A type annotation is necessary.")};
        static DiagnosticMessageStore A_module_cannot_have_multiple_default_exports = {2528, DiagnosticCategory::Error, S("A_module_cannot_have_multiple_default_exports_2528"), S("A module cannot have multiple default exports.")};
        static DiagnosticMessageStore Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module_containing_async_functions = {2529, DiagnosticCategory::Error, S("Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module_containing_async_func_2529"), S("Duplicate identifier '{0}'. Compiler reserves name '{1}' in top level scope of a module containing async functions.")};
        static DiagnosticMessageStore Property_0_is_incompatible_with_index_signature = {2530, DiagnosticCategory::Error, S("Property_0_is_incompatible_with_index_signature_2530"), S("Property '{0}' is incompatible with index signature.")};
        static DiagnosticMessageStore Object_is_possibly_null = {2531, DiagnosticCategory::Error, S("Object_is_possibly_null_2531"), S("Object is possibly 'null'.")};
        static DiagnosticMessageStore Object_is_possibly_undefined = {2532, DiagnosticCategory::Error, S("Object_is_possibly_undefined_2532"), S("Object is possibly 'undefined'.")};
        static DiagnosticMessageStore Object_is_possibly_null_or_undefined = {2533, DiagnosticCategory::Error, S("Object_is_possibly_null_or_undefined_2533"), S("Object is possibly 'null' or 'undefined'.")};
        static DiagnosticMessageStore A_function_returning_never_cannot_have_a_reachable_end_point = {2534, DiagnosticCategory::Error, S("A_function_returning_never_cannot_have_a_reachable_end_point_2534"), S("A function returning 'never' cannot have a reachable end point.")};
        static DiagnosticMessageStore Enum_type_0_has_members_with_initializers_that_are_not_literals = {2535, DiagnosticCategory::Error, S("Enum_type_0_has_members_with_initializers_that_are_not_literals_2535"), S("Enum type '{0}' has members with initializers that are not literals.")};
        static DiagnosticMessageStore Type_0_cannot_be_used_to_index_type_1 = {2536, DiagnosticCategory::Error, S("Type_0_cannot_be_used_to_index_type_1_2536"), S("Type '{0}' cannot be used to index type '{1}'.")};
        static DiagnosticMessageStore Type_0_has_no_matching_index_signature_for_type_1 = {2537, DiagnosticCategory::Error, S("Type_0_has_no_matching_index_signature_for_type_1_2537"), S("Type '{0}' has no matching index signature for type '{1}'.")};
        static DiagnosticMessageStore Type_0_cannot_be_used_as_an_index_type = {2538, DiagnosticCategory::Error, S("Type_0_cannot_be_used_as_an_index_type_2538"), S("Type '{0}' cannot be used as an index type.")};
        static DiagnosticMessageStore Cannot_assign_to_0_because_it_is_not_a_variable = {2539, DiagnosticCategory::Error, S("Cannot_assign_to_0_because_it_is_not_a_variable_2539"), S("Cannot assign to '{0}' because it is not a variable.")};
        static DiagnosticMessageStore Cannot_assign_to_0_because_it_is_a_read_only_property = {2540, DiagnosticCategory::Error, S("Cannot_assign_to_0_because_it_is_a_read_only_property_2540"), S("Cannot assign to '{0}' because it is a read-only property.")};
        static DiagnosticMessageStore The_target_of_an_assignment_must_be_a_variable_or_a_property_access = {2541, DiagnosticCategory::Error, S("The_target_of_an_assignment_must_be_a_variable_or_a_property_access_2541"), S("The target of an assignment must be a variable or a property access.")};
        static DiagnosticMessageStore Index_signature_in_type_0_only_permits_reading = {2542, DiagnosticCategory::Error, S("Index_signature_in_type_0_only_permits_reading_2542"), S("Index signature in type '{0}' only permits reading.")};
        static DiagnosticMessageStore Duplicate_identifier_newTarget_Compiler_uses_variable_declaration_newTarget_to_capture_new_target_meta_property_reference = {2543, DiagnosticCategory::Error, S("Duplicate_identifier_newTarget_Compiler_uses_variable_declaration_newTarget_to_capture_new_target_me_2543"), S("Duplicate identifier '_newTarget'. Compiler uses variable declaration '_newTarget' to capture 'new.target' meta-property reference.")};
        static DiagnosticMessageStore Expression_resolves_to_variable_declaration_newTarget_that_compiler_uses_to_capture_new_target_meta_property_reference = {2544, DiagnosticCategory::Error, S("Expression_resolves_to_variable_declaration_newTarget_that_compiler_uses_to_capture_new_target_meta__2544"), S("Expression resolves to variable declaration '_newTarget' that compiler uses to capture 'new.target' meta-property reference.")};
        static DiagnosticMessageStore A_mixin_class_must_have_a_constructor_with_a_single_rest_parameter_of_type_any = {2545, DiagnosticCategory::Error, S("A_mixin_class_must_have_a_constructor_with_a_single_rest_parameter_of_type_any_2545"), S("A mixin class must have a constructor with a single rest parameter of type 'any[]'.")};
        static DiagnosticMessageStore The_type_returned_by_the_0_method_of_an_async_iterator_must_be_a_promise_for_a_type_with_a_value_property = {2547, DiagnosticCategory::Error, S("The_type_returned_by_the_0_method_of_an_async_iterator_must_be_a_promise_for_a_type_with_a_value_pro_2547"), S("The type returned by the '{0}()' method of an async iterator must be a promise for a type with a 'value' property.")};
        static DiagnosticMessageStore Type_0_is_not_an_array_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator = {2548, DiagnosticCategory::Error, S("Type_0_is_not_an_array_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator_2548"), S("Type '{0}' is not an array type or does not have a '[Symbol.iterator]()' method that returns an iterator.")};
        static DiagnosticMessageStore Type_0_is_not_an_array_type_or_a_string_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator = {2549, DiagnosticCategory::Error, S("Type_0_is_not_an_array_type_or_a_string_type_or_does_not_have_a_Symbol_iterator_method_that_returns__2549"), S("Type '{0}' is not an array type or a string type or does not have a '[Symbol.iterator]()' method that returns an iterator.")};
        static DiagnosticMessageStore Property_0_does_not_exist_on_type_1_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_2_or_later = {2550, DiagnosticCategory::Error, S("Property_0_does_not_exist_on_type_1_Do_you_need_to_change_your_target_library_Try_changing_the_lib_c_2550"), S("Property '{0}' does not exist on type '{1}'. Do you need to change your target library? Try changing the `lib` compiler option to '{2}' or later.")};
        static DiagnosticMessageStore Property_0_does_not_exist_on_type_1_Did_you_mean_2 = {2551, DiagnosticCategory::Error, S("Property_0_does_not_exist_on_type_1_Did_you_mean_2_2551"), S("Property '{0}' does not exist on type '{1}'. Did you mean '{2}'?")};
        static DiagnosticMessageStore Cannot_find_name_0_Did_you_mean_1 = {2552, DiagnosticCategory::Error, S("Cannot_find_name_0_Did_you_mean_1_2552"), S("Cannot find name '{0}'. Did you mean '{1}'?")};
        static DiagnosticMessageStore Computed_values_are_not_permitted_in_an_enum_with_string_valued_members = {2553, DiagnosticCategory::Error, S("Computed_values_are_not_permitted_in_an_enum_with_string_valued_members_2553"), S("Computed values are not permitted in an enum with string valued members.")};
        static DiagnosticMessageStore Expected_0_arguments_but_got_1 = {2554, DiagnosticCategory::Error, S("Expected_0_arguments_but_got_1_2554"), S("Expected {0} arguments, but got {1}.")};
        static DiagnosticMessageStore Expected_at_least_0_arguments_but_got_1 = {2555, DiagnosticCategory::Error, S("Expected_at_least_0_arguments_but_got_1_2555"), S("Expected at least {0} arguments, but got {1}.")};
        static DiagnosticMessageStore Expected_0_arguments_but_got_1_or_more = {2556, DiagnosticCategory::Error, S("Expected_0_arguments_but_got_1_or_more_2556"), S("Expected {0} arguments, but got {1} or more.")};
        static DiagnosticMessageStore Expected_at_least_0_arguments_but_got_1_or_more = {2557, DiagnosticCategory::Error, S("Expected_at_least_0_arguments_but_got_1_or_more_2557"), S("Expected at least {0} arguments, but got {1} or more.")};
        static DiagnosticMessageStore Expected_0_type_arguments_but_got_1 = {2558, DiagnosticCategory::Error, S("Expected_0_type_arguments_but_got_1_2558"), S("Expected {0} type arguments, but got {1}.")};
        static DiagnosticMessageStore Type_0_has_no_properties_in_common_with_type_1 = {2559, DiagnosticCategory::Error, S("Type_0_has_no_properties_in_common_with_type_1_2559"), S("Type '{0}' has no properties in common with type '{1}'.")};
        static DiagnosticMessageStore Value_of_type_0_has_no_properties_in_common_with_type_1_Did_you_mean_to_call_it = {2560, DiagnosticCategory::Error, S("Value_of_type_0_has_no_properties_in_common_with_type_1_Did_you_mean_to_call_it_2560"), S("Value of type '{0}' has no properties in common with type '{1}'. Did you mean to call it?")};
        static DiagnosticMessageStore Object_literal_may_only_specify_known_properties_but_0_does_not_exist_in_type_1_Did_you_mean_to_write_2 = {2561, DiagnosticCategory::Error, S("Object_literal_may_only_specify_known_properties_but_0_does_not_exist_in_type_1_Did_you_mean_to_writ_2561"), S("Object literal may only specify known properties, but '{0}' does not exist in type '{1}'. Did you mean to write '{2}'?")};
        static DiagnosticMessageStore Base_class_expressions_cannot_reference_class_type_parameters = {2562, DiagnosticCategory::Error, S("Base_class_expressions_cannot_reference_class_type_parameters_2562"), S("Base class expressions cannot reference class type parameters.")};
        static DiagnosticMessageStore The_containing_function_or_module_body_is_too_large_for_control_flow_analysis = {2563, DiagnosticCategory::Error, S("The_containing_function_or_module_body_is_too_large_for_control_flow_analysis_2563"), S("The containing function or module body is too large for control flow analysis.")};
        static DiagnosticMessageStore Property_0_has_no_initializer_and_is_not_definitely_assigned_in_the_constructor = {2564, DiagnosticCategory::Error, S("Property_0_has_no_initializer_and_is_not_definitely_assigned_in_the_constructor_2564"), S("Property '{0}' has no initializer and is not definitely assigned in the constructor.")};
        static DiagnosticMessageStore Property_0_is_used_before_being_assigned = {2565, DiagnosticCategory::Error, S("Property_0_is_used_before_being_assigned_2565"), S("Property '{0}' is used before being assigned.")};
        static DiagnosticMessageStore A_rest_element_cannot_have_a_property_name = {2566, DiagnosticCategory::Error, S("A_rest_element_cannot_have_a_property_name_2566"), S("A rest element cannot have a property name.")};
        static DiagnosticMessageStore Enum_declarations_can_only_merge_with_namespace_or_other_enum_declarations = {2567, DiagnosticCategory::Error, S("Enum_declarations_can_only_merge_with_namespace_or_other_enum_declarations_2567"), S("Enum declarations can only merge with namespace or other enum declarations.")};
        static DiagnosticMessageStore Type_0_is_not_an_array_type_or_a_string_type_Use_compiler_option_downlevelIteration_to_allow_iterating_of_iterators = {2569, DiagnosticCategory::Error, S("Type_0_is_not_an_array_type_or_a_string_type_Use_compiler_option_downlevelIteration_to_allow_iterati_2569"), S("Type '{0}' is not an array type or a string type. Use compiler option '--downlevelIteration' to allow iterating of iterators.")};
        static DiagnosticMessageStore Object_is_of_type_unknown = {2571, DiagnosticCategory::Error, S("Object_is_of_type_unknown_2571"), S("Object is of type 'unknown'.")};
        static DiagnosticMessageStore Rest_signatures_are_incompatible = {2572, DiagnosticCategory::Error, S("Rest_signatures_are_incompatible_2572"), S("Rest signatures are incompatible.")};
        static DiagnosticMessageStore Property_0_is_incompatible_with_rest_element_type = {2573, DiagnosticCategory::Error, S("Property_0_is_incompatible_with_rest_element_type_2573"), S("Property '{0}' is incompatible with rest element type.")};
        static DiagnosticMessageStore A_rest_element_type_must_be_an_array_type = {2574, DiagnosticCategory::Error, S("A_rest_element_type_must_be_an_array_type_2574"), S("A rest element type must be an array type.")};
        static DiagnosticMessageStore No_overload_expects_0_arguments_but_overloads_do_exist_that_expect_either_1_or_2_arguments = {2575, DiagnosticCategory::Error, S("No_overload_expects_0_arguments_but_overloads_do_exist_that_expect_either_1_or_2_arguments_2575"), S("No overload expects {0} arguments, but overloads do exist that expect either {1} or {2} arguments.")};
        static DiagnosticMessageStore Property_0_does_not_exist_on_type_1_Did_you_mean_to_access_the_static_member_2_instead = {2576, DiagnosticCategory::Error, S("Property_0_does_not_exist_on_type_1_Did_you_mean_to_access_the_static_member_2_instead_2576"), S("Property '{0}' does not exist on type '{1}'. Did you mean to access the static member '{2}' instead?")};
        static DiagnosticMessageStore Return_type_annotation_circularly_references_itself = {2577, DiagnosticCategory::Error, S("Return_type_annotation_circularly_references_itself_2577"), S("Return type annotation circularly references itself.")};
        static DiagnosticMessageStore Unused_ts_expect_error_directive = {2578, DiagnosticCategory::Error, S("Unused_ts_expect_error_directive_2578"), S("Unused '@ts-expect-error' directive.")};
        static DiagnosticMessageStore Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_Slashnode = {2580, DiagnosticCategory::Error, S("Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_Slashno_2580"), S("Cannot find name '{0}'. Do you need to install type definitions for node? Try `npm i --save-dev @types/node`.")};
        static DiagnosticMessageStore Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_Slashjquery = {2581, DiagnosticCategory::Error, S("Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_Slash_2581"), S("Cannot find name '{0}'. Do you need to install type definitions for jQuery? Try `npm i --save-dev @types/jquery`.")};
        static DiagnosticMessageStore Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_types_Slashjest_or_npm_i_save_dev_types_Slashmocha = {2582, DiagnosticCategory::Error, S("Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_type_2582"), S("Cannot find name '{0}'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha`.")};
        static DiagnosticMessageStore Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_1_or_later = {2583, DiagnosticCategory::Error, S("Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_2583"), S("Cannot find name '{0}'. Do you need to change your target library? Try changing the `lib` compiler option to '{1}' or later.")};
        static DiagnosticMessageStore Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_include_dom = {2584, DiagnosticCategory::Error, S("Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_2584"), S("Cannot find name '{0}'. Do you need to change your target library? Try changing the `lib` compiler option to include 'dom'.")};
        static DiagnosticMessageStore _0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_es2015_or_later = {2585, DiagnosticCategory::Error, S("_0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Do_you_need_to_change_your_target_library_2585"), S("'{0}' only refers to a type, but is being used as a value here. Do you need to change your target library? Try changing the `lib` compiler option to es2015 or later.")};
        static DiagnosticMessageStore Enum_type_0_circularly_references_itself = {2586, DiagnosticCategory::Error, S("Enum_type_0_circularly_references_itself_2586"), S("Enum type '{0}' circularly references itself.")};
        static DiagnosticMessageStore JSDoc_type_0_circularly_references_itself = {2587, DiagnosticCategory::Error, S("JSDoc_type_0_circularly_references_itself_2587"), S("JSDoc type '{0}' circularly references itself.")};
        static DiagnosticMessageStore Cannot_assign_to_0_because_it_is_a_constant = {2588, DiagnosticCategory::Error, S("Cannot_assign_to_0_because_it_is_a_constant_2588"), S("Cannot assign to '{0}' because it is a constant.")};
        static DiagnosticMessageStore Type_instantiation_is_excessively_deep_and_possibly_infinite = {2589, DiagnosticCategory::Error, S("Type_instantiation_is_excessively_deep_and_possibly_infinite_2589"), S("Type instantiation is excessively deep and possibly infinite.")};
        static DiagnosticMessageStore Expression_produces_a_union_type_that_is_too_complex_to_represent = {2590, DiagnosticCategory::Error, S("Expression_produces_a_union_type_that_is_too_complex_to_represent_2590"), S("Expression produces a union type that is too complex to represent.")};
        static DiagnosticMessageStore Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_Slashnode_and_then_add_node_to_the_types_field_in_your_tsconfig = {2591, DiagnosticCategory::Error, S("Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_Slashno_2591"), S("Cannot find name '{0}'. Do you need to install type definitions for node? Try `npm i --save-dev @types/node` and then add `node` to the types field in your tsconfig.")};
        static DiagnosticMessageStore Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_Slashjquery_and_then_add_jquery_to_the_types_field_in_your_tsconfig = {2592, DiagnosticCategory::Error, S("Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_Slash_2592"), S("Cannot find name '{0}'. Do you need to install type definitions for jQuery? Try `npm i --save-dev @types/jquery` and then add `jquery` to the types field in your tsconfig.")};
        static DiagnosticMessageStore Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_types_Slashjest_or_npm_i_save_dev_types_Slashmocha_and_then_add_jest_or_mocha_to_the_types_field_in_your_tsconfig = {2593, DiagnosticCategory::Error, S("Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_type_2593"), S("Cannot find name '{0}'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add `jest` or `mocha` to the types field in your tsconfig.")};
        static DiagnosticMessageStore This_module_is_declared_with_using_export_and_can_only_be_used_with_a_default_import_when_using_the_0_flag = {2594, DiagnosticCategory::Error, S("This_module_is_declared_with_using_export_and_can_only_be_used_with_a_default_import_when_using_the__2594"), S("This module is declared with using 'export =', and can only be used with a default import when using the '{0}' flag.")};
        static DiagnosticMessageStore _0_can_only_be_imported_by_using_a_default_import = {2595, DiagnosticCategory::Error, S("_0_can_only_be_imported_by_using_a_default_import_2595"), S("'{0}' can only be imported by using a default import.")};
        static DiagnosticMessageStore _0_can_only_be_imported_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import = {2596, DiagnosticCategory::Error, S("_0_can_only_be_imported_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import_2596"), S("'{0}' can only be imported by turning on the 'esModuleInterop' flag and using a default import.")};
        static DiagnosticMessageStore _0_can_only_be_imported_by_using_a_require_call_or_by_using_a_default_import = {2597, DiagnosticCategory::Error, S("_0_can_only_be_imported_by_using_a_require_call_or_by_using_a_default_import_2597"), S("'{0}' can only be imported by using a 'require' call or by using a default import.")};
        static DiagnosticMessageStore _0_can_only_be_imported_by_using_a_require_call_or_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import = {2598, DiagnosticCategory::Error, S("_0_can_only_be_imported_by_using_a_require_call_or_by_turning_on_the_esModuleInterop_flag_and_using__2598"), S("'{0}' can only be imported by using a 'require' call or by turning on the 'esModuleInterop' flag and using a default import.")};
        static DiagnosticMessageStore JSX_element_attributes_type_0_may_not_be_a_union_type = {2600, DiagnosticCategory::Error, S("JSX_element_attributes_type_0_may_not_be_a_union_type_2600"), S("JSX element attributes type '{0}' may not be a union type.")};
        static DiagnosticMessageStore The_return_type_of_a_JSX_element_constructor_must_return_an_object_type = {2601, DiagnosticCategory::Error, S("The_return_type_of_a_JSX_element_constructor_must_return_an_object_type_2601"), S("The return type of a JSX element constructor must return an object type.")};
        static DiagnosticMessageStore JSX_element_implicitly_has_type_any_because_the_global_type_JSX_Element_does_not_exist = {2602, DiagnosticCategory::Error, S("JSX_element_implicitly_has_type_any_because_the_global_type_JSX_Element_does_not_exist_2602"), S("JSX element implicitly has type 'any' because the global type 'JSX.Element' does not exist.")};
        static DiagnosticMessageStore Property_0_in_type_1_is_not_assignable_to_type_2 = {2603, DiagnosticCategory::Error, S("Property_0_in_type_1_is_not_assignable_to_type_2_2603"), S("Property '{0}' in type '{1}' is not assignable to type '{2}'.")};
        static DiagnosticMessageStore JSX_element_type_0_does_not_have_any_construct_or_call_signatures = {2604, DiagnosticCategory::Error, S("JSX_element_type_0_does_not_have_any_construct_or_call_signatures_2604"), S("JSX element type '{0}' does not have any construct or call signatures.")};
        static DiagnosticMessageStore JSX_element_type_0_is_not_a_constructor_function_for_JSX_elements = {2605, DiagnosticCategory::Error, S("JSX_element_type_0_is_not_a_constructor_function_for_JSX_elements_2605"), S("JSX element type '{0}' is not a constructor function for JSX elements.")};
        static DiagnosticMessageStore Property_0_of_JSX_spread_attribute_is_not_assignable_to_target_property = {2606, DiagnosticCategory::Error, S("Property_0_of_JSX_spread_attribute_is_not_assignable_to_target_property_2606"), S("Property '{0}' of JSX spread attribute is not assignable to target property.")};
        static DiagnosticMessageStore JSX_element_class_does_not_support_attributes_because_it_does_not_have_a_0_property = {2607, DiagnosticCategory::Error, S("JSX_element_class_does_not_support_attributes_because_it_does_not_have_a_0_property_2607"), S("JSX element class does not support attributes because it does not have a '{0}' property.")};
        static DiagnosticMessageStore The_global_type_JSX_0_may_not_have_more_than_one_property = {2608, DiagnosticCategory::Error, S("The_global_type_JSX_0_may_not_have_more_than_one_property_2608"), S("The global type 'JSX.{0}' may not have more than one property.")};
        static DiagnosticMessageStore JSX_spread_child_must_be_an_array_type = {2609, DiagnosticCategory::Error, S("JSX_spread_child_must_be_an_array_type_2609"), S("JSX spread child must be an array type.")};
        static DiagnosticMessageStore _0_is_defined_as_an_accessor_in_class_1_but_is_overridden_here_in_2_as_an_instance_property = {2610, DiagnosticCategory::Error, S("_0_is_defined_as_an_accessor_in_class_1_but_is_overridden_here_in_2_as_an_instance_property_2610"), S("'{0}' is defined as an accessor in class '{1}', but is overridden here in '{2}' as an instance property.")};
        static DiagnosticMessageStore _0_is_defined_as_a_property_in_class_1_but_is_overridden_here_in_2_as_an_accessor = {2611, DiagnosticCategory::Error, S("_0_is_defined_as_a_property_in_class_1_but_is_overridden_here_in_2_as_an_accessor_2611"), S("'{0}' is defined as a property in class '{1}', but is overridden here in '{2}' as an accessor.")};
        static DiagnosticMessageStore Property_0_will_overwrite_the_base_property_in_1_If_this_is_intentional_add_an_initializer_Otherwise_add_a_declare_modifier_or_remove_the_redundant_declaration = {2612, DiagnosticCategory::Error, S("Property_0_will_overwrite_the_base_property_in_1_If_this_is_intentional_add_an_initializer_Otherwise_2612"), S("Property '{0}' will overwrite the base property in '{1}'. If this is intentional, add an initializer. Otherwise, add a 'declare' modifier or remove the redundant declaration.")};
        static DiagnosticMessageStore Module_0_has_no_default_export_Did_you_mean_to_use_import_1_from_0_instead = {2613, DiagnosticCategory::Error, S("Module_0_has_no_default_export_Did_you_mean_to_use_import_1_from_0_instead_2613"), S("Module '{0}' has no default export. Did you mean to use 'import { {1} } from {0}' instead?")};
        static DiagnosticMessageStore Module_0_has_no_exported_member_1_Did_you_mean_to_use_import_1_from_0_instead = {2614, DiagnosticCategory::Error, S("Module_0_has_no_exported_member_1_Did_you_mean_to_use_import_1_from_0_instead_2614"), S("Module '{0}' has no exported member '{1}'. Did you mean to use 'import {1} from {0}' instead?")};
        static DiagnosticMessageStore Type_of_property_0_circularly_references_itself_in_mapped_type_1 = {2615, DiagnosticCategory::Error, S("Type_of_property_0_circularly_references_itself_in_mapped_type_1_2615"), S("Type of property '{0}' circularly references itself in mapped type '{1}'.")};
        static DiagnosticMessageStore _0_can_only_be_imported_by_using_import_1_require_2_or_a_default_import = {2616, DiagnosticCategory::Error, S("_0_can_only_be_imported_by_using_import_1_require_2_or_a_default_import_2616"), S("'{0}' can only be imported by using 'import {1} = require({2})' or a default import.")};
        static DiagnosticMessageStore _0_can_only_be_imported_by_using_import_1_require_2_or_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import = {2617, DiagnosticCategory::Error, S("_0_can_only_be_imported_by_using_import_1_require_2_or_by_turning_on_the_esModuleInterop_flag_and_us_2617"), S("'{0}' can only be imported by using 'import {1} = require({2})' or by turning on the 'esModuleInterop' flag and using a default import.")};
        static DiagnosticMessageStore Source_has_0_element_s_but_target_requires_1 = {2618, DiagnosticCategory::Error, S("Source_has_0_element_s_but_target_requires_1_2618"), S("Source has {0} element(s) but target requires {1}.")};
        static DiagnosticMessageStore Source_has_0_element_s_but_target_allows_only_1 = {2619, DiagnosticCategory::Error, S("Source_has_0_element_s_but_target_allows_only_1_2619"), S("Source has {0} element(s) but target allows only {1}.")};
        static DiagnosticMessageStore Target_requires_0_element_s_but_source_may_have_fewer = {2620, DiagnosticCategory::Error, S("Target_requires_0_element_s_but_source_may_have_fewer_2620"), S("Target requires {0} element(s) but source may have fewer.")};
        static DiagnosticMessageStore Target_allows_only_0_element_s_but_source_may_have_more = {2621, DiagnosticCategory::Error, S("Target_allows_only_0_element_s_but_source_may_have_more_2621"), S("Target allows only {0} element(s) but source may have more.")};
        static DiagnosticMessageStore Source_provides_no_match_for_required_element_at_position_0_in_target = {2623, DiagnosticCategory::Error, S("Source_provides_no_match_for_required_element_at_position_0_in_target_2623"), S("Source provides no match for required element at position {0} in target.")};
        static DiagnosticMessageStore Source_provides_no_match_for_variadic_element_at_position_0_in_target = {2624, DiagnosticCategory::Error, S("Source_provides_no_match_for_variadic_element_at_position_0_in_target_2624"), S("Source provides no match for variadic element at position {0} in target.")};
        static DiagnosticMessageStore Variadic_element_at_position_0_in_source_does_not_match_element_at_position_1_in_target = {2625, DiagnosticCategory::Error, S("Variadic_element_at_position_0_in_source_does_not_match_element_at_position_1_in_target_2625"), S("Variadic element at position {0} in source does not match element at position {1} in target.")};
        static DiagnosticMessageStore Type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target = {2626, DiagnosticCategory::Error, S("Type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target_2626"), S("Type at position {0} in source is not compatible with type at position {1} in target.")};
        static DiagnosticMessageStore Type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target = {2627, DiagnosticCategory::Error, S("Type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target_2627"), S("Type at positions {0} through {1} in source is not compatible with type at position {2} in target.")};
        static DiagnosticMessageStore Cannot_augment_module_0_with_value_exports_because_it_resolves_to_a_non_module_entity = {2649, DiagnosticCategory::Error, S("Cannot_augment_module_0_with_value_exports_because_it_resolves_to_a_non_module_entity_2649"), S("Cannot augment module '{0}' with value exports because it resolves to a non-module entity.")};
        static DiagnosticMessageStore A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums = {2651, DiagnosticCategory::Error, S("A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_memb_2651"), S("A member initializer in a enum declaration cannot reference members declared after it, including members defined in other enums.")};
        static DiagnosticMessageStore Merged_declaration_0_cannot_include_a_default_export_declaration_Consider_adding_a_separate_export_default_0_declaration_instead = {2652, DiagnosticCategory::Error, S("Merged_declaration_0_cannot_include_a_default_export_declaration_Consider_adding_a_separate_export_d_2652"), S("Merged declaration '{0}' cannot include a default export declaration. Consider adding a separate 'export default {0}' declaration instead.")};
        static DiagnosticMessageStore Non_abstract_class_expression_does_not_implement_inherited_abstract_member_0_from_class_1 = {2653, DiagnosticCategory::Error, S("Non_abstract_class_expression_does_not_implement_inherited_abstract_member_0_from_class_1_2653"), S("Non-abstract class expression does not implement inherited abstract member '{0}' from class '{1}'.")};
        static DiagnosticMessageStore Exported_external_package_typings_file_cannot_contain_tripleslash_references_Please_contact_the_package_author_to_update_the_package_definition = {2654, DiagnosticCategory::Error, S("Exported_external_package_typings_file_cannot_contain_tripleslash_references_Please_contact_the_pack_2654"), S("Exported external package typings file cannot contain tripleslash references. Please contact the package author to update the package definition.")};
        static DiagnosticMessageStore Exported_external_package_typings_file_0_is_not_a_module_Please_contact_the_package_author_to_update_the_package_definition = {2656, DiagnosticCategory::Error, S("Exported_external_package_typings_file_0_is_not_a_module_Please_contact_the_package_author_to_update_2656"), S("Exported external package typings file '{0}' is not a module. Please contact the package author to update the package definition.")};
        static DiagnosticMessageStore JSX_expressions_must_have_one_parent_element = {2657, DiagnosticCategory::Error, S("JSX_expressions_must_have_one_parent_element_2657"), S("JSX expressions must have one parent element.")};
        static DiagnosticMessageStore Type_0_provides_no_match_for_the_signature_1 = {2658, DiagnosticCategory::Error, S("Type_0_provides_no_match_for_the_signature_1_2658"), S("Type '{0}' provides no match for the signature '{1}'.")};
        static DiagnosticMessageStore super_is_only_allowed_in_members_of_object_literal_expressions_when_option_target_is_ES2015_or_higher = {2659, DiagnosticCategory::Error, S("super_is_only_allowed_in_members_of_object_literal_expressions_when_option_target_is_ES2015_or_highe_2659"), S("'super' is only allowed in members of object literal expressions when option 'target' is 'ES2015' or higher.")};
        static DiagnosticMessageStore super_can_only_be_referenced_in_members_of_derived_classes_or_object_literal_expressions = {2660, DiagnosticCategory::Error, S("super_can_only_be_referenced_in_members_of_derived_classes_or_object_literal_expressions_2660"), S("'super' can only be referenced in members of derived classes or object literal expressions.")};
        static DiagnosticMessageStore Cannot_export_0_Only_local_declarations_can_be_exported_from_a_module = {2661, DiagnosticCategory::Error, S("Cannot_export_0_Only_local_declarations_can_be_exported_from_a_module_2661"), S("Cannot export '{0}'. Only local declarations can be exported from a module.")};
        static DiagnosticMessageStore Cannot_find_name_0_Did_you_mean_the_static_member_1_0 = {2662, DiagnosticCategory::Error, S("Cannot_find_name_0_Did_you_mean_the_static_member_1_0_2662"), S("Cannot find name '{0}'. Did you mean the static member '{1}.{0}'?")};
        static DiagnosticMessageStore Cannot_find_name_0_Did_you_mean_the_instance_member_this_0 = {2663, DiagnosticCategory::Error, S("Cannot_find_name_0_Did_you_mean_the_instance_member_this_0_2663"), S("Cannot find name '{0}'. Did you mean the instance member 'this.{0}'?")};
        static DiagnosticMessageStore Invalid_module_name_in_augmentation_module_0_cannot_be_found = {2664, DiagnosticCategory::Error, S("Invalid_module_name_in_augmentation_module_0_cannot_be_found_2664"), S("Invalid module name in augmentation, module '{0}' cannot be found.")};
        static DiagnosticMessageStore Invalid_module_name_in_augmentation_Module_0_resolves_to_an_untyped_module_at_1_which_cannot_be_augmented = {2665, DiagnosticCategory::Error, S("Invalid_module_name_in_augmentation_Module_0_resolves_to_an_untyped_module_at_1_which_cannot_be_augm_2665"), S("Invalid module name in augmentation. Module '{0}' resolves to an untyped module at '{1}', which cannot be augmented.")};
        static DiagnosticMessageStore Exports_and_export_assignments_are_not_permitted_in_module_augmentations = {2666, DiagnosticCategory::Error, S("Exports_and_export_assignments_are_not_permitted_in_module_augmentations_2666"), S("Exports and export assignments are not permitted in module augmentations.")};
        static DiagnosticMessageStore Imports_are_not_permitted_in_module_augmentations_Consider_moving_them_to_the_enclosing_external_module = {2667, DiagnosticCategory::Error, S("Imports_are_not_permitted_in_module_augmentations_Consider_moving_them_to_the_enclosing_external_mod_2667"), S("Imports are not permitted in module augmentations. Consider moving them to the enclosing external module.")};
        static DiagnosticMessageStore export_modifier_cannot_be_applied_to_ambient_modules_and_module_augmentations_since_they_are_always_visible = {2668, DiagnosticCategory::Error, S("export_modifier_cannot_be_applied_to_ambient_modules_and_module_augmentations_since_they_are_always__2668"), S("'export' modifier cannot be applied to ambient modules and module augmentations since they are always visible.")};
        static DiagnosticMessageStore Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_declarations = {2669, DiagnosticCategory::Error, S("Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_2669"), S("Augmentations for the global scope can only be directly nested in external modules or ambient module declarations.")};
        static DiagnosticMessageStore Augmentations_for_the_global_scope_should_have_declare_modifier_unless_they_appear_in_already_ambient_context = {2670, DiagnosticCategory::Error, S("Augmentations_for_the_global_scope_should_have_declare_modifier_unless_they_appear_in_already_ambien_2670"), S("Augmentations for the global scope should have 'declare' modifier unless they appear in already ambient context.")};
        static DiagnosticMessageStore Cannot_augment_module_0_because_it_resolves_to_a_non_module_entity = {2671, DiagnosticCategory::Error, S("Cannot_augment_module_0_because_it_resolves_to_a_non_module_entity_2671"), S("Cannot augment module '{0}' because it resolves to a non-module entity.")};
        static DiagnosticMessageStore Cannot_assign_a_0_constructor_type_to_a_1_constructor_type = {2672, DiagnosticCategory::Error, S("Cannot_assign_a_0_constructor_type_to_a_1_constructor_type_2672"), S("Cannot assign a '{0}' constructor type to a '{1}' constructor type.")};
        static DiagnosticMessageStore Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration = {2673, DiagnosticCategory::Error, S("Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration_2673"), S("Constructor of class '{0}' is private and only accessible within the class declaration.")};
        static DiagnosticMessageStore Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration = {2674, DiagnosticCategory::Error, S("Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration_2674"), S("Constructor of class '{0}' is protected and only accessible within the class declaration.")};
        static DiagnosticMessageStore Cannot_extend_a_class_0_Class_constructor_is_marked_as_private = {2675, DiagnosticCategory::Error, S("Cannot_extend_a_class_0_Class_constructor_is_marked_as_private_2675"), S("Cannot extend a class '{0}'. Class constructor is marked as private.")};
        static DiagnosticMessageStore Accessors_must_both_be_abstract_or_non_abstract = {2676, DiagnosticCategory::Error, S("Accessors_must_both_be_abstract_or_non_abstract_2676"), S("Accessors must both be abstract or non-abstract.")};
        static DiagnosticMessageStore A_type_predicate_s_type_must_be_assignable_to_its_parameter_s_type = {2677, DiagnosticCategory::Error, S("A_type_predicate_s_type_must_be_assignable_to_its_parameter_s_type_2677"), S("A type predicate's type must be assignable to its parameter's type.")};
        static DiagnosticMessageStore Type_0_is_not_comparable_to_type_1 = {2678, DiagnosticCategory::Error, S("Type_0_is_not_comparable_to_type_1_2678"), S("Type '{0}' is not comparable to type '{1}'.")};
        static DiagnosticMessageStore A_function_that_is_called_with_the_new_keyword_cannot_have_a_this_type_that_is_void = {2679, DiagnosticCategory::Error, S("A_function_that_is_called_with_the_new_keyword_cannot_have_a_this_type_that_is_void_2679"), S("A function that is called with the 'new' keyword cannot have a 'this' type that is 'void'.")};
        static DiagnosticMessageStore A_0_parameter_must_be_the_first_parameter = {2680, DiagnosticCategory::Error, S("A_0_parameter_must_be_the_first_parameter_2680"), S("A '{0}' parameter must be the first parameter.")};
        static DiagnosticMessageStore A_constructor_cannot_have_a_this_parameter = {2681, DiagnosticCategory::Error, S("A_constructor_cannot_have_a_this_parameter_2681"), S("A constructor cannot have a 'this' parameter.")};
        static DiagnosticMessageStore get_and_set_accessor_must_have_the_same_this_type = {2682, DiagnosticCategory::Error, S("get_and_set_accessor_must_have_the_same_this_type_2682"), S("'get' and 'set' accessor must have the same 'this' type.")};
        static DiagnosticMessageStore this_implicitly_has_type_any_because_it_does_not_have_a_type_annotation = {2683, DiagnosticCategory::Error, S("this_implicitly_has_type_any_because_it_does_not_have_a_type_annotation_2683"), S("'this' implicitly has type 'any' because it does not have a type annotation.")};
        static DiagnosticMessageStore The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1 = {2684, DiagnosticCategory::Error, S("The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1_2684"), S("The 'this' context of type '{0}' is not assignable to method's 'this' of type '{1}'.")};
        static DiagnosticMessageStore The_this_types_of_each_signature_are_incompatible = {2685, DiagnosticCategory::Error, S("The_this_types_of_each_signature_are_incompatible_2685"), S("The 'this' types of each signature are incompatible.")};
        static DiagnosticMessageStore _0_refers_to_a_UMD_global_but_the_current_file_is_a_module_Consider_adding_an_import_instead = {2686, DiagnosticCategory::Error, S("_0_refers_to_a_UMD_global_but_the_current_file_is_a_module_Consider_adding_an_import_instead_2686"), S("'{0}' refers to a UMD global, but the current file is a module. Consider adding an import instead.")};
        static DiagnosticMessageStore All_declarations_of_0_must_have_identical_modifiers = {2687, DiagnosticCategory::Error, S("All_declarations_of_0_must_have_identical_modifiers_2687"), S("All declarations of '{0}' must have identical modifiers.")};
        static DiagnosticMessageStore Cannot_find_type_definition_file_for_0 = {2688, DiagnosticCategory::Error, S("Cannot_find_type_definition_file_for_0_2688"), S("Cannot find type definition file for '{0}'.")};
        static DiagnosticMessageStore Cannot_extend_an_interface_0_Did_you_mean_implements = {2689, DiagnosticCategory::Error, S("Cannot_extend_an_interface_0_Did_you_mean_implements_2689"), S("Cannot extend an interface '{0}'. Did you mean 'implements'?")};
        static DiagnosticMessageStore _0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Did_you_mean_to_use_1_in_0 = {2690, DiagnosticCategory::Error, S("_0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Did_you_mean_to_use_1_in_0_2690"), S("'{0}' only refers to a type, but is being used as a value here. Did you mean to use '{1} in {0}'?")};
        static DiagnosticMessageStore An_import_path_cannot_end_with_a_0_extension_Consider_importing_1_instead = {2691, DiagnosticCategory::Error, S("An_import_path_cannot_end_with_a_0_extension_Consider_importing_1_instead_2691"), S("An import path cannot end with a '{0}' extension. Consider importing '{1}' instead.")};
        static DiagnosticMessageStore _0_is_a_primitive_but_1_is_a_wrapper_object_Prefer_using_0_when_possible = {2692, DiagnosticCategory::Error, S("_0_is_a_primitive_but_1_is_a_wrapper_object_Prefer_using_0_when_possible_2692"), S("'{0}' is a primitive, but '{1}' is a wrapper object. Prefer using '{0}' when possible.")};
        static DiagnosticMessageStore _0_only_refers_to_a_type_but_is_being_used_as_a_value_here = {2693, DiagnosticCategory::Error, S("_0_only_refers_to_a_type_but_is_being_used_as_a_value_here_2693"), S("'{0}' only refers to a type, but is being used as a value here.")};
        static DiagnosticMessageStore Namespace_0_has_no_exported_member_1 = {2694, DiagnosticCategory::Error, S("Namespace_0_has_no_exported_member_1_2694"), S("Namespace '{0}' has no exported member '{1}'.")};
        static DiagnosticMessageStore Left_side_of_comma_operator_is_unused_and_has_no_side_effects = {2695, DiagnosticCategory::Error, S("Left_side_of_comma_operator_is_unused_and_has_no_side_effects_2695"), S("Left side of comma operator is unused and has no side effects.")};
        static DiagnosticMessageStore The_Object_type_is_assignable_to_very_few_other_types_Did_you_mean_to_use_the_any_type_instead = {2696, DiagnosticCategory::Error, S("The_Object_type_is_assignable_to_very_few_other_types_Did_you_mean_to_use_the_any_type_instead_2696"), S("The 'Object' type is assignable to very few other types. Did you mean to use the 'any' type instead?")};
        static DiagnosticMessageStore An_async_function_or_method_must_return_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES2015_in_your_lib_option = {2697, DiagnosticCategory::Error, S("An_async_function_or_method_must_return_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_in_2697"), S("An async function or method must return a 'Promise'. Make sure you have a declaration for 'Promise' or include 'ES2015' in your `--lib` option.")};
        static DiagnosticMessageStore Spread_types_may_only_be_created_from_object_types = {2698, DiagnosticCategory::Error, S("Spread_types_may_only_be_created_from_object_types_2698"), S("Spread types may only be created from object types.")};
        static DiagnosticMessageStore Static_property_0_conflicts_with_built_in_property_Function_0_of_constructor_function_1 = {2699, DiagnosticCategory::Error, S("Static_property_0_conflicts_with_built_in_property_Function_0_of_constructor_function_1_2699"), S("Static property '{0}' conflicts with built-in property 'Function.{0}' of constructor function '{1}'.")};
        static DiagnosticMessageStore Rest_types_may_only_be_created_from_object_types = {2700, DiagnosticCategory::Error, S("Rest_types_may_only_be_created_from_object_types_2700"), S("Rest types may only be created from object types.")};
        static DiagnosticMessageStore The_target_of_an_object_rest_assignment_must_be_a_variable_or_a_property_access = {2701, DiagnosticCategory::Error, S("The_target_of_an_object_rest_assignment_must_be_a_variable_or_a_property_access_2701"), S("The target of an object rest assignment must be a variable or a property access.")};
        static DiagnosticMessageStore _0_only_refers_to_a_type_but_is_being_used_as_a_namespace_here = {2702, DiagnosticCategory::Error, S("_0_only_refers_to_a_type_but_is_being_used_as_a_namespace_here_2702"), S("'{0}' only refers to a type, but is being used as a namespace here.")};
        static DiagnosticMessageStore The_operand_of_a_delete_operator_must_be_a_property_reference = {2703, DiagnosticCategory::Error, S("The_operand_of_a_delete_operator_must_be_a_property_reference_2703"), S("The operand of a 'delete' operator must be a property reference.")};
        static DiagnosticMessageStore The_operand_of_a_delete_operator_cannot_be_a_read_only_property = {2704, DiagnosticCategory::Error, S("The_operand_of_a_delete_operator_cannot_be_a_read_only_property_2704"), S("The operand of a 'delete' operator cannot be a read-only property.")};
        static DiagnosticMessageStore An_async_function_or_method_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option = {2705, DiagnosticCategory::Error, S("An_async_function_or_method_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_de_2705"), S("An async function or method in ES5/ES3 requires the 'Promise' constructor.  Make sure you have a declaration for the 'Promise' constructor or include 'ES2015' in your `--lib` option.")};
        static DiagnosticMessageStore Required_type_parameters_may_not_follow_optional_type_parameters = {2706, DiagnosticCategory::Error, S("Required_type_parameters_may_not_follow_optional_type_parameters_2706"), S("Required type parameters may not follow optional type parameters.")};
        static DiagnosticMessageStore Generic_type_0_requires_between_1_and_2_type_arguments = {2707, DiagnosticCategory::Error, S("Generic_type_0_requires_between_1_and_2_type_arguments_2707"), S("Generic type '{0}' requires between {1} and {2} type arguments.")};
        static DiagnosticMessageStore Cannot_use_namespace_0_as_a_value = {2708, DiagnosticCategory::Error, S("Cannot_use_namespace_0_as_a_value_2708"), S("Cannot use namespace '{0}' as a value.")};
        static DiagnosticMessageStore Cannot_use_namespace_0_as_a_type = {2709, DiagnosticCategory::Error, S("Cannot_use_namespace_0_as_a_type_2709"), S("Cannot use namespace '{0}' as a type.")};
        static DiagnosticMessageStore _0_are_specified_twice_The_attribute_named_0_will_be_overwritten = {2710, DiagnosticCategory::Error, S("_0_are_specified_twice_The_attribute_named_0_will_be_overwritten_2710"), S("'{0}' are specified twice. The attribute named '{0}' will be overwritten.")};
        static DiagnosticMessageStore A_dynamic_import_call_returns_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES2015_in_your_lib_option = {2711, DiagnosticCategory::Error, S("A_dynamic_import_call_returns_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES20_2711"), S("A dynamic import call returns a 'Promise'. Make sure you have a declaration for 'Promise' or include 'ES2015' in your `--lib` option.")};
        static DiagnosticMessageStore A_dynamic_import_call_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option = {2712, DiagnosticCategory::Error, S("A_dynamic_import_call_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_declarat_2712"), S("A dynamic import call in ES5/ES3 requires the 'Promise' constructor.  Make sure you have a declaration for the 'Promise' constructor or include 'ES2015' in your `--lib` option.")};
        static DiagnosticMessageStore Cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_Did_you_mean_to_retrieve_the_type_of_the_property_1_in_0_with_0_1 = {2713, DiagnosticCategory::Error, S("Cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_Did_you_mean_to_retrieve_the_type_of_the_p_2713"), S("Cannot access '{0}.{1}' because '{0}' is a type, but not a namespace. Did you mean to retrieve the type of the property '{1}' in '{0}' with '{0}[\"){1}\"]'?")};
        static DiagnosticMessageStore The_expression_of_an_export_assignment_must_be_an_identifier_or_qualified_name_in_an_ambient_context = {2714, DiagnosticCategory::Error, S("The_expression_of_an_export_assignment_must_be_an_identifier_or_qualified_name_in_an_ambient_context_2714"), S("The expression of an export assignment must be an identifier or qualified name in an ambient context.")};
        static DiagnosticMessageStore Abstract_property_0_in_class_1_cannot_be_accessed_in_the_constructor = {2715, DiagnosticCategory::Error, S("Abstract_property_0_in_class_1_cannot_be_accessed_in_the_constructor_2715"), S("Abstract property '{0}' in class '{1}' cannot be accessed in the constructor.")};
        static DiagnosticMessageStore Type_parameter_0_has_a_circular_default = {2716, DiagnosticCategory::Error, S("Type_parameter_0_has_a_circular_default_2716"), S("Type parameter '{0}' has a circular default.")};
        static DiagnosticMessageStore Subsequent_property_declarations_must_have_the_same_type_Property_0_must_be_of_type_1_but_here_has_type_2 = {2717, DiagnosticCategory::Error, S("Subsequent_property_declarations_must_have_the_same_type_Property_0_must_be_of_type_1_but_here_has_t_2717"), S("Subsequent property declarations must have the same type.  Property '{0}' must be of type '{1}', but here has type '{2}'.")};
        static DiagnosticMessageStore Duplicate_property_0 = {2718, DiagnosticCategory::Error, S("Duplicate_property_0_2718"), S("Duplicate property '{0}'.")};
        static DiagnosticMessageStore Type_0_is_not_assignable_to_type_1_Two_different_types_with_this_name_exist_but_they_are_unrelated = {2719, DiagnosticCategory::Error, S("Type_0_is_not_assignable_to_type_1_Two_different_types_with_this_name_exist_but_they_are_unrelated_2719"), S("Type '{0}' is not assignable to type '{1}'. Two different types with this name exist, but they are unrelated.")};
        static DiagnosticMessageStore Class_0_incorrectly_implements_class_1_Did_you_mean_to_extend_1_and_inherit_its_members_as_a_subclass = {2720, DiagnosticCategory::Error, S("Class_0_incorrectly_implements_class_1_Did_you_mean_to_extend_1_and_inherit_its_members_as_a_subclas_2720"), S("Class '{0}' incorrectly implements class '{1}'. Did you mean to extend '{1}' and inherit its members as a subclass?")};
        static DiagnosticMessageStore Cannot_invoke_an_object_which_is_possibly_null = {2721, DiagnosticCategory::Error, S("Cannot_invoke_an_object_which_is_possibly_null_2721"), S("Cannot invoke an object which is possibly 'null'.")};
        static DiagnosticMessageStore Cannot_invoke_an_object_which_is_possibly_undefined = {2722, DiagnosticCategory::Error, S("Cannot_invoke_an_object_which_is_possibly_undefined_2722"), S("Cannot invoke an object which is possibly 'undefined'.")};
        static DiagnosticMessageStore Cannot_invoke_an_object_which_is_possibly_null_or_undefined = {2723, DiagnosticCategory::Error, S("Cannot_invoke_an_object_which_is_possibly_null_or_undefined_2723"), S("Cannot invoke an object which is possibly 'null' or 'undefined'.")};
        static DiagnosticMessageStore _0_has_no_exported_member_named_1_Did_you_mean_2 = {2724, DiagnosticCategory::Error, S("_0_has_no_exported_member_named_1_Did_you_mean_2_2724"), S("'{0}' has no exported member named '{1}'. Did you mean '{2}'?")};
        static DiagnosticMessageStore Class_name_cannot_be_Object_when_targeting_ES5_with_module_0 = {2725, DiagnosticCategory::Error, S("Class_name_cannot_be_Object_when_targeting_ES5_with_module_0_2725"), S("Class name cannot be 'Object' when targeting ES5 with module {0}.")};
        static DiagnosticMessageStore Cannot_find_lib_definition_for_0 = {2726, DiagnosticCategory::Error, S("Cannot_find_lib_definition_for_0_2726"), S("Cannot find lib definition for '{0}'.")};
        static DiagnosticMessageStore Cannot_find_lib_definition_for_0_Did_you_mean_1 = {2727, DiagnosticCategory::Error, S("Cannot_find_lib_definition_for_0_Did_you_mean_1_2727"), S("Cannot find lib definition for '{0}'. Did you mean '{1}'?")};
        static DiagnosticMessageStore _0_is_declared_here = {2728, DiagnosticCategory::Message, S("_0_is_declared_here_2728"), S("'{0}' is declared here.")};
        static DiagnosticMessageStore Property_0_is_used_before_its_initialization = {2729, DiagnosticCategory::Error, S("Property_0_is_used_before_its_initialization_2729"), S("Property '{0}' is used before its initialization.")};
        static DiagnosticMessageStore An_arrow_function_cannot_have_a_this_parameter = {2730, DiagnosticCategory::Error, S("An_arrow_function_cannot_have_a_this_parameter_2730"), S("An arrow function cannot have a 'this' parameter.")};
        static DiagnosticMessageStore Implicit_conversion_of_a_symbol_to_a_string_will_fail_at_runtime_Consider_wrapping_this_expression_in_String = {2731, DiagnosticCategory::Error, S("Implicit_conversion_of_a_symbol_to_a_string_will_fail_at_runtime_Consider_wrapping_this_expression_i_2731"), S("Implicit conversion of a 'symbol' to a 'string' will fail at runtime. Consider wrapping this expression in 'String(...)'.")};
        static DiagnosticMessageStore Cannot_find_module_0_Consider_using_resolveJsonModule_to_import_module_with_json_extension = {2732, DiagnosticCategory::Error, S("Cannot_find_module_0_Consider_using_resolveJsonModule_to_import_module_with_json_extension_2732"), S("Cannot find module '{0}'. Consider using '--resolveJsonModule' to import module with '.json' extension.")};
        static DiagnosticMessageStore Property_0_was_also_declared_here = {2733, DiagnosticCategory::Error, S("Property_0_was_also_declared_here_2733"), S("Property '{0}' was also declared here.")};
        static DiagnosticMessageStore Are_you_missing_a_semicolon = {2734, DiagnosticCategory::Error, S("Are_you_missing_a_semicolon_2734"), S("Are you missing a semicolon?")};
        static DiagnosticMessageStore Did_you_mean_for_0_to_be_constrained_to_type_new_args_Colon_any_1 = {2735, DiagnosticCategory::Error, S("Did_you_mean_for_0_to_be_constrained_to_type_new_args_Colon_any_1_2735"), S("Did you mean for '{0}' to be constrained to type 'new (...args: any[]) => {1}'?")};
        static DiagnosticMessageStore Operator_0_cannot_be_applied_to_type_1 = {2736, DiagnosticCategory::Error, S("Operator_0_cannot_be_applied_to_type_1_2736"), S("Operator '{0}' cannot be applied to type '{1}'.")};
        static DiagnosticMessageStore BigInt_literals_are_not_available_when_targeting_lower_than_ES2020 = {2737, DiagnosticCategory::Error, S("BigInt_literals_are_not_available_when_targeting_lower_than_ES2020_2737"), S("BigInt literals are not available when targeting lower than ES2020.")};
        static DiagnosticMessageStore An_outer_value_of_this_is_shadowed_by_this_container = {2738, DiagnosticCategory::Message, S("An_outer_value_of_this_is_shadowed_by_this_container_2738"), S("An outer value of 'this' is shadowed by this container.")};
        static DiagnosticMessageStore Type_0_is_missing_the_following_properties_from_type_1_Colon_2 = {2739, DiagnosticCategory::Error, S("Type_0_is_missing_the_following_properties_from_type_1_Colon_2_2739"), S("Type '{0}' is missing the following properties from type '{1}': {2}")};
        static DiagnosticMessageStore Type_0_is_missing_the_following_properties_from_type_1_Colon_2_and_3_more = {2740, DiagnosticCategory::Error, S("Type_0_is_missing_the_following_properties_from_type_1_Colon_2_and_3_more_2740"), S("Type '{0}' is missing the following properties from type '{1}': {2}, and {3} more.")};
        static DiagnosticMessageStore Property_0_is_missing_in_type_1_but_required_in_type_2 = {2741, DiagnosticCategory::Error, S("Property_0_is_missing_in_type_1_but_required_in_type_2_2741"), S("Property '{0}' is missing in type '{1}' but required in type '{2}'.")};
        static DiagnosticMessageStore The_inferred_type_of_0_cannot_be_named_without_a_reference_to_1_This_is_likely_not_portable_A_type_annotation_is_necessary = {2742, DiagnosticCategory::Error, S("The_inferred_type_of_0_cannot_be_named_without_a_reference_to_1_This_is_likely_not_portable_A_type_a_2742"), S("The inferred type of '{0}' cannot be named without a reference to '{1}'. This is likely not portable. A type annotation is necessary.")};
        static DiagnosticMessageStore No_overload_expects_0_type_arguments_but_overloads_do_exist_that_expect_either_1_or_2_type_arguments = {2743, DiagnosticCategory::Error, S("No_overload_expects_0_type_arguments_but_overloads_do_exist_that_expect_either_1_or_2_type_arguments_2743"), S("No overload expects {0} type arguments, but overloads do exist that expect either {1} or {2} type arguments.")};
        static DiagnosticMessageStore Type_parameter_defaults_can_only_reference_previously_declared_type_parameters = {2744, DiagnosticCategory::Error, S("Type_parameter_defaults_can_only_reference_previously_declared_type_parameters_2744"), S("Type parameter defaults can only reference previously declared type parameters.")};
        static DiagnosticMessageStore This_JSX_tag_s_0_prop_expects_type_1_which_requires_multiple_children_but_only_a_single_child_was_provided = {2745, DiagnosticCategory::Error, S("This_JSX_tag_s_0_prop_expects_type_1_which_requires_multiple_children_but_only_a_single_child_was_pr_2745"), S("This JSX tag's '{0}' prop expects type '{1}' which requires multiple children, but only a single child was provided.")};
        static DiagnosticMessageStore This_JSX_tag_s_0_prop_expects_a_single_child_of_type_1_but_multiple_children_were_provided = {2746, DiagnosticCategory::Error, S("This_JSX_tag_s_0_prop_expects_a_single_child_of_type_1_but_multiple_children_were_provided_2746"), S("This JSX tag's '{0}' prop expects a single child of type '{1}', but multiple children were provided.")};
        static DiagnosticMessageStore _0_components_don_t_accept_text_as_child_elements_Text_in_JSX_has_the_type_string_but_the_expected_type_of_1_is_2 = {2747, DiagnosticCategory::Error, S("_0_components_don_t_accept_text_as_child_elements_Text_in_JSX_has_the_type_string_but_the_expected_t_2747"), S("'{0}' components don't accept text as child elements. Text in JSX has the type 'string', but the expected type of '{1}' is '{2}'.")};
        static DiagnosticMessageStore Cannot_access_ambient_const_enums_when_the_isolatedModules_flag_is_provided = {2748, DiagnosticCategory::Error, S("Cannot_access_ambient_const_enums_when_the_isolatedModules_flag_is_provided_2748"), S("Cannot access ambient const enums when the '--isolatedModules' flag is provided.")};
        static DiagnosticMessageStore _0_refers_to_a_value_but_is_being_used_as_a_type_here_Did_you_mean_typeof_0 = {2749, DiagnosticCategory::Error, S("_0_refers_to_a_value_but_is_being_used_as_a_type_here_Did_you_mean_typeof_0_2749"), S("'{0}' refers to a value, but is being used as a type here. Did you mean 'typeof {0}'?")};
        static DiagnosticMessageStore The_implementation_signature_is_declared_here = {2750, DiagnosticCategory::Error, S("The_implementation_signature_is_declared_here_2750"), S("The implementation signature is declared here.")};
        static DiagnosticMessageStore Circularity_originates_in_type_at_this_location = {2751, DiagnosticCategory::Error, S("Circularity_originates_in_type_at_this_location_2751"), S("Circularity originates in type at this location.")};
        static DiagnosticMessageStore The_first_export_default_is_here = {2752, DiagnosticCategory::Error, S("The_first_export_default_is_here_2752"), S("The first export default is here.")};
        static DiagnosticMessageStore Another_export_default_is_here = {2753, DiagnosticCategory::Error, S("Another_export_default_is_here_2753"), S("Another export default is here.")};
        static DiagnosticMessageStore super_may_not_use_type_arguments = {2754, DiagnosticCategory::Error, S("super_may_not_use_type_arguments_2754"), S("'super' may not use type arguments.")};
        static DiagnosticMessageStore No_constituent_of_type_0_is_callable = {2755, DiagnosticCategory::Error, S("No_constituent_of_type_0_is_callable_2755"), S("No constituent of type '{0}' is callable.")};
        static DiagnosticMessageStore Not_all_constituents_of_type_0_are_callable = {2756, DiagnosticCategory::Error, S("Not_all_constituents_of_type_0_are_callable_2756"), S("Not all constituents of type '{0}' are callable.")};
        static DiagnosticMessageStore Type_0_has_no_call_signatures = {2757, DiagnosticCategory::Error, S("Type_0_has_no_call_signatures_2757"), S("Type '{0}' has no call signatures.")};
        static DiagnosticMessageStore Each_member_of_the_union_type_0_has_signatures_but_none_of_those_signatures_are_compatible_with_each_other = {2758, DiagnosticCategory::Error, S("Each_member_of_the_union_type_0_has_signatures_but_none_of_those_signatures_are_compatible_with_each_2758"), S("Each member of the union type '{0}' has signatures, but none of those signatures are compatible with each other.")};
        static DiagnosticMessageStore No_constituent_of_type_0_is_constructable = {2759, DiagnosticCategory::Error, S("No_constituent_of_type_0_is_constructable_2759"), S("No constituent of type '{0}' is constructable.")};
        static DiagnosticMessageStore Not_all_constituents_of_type_0_are_constructable = {2760, DiagnosticCategory::Error, S("Not_all_constituents_of_type_0_are_constructable_2760"), S("Not all constituents of type '{0}' are constructable.")};
        static DiagnosticMessageStore Type_0_has_no_construct_signatures = {2761, DiagnosticCategory::Error, S("Type_0_has_no_construct_signatures_2761"), S("Type '{0}' has no construct signatures.")};
        static DiagnosticMessageStore Each_member_of_the_union_type_0_has_construct_signatures_but_none_of_those_signatures_are_compatible_with_each_other = {2762, DiagnosticCategory::Error, S("Each_member_of_the_union_type_0_has_construct_signatures_but_none_of_those_signatures_are_compatible_2762"), S("Each member of the union type '{0}' has construct signatures, but none of those signatures are compatible with each other.")};
        static DiagnosticMessageStore Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_for_of_will_always_send_0 = {2763, DiagnosticCategory::Error, S("Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_for_of_will_always_s_2763"), S("Cannot iterate value because the 'next' method of its iterator expects type '{1}', but for-of will always send '{0}'.")};
        static DiagnosticMessageStore Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_spread_will_always_send_0 = {2764, DiagnosticCategory::Error, S("Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_spread_will_al_2764"), S("Cannot iterate value because the 'next' method of its iterator expects type '{1}', but array spread will always send '{0}'.")};
        static DiagnosticMessageStore Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_destructuring_will_always_send_0 = {2765, DiagnosticCategory::Error, S("Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_destructuring__2765"), S("Cannot iterate value because the 'next' method of its iterator expects type '{1}', but array destructuring will always send '{0}'.")};
        static DiagnosticMessageStore Cannot_delegate_iteration_to_value_because_the_next_method_of_its_iterator_expects_type_1_but_the_containing_generator_will_always_send_0 = {2766, DiagnosticCategory::Error, S("Cannot_delegate_iteration_to_value_because_the_next_method_of_its_iterator_expects_type_1_but_the_co_2766"), S("Cannot delegate iteration to value because the 'next' method of its iterator expects type '{1}', but the containing generator will always send '{0}'.")};
        static DiagnosticMessageStore The_0_property_of_an_iterator_must_be_a_method = {2767, DiagnosticCategory::Error, S("The_0_property_of_an_iterator_must_be_a_method_2767"), S("The '{0}' property of an iterator must be a method.")};
        static DiagnosticMessageStore The_0_property_of_an_async_iterator_must_be_a_method = {2768, DiagnosticCategory::Error, S("The_0_property_of_an_async_iterator_must_be_a_method_2768"), S("The '{0}' property of an async iterator must be a method.")};
        static DiagnosticMessageStore No_overload_matches_this_call = {2769, DiagnosticCategory::Error, S("No_overload_matches_this_call_2769"), S("No overload matches this call.")};
        static DiagnosticMessageStore The_last_overload_gave_the_following_error = {2770, DiagnosticCategory::Error, S("The_last_overload_gave_the_following_error_2770"), S("The last overload gave the following error.")};
        static DiagnosticMessageStore The_last_overload_is_declared_here = {2771, DiagnosticCategory::Error, S("The_last_overload_is_declared_here_2771"), S("The last overload is declared here.")};
        static DiagnosticMessageStore Overload_0_of_1_2_gave_the_following_error = {2772, DiagnosticCategory::Error, S("Overload_0_of_1_2_gave_the_following_error_2772"), S("Overload {0} of {1}, '{2}', gave the following error.")};
        static DiagnosticMessageStore Did_you_forget_to_use_await = {2773, DiagnosticCategory::Error, S("Did_you_forget_to_use_await_2773"), S("Did you forget to use 'await'?")};
        static DiagnosticMessageStore This_condition_will_always_return_true_since_the_function_is_always_defined_Did_you_mean_to_call_it_instead = {2774, DiagnosticCategory::Error, S("This_condition_will_always_return_true_since_the_function_is_always_defined_Did_you_mean_to_call_it__2774"), S("This condition will always return true since the function is always defined. Did you mean to call it instead?")};
        static DiagnosticMessageStore Assertions_require_every_name_in_the_call_target_to_be_declared_with_an_explicit_type_annotation = {2775, DiagnosticCategory::Error, S("Assertions_require_every_name_in_the_call_target_to_be_declared_with_an_explicit_type_annotation_2775"), S("Assertions require every name in the call target to be declared with an explicit type annotation.")};
        static DiagnosticMessageStore Assertions_require_the_call_target_to_be_an_identifier_or_qualified_name = {2776, DiagnosticCategory::Error, S("Assertions_require_the_call_target_to_be_an_identifier_or_qualified_name_2776"), S("Assertions require the call target to be an identifier or qualified name.")};
        static DiagnosticMessageStore The_operand_of_an_increment_or_decrement_operator_may_not_be_an_optional_property_access = {2777, DiagnosticCategory::Error, S("The_operand_of_an_increment_or_decrement_operator_may_not_be_an_optional_property_access_2777"), S("The operand of an increment or decrement operator may not be an optional property access.")};
        static DiagnosticMessageStore The_target_of_an_object_rest_assignment_may_not_be_an_optional_property_access = {2778, DiagnosticCategory::Error, S("The_target_of_an_object_rest_assignment_may_not_be_an_optional_property_access_2778"), S("The target of an object rest assignment may not be an optional property access.")};
        static DiagnosticMessageStore The_left_hand_side_of_an_assignment_expression_may_not_be_an_optional_property_access = {2779, DiagnosticCategory::Error, S("The_left_hand_side_of_an_assignment_expression_may_not_be_an_optional_property_access_2779"), S("The left-hand side of an assignment expression may not be an optional property access.")};
        static DiagnosticMessageStore The_left_hand_side_of_a_for_in_statement_may_not_be_an_optional_property_access = {2780, DiagnosticCategory::Error, S("The_left_hand_side_of_a_for_in_statement_may_not_be_an_optional_property_access_2780"), S("The left-hand side of a 'for...in' statement may not be an optional property access.")};
        static DiagnosticMessageStore The_left_hand_side_of_a_for_of_statement_may_not_be_an_optional_property_access = {2781, DiagnosticCategory::Error, S("The_left_hand_side_of_a_for_of_statement_may_not_be_an_optional_property_access_2781"), S("The left-hand side of a 'for...of' statement may not be an optional property access.")};
        static DiagnosticMessageStore _0_needs_an_explicit_type_annotation = {2782, DiagnosticCategory::Message, S("_0_needs_an_explicit_type_annotation_2782"), S("'{0}' needs an explicit type annotation.")};
        static DiagnosticMessageStore _0_is_specified_more_than_once_so_this_usage_will_be_overwritten = {2783, DiagnosticCategory::Error, S("_0_is_specified_more_than_once_so_this_usage_will_be_overwritten_2783"), S("'{0}' is specified more than once, so this usage will be overwritten.")};
        static DiagnosticMessageStore get_and_set_accessors_cannot_declare_this_parameters = {2784, DiagnosticCategory::Error, S("get_and_set_accessors_cannot_declare_this_parameters_2784"), S("'get' and 'set' accessors cannot declare 'this' parameters.")};
        static DiagnosticMessageStore This_spread_always_overwrites_this_property = {2785, DiagnosticCategory::Error, S("This_spread_always_overwrites_this_property_2785"), S("This spread always overwrites this property.")};
        static DiagnosticMessageStore _0_cannot_be_used_as_a_JSX_component = {2786, DiagnosticCategory::Error, S("_0_cannot_be_used_as_a_JSX_component_2786"), S("'{0}' cannot be used as a JSX component.")};
        static DiagnosticMessageStore Its_return_type_0_is_not_a_valid_JSX_element = {2787, DiagnosticCategory::Error, S("Its_return_type_0_is_not_a_valid_JSX_element_2787"), S("Its return type '{0}' is not a valid JSX element.")};
        static DiagnosticMessageStore Its_instance_type_0_is_not_a_valid_JSX_element = {2788, DiagnosticCategory::Error, S("Its_instance_type_0_is_not_a_valid_JSX_element_2788"), S("Its instance type '{0}' is not a valid JSX element.")};
        static DiagnosticMessageStore Its_element_type_0_is_not_a_valid_JSX_element = {2789, DiagnosticCategory::Error, S("Its_element_type_0_is_not_a_valid_JSX_element_2789"), S("Its element type '{0}' is not a valid JSX element.")};
        static DiagnosticMessageStore The_operand_of_a_delete_operator_must_be_optional = {2790, DiagnosticCategory::Error, S("The_operand_of_a_delete_operator_must_be_optional_2790"), S("The operand of a 'delete' operator must be optional.")};
        static DiagnosticMessageStore Exponentiation_cannot_be_performed_on_bigint_values_unless_the_target_option_is_set_to_es2016_or_later = {2791, DiagnosticCategory::Error, S("Exponentiation_cannot_be_performed_on_bigint_values_unless_the_target_option_is_set_to_es2016_or_lat_2791"), S("Exponentiation cannot be performed on 'bigint' values unless the 'target' option is set to 'es2016' or later.")};
        static DiagnosticMessageStore Cannot_find_module_0_Did_you_mean_to_set_the_moduleResolution_option_to_node_or_to_add_aliases_to_the_paths_option = {2792, DiagnosticCategory::Error, S("Cannot_find_module_0_Did_you_mean_to_set_the_moduleResolution_option_to_node_or_to_add_aliases_to_th_2792"), S("Cannot find module '{0}'. Did you mean to set the 'moduleResolution' option to 'node', or to add aliases to the 'paths' option?")};
        static DiagnosticMessageStore The_call_would_have_succeeded_against_this_implementation_but_implementation_signatures_of_overloads_are_not_externally_visible = {2793, DiagnosticCategory::Error, S("The_call_would_have_succeeded_against_this_implementation_but_implementation_signatures_of_overloads_2793"), S("The call would have succeeded against this implementation, but implementation signatures of overloads are not externally visible.")};
        static DiagnosticMessageStore Expected_0_arguments_but_got_1_Did_you_forget_to_include_void_in_your_type_argument_to_Promise = {2794, DiagnosticCategory::Error, S("Expected_0_arguments_but_got_1_Did_you_forget_to_include_void_in_your_type_argument_to_Promise_2794"), S("Expected {0} arguments, but got {1}. Did you forget to include 'void' in your type argument to 'Promise'?")};
        static DiagnosticMessageStore The_intrinsic_keyword_can_only_be_used_to_declare_compiler_provided_intrinsic_types = {2795, DiagnosticCategory::Error, S("The_intrinsic_keyword_can_only_be_used_to_declare_compiler_provided_intrinsic_types_2795"), S("The 'intrinsic' keyword can only be used to declare compiler provided intrinsic types.")};
        static DiagnosticMessageStore It_is_likely_that_you_are_missing_a_comma_to_separate_these_two_template_expressions_They_form_a_tagged_template_expression_which_cannot_be_invoked = {2796, DiagnosticCategory::Error, S("It_is_likely_that_you_are_missing_a_comma_to_separate_these_two_template_expressions_They_form_a_tag_2796"), S("It is likely that you are missing a comma to separate these two template expressions. They form a tagged template expression which cannot be invoked.")};
        static DiagnosticMessageStore A_mixin_class_that_extends_from_a_type_variable_containing_an_abstract_construct_signature_must_also_be_declared_abstract = {2797, DiagnosticCategory::Error, S("A_mixin_class_that_extends_from_a_type_variable_containing_an_abstract_construct_signature_must_also_2797"), S("A mixin class that extends from a type variable containing an abstract construct signature must also be declared 'abstract'.")};
        static DiagnosticMessageStore Import_declaration_0_is_using_private_name_1 = {4000, DiagnosticCategory::Error, S("Import_declaration_0_is_using_private_name_1_4000"), S("Import declaration '{0}' is using private name '{1}'.")};
        static DiagnosticMessageStore Type_parameter_0_of_exported_class_has_or_is_using_private_name_1 = {4002, DiagnosticCategory::Error, S("Type_parameter_0_of_exported_class_has_or_is_using_private_name_1_4002"), S("Type parameter '{0}' of exported class has or is using private name '{1}'.")};
        static DiagnosticMessageStore Type_parameter_0_of_exported_interface_has_or_is_using_private_name_1 = {4004, DiagnosticCategory::Error, S("Type_parameter_0_of_exported_interface_has_or_is_using_private_name_1_4004"), S("Type parameter '{0}' of exported interface has or is using private name '{1}'.")};
        static DiagnosticMessageStore Type_parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1 = {4006, DiagnosticCategory::Error, S("Type_parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1_4006"), S("Type parameter '{0}' of constructor signature from exported interface has or is using private name '{1}'.")};
        static DiagnosticMessageStore Type_parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1 = {4008, DiagnosticCategory::Error, S("Type_parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1_4008"), S("Type parameter '{0}' of call signature from exported interface has or is using private name '{1}'.")};
        static DiagnosticMessageStore Type_parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1 = {4010, DiagnosticCategory::Error, S("Type_parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1_4010"), S("Type parameter '{0}' of public static method from exported class has or is using private name '{1}'.")};
        static DiagnosticMessageStore Type_parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1 = {4012, DiagnosticCategory::Error, S("Type_parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1_4012"), S("Type parameter '{0}' of public method from exported class has or is using private name '{1}'.")};
        static DiagnosticMessageStore Type_parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1 = {4014, DiagnosticCategory::Error, S("Type_parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1_4014"), S("Type parameter '{0}' of method from exported interface has or is using private name '{1}'.")};
        static DiagnosticMessageStore Type_parameter_0_of_exported_function_has_or_is_using_private_name_1 = {4016, DiagnosticCategory::Error, S("Type_parameter_0_of_exported_function_has_or_is_using_private_name_1_4016"), S("Type parameter '{0}' of exported function has or is using private name '{1}'.")};
        static DiagnosticMessageStore Implements_clause_of_exported_class_0_has_or_is_using_private_name_1 = {4019, DiagnosticCategory::Error, S("Implements_clause_of_exported_class_0_has_or_is_using_private_name_1_4019"), S("Implements clause of exported class '{0}' has or is using private name '{1}'.")};
        static DiagnosticMessageStore extends_clause_of_exported_class_0_has_or_is_using_private_name_1 = {4020, DiagnosticCategory::Error, S("extends_clause_of_exported_class_0_has_or_is_using_private_name_1_4020"), S("'extends' clause of exported class '{0}' has or is using private name '{1}'.")};
        static DiagnosticMessageStore extends_clause_of_exported_class_has_or_is_using_private_name_0 = {4021, DiagnosticCategory::Error, S("extends_clause_of_exported_class_has_or_is_using_private_name_0_4021"), S("'extends' clause of exported class has or is using private name '{0}'.")};
        static DiagnosticMessageStore extends_clause_of_exported_interface_0_has_or_is_using_private_name_1 = {4022, DiagnosticCategory::Error, S("extends_clause_of_exported_interface_0_has_or_is_using_private_name_1_4022"), S("'extends' clause of exported interface '{0}' has or is using private name '{1}'.")};
        static DiagnosticMessageStore Exported_variable_0_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named = {4023, DiagnosticCategory::Error, S("Exported_variable_0_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named_4023"), S("Exported variable '{0}' has or is using name '{1}' from external module {2} but cannot be named.")};
        static DiagnosticMessageStore Exported_variable_0_has_or_is_using_name_1_from_private_module_2 = {4024, DiagnosticCategory::Error, S("Exported_variable_0_has_or_is_using_name_1_from_private_module_2_4024"), S("Exported variable '{0}' has or is using name '{1}' from private module '{2}'.")};
        static DiagnosticMessageStore Exported_variable_0_has_or_is_using_private_name_1 = {4025, DiagnosticCategory::Error, S("Exported_variable_0_has_or_is_using_private_name_1_4025"), S("Exported variable '{0}' has or is using private name '{1}'.")};
        static DiagnosticMessageStore Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named = {4026, DiagnosticCategory::Error, S("Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot__4026"), S("Public static property '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named.")};
        static DiagnosticMessageStore Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2 = {4027, DiagnosticCategory::Error, S("Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2_4027"), S("Public static property '{0}' of exported class has or is using name '{1}' from private module '{2}'.")};
        static DiagnosticMessageStore Public_static_property_0_of_exported_class_has_or_is_using_private_name_1 = {4028, DiagnosticCategory::Error, S("Public_static_property_0_of_exported_class_has_or_is_using_private_name_1_4028"), S("Public static property '{0}' of exported class has or is using private name '{1}'.")};
        static DiagnosticMessageStore Public_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named = {4029, DiagnosticCategory::Error, S("Public_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_name_4029"), S("Public property '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named.")};
        static DiagnosticMessageStore Public_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2 = {4030, DiagnosticCategory::Error, S("Public_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2_4030"), S("Public property '{0}' of exported class has or is using name '{1}' from private module '{2}'.")};
        static DiagnosticMessageStore Public_property_0_of_exported_class_has_or_is_using_private_name_1 = {4031, DiagnosticCategory::Error, S("Public_property_0_of_exported_class_has_or_is_using_private_name_1_4031"), S("Public property '{0}' of exported class has or is using private name '{1}'.")};
        static DiagnosticMessageStore Property_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2 = {4032, DiagnosticCategory::Error, S("Property_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2_4032"), S("Property '{0}' of exported interface has or is using name '{1}' from private module '{2}'.")};
        static DiagnosticMessageStore Property_0_of_exported_interface_has_or_is_using_private_name_1 = {4033, DiagnosticCategory::Error, S("Property_0_of_exported_interface_has_or_is_using_private_name_1_4033"), S("Property '{0}' of exported interface has or is using private name '{1}'.")};
        static DiagnosticMessageStore Parameter_type_of_public_static_setter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2 = {4034, DiagnosticCategory::Error, S("Parameter_type_of_public_static_setter_0_from_exported_class_has_or_is_using_name_1_from_private_mod_4034"), S("Parameter type of public static setter '{0}' from exported class has or is using name '{1}' from private module '{2}'.")};
        static DiagnosticMessageStore Parameter_type_of_public_static_setter_0_from_exported_class_has_or_is_using_private_name_1 = {4035, DiagnosticCategory::Error, S("Parameter_type_of_public_static_setter_0_from_exported_class_has_or_is_using_private_name_1_4035"), S("Parameter type of public static setter '{0}' from exported class has or is using private name '{1}'.")};
        static DiagnosticMessageStore Parameter_type_of_public_setter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2 = {4036, DiagnosticCategory::Error, S("Parameter_type_of_public_setter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2_4036"), S("Parameter type of public setter '{0}' from exported class has or is using name '{1}' from private module '{2}'.")};
        static DiagnosticMessageStore Parameter_type_of_public_setter_0_from_exported_class_has_or_is_using_private_name_1 = {4037, DiagnosticCategory::Error, S("Parameter_type_of_public_setter_0_from_exported_class_has_or_is_using_private_name_1_4037"), S("Parameter type of public setter '{0}' from exported class has or is using private name '{1}'.")};
        static DiagnosticMessageStore Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named = {4038, DiagnosticCategory::Error, S("Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_name_1_from_external_modul_4038"), S("Return type of public static getter '{0}' from exported class has or is using name '{1}' from external module {2} but cannot be named.")};
        static DiagnosticMessageStore Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2 = {4039, DiagnosticCategory::Error, S("Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_name_1_from_private_module_4039"), S("Return type of public static getter '{0}' from exported class has or is using name '{1}' from private module '{2}'.")};
        static DiagnosticMessageStore Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_private_name_1 = {4040, DiagnosticCategory::Error, S("Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_private_name_1_4040"), S("Return type of public static getter '{0}' from exported class has or is using private name '{1}'.")};
        static DiagnosticMessageStore Return_type_of_public_getter_0_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named = {4041, DiagnosticCategory::Error, S("Return_type_of_public_getter_0_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_4041"), S("Return type of public getter '{0}' from exported class has or is using name '{1}' from external module {2} but cannot be named.")};
        static DiagnosticMessageStore Return_type_of_public_getter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2 = {4042, DiagnosticCategory::Error, S("Return_type_of_public_getter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2_4042"), S("Return type of public getter '{0}' from exported class has or is using name '{1}' from private module '{2}'.")};
        static DiagnosticMessageStore Return_type_of_public_getter_0_from_exported_class_has_or_is_using_private_name_1 = {4043, DiagnosticCategory::Error, S("Return_type_of_public_getter_0_from_exported_class_has_or_is_using_private_name_1_4043"), S("Return type of public getter '{0}' from exported class has or is using private name '{1}'.")};
        static DiagnosticMessageStore Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1 = {4044, DiagnosticCategory::Error, S("Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_name_0_from_private_mod_4044"), S("Return type of constructor signature from exported interface has or is using name '{0}' from private module '{1}'.")};
        static DiagnosticMessageStore Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_0 = {4045, DiagnosticCategory::Error, S("Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_0_4045"), S("Return type of constructor signature from exported interface has or is using private name '{0}'.")};
        static DiagnosticMessageStore Return_type_of_call_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1 = {4046, DiagnosticCategory::Error, S("Return_type_of_call_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1_4046"), S("Return type of call signature from exported interface has or is using name '{0}' from private module '{1}'.")};
        static DiagnosticMessageStore Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_name_0 = {4047, DiagnosticCategory::Error, S("Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_name_0_4047"), S("Return type of call signature from exported interface has or is using private name '{0}'.")};
        static DiagnosticMessageStore Return_type_of_index_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1 = {4048, DiagnosticCategory::Error, S("Return_type_of_index_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1_4048"), S("Return type of index signature from exported interface has or is using name '{0}' from private module '{1}'.")};
        static DiagnosticMessageStore Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_name_0 = {4049, DiagnosticCategory::Error, S("Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_name_0_4049"), S("Return type of index signature from exported interface has or is using private name '{0}'.")};
        static DiagnosticMessageStore Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named = {4050, DiagnosticCategory::Error, S("Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_external_module__4050"), S("Return type of public static method from exported class has or is using name '{0}' from external module {1} but cannot be named.")};
        static DiagnosticMessageStore Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_private_module_1 = {4051, DiagnosticCategory::Error, S("Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_private_module_1_4051"), S("Return type of public static method from exported class has or is using name '{0}' from private module '{1}'.")};
        static DiagnosticMessageStore Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_name_0 = {4052, DiagnosticCategory::Error, S("Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_name_0_4052"), S("Return type of public static method from exported class has or is using private name '{0}'.")};
        static DiagnosticMessageStore Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named = {4053, DiagnosticCategory::Error, S("Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_c_4053"), S("Return type of public method from exported class has or is using name '{0}' from external module {1} but cannot be named.")};
        static DiagnosticMessageStore Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_private_module_1 = {4054, DiagnosticCategory::Error, S("Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_private_module_1_4054"), S("Return type of public method from exported class has or is using name '{0}' from private module '{1}'.")};
        static DiagnosticMessageStore Return_type_of_public_method_from_exported_class_has_or_is_using_private_name_0 = {4055, DiagnosticCategory::Error, S("Return_type_of_public_method_from_exported_class_has_or_is_using_private_name_0_4055"), S("Return type of public method from exported class has or is using private name '{0}'.")};
        static DiagnosticMessageStore Return_type_of_method_from_exported_interface_has_or_is_using_name_0_from_private_module_1 = {4056, DiagnosticCategory::Error, S("Return_type_of_method_from_exported_interface_has_or_is_using_name_0_from_private_module_1_4056"), S("Return type of method from exported interface has or is using name '{0}' from private module '{1}'.")};
        static DiagnosticMessageStore Return_type_of_method_from_exported_interface_has_or_is_using_private_name_0 = {4057, DiagnosticCategory::Error, S("Return_type_of_method_from_exported_interface_has_or_is_using_private_name_0_4057"), S("Return type of method from exported interface has or is using private name '{0}'.")};
        static DiagnosticMessageStore Return_type_of_exported_function_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named = {4058, DiagnosticCategory::Error, S("Return_type_of_exported_function_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named_4058"), S("Return type of exported function has or is using name '{0}' from external module {1} but cannot be named.")};
        static DiagnosticMessageStore Return_type_of_exported_function_has_or_is_using_name_0_from_private_module_1 = {4059, DiagnosticCategory::Error, S("Return_type_of_exported_function_has_or_is_using_name_0_from_private_module_1_4059"), S("Return type of exported function has or is using name '{0}' from private module '{1}'.")};
        static DiagnosticMessageStore Return_type_of_exported_function_has_or_is_using_private_name_0 = {4060, DiagnosticCategory::Error, S("Return_type_of_exported_function_has_or_is_using_private_name_0_4060"), S("Return type of exported function has or is using private name '{0}'.")};
        static DiagnosticMessageStore Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named = {4061, DiagnosticCategory::Error, S("Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_can_4061"), S("Parameter '{0}' of constructor from exported class has or is using name '{1}' from external module {2} but cannot be named.")};
        static DiagnosticMessageStore Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_private_module_2 = {4062, DiagnosticCategory::Error, S("Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_private_module_2_4062"), S("Parameter '{0}' of constructor from exported class has or is using name '{1}' from private module '{2}'.")};
        static DiagnosticMessageStore Parameter_0_of_constructor_from_exported_class_has_or_is_using_private_name_1 = {4063, DiagnosticCategory::Error, S("Parameter_0_of_constructor_from_exported_class_has_or_is_using_private_name_1_4063"), S("Parameter '{0}' of constructor from exported class has or is using private name '{1}'.")};
        static DiagnosticMessageStore Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2 = {4064, DiagnosticCategory::Error, S("Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_name_1_from_private_mod_4064"), S("Parameter '{0}' of constructor signature from exported interface has or is using name '{1}' from private module '{2}'.")};
        static DiagnosticMessageStore Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1 = {4065, DiagnosticCategory::Error, S("Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1_4065"), S("Parameter '{0}' of constructor signature from exported interface has or is using private name '{1}'.")};
        static DiagnosticMessageStore Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2 = {4066, DiagnosticCategory::Error, S("Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2_4066"), S("Parameter '{0}' of call signature from exported interface has or is using name '{1}' from private module '{2}'.")};
        static DiagnosticMessageStore Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1 = {4067, DiagnosticCategory::Error, S("Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1_4067"), S("Parameter '{0}' of call signature from exported interface has or is using private name '{1}'.")};
        static DiagnosticMessageStore Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named = {4068, DiagnosticCategory::Error, S("Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_external_module__4068"), S("Parameter '{0}' of public static method from exported class has or is using name '{1}' from external module {2} but cannot be named.")};
        static DiagnosticMessageStore Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_private_module_2 = {4069, DiagnosticCategory::Error, S("Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_private_module_2_4069"), S("Parameter '{0}' of public static method from exported class has or is using name '{1}' from private module '{2}'.")};
        static DiagnosticMessageStore Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1 = {4070, DiagnosticCategory::Error, S("Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1_4070"), S("Parameter '{0}' of public static method from exported class has or is using private name '{1}'.")};
        static DiagnosticMessageStore Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named = {4071, DiagnosticCategory::Error, S("Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_c_4071"), S("Parameter '{0}' of public method from exported class has or is using name '{1}' from external module {2} but cannot be named.")};
        static DiagnosticMessageStore Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_private_module_2 = {4072, DiagnosticCategory::Error, S("Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_private_module_2_4072"), S("Parameter '{0}' of public method from exported class has or is using name '{1}' from private module '{2}'.")};
        static DiagnosticMessageStore Parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1 = {4073, DiagnosticCategory::Error, S("Parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1_4073"), S("Parameter '{0}' of public method from exported class has or is using private name '{1}'.")};
        static DiagnosticMessageStore Parameter_0_of_method_from_exported_interface_has_or_is_using_name_1_from_private_module_2 = {4074, DiagnosticCategory::Error, S("Parameter_0_of_method_from_exported_interface_has_or_is_using_name_1_from_private_module_2_4074"), S("Parameter '{0}' of method from exported interface has or is using name '{1}' from private module '{2}'.")};
        static DiagnosticMessageStore Parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1 = {4075, DiagnosticCategory::Error, S("Parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1_4075"), S("Parameter '{0}' of method from exported interface has or is using private name '{1}'.")};
        static DiagnosticMessageStore Parameter_0_of_exported_function_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named = {4076, DiagnosticCategory::Error, S("Parameter_0_of_exported_function_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named_4076"), S("Parameter '{0}' of exported function has or is using name '{1}' from external module {2} but cannot be named.")};
        static DiagnosticMessageStore Parameter_0_of_exported_function_has_or_is_using_name_1_from_private_module_2 = {4077, DiagnosticCategory::Error, S("Parameter_0_of_exported_function_has_or_is_using_name_1_from_private_module_2_4077"), S("Parameter '{0}' of exported function has or is using name '{1}' from private module '{2}'.")};
        static DiagnosticMessageStore Parameter_0_of_exported_function_has_or_is_using_private_name_1 = {4078, DiagnosticCategory::Error, S("Parameter_0_of_exported_function_has_or_is_using_private_name_1_4078"), S("Parameter '{0}' of exported function has or is using private name '{1}'.")};
        static DiagnosticMessageStore Exported_type_alias_0_has_or_is_using_private_name_1 = {4081, DiagnosticCategory::Error, S("Exported_type_alias_0_has_or_is_using_private_name_1_4081"), S("Exported type alias '{0}' has or is using private name '{1}'.")};
        static DiagnosticMessageStore Default_export_of_the_module_has_or_is_using_private_name_0 = {4082, DiagnosticCategory::Error, S("Default_export_of_the_module_has_or_is_using_private_name_0_4082"), S("Default export of the module has or is using private name '{0}'.")};
        static DiagnosticMessageStore Type_parameter_0_of_exported_type_alias_has_or_is_using_private_name_1 = {4083, DiagnosticCategory::Error, S("Type_parameter_0_of_exported_type_alias_has_or_is_using_private_name_1_4083"), S("Type parameter '{0}' of exported type alias has or is using private name '{1}'.")};
        static DiagnosticMessageStore Conflicting_definitions_for_0_found_at_1_and_2_Consider_installing_a_specific_version_of_this_library_to_resolve_the_conflict = {4090, DiagnosticCategory::Error, S("Conflicting_definitions_for_0_found_at_1_and_2_Consider_installing_a_specific_version_of_this_librar_4090"), S("Conflicting definitions for '{0}' found at '{1}' and '{2}'. Consider installing a specific version of this library to resolve the conflict.")};
        static DiagnosticMessageStore Parameter_0_of_index_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2 = {4091, DiagnosticCategory::Error, S("Parameter_0_of_index_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2_4091"), S("Parameter '{0}' of index signature from exported interface has or is using name '{1}' from private module '{2}'.")};
        static DiagnosticMessageStore Parameter_0_of_index_signature_from_exported_interface_has_or_is_using_private_name_1 = {4092, DiagnosticCategory::Error, S("Parameter_0_of_index_signature_from_exported_interface_has_or_is_using_private_name_1_4092"), S("Parameter '{0}' of index signature from exported interface has or is using private name '{1}'.")};
        static DiagnosticMessageStore Property_0_of_exported_class_expression_may_not_be_private_or_protected = {4094, DiagnosticCategory::Error, S("Property_0_of_exported_class_expression_may_not_be_private_or_protected_4094"), S("Property '{0}' of exported class expression may not be private or protected.")};
        static DiagnosticMessageStore Public_static_method_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named = {4095, DiagnosticCategory::Error, S("Public_static_method_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_4095"), S("Public static method '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named.")};
        static DiagnosticMessageStore Public_static_method_0_of_exported_class_has_or_is_using_name_1_from_private_module_2 = {4096, DiagnosticCategory::Error, S("Public_static_method_0_of_exported_class_has_or_is_using_name_1_from_private_module_2_4096"), S("Public static method '{0}' of exported class has or is using name '{1}' from private module '{2}'.")};
        static DiagnosticMessageStore Public_static_method_0_of_exported_class_has_or_is_using_private_name_1 = {4097, DiagnosticCategory::Error, S("Public_static_method_0_of_exported_class_has_or_is_using_private_name_1_4097"), S("Public static method '{0}' of exported class has or is using private name '{1}'.")};
        static DiagnosticMessageStore Public_method_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named = {4098, DiagnosticCategory::Error, S("Public_method_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named_4098"), S("Public method '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named.")};
        static DiagnosticMessageStore Public_method_0_of_exported_class_has_or_is_using_name_1_from_private_module_2 = {4099, DiagnosticCategory::Error, S("Public_method_0_of_exported_class_has_or_is_using_name_1_from_private_module_2_4099"), S("Public method '{0}' of exported class has or is using name '{1}' from private module '{2}'.")};
        static DiagnosticMessageStore Public_method_0_of_exported_class_has_or_is_using_private_name_1 = {4100, DiagnosticCategory::Error, S("Public_method_0_of_exported_class_has_or_is_using_private_name_1_4100"), S("Public method '{0}' of exported class has or is using private name '{1}'.")};
        static DiagnosticMessageStore Method_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2 = {4101, DiagnosticCategory::Error, S("Method_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2_4101"), S("Method '{0}' of exported interface has or is using name '{1}' from private module '{2}'.")};
        static DiagnosticMessageStore Method_0_of_exported_interface_has_or_is_using_private_name_1 = {4102, DiagnosticCategory::Error, S("Method_0_of_exported_interface_has_or_is_using_private_name_1_4102"), S("Method '{0}' of exported interface has or is using private name '{1}'.")};
        static DiagnosticMessageStore Type_parameter_0_of_exported_mapped_object_type_is_using_private_name_1 = {4103, DiagnosticCategory::Error, S("Type_parameter_0_of_exported_mapped_object_type_is_using_private_name_1_4103"), S("Type parameter '{0}' of exported mapped object type is using private name '{1}'.")};
        static DiagnosticMessageStore The_type_0_is_readonly_and_cannot_be_assigned_to_the_mutable_type_1 = {4104, DiagnosticCategory::Error, S("The_type_0_is_readonly_and_cannot_be_assigned_to_the_mutable_type_1_4104"), S("The type '{0}' is 'readonly' and cannot be assigned to the mutable type '{1}'.")};
        static DiagnosticMessageStore Private_or_protected_member_0_cannot_be_accessed_on_a_type_parameter = {4105, DiagnosticCategory::Error, S("Private_or_protected_member_0_cannot_be_accessed_on_a_type_parameter_4105"), S("Private or protected member '{0}' cannot be accessed on a type parameter.")};
        static DiagnosticMessageStore Parameter_0_of_accessor_has_or_is_using_private_name_1 = {4106, DiagnosticCategory::Error, S("Parameter_0_of_accessor_has_or_is_using_private_name_1_4106"), S("Parameter '{0}' of accessor has or is using private name '{1}'.")};
        static DiagnosticMessageStore Parameter_0_of_accessor_has_or_is_using_name_1_from_private_module_2 = {4107, DiagnosticCategory::Error, S("Parameter_0_of_accessor_has_or_is_using_name_1_from_private_module_2_4107"), S("Parameter '{0}' of accessor has or is using name '{1}' from private module '{2}'.")};
        static DiagnosticMessageStore Parameter_0_of_accessor_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named = {4108, DiagnosticCategory::Error, S("Parameter_0_of_accessor_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named_4108"), S("Parameter '{0}' of accessor has or is using name '{1}' from external module '{2}' but cannot be named.")};
        static DiagnosticMessageStore Type_arguments_for_0_circularly_reference_themselves = {4109, DiagnosticCategory::Error, S("Type_arguments_for_0_circularly_reference_themselves_4109"), S("Type arguments for '{0}' circularly reference themselves.")};
        static DiagnosticMessageStore Tuple_type_arguments_circularly_reference_themselves = {4110, DiagnosticCategory::Error, S("Tuple_type_arguments_circularly_reference_themselves_4110"), S("Tuple type arguments circularly reference themselves.")};
        static DiagnosticMessageStore Property_0_comes_from_an_index_signature_so_it_must_be_accessed_with_0 = {4111, DiagnosticCategory::Error, S("Property_0_comes_from_an_index_signature_so_it_must_be_accessed_with_0_4111"), S("Property '{0}' comes from an index signature, so it must be accessed with ['{0}'].")};
        static DiagnosticMessageStore The_current_host_does_not_support_the_0_option = {5001, DiagnosticCategory::Error, S("The_current_host_does_not_support_the_0_option_5001"), S("The current host does not support the '{0}' option.")};
        static DiagnosticMessageStore Cannot_find_the_common_subdirectory_path_for_the_input_files = {5009, DiagnosticCategory::Error, S("Cannot_find_the_common_subdirectory_path_for_the_input_files_5009"), S("Cannot find the common subdirectory path for the input files.")};
        static DiagnosticMessageStore File_specification_cannot_end_in_a_recursive_directory_wildcard_Asterisk_Asterisk_Colon_0 = {5010, DiagnosticCategory::Error, S("File_specification_cannot_end_in_a_recursive_directory_wildcard_Asterisk_Asterisk_Colon_0_5010"), S("File specification cannot end in a recursive directory wildcard ('**'): '{0}'.")};
        static DiagnosticMessageStore Cannot_read_file_0_Colon_1 = {5012, DiagnosticCategory::Error, S("Cannot_read_file_0_Colon_1_5012"), S("Cannot read file '{0}': {1}.")};
        static DiagnosticMessageStore Failed_to_parse_file_0_Colon_1 = {5014, DiagnosticCategory::Error, S("Failed_to_parse_file_0_Colon_1_5014"), S("Failed to parse file '{0}': {1}.")};
        static DiagnosticMessageStore Unknown_compiler_option_0 = {5023, DiagnosticCategory::Error, S("Unknown_compiler_option_0_5023"), S("Unknown compiler option '{0}'.")};
        static DiagnosticMessageStore Compiler_option_0_requires_a_value_of_type_1 = {5024, DiagnosticCategory::Error, S("Compiler_option_0_requires_a_value_of_type_1_5024"), S("Compiler option '{0}' requires a value of type {1}.")};
        static DiagnosticMessageStore Unknown_compiler_option_0_Did_you_mean_1 = {5025, DiagnosticCategory::Error, S("Unknown_compiler_option_0_Did_you_mean_1_5025"), S("Unknown compiler option '{0}'. Did you mean '{1}'?")};
        static DiagnosticMessageStore Could_not_write_file_0_Colon_1 = {5033, DiagnosticCategory::Error, S("Could_not_write_file_0_Colon_1_5033"), S("Could not write file '{0}': {1}.")};
        static DiagnosticMessageStore Option_project_cannot_be_mixed_with_source_files_on_a_command_line = {5042, DiagnosticCategory::Error, S("Option_project_cannot_be_mixed_with_source_files_on_a_command_line_5042"), S("Option 'project' cannot be mixed with source files on a command line.")};
        static DiagnosticMessageStore Option_isolatedModules_can_only_be_used_when_either_option_module_is_provided_or_option_target_is_ES2015_or_higher = {5047, DiagnosticCategory::Error, S("Option_isolatedModules_can_only_be_used_when_either_option_module_is_provided_or_option_target_is_ES_5047"), S("Option 'isolatedModules' can only be used when either option '--module' is provided or option 'target' is 'ES2015' or higher.")};
        static DiagnosticMessageStore Option_0_cannot_be_specified_when_option_target_is_ES3 = {5048, DiagnosticCategory::Error, S("Option_0_cannot_be_specified_when_option_target_is_ES3_5048"), S("Option '{0}' cannot be specified when option 'target' is 'ES3'.")};
        static DiagnosticMessageStore Option_0_can_only_be_used_when_either_option_inlineSourceMap_or_option_sourceMap_is_provided = {5051, DiagnosticCategory::Error, S("Option_0_can_only_be_used_when_either_option_inlineSourceMap_or_option_sourceMap_is_provided_5051"), S("Option '{0} can only be used when either option '--inlineSourceMap' or option '--sourceMap' is provided.")};
        static DiagnosticMessageStore Option_0_cannot_be_specified_without_specifying_option_1 = {5052, DiagnosticCategory::Error, S("Option_0_cannot_be_specified_without_specifying_option_1_5052"), S("Option '{0}' cannot be specified without specifying option '{1}'.")};
        static DiagnosticMessageStore Option_0_cannot_be_specified_with_option_1 = {5053, DiagnosticCategory::Error, S("Option_0_cannot_be_specified_with_option_1_5053"), S("Option '{0}' cannot be specified with option '{1}'.")};
        static DiagnosticMessageStore A_tsconfig_json_file_is_already_defined_at_Colon_0 = {5054, DiagnosticCategory::Error, S("A_tsconfig_json_file_is_already_defined_at_Colon_0_5054"), S("A 'tsconfig.json' file is already defined at: '{0}'.")};
        static DiagnosticMessageStore Cannot_write_file_0_because_it_would_overwrite_input_file = {5055, DiagnosticCategory::Error, S("Cannot_write_file_0_because_it_would_overwrite_input_file_5055"), S("Cannot write file '{0}' because it would overwrite input file.")};
        static DiagnosticMessageStore Cannot_write_file_0_because_it_would_be_overwritten_by_multiple_input_files = {5056, DiagnosticCategory::Error, S("Cannot_write_file_0_because_it_would_be_overwritten_by_multiple_input_files_5056"), S("Cannot write file '{0}' because it would be overwritten by multiple input files.")};
        static DiagnosticMessageStore Cannot_find_a_tsconfig_json_file_at_the_specified_directory_Colon_0 = {5057, DiagnosticCategory::Error, S("Cannot_find_a_tsconfig_json_file_at_the_specified_directory_Colon_0_5057"), S("Cannot find a tsconfig.json file at the specified directory: '{0}'.")};
        static DiagnosticMessageStore The_specified_path_does_not_exist_Colon_0 = {5058, DiagnosticCategory::Error, S("The_specified_path_does_not_exist_Colon_0_5058"), S("The specified path does not exist: '{0}'.")};
        static DiagnosticMessageStore Invalid_value_for_reactNamespace_0_is_not_a_valid_identifier = {5059, DiagnosticCategory::Error, S("Invalid_value_for_reactNamespace_0_is_not_a_valid_identifier_5059"), S("Invalid value for '--reactNamespace'. '{0}' is not a valid identifier.")};
        static DiagnosticMessageStore Pattern_0_can_have_at_most_one_Asterisk_character = {5061, DiagnosticCategory::Error, S("Pattern_0_can_have_at_most_one_Asterisk_character_5061"), S("Pattern '{0}' can have at most one '*' character.")};
        static DiagnosticMessageStore Substitution_0_in_pattern_1_can_have_at_most_one_Asterisk_character = {5062, DiagnosticCategory::Error, S("Substitution_0_in_pattern_1_can_have_at_most_one_Asterisk_character_5062"), S("Substitution '{0}' in pattern '{1}' can have at most one '*' character.")};
        static DiagnosticMessageStore Substitutions_for_pattern_0_should_be_an_array = {5063, DiagnosticCategory::Error, S("Substitutions_for_pattern_0_should_be_an_array_5063"), S("Substitutions for pattern '{0}' should be an array.")};
        static DiagnosticMessageStore Substitution_0_for_pattern_1_has_incorrect_type_expected_string_got_2 = {5064, DiagnosticCategory::Error, S("Substitution_0_for_pattern_1_has_incorrect_type_expected_string_got_2_5064"), S("Substitution '{0}' for pattern '{1}' has incorrect type, expected 'string', got '{2}'.")};
        static DiagnosticMessageStore File_specification_cannot_contain_a_parent_directory_that_appears_after_a_recursive_directory_wildcard_Asterisk_Asterisk_Colon_0 = {5065, DiagnosticCategory::Error, S("File_specification_cannot_contain_a_parent_directory_that_appears_after_a_recursive_directory_wildca_5065"), S("File specification cannot contain a parent directory ('..') that appears after a recursive directory wildcard ('**'): '{0}'.")};
        static DiagnosticMessageStore Substitutions_for_pattern_0_shouldn_t_be_an_empty_array = {5066, DiagnosticCategory::Error, S("Substitutions_for_pattern_0_shouldn_t_be_an_empty_array_5066"), S("Substitutions for pattern '{0}' shouldn't be an empty array.")};
        static DiagnosticMessageStore Invalid_value_for_jsxFactory_0_is_not_a_valid_identifier_or_qualified_name = {5067, DiagnosticCategory::Error, S("Invalid_value_for_jsxFactory_0_is_not_a_valid_identifier_or_qualified_name_5067"), S("Invalid value for 'jsxFactory'. '{0}' is not a valid identifier or qualified-name.")};
        static DiagnosticMessageStore Adding_a_tsconfig_json_file_will_help_organize_projects_that_contain_both_TypeScript_and_JavaScript_files_Learn_more_at_https_Colon_Slash_Slashaka_ms_Slashtsconfig = {5068, DiagnosticCategory::Error, S("Adding_a_tsconfig_json_file_will_help_organize_projects_that_contain_both_TypeScript_and_JavaScript__5068"), S("Adding a tsconfig.json file will help organize projects that contain both TypeScript and JavaScript files. Learn more at https://aka.ms/tsconfig.")};
        static DiagnosticMessageStore Option_0_cannot_be_specified_without_specifying_option_1_or_option_2 = {5069, DiagnosticCategory::Error, S("Option_0_cannot_be_specified_without_specifying_option_1_or_option_2_5069"), S("Option '{0}' cannot be specified without specifying option '{1}' or option '{2}'.")};
        static DiagnosticMessageStore Option_resolveJsonModule_cannot_be_specified_without_node_module_resolution_strategy = {5070, DiagnosticCategory::Error, S("Option_resolveJsonModule_cannot_be_specified_without_node_module_resolution_strategy_5070"), S("Option '--resolveJsonModule' cannot be specified without 'node' module resolution strategy.")};
        static DiagnosticMessageStore Option_resolveJsonModule_can_only_be_specified_when_module_code_generation_is_commonjs_amd_es2015_or_esNext = {5071, DiagnosticCategory::Error, S("Option_resolveJsonModule_can_only_be_specified_when_module_code_generation_is_commonjs_amd_es2015_or_5071"), S("Option '--resolveJsonModule' can only be specified when module code generation is 'commonjs', 'amd', 'es2015' or 'esNext'.")};
        static DiagnosticMessageStore Unknown_build_option_0 = {5072, DiagnosticCategory::Error, S("Unknown_build_option_0_5072"), S("Unknown build option '{0}'.")};
        static DiagnosticMessageStore Build_option_0_requires_a_value_of_type_1 = {5073, DiagnosticCategory::Error, S("Build_option_0_requires_a_value_of_type_1_5073"), S("Build option '{0}' requires a value of type {1}.")};
        static DiagnosticMessageStore Option_incremental_can_only_be_specified_using_tsconfig_emitting_to_single_file_or_when_option_tsBuildInfoFile_is_specified = {5074, DiagnosticCategory::Error, S("Option_incremental_can_only_be_specified_using_tsconfig_emitting_to_single_file_or_when_option_tsBui_5074"), S("Option '--incremental' can only be specified using tsconfig, emitting to single file or when option `--tsBuildInfoFile` is specified.")};
        static DiagnosticMessageStore _0_is_assignable_to_the_constraint_of_type_1_but_1_could_be_instantiated_with_a_different_subtype_of_constraint_2 = {5075, DiagnosticCategory::Error, S("_0_is_assignable_to_the_constraint_of_type_1_but_1_could_be_instantiated_with_a_different_subtype_of_5075"), S("'{0}' is assignable to the constraint of type '{1}', but '{1}' could be instantiated with a different subtype of constraint '{2}'.")};
        static DiagnosticMessageStore _0_and_1_operations_cannot_be_mixed_without_parentheses = {5076, DiagnosticCategory::Error, S("_0_and_1_operations_cannot_be_mixed_without_parentheses_5076"), S("'{0}' and '{1}' operations cannot be mixed without parentheses.")};
        static DiagnosticMessageStore Unknown_build_option_0_Did_you_mean_1 = {5077, DiagnosticCategory::Error, S("Unknown_build_option_0_Did_you_mean_1_5077"), S("Unknown build option '{0}'. Did you mean '{1}'?")};
        static DiagnosticMessageStore Unknown_watch_option_0 = {5078, DiagnosticCategory::Error, S("Unknown_watch_option_0_5078"), S("Unknown watch option '{0}'.")};
        static DiagnosticMessageStore Unknown_watch_option_0_Did_you_mean_1 = {5079, DiagnosticCategory::Error, S("Unknown_watch_option_0_Did_you_mean_1_5079"), S("Unknown watch option '{0}'. Did you mean '{1}'?")};
        static DiagnosticMessageStore Watch_option_0_requires_a_value_of_type_1 = {5080, DiagnosticCategory::Error, S("Watch_option_0_requires_a_value_of_type_1_5080"), S("Watch option '{0}' requires a value of type {1}.")};
        static DiagnosticMessageStore Cannot_find_a_tsconfig_json_file_at_the_current_directory_Colon_0 = {5081, DiagnosticCategory::Error, S("Cannot_find_a_tsconfig_json_file_at_the_current_directory_Colon_0_5081"), S("Cannot find a tsconfig.json file at the current directory: {0}.")};
        static DiagnosticMessageStore _0_could_be_instantiated_with_an_arbitrary_type_which_could_be_unrelated_to_1 = {5082, DiagnosticCategory::Error, S("_0_could_be_instantiated_with_an_arbitrary_type_which_could_be_unrelated_to_1_5082"), S("'{0}' could be instantiated with an arbitrary type which could be unrelated to '{1}'.")};
        static DiagnosticMessageStore Cannot_read_file_0 = {5083, DiagnosticCategory::Error, S("Cannot_read_file_0_5083"), S("Cannot read file '{0}'.")};
        static DiagnosticMessageStore Tuple_members_must_all_have_names_or_all_not_have_names = {5084, DiagnosticCategory::Error, S("Tuple_members_must_all_have_names_or_all_not_have_names_5084"), S("Tuple members must all have names or all not have names.")};
        static DiagnosticMessageStore A_tuple_member_cannot_be_both_optional_and_rest = {5085, DiagnosticCategory::Error, S("A_tuple_member_cannot_be_both_optional_and_rest_5085"), S("A tuple member cannot be both optional and rest.")};
        static DiagnosticMessageStore A_labeled_tuple_element_is_declared_as_optional_with_a_question_mark_after_the_name_and_before_the_colon_rather_than_after_the_type = {5086, DiagnosticCategory::Error, S("A_labeled_tuple_element_is_declared_as_optional_with_a_question_mark_after_the_name_and_before_the_c_5086"), S("A labeled tuple element is declared as optional with a question mark after the name and before the colon, rather than after the type.")};
        static DiagnosticMessageStore A_labeled_tuple_element_is_declared_as_rest_with_a_before_the_name_rather_than_before_the_type = {5087, DiagnosticCategory::Error, S("A_labeled_tuple_element_is_declared_as_rest_with_a_before_the_name_rather_than_before_the_type_5087"), S("A labeled tuple element is declared as rest with a `...` before the name, rather than before the type.")};
        static DiagnosticMessageStore The_inferred_type_of_0_references_a_type_with_a_cyclic_structure_which_cannot_be_trivially_serialized_A_type_annotation_is_necessary = {5088, DiagnosticCategory::Error, S("The_inferred_type_of_0_references_a_type_with_a_cyclic_structure_which_cannot_be_trivially_serialize_5088"), S("The inferred type of '{0}' references a type with a cyclic structure which cannot be trivially serialized. A type annotation is necessary.")};
        static DiagnosticMessageStore Option_0_cannot_be_specified_when_option_jsx_is_1 = {5089, DiagnosticCategory::Error, S("Option_0_cannot_be_specified_when_option_jsx_is_1_5089"), S("Option '{0}' cannot be specified when option 'jsx' is '{1}'.")};
        static DiagnosticMessageStore Non_relative_paths_are_not_allowed_when_baseUrl_is_not_set_Did_you_forget_a_leading_Slash = {5090, DiagnosticCategory::Error, S("Non_relative_paths_are_not_allowed_when_baseUrl_is_not_set_Did_you_forget_a_leading_Slash_5090"), S("Non-relative paths are not allowed when 'baseUrl' is not set. Did you forget a leading './'?")};
        static DiagnosticMessageStore Generates_a_sourcemap_for_each_corresponding_d_ts_file = {6000, DiagnosticCategory::Message, S("Generates_a_sourcemap_for_each_corresponding_d_ts_file_6000"), S("Generates a sourcemap for each corresponding '.d.ts' file.")};
        static DiagnosticMessageStore Concatenate_and_emit_output_to_single_file = {6001, DiagnosticCategory::Message, S("Concatenate_and_emit_output_to_single_file_6001"), S("Concatenate and emit output to single file.")};
        static DiagnosticMessageStore Generates_corresponding_d_ts_file = {6002, DiagnosticCategory::Message, S("Generates_corresponding_d_ts_file_6002"), S("Generates corresponding '.d.ts' file.")};
        static DiagnosticMessageStore Specify_the_location_where_debugger_should_locate_map_files_instead_of_generated_locations = {6003, DiagnosticCategory::Message, S("Specify_the_location_where_debugger_should_locate_map_files_instead_of_generated_locations_6003"), S("Specify the location where debugger should locate map files instead of generated locations.")};
        static DiagnosticMessageStore Specify_the_location_where_debugger_should_locate_TypeScript_files_instead_of_source_locations = {6004, DiagnosticCategory::Message, S("Specify_the_location_where_debugger_should_locate_TypeScript_files_instead_of_source_locations_6004"), S("Specify the location where debugger should locate TypeScript files instead of source locations.")};
        static DiagnosticMessageStore Watch_input_files = {6005, DiagnosticCategory::Message, S("Watch_input_files_6005"), S("Watch input files.")};
        static DiagnosticMessageStore Redirect_output_structure_to_the_directory = {6006, DiagnosticCategory::Message, S("Redirect_output_structure_to_the_directory_6006"), S("Redirect output structure to the directory.")};
        static DiagnosticMessageStore Do_not_erase_const_enum_declarations_in_generated_code = {6007, DiagnosticCategory::Message, S("Do_not_erase_const_enum_declarations_in_generated_code_6007"), S("Do not erase const enum declarations in generated code.")};
        static DiagnosticMessageStore Do_not_emit_outputs_if_any_errors_were_reported = {6008, DiagnosticCategory::Message, S("Do_not_emit_outputs_if_any_errors_were_reported_6008"), S("Do not emit outputs if any errors were reported.")};
        static DiagnosticMessageStore Do_not_emit_comments_to_output = {6009, DiagnosticCategory::Message, S("Do_not_emit_comments_to_output_6009"), S("Do not emit comments to output.")};
        static DiagnosticMessageStore Do_not_emit_outputs = {6010, DiagnosticCategory::Message, S("Do_not_emit_outputs_6010"), S("Do not emit outputs.")};
        static DiagnosticMessageStore Allow_default_imports_from_modules_with_no_default_export_This_does_not_affect_code_emit_just_typechecking = {6011, DiagnosticCategory::Message, S("Allow_default_imports_from_modules_with_no_default_export_This_does_not_affect_code_emit_just_typech_6011"), S("Allow default imports from modules with no default export. This does not affect code emit, just typechecking.")};
        static DiagnosticMessageStore Skip_type_checking_of_declaration_files = {6012, DiagnosticCategory::Message, S("Skip_type_checking_of_declaration_files_6012"), S("Skip type checking of declaration files.")};
        static DiagnosticMessageStore Do_not_resolve_the_real_path_of_symlinks = {6013, DiagnosticCategory::Message, S("Do_not_resolve_the_real_path_of_symlinks_6013"), S("Do not resolve the real path of symlinks.")};
        static DiagnosticMessageStore Only_emit_d_ts_declaration_files = {6014, DiagnosticCategory::Message, S("Only_emit_d_ts_declaration_files_6014"), S("Only emit '.d.ts' declaration files.")};
        static DiagnosticMessageStore Specify_ECMAScript_target_version_Colon_ES3_default_ES5_ES2015_ES2016_ES2017_ES2018_ES2019_ES2020_or_ESNEXT = {6015, DiagnosticCategory::Message, S("Specify_ECMAScript_target_version_Colon_ES3_default_ES5_ES2015_ES2016_ES2017_ES2018_ES2019_ES2020_or_6015"), S("Specify ECMAScript target version: 'ES3' (default}; 'ES5', 'ES2015', 'ES2016', 'ES2017', 'ES2018', 'ES2019', 'ES2020', or 'ESNEXT'.")};
        static DiagnosticMessageStore Specify_module_code_generation_Colon_none_commonjs_amd_system_umd_es2015_es2020_or_ESNext = {6016, DiagnosticCategory::Message, S("Specify_module_code_generation_Colon_none_commonjs_amd_system_umd_es2015_es2020_or_ESNext_6016"), S("Specify module code generation: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', 'es2020', or 'ESNext'.")};
        static DiagnosticMessageStore Print_this_message = {6017, DiagnosticCategory::Message, S("Print_this_message_6017"), S("Print this message.")};
        static DiagnosticMessageStore Print_the_compiler_s_version = {6019, DiagnosticCategory::Message, S("Print_the_compiler_s_version_6019"), S("Print the compiler's version.")};
        static DiagnosticMessageStore Compile_the_project_given_the_path_to_its_configuration_file_or_to_a_folder_with_a_tsconfig_json = {6020, DiagnosticCategory::Message, S("Compile_the_project_given_the_path_to_its_configuration_file_or_to_a_folder_with_a_tsconfig_json_6020"), S("Compile the project given the path to its configuration file, or to a folder with a 'tsconfig.json'.")};
        static DiagnosticMessageStore Syntax_Colon_0 = {6023, DiagnosticCategory::Message, S("Syntax_Colon_0_6023"), S("Syntax: {0}")};
        static DiagnosticMessageStore options = {6024, DiagnosticCategory::Message, S("options_6024"), S("options")};
        static DiagnosticMessageStore file = {6025, DiagnosticCategory::Message, S("file_6025"), S("file")};
        static DiagnosticMessageStore Examples_Colon_0 = {6026, DiagnosticCategory::Message, S("Examples_Colon_0_6026"), S("Examples: {0}")};
        static DiagnosticMessageStore Options_Colon = {6027, DiagnosticCategory::Message, S("Options_Colon_6027"), S("Options:")};
        static DiagnosticMessageStore Version_0 = {6029, DiagnosticCategory::Message, S("Version_0_6029"), S("Version {0}")};
        static DiagnosticMessageStore Insert_command_line_options_and_files_from_a_file = {6030, DiagnosticCategory::Message, S("Insert_command_line_options_and_files_from_a_file_6030"), S("Insert command line options and files from a file.")};
        static DiagnosticMessageStore Starting_compilation_in_watch_mode = {6031, DiagnosticCategory::Message, S("Starting_compilation_in_watch_mode_6031"), S("Starting compilation in watch mode...")};
        static DiagnosticMessageStore File_change_detected_Starting_incremental_compilation = {6032, DiagnosticCategory::Message, S("File_change_detected_Starting_incremental_compilation_6032"), S("File change detected. Starting incremental compilation...")};
        static DiagnosticMessageStore KIND = {6034, DiagnosticCategory::Message, S("KIND_6034"), S("KIND")};
        static DiagnosticMessageStore FILE = {6035, DiagnosticCategory::Message, S("FILE_6035"), S("FILE")};
        static DiagnosticMessageStore VERSION = {6036, DiagnosticCategory::Message, S("VERSION_6036"), S("VERSION")};
        static DiagnosticMessageStore LOCATION = {6037, DiagnosticCategory::Message, S("LOCATION_6037"), S("LOCATION")};
        static DiagnosticMessageStore DIRECTORY = {6038, DiagnosticCategory::Message, S("DIRECTORY_6038"), S("DIRECTORY")};
        static DiagnosticMessageStore STRATEGY = {6039, DiagnosticCategory::Message, S("STRATEGY_6039"), S("STRATEGY")};
        static DiagnosticMessageStore FILE_OR_DIRECTORY = {6040, DiagnosticCategory::Message, S("FILE_OR_DIRECTORY_6040"), S("FILE OR DIRECTORY")};
        static DiagnosticMessageStore Generates_corresponding_map_file = {6043, DiagnosticCategory::Message, S("Generates_corresponding_map_file_6043"), S("Generates corresponding '.map' file.")};
        static DiagnosticMessageStore Compiler_option_0_expects_an_argument = {6044, DiagnosticCategory::Error, S("Compiler_option_0_expects_an_argument_6044"), S("Compiler option '{0}' expects an argument.")};
        static DiagnosticMessageStore Unterminated_quoted_string_in_response_file_0 = {6045, DiagnosticCategory::Error, S("Unterminated_quoted_string_in_response_file_0_6045"), S("Unterminated quoted string in response file '{0}'.")};
        static DiagnosticMessageStore Argument_for_0_option_must_be_Colon_1 = {6046, DiagnosticCategory::Error, S("Argument_for_0_option_must_be_Colon_1_6046"), S("Argument for '{0}' option must be: {1}.")};
        static DiagnosticMessageStore Locale_must_be_of_the_form_language_or_language_territory_For_example_0_or_1 = {6048, DiagnosticCategory::Error, S("Locale_must_be_of_the_form_language_or_language_territory_For_example_0_or_1_6048"), S("Locale must be of the form <language> or <language>-<territory>. For example '{0}' or '{1}'.")};
        static DiagnosticMessageStore Unsupported_locale_0 = {6049, DiagnosticCategory::Error, S("Unsupported_locale_0_6049"), S("Unsupported locale '{0}'.")};
        static DiagnosticMessageStore Unable_to_open_file_0 = {6050, DiagnosticCategory::Error, S("Unable_to_open_file_0_6050"), S("Unable to open file '{0}'.")};
        static DiagnosticMessageStore Corrupted_locale_file_0 = {6051, DiagnosticCategory::Error, S("Corrupted_locale_file_0_6051"), S("Corrupted locale file {0}.")};
        static DiagnosticMessageStore Raise_error_on_expressions_and_declarations_with_an_implied_any_type = {6052, DiagnosticCategory::Message, S("Raise_error_on_expressions_and_declarations_with_an_implied_any_type_6052"), S("Raise error on expressions and declarations with an implied 'any' type.")};
        static DiagnosticMessageStore File_0_not_found = {6053, DiagnosticCategory::Error, S("File_0_not_found_6053"), S("File '{0}' not found.")};
        static DiagnosticMessageStore File_0_has_an_unsupported_extension_The_only_supported_extensions_are_1 = {6054, DiagnosticCategory::Error, S("File_0_has_an_unsupported_extension_The_only_supported_extensions_are_1_6054"), S("File '{0}' has an unsupported extension. The only supported extensions are {1}.")};
        static DiagnosticMessageStore Suppress_noImplicitAny_errors_for_indexing_objects_lacking_index_signatures = {6055, DiagnosticCategory::Message, S("Suppress_noImplicitAny_errors_for_indexing_objects_lacking_index_signatures_6055"), S("Suppress noImplicitAny errors for indexing objects lacking index signatures.")};
        static DiagnosticMessageStore Do_not_emit_declarations_for_code_that_has_an_internal_annotation = {6056, DiagnosticCategory::Message, S("Do_not_emit_declarations_for_code_that_has_an_internal_annotation_6056"), S("Do not emit declarations for code that has an '@internal' annotation.")};
        static DiagnosticMessageStore Specify_the_root_directory_of_input_files_Use_to_control_the_output_directory_structure_with_outDir = {6058, DiagnosticCategory::Message, S("Specify_the_root_directory_of_input_files_Use_to_control_the_output_directory_structure_with_outDir_6058"), S("Specify the root directory of input files. Use to control the output directory structure with --outDir.")};
        static DiagnosticMessageStore File_0_is_not_under_rootDir_1_rootDir_is_expected_to_contain_all_source_files = {6059, DiagnosticCategory::Error, S("File_0_is_not_under_rootDir_1_rootDir_is_expected_to_contain_all_source_files_6059"), S("File '{0}' is not under 'rootDir' '{1}'. 'rootDir' is expected to contain all source files.")};
        static DiagnosticMessageStore Specify_the_end_of_line_sequence_to_be_used_when_emitting_files_Colon_CRLF_dos_or_LF_unix = {6060, DiagnosticCategory::Message, S("Specify_the_end_of_line_sequence_to_be_used_when_emitting_files_Colon_CRLF_dos_or_LF_unix_6060"), S("Specify the end of line sequence to be used when emitting files: 'CRLF' (dos) or 'LF' (unix).")};
        static DiagnosticMessageStore NEWLINE = {6061, DiagnosticCategory::Message, S("NEWLINE_6061"), S("NEWLINE")};
        static DiagnosticMessageStore Option_0_can_only_be_specified_in_tsconfig_json_file_or_set_to_null_on_command_line = {6064, DiagnosticCategory::Error, S("Option_0_can_only_be_specified_in_tsconfig_json_file_or_set_to_null_on_command_line_6064"), S("Option '{0}' can only be specified in 'tsconfig.json' file or set to 'null' on command line.")};
        static DiagnosticMessageStore Enables_experimental_support_for_ES7_decorators = {6065, DiagnosticCategory::Message, S("Enables_experimental_support_for_ES7_decorators_6065"), S("Enables experimental support for ES7 decorators.")};
        static DiagnosticMessageStore Enables_experimental_support_for_emitting_type_metadata_for_decorators = {6066, DiagnosticCategory::Message, S("Enables_experimental_support_for_emitting_type_metadata_for_decorators_6066"), S("Enables experimental support for emitting type metadata for decorators.")};
        static DiagnosticMessageStore Enables_experimental_support_for_ES7_async_functions = {6068, DiagnosticCategory::Message, S("Enables_experimental_support_for_ES7_async_functions_6068"), S("Enables experimental support for ES7 async functions.")};
        static DiagnosticMessageStore Specify_module_resolution_strategy_Colon_node_Node_js_or_classic_TypeScript_pre_1_6 = {6069, DiagnosticCategory::Message, S("Specify_module_resolution_strategy_Colon_node_Node_js_or_classic_TypeScript_pre_1_6_6069"), S("Specify module resolution strategy: 'node' (Node.js) or 'classic' (TypeScript pre-1.6).")};
        static DiagnosticMessageStore Initializes_a_TypeScript_project_and_creates_a_tsconfig_json_file = {6070, DiagnosticCategory::Message, S("Initializes_a_TypeScript_project_and_creates_a_tsconfig_json_file_6070"), S("Initializes a TypeScript project and creates a tsconfig.json file.")};
        static DiagnosticMessageStore Successfully_created_a_tsconfig_json_file = {6071, DiagnosticCategory::Message, S("Successfully_created_a_tsconfig_json_file_6071"), S("Successfully created a tsconfig.json file.")};
        static DiagnosticMessageStore Suppress_excess_property_checks_for_object_literals = {6072, DiagnosticCategory::Message, S("Suppress_excess_property_checks_for_object_literals_6072"), S("Suppress excess property checks for object literals.")};
        static DiagnosticMessageStore Stylize_errors_and_messages_using_color_and_context_experimental = {6073, DiagnosticCategory::Message, S("Stylize_errors_and_messages_using_color_and_context_experimental_6073"), S("Stylize errors and messages using color and context (experimental).")};
        static DiagnosticMessageStore Do_not_report_errors_on_unused_labels = {6074, DiagnosticCategory::Message, S("Do_not_report_errors_on_unused_labels_6074"), S("Do not report errors on unused labels.")};
        static DiagnosticMessageStore Report_error_when_not_all_code_paths_in_function_return_a_value = {6075, DiagnosticCategory::Message, S("Report_error_when_not_all_code_paths_in_function_return_a_value_6075"), S("Report error when not all code paths in function return a value.")};
        static DiagnosticMessageStore Report_errors_for_fallthrough_cases_in_switch_statement = {6076, DiagnosticCategory::Message, S("Report_errors_for_fallthrough_cases_in_switch_statement_6076"), S("Report errors for fallthrough cases in switch statement.")};
        static DiagnosticMessageStore Do_not_report_errors_on_unreachable_code = {6077, DiagnosticCategory::Message, S("Do_not_report_errors_on_unreachable_code_6077"), S("Do not report errors on unreachable code.")};
        static DiagnosticMessageStore Disallow_inconsistently_cased_references_to_the_same_file = {6078, DiagnosticCategory::Message, S("Disallow_inconsistently_cased_references_to_the_same_file_6078"), S("Disallow inconsistently-cased references to the same file.")};
        static DiagnosticMessageStore Specify_library_files_to_be_included_in_the_compilation = {6079, DiagnosticCategory::Message, S("Specify_library_files_to_be_included_in_the_compilation_6079"), S("Specify library files to be included in the compilation.")};
        static DiagnosticMessageStore Specify_JSX_code_generation_Colon_preserve_react_native_react_react_jsx_or_react_jsxdev = {6080, DiagnosticCategory::Message, S("Specify_JSX_code_generation_Colon_preserve_react_native_react_react_jsx_or_react_jsxdev_6080"), S("Specify JSX code generation: 'preserve', 'react-native', 'react', 'react-jsx' or 'react-jsxdev'.")};
        static DiagnosticMessageStore File_0_has_an_unsupported_extension_so_skipping_it = {6081, DiagnosticCategory::Message, S("File_0_has_an_unsupported_extension_so_skipping_it_6081"), S("File '{0}' has an unsupported extension, so skipping it.")};
        static DiagnosticMessageStore Only_amd_and_system_modules_are_supported_alongside_0 = {6082, DiagnosticCategory::Error, S("Only_amd_and_system_modules_are_supported_alongside_0_6082"), S("Only 'amd' and 'system' modules are supported alongside --{0}.")};
        static DiagnosticMessageStore Base_directory_to_resolve_non_absolute_module_names = {6083, DiagnosticCategory::Message, S("Base_directory_to_resolve_non_absolute_module_names_6083"), S("Base directory to resolve non-absolute module names.")};
        static DiagnosticMessageStore Deprecated_Use_jsxFactory_instead_Specify_the_object_invoked_for_createElement_when_targeting_react_JSX_emit = {6084, DiagnosticCategory::Message, S("Deprecated_Use_jsxFactory_instead_Specify_the_object_invoked_for_createElement_when_targeting_react__6084"), S("[Deprecated] Use '--jsxFactory' instead. Specify the object invoked for createElement when targeting 'react' JSX emit")};
        static DiagnosticMessageStore Enable_tracing_of_the_name_resolution_process = {6085, DiagnosticCategory::Message, S("Enable_tracing_of_the_name_resolution_process_6085"), S("Enable tracing of the name resolution process.")};
        static DiagnosticMessageStore Resolving_module_0_from_1 = {6086, DiagnosticCategory::Message, S("Resolving_module_0_from_1_6086"), S("======== Resolving module '{0}' from '{1}'. ========")};
        static DiagnosticMessageStore Explicitly_specified_module_resolution_kind_Colon_0 = {6087, DiagnosticCategory::Message, S("Explicitly_specified_module_resolution_kind_Colon_0_6087"), S("Explicitly specified module resolution kind: '{0}'.")};
        static DiagnosticMessageStore Module_resolution_kind_is_not_specified_using_0 = {6088, DiagnosticCategory::Message, S("Module_resolution_kind_is_not_specified_using_0_6088"), S("Module resolution kind is not specified, using '{0}'.")};
        static DiagnosticMessageStore Module_name_0_was_successfully_resolved_to_1 = {6089, DiagnosticCategory::Message, S("Module_name_0_was_successfully_resolved_to_1_6089"), S("======== Module name '{0}' was successfully resolved to '{1}'. ========")};
        static DiagnosticMessageStore Module_name_0_was_not_resolved = {6090, DiagnosticCategory::Message, S("Module_name_0_was_not_resolved_6090"), S("======== Module name '{0}' was not resolved. ========")};
        static DiagnosticMessageStore paths_option_is_specified_looking_for_a_pattern_to_match_module_name_0 = {6091, DiagnosticCategory::Message, S("paths_option_is_specified_looking_for_a_pattern_to_match_module_name_0_6091"), S("'paths' option is specified, looking for a pattern to match module name '{0}'.")};
        static DiagnosticMessageStore Module_name_0_matched_pattern_1 = {6092, DiagnosticCategory::Message, S("Module_name_0_matched_pattern_1_6092"), S("Module name '{0}', matched pattern '{1}'.")};
        static DiagnosticMessageStore Trying_substitution_0_candidate_module_location_Colon_1 = {6093, DiagnosticCategory::Message, S("Trying_substitution_0_candidate_module_location_Colon_1_6093"), S("Trying substitution '{0}', candidate module location: '{1}'.")};
        static DiagnosticMessageStore Resolving_module_name_0_relative_to_base_url_1_2 = {6094, DiagnosticCategory::Message, S("Resolving_module_name_0_relative_to_base_url_1_2_6094"), S("Resolving module name '{0}' relative to base url '{1}' - '{2}'.")};
        static DiagnosticMessageStore Loading_module_as_file_Slash_folder_candidate_module_location_0_target_file_type_1 = {6095, DiagnosticCategory::Message, S("Loading_module_as_file_Slash_folder_candidate_module_location_0_target_file_type_1_6095"), S("Loading module as file / folder, candidate module location '{0}', target file type '{1}'.")};
        static DiagnosticMessageStore File_0_does_not_exist = {6096, DiagnosticCategory::Message, S("File_0_does_not_exist_6096"), S("File '{0}' does not exist.")};
        static DiagnosticMessageStore File_0_exist_use_it_as_a_name_resolution_result = {6097, DiagnosticCategory::Message, S("File_0_exist_use_it_as_a_name_resolution_result_6097"), S("File '{0}' exist - use it as a name resolution result.")};
        static DiagnosticMessageStore Loading_module_0_from_node_modules_folder_target_file_type_1 = {6098, DiagnosticCategory::Message, S("Loading_module_0_from_node_modules_folder_target_file_type_1_6098"), S("Loading module '{0}' from 'node_modules' folder, target file type '{1}'.")};
        static DiagnosticMessageStore Found_package_json_at_0 = {6099, DiagnosticCategory::Message, S("Found_package_json_at_0_6099"), S("Found 'package.json' at '{0}'.")};
        static DiagnosticMessageStore package_json_does_not_have_a_0_field = {6100, DiagnosticCategory::Message, S("package_json_does_not_have_a_0_field_6100"), S("'package.json' does not have a '{0}' field.")};
        static DiagnosticMessageStore package_json_has_0_field_1_that_references_2 = {6101, DiagnosticCategory::Message, S("package_json_has_0_field_1_that_references_2_6101"), S("'package.json' has '{0}' field '{1}' that references '{2}'.")};
        static DiagnosticMessageStore Allow_javascript_files_to_be_compiled = {6102, DiagnosticCategory::Message, S("Allow_javascript_files_to_be_compiled_6102"), S("Allow javascript files to be compiled.")};
        static DiagnosticMessageStore Option_0_should_have_array_of_strings_as_a_value = {6103, DiagnosticCategory::Error, S("Option_0_should_have_array_of_strings_as_a_value_6103"), S("Option '{0}' should have array of strings as a value.")};
        static DiagnosticMessageStore Checking_if_0_is_the_longest_matching_prefix_for_1_2 = {6104, DiagnosticCategory::Message, S("Checking_if_0_is_the_longest_matching_prefix_for_1_2_6104"), S("Checking if '{0}' is the longest matching prefix for '{1}' - '{2}'.")};
        static DiagnosticMessageStore Expected_type_of_0_field_in_package_json_to_be_1_got_2 = {6105, DiagnosticCategory::Message, S("Expected_type_of_0_field_in_package_json_to_be_1_got_2_6105"), S("Expected type of '{0}' field in 'package.json' to be '{1}', got '{2}'.")};
        static DiagnosticMessageStore baseUrl_option_is_set_to_0_using_this_value_to_resolve_non_relative_module_name_1 = {6106, DiagnosticCategory::Message, S("baseUrl_option_is_set_to_0_using_this_value_to_resolve_non_relative_module_name_1_6106"), S("'baseUrl' option is set to '{0}', using this value to resolve non-relative module name '{1}'.")};
        static DiagnosticMessageStore rootDirs_option_is_set_using_it_to_resolve_relative_module_name_0 = {6107, DiagnosticCategory::Message, S("rootDirs_option_is_set_using_it_to_resolve_relative_module_name_0_6107"), S("'rootDirs' option is set, using it to resolve relative module name '{0}'.")};
        static DiagnosticMessageStore Longest_matching_prefix_for_0_is_1 = {6108, DiagnosticCategory::Message, S("Longest_matching_prefix_for_0_is_1_6108"), S("Longest matching prefix for '{0}' is '{1}'.")};
        static DiagnosticMessageStore Loading_0_from_the_root_dir_1_candidate_location_2 = {6109, DiagnosticCategory::Message, S("Loading_0_from_the_root_dir_1_candidate_location_2_6109"), S("Loading '{0}' from the root dir '{1}', candidate location '{2}'.")};
        static DiagnosticMessageStore Trying_other_entries_in_rootDirs = {6110, DiagnosticCategory::Message, S("Trying_other_entries_in_rootDirs_6110"), S("Trying other entries in 'rootDirs'.")};
        static DiagnosticMessageStore Module_resolution_using_rootDirs_has_failed = {6111, DiagnosticCategory::Message, S("Module_resolution_using_rootDirs_has_failed_6111"), S("Module resolution using 'rootDirs' has failed.")};
        static DiagnosticMessageStore Do_not_emit_use_strict_directives_in_module_output = {6112, DiagnosticCategory::Message, S("Do_not_emit_use_strict_directives_in_module_output_6112"), S("Do not emit 'use strict' directives in module output.")};
        static DiagnosticMessageStore Enable_strict_null_checks = {6113, DiagnosticCategory::Message, S("Enable_strict_null_checks_6113"), S("Enable strict null checks.")};
        static DiagnosticMessageStore Unknown_option_excludes_Did_you_mean_exclude = {6114, DiagnosticCategory::Error, S("Unknown_option_excludes_Did_you_mean_exclude_6114"), S("Unknown option 'excludes'. Did you mean 'exclude'?")};
        static DiagnosticMessageStore Raise_error_on_this_expressions_with_an_implied_any_type = {6115, DiagnosticCategory::Message, S("Raise_error_on_this_expressions_with_an_implied_any_type_6115"), S("Raise error on 'this' expressions with an implied 'any' type.")};
        static DiagnosticMessageStore Resolving_type_reference_directive_0_containing_file_1_root_directory_2 = {6116, DiagnosticCategory::Message, S("Resolving_type_reference_directive_0_containing_file_1_root_directory_2_6116"), S("======== Resolving type reference directive '{0}', containing file '{1}', root directory '{2}'. ========")};
        static DiagnosticMessageStore Resolving_using_primary_search_paths = {6117, DiagnosticCategory::Message, S("Resolving_using_primary_search_paths_6117"), S("Resolving using primary search paths...")};
        static DiagnosticMessageStore Resolving_from_node_modules_folder = {6118, DiagnosticCategory::Message, S("Resolving_from_node_modules_folder_6118"), S("Resolving from node_modules folder...")};
        static DiagnosticMessageStore Type_reference_directive_0_was_successfully_resolved_to_1_primary_Colon_2 = {6119, DiagnosticCategory::Message, S("Type_reference_directive_0_was_successfully_resolved_to_1_primary_Colon_2_6119"), S("======== Type reference directive '{0}' was successfully resolved to '{1}', primary: {2}. ========")};
        static DiagnosticMessageStore Type_reference_directive_0_was_not_resolved = {6120, DiagnosticCategory::Message, S("Type_reference_directive_0_was_not_resolved_6120"), S("======== Type reference directive '{0}' was not resolved. ========")};
        static DiagnosticMessageStore Resolving_with_primary_search_path_0 = {6121, DiagnosticCategory::Message, S("Resolving_with_primary_search_path_0_6121"), S("Resolving with primary search path '{0}'.")};
        static DiagnosticMessageStore Root_directory_cannot_be_determined_skipping_primary_search_paths = {6122, DiagnosticCategory::Message, S("Root_directory_cannot_be_determined_skipping_primary_search_paths_6122"), S("Root directory cannot be determined, skipping primary search paths.")};
        static DiagnosticMessageStore Resolving_type_reference_directive_0_containing_file_1_root_directory_not_set = {6123, DiagnosticCategory::Message, S("Resolving_type_reference_directive_0_containing_file_1_root_directory_not_set_6123"), S("======== Resolving type reference directive '{0}', containing file '{1}', root directory not set. ========")};
        static DiagnosticMessageStore Type_declaration_files_to_be_included_in_compilation = {6124, DiagnosticCategory::Message, S("Type_declaration_files_to_be_included_in_compilation_6124"), S("Type declaration files to be included in compilation.")};
        static DiagnosticMessageStore Looking_up_in_node_modules_folder_initial_location_0 = {6125, DiagnosticCategory::Message, S("Looking_up_in_node_modules_folder_initial_location_0_6125"), S("Looking up in 'node_modules' folder, initial location '{0}'.")};
        static DiagnosticMessageStore Containing_file_is_not_specified_and_root_directory_cannot_be_determined_skipping_lookup_in_node_modules_folder = {6126, DiagnosticCategory::Message, S("Containing_file_is_not_specified_and_root_directory_cannot_be_determined_skipping_lookup_in_node_mod_6126"), S("Containing file is not specified and root directory cannot be determined, skipping lookup in 'node_modules' folder.")};
        static DiagnosticMessageStore Resolving_type_reference_directive_0_containing_file_not_set_root_directory_1 = {6127, DiagnosticCategory::Message, S("Resolving_type_reference_directive_0_containing_file_not_set_root_directory_1_6127"), S("======== Resolving type reference directive '{0}', containing file not set, root directory '{1}'. ========")};
        static DiagnosticMessageStore Resolving_type_reference_directive_0_containing_file_not_set_root_directory_not_set = {6128, DiagnosticCategory::Message, S("Resolving_type_reference_directive_0_containing_file_not_set_root_directory_not_set_6128"), S("======== Resolving type reference directive '{0}', containing file not set, root directory not set. ========")};
        static DiagnosticMessageStore Resolving_real_path_for_0_result_1 = {6130, DiagnosticCategory::Message, S("Resolving_real_path_for_0_result_1_6130"), S("Resolving real path for '{0}', result '{1}'.")};
        static DiagnosticMessageStore Cannot_compile_modules_using_option_0_unless_the_module_flag_is_amd_or_system = {6131, DiagnosticCategory::Error, S("Cannot_compile_modules_using_option_0_unless_the_module_flag_is_amd_or_system_6131"), S("Cannot compile modules using option '{0}' unless the '--module' flag is 'amd' or 'system'.")};
        static DiagnosticMessageStore File_name_0_has_a_1_extension_stripping_it = {6132, DiagnosticCategory::Message, S("File_name_0_has_a_1_extension_stripping_it_6132"), S("File name '{0}' has a '{1}' extension - stripping it.")};
        static DiagnosticMessageStore _0_is_declared_but_its_value_is_never_read = {6133, DiagnosticCategory::Error, S("_0_is_declared_but_its_value_is_never_read_6133"), S("'{0}' is declared but its value is never read.")};
        static DiagnosticMessageStore Report_errors_on_unused_locals = {6134, DiagnosticCategory::Message, S("Report_errors_on_unused_locals_6134"), S("Report errors on unused locals.")};
        static DiagnosticMessageStore Report_errors_on_unused_parameters = {6135, DiagnosticCategory::Message, S("Report_errors_on_unused_parameters_6135"), S("Report errors on unused parameters.")};
        static DiagnosticMessageStore The_maximum_dependency_depth_to_search_under_node_modules_and_load_JavaScript_files = {6136, DiagnosticCategory::Message, S("The_maximum_dependency_depth_to_search_under_node_modules_and_load_JavaScript_files_6136"), S("The maximum dependency depth to search under node_modules and load JavaScript files.")};
        static DiagnosticMessageStore Cannot_import_type_declaration_files_Consider_importing_0_instead_of_1 = {6137, DiagnosticCategory::Error, S("Cannot_import_type_declaration_files_Consider_importing_0_instead_of_1_6137"), S("Cannot import type declaration files. Consider importing '{0}' instead of '{1}'.")};
        static DiagnosticMessageStore Property_0_is_declared_but_its_value_is_never_read = {6138, DiagnosticCategory::Error, S("Property_0_is_declared_but_its_value_is_never_read_6138"), S("Property '{0}' is declared but its value is never read.")};
        static DiagnosticMessageStore Import_emit_helpers_from_tslib = {6139, DiagnosticCategory::Message, S("Import_emit_helpers_from_tslib_6139"), S("Import emit helpers from 'tslib'.")};
        static DiagnosticMessageStore Auto_discovery_for_typings_is_enabled_in_project_0_Running_extra_resolution_pass_for_module_1_using_cache_location_2 = {6140, DiagnosticCategory::Error, S("Auto_discovery_for_typings_is_enabled_in_project_0_Running_extra_resolution_pass_for_module_1_using__6140"), S("Auto discovery for typings is enabled in project '{0}'. Running extra resolution pass for module '{1}' using cache location '{2}'.")};
        static DiagnosticMessageStore Parse_in_strict_mode_and_emit_use_strict_for_each_source_file = {6141, DiagnosticCategory::Message, S("Parse_in_strict_mode_and_emit_use_strict_for_each_source_file_6141"), S("Parse in strict mode and emit \")use strict\" for each source file.")};
        static DiagnosticMessageStore Module_0_was_resolved_to_1_but_jsx_is_not_set = {6142, DiagnosticCategory::Error, S("Module_0_was_resolved_to_1_but_jsx_is_not_set_6142"), S("Module '{0}' was resolved to '{1}', but '--jsx' is not set.")};
        static DiagnosticMessageStore Module_0_was_resolved_as_locally_declared_ambient_module_in_file_1 = {6144, DiagnosticCategory::Message, S("Module_0_was_resolved_as_locally_declared_ambient_module_in_file_1_6144"), S("Module '{0}' was resolved as locally declared ambient module in file '{1}'.")};
        static DiagnosticMessageStore Module_0_was_resolved_as_ambient_module_declared_in_1_since_this_file_was_not_modified = {6145, DiagnosticCategory::Message, S("Module_0_was_resolved_as_ambient_module_declared_in_1_since_this_file_was_not_modified_6145"), S("Module '{0}' was resolved as ambient module declared in '{1}' since this file was not modified.")};
        static DiagnosticMessageStore Specify_the_JSX_factory_function_to_use_when_targeting_react_JSX_emit_e_g_React_createElement_or_h = {6146, DiagnosticCategory::Message, S("Specify_the_JSX_factory_function_to_use_when_targeting_react_JSX_emit_e_g_React_createElement_or_h_6146"), S("Specify the JSX factory function to use when targeting 'react' JSX emit, e.g. 'React.createElement' or 'h'.")};
        static DiagnosticMessageStore Resolution_for_module_0_was_found_in_cache_from_location_1 = {6147, DiagnosticCategory::Message, S("Resolution_for_module_0_was_found_in_cache_from_location_1_6147"), S("Resolution for module '{0}' was found in cache from location '{1}'.")};
        static DiagnosticMessageStore Directory_0_does_not_exist_skipping_all_lookups_in_it = {6148, DiagnosticCategory::Message, S("Directory_0_does_not_exist_skipping_all_lookups_in_it_6148"), S("Directory '{0}' does not exist, skipping all lookups in it.")};
        static DiagnosticMessageStore Show_diagnostic_information = {6149, DiagnosticCategory::Message, S("Show_diagnostic_information_6149"), S("Show diagnostic information.")};
        static DiagnosticMessageStore Show_verbose_diagnostic_information = {6150, DiagnosticCategory::Message, S("Show_verbose_diagnostic_information_6150"), S("Show verbose diagnostic information.")};
        static DiagnosticMessageStore Emit_a_single_file_with_source_maps_instead_of_having_a_separate_file = {6151, DiagnosticCategory::Message, S("Emit_a_single_file_with_source_maps_instead_of_having_a_separate_file_6151"), S("Emit a single file with source maps instead of having a separate file.")};
        static DiagnosticMessageStore Emit_the_source_alongside_the_sourcemaps_within_a_single_file_requires_inlineSourceMap_or_sourceMap_to_be_set = {6152, DiagnosticCategory::Message, S("Emit_the_source_alongside_the_sourcemaps_within_a_single_file_requires_inlineSourceMap_or_sourceMap__6152"), S("Emit the source alongside the sourcemaps within a single file; requires '--inlineSourceMap' or '--sourceMap' to be set.")};
        static DiagnosticMessageStore Transpile_each_file_as_a_separate_module_similar_to_ts_transpileModule = {6153, DiagnosticCategory::Message, S("Transpile_each_file_as_a_separate_module_similar_to_ts_transpileModule_6153"), S("Transpile each file as a separate module (similar to 'ts.transpileModule').")};
        static DiagnosticMessageStore Print_names_of_generated_files_part_of_the_compilation = {6154, DiagnosticCategory::Message, S("Print_names_of_generated_files_part_of_the_compilation_6154"), S("Print names of generated files part of the compilation.")};
        static DiagnosticMessageStore Print_names_of_files_part_of_the_compilation = {6155, DiagnosticCategory::Message, S("Print_names_of_files_part_of_the_compilation_6155"), S("Print names of files part of the compilation.")};
        static DiagnosticMessageStore The_locale_used_when_displaying_messages_to_the_user_e_g_en_us = {6156, DiagnosticCategory::Message, S("The_locale_used_when_displaying_messages_to_the_user_e_g_en_us_6156"), S("The locale used when displaying messages to the user (e.g. 'en-us')")};
        static DiagnosticMessageStore Do_not_generate_custom_helper_functions_like_extends_in_compiled_output = {6157, DiagnosticCategory::Message, S("Do_not_generate_custom_helper_functions_like_extends_in_compiled_output_6157"), S("Do not generate custom helper functions like '__extends' in compiled output.")};
        static DiagnosticMessageStore Do_not_include_the_default_library_file_lib_d_ts = {6158, DiagnosticCategory::Message, S("Do_not_include_the_default_library_file_lib_d_ts_6158"), S("Do not include the default library file (lib.d.ts).")};
        static DiagnosticMessageStore Do_not_add_triple_slash_references_or_imported_modules_to_the_list_of_compiled_files = {6159, DiagnosticCategory::Message, S("Do_not_add_triple_slash_references_or_imported_modules_to_the_list_of_compiled_files_6159"), S("Do not add triple-slash references or imported modules to the list of compiled files.")};
        static DiagnosticMessageStore Deprecated_Use_skipLibCheck_instead_Skip_type_checking_of_default_library_declaration_files = {6160, DiagnosticCategory::Message, S("Deprecated_Use_skipLibCheck_instead_Skip_type_checking_of_default_library_declaration_files_6160"), S("[Deprecated] Use '--skipLibCheck' instead. Skip type checking of default library declaration files.")};
        static DiagnosticMessageStore List_of_folders_to_include_type_definitions_from = {6161, DiagnosticCategory::Message, S("List_of_folders_to_include_type_definitions_from_6161"), S("List of folders to include type definitions from.")};
        static DiagnosticMessageStore Disable_size_limitations_on_JavaScript_projects = {6162, DiagnosticCategory::Message, S("Disable_size_limitations_on_JavaScript_projects_6162"), S("Disable size limitations on JavaScript projects.")};
        static DiagnosticMessageStore The_character_set_of_the_input_files = {6163, DiagnosticCategory::Message, S("The_character_set_of_the_input_files_6163"), S("The character set of the input files.")};
        static DiagnosticMessageStore Emit_a_UTF_8_Byte_Order_Mark_BOM_in_the_beginning_of_output_files = {6164, DiagnosticCategory::Message, S("Emit_a_UTF_8_Byte_Order_Mark_BOM_in_the_beginning_of_output_files_6164"), S("Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files.")};
        static DiagnosticMessageStore Do_not_truncate_error_messages = {6165, DiagnosticCategory::Message, S("Do_not_truncate_error_messages_6165"), S("Do not truncate error messages.")};
        static DiagnosticMessageStore Output_directory_for_generated_declaration_files = {6166, DiagnosticCategory::Message, S("Output_directory_for_generated_declaration_files_6166"), S("Output directory for generated declaration files.")};
        static DiagnosticMessageStore A_series_of_entries_which_re_map_imports_to_lookup_locations_relative_to_the_baseUrl = {6167, DiagnosticCategory::Message, S("A_series_of_entries_which_re_map_imports_to_lookup_locations_relative_to_the_baseUrl_6167"), S("A series of entries which re-map imports to lookup locations relative to the 'baseUrl'.")};
        static DiagnosticMessageStore List_of_root_folders_whose_combined_content_represents_the_structure_of_the_project_at_runtime = {6168, DiagnosticCategory::Message, S("List_of_root_folders_whose_combined_content_represents_the_structure_of_the_project_at_runtime_6168"), S("List of root folders whose combined content represents the structure of the project at runtime.")};
        static DiagnosticMessageStore Show_all_compiler_options = {6169, DiagnosticCategory::Message, S("Show_all_compiler_options_6169"), S("Show all compiler options.")};
        static DiagnosticMessageStore Deprecated_Use_outFile_instead_Concatenate_and_emit_output_to_single_file = {6170, DiagnosticCategory::Message, S("Deprecated_Use_outFile_instead_Concatenate_and_emit_output_to_single_file_6170"), S("[Deprecated] Use '--outFile' instead. Concatenate and emit output to single file")};
        static DiagnosticMessageStore Command_line_Options = {6171, DiagnosticCategory::Message, S("Command_line_Options_6171"), S("Command-line Options")};
        static DiagnosticMessageStore Basic_Options = {6172, DiagnosticCategory::Message, S("Basic_Options_6172"), S("Basic Options")};
        static DiagnosticMessageStore Strict_Type_Checking_Options = {6173, DiagnosticCategory::Message, S("Strict_Type_Checking_Options_6173"), S("Strict Type-Checking Options")};
        static DiagnosticMessageStore Module_Resolution_Options = {6174, DiagnosticCategory::Message, S("Module_Resolution_Options_6174"), S("Module Resolution Options")};
        static DiagnosticMessageStore Source_Map_Options = {6175, DiagnosticCategory::Message, S("Source_Map_Options_6175"), S("Source Map Options")};
        static DiagnosticMessageStore Additional_Checks = {6176, DiagnosticCategory::Message, S("Additional_Checks_6176"), S("Additional Checks")};
        static DiagnosticMessageStore Experimental_Options = {6177, DiagnosticCategory::Message, S("Experimental_Options_6177"), S("Experimental Options")};
        static DiagnosticMessageStore Advanced_Options = {6178, DiagnosticCategory::Message, S("Advanced_Options_6178"), S("Advanced Options")};
        static DiagnosticMessageStore Provide_full_support_for_iterables_in_for_of_spread_and_destructuring_when_targeting_ES5_or_ES3 = {6179, DiagnosticCategory::Message, S("Provide_full_support_for_iterables_in_for_of_spread_and_destructuring_when_targeting_ES5_or_ES3_6179"), S("Provide full support for iterables in 'for-of', spread, and destructuring when targeting 'ES5' or 'ES3'.")};
        static DiagnosticMessageStore Enable_all_strict_type_checking_options = {6180, DiagnosticCategory::Message, S("Enable_all_strict_type_checking_options_6180"), S("Enable all strict type-checking options.")};
        static DiagnosticMessageStore List_of_language_service_plugins = {6181, DiagnosticCategory::Message, S("List_of_language_service_plugins_6181"), S("List of language service plugins.")};
        static DiagnosticMessageStore Scoped_package_detected_looking_in_0 = {6182, DiagnosticCategory::Message, S("Scoped_package_detected_looking_in_0_6182"), S("Scoped package detected, looking in '{0}'")};
        static DiagnosticMessageStore Reusing_resolution_of_module_0_to_file_1_from_old_program = {6183, DiagnosticCategory::Message, S("Reusing_resolution_of_module_0_to_file_1_from_old_program_6183"), S("Reusing resolution of module '{0}' to file '{1}' from old program.")};
        static DiagnosticMessageStore Reusing_module_resolutions_originating_in_0_since_resolutions_are_unchanged_from_old_program = {6184, DiagnosticCategory::Message, S("Reusing_module_resolutions_originating_in_0_since_resolutions_are_unchanged_from_old_program_6184"), S("Reusing module resolutions originating in '{0}' since resolutions are unchanged from old program.")};
        static DiagnosticMessageStore Disable_strict_checking_of_generic_signatures_in_function_types = {6185, DiagnosticCategory::Message, S("Disable_strict_checking_of_generic_signatures_in_function_types_6185"), S("Disable strict checking of generic signatures in function types.")};
        static DiagnosticMessageStore Enable_strict_checking_of_function_types = {6186, DiagnosticCategory::Message, S("Enable_strict_checking_of_function_types_6186"), S("Enable strict checking of function types.")};
        static DiagnosticMessageStore Enable_strict_checking_of_property_initialization_in_classes = {6187, DiagnosticCategory::Message, S("Enable_strict_checking_of_property_initialization_in_classes_6187"), S("Enable strict checking of property initialization in classes.")};
        static DiagnosticMessageStore Numeric_separators_are_not_allowed_here = {6188, DiagnosticCategory::Error, S("Numeric_separators_are_not_allowed_here_6188"), S("Numeric separators are not allowed here.")};
        static DiagnosticMessageStore Multiple_consecutive_numeric_separators_are_not_permitted = {6189, DiagnosticCategory::Error, S("Multiple_consecutive_numeric_separators_are_not_permitted_6189"), S("Multiple consecutive numeric separators are not permitted.")};
        static DiagnosticMessageStore Whether_to_keep_outdated_console_output_in_watch_mode_instead_of_clearing_the_screen = {6191, DiagnosticCategory::Message, S("Whether_to_keep_outdated_console_output_in_watch_mode_instead_of_clearing_the_screen_6191"), S("Whether to keep outdated console output in watch mode instead of clearing the screen.")};
        static DiagnosticMessageStore All_imports_in_import_declaration_are_unused = {6192, DiagnosticCategory::Error, S("All_imports_in_import_declaration_are_unused_6192"), S("All imports in import declaration are unused.")};
        static DiagnosticMessageStore Found_1_error_Watching_for_file_changes = {6193, DiagnosticCategory::Message, S("Found_1_error_Watching_for_file_changes_6193"), S("Found 1 error. Watching for file changes.")};
        static DiagnosticMessageStore Found_0_errors_Watching_for_file_changes = {6194, DiagnosticCategory::Message, S("Found_0_errors_Watching_for_file_changes_6194"), S("Found {0} errors. Watching for file changes.")};
        static DiagnosticMessageStore Resolve_keyof_to_string_valued_property_names_only_no_numbers_or_symbols = {6195, DiagnosticCategory::Message, S("Resolve_keyof_to_string_valued_property_names_only_no_numbers_or_symbols_6195"), S("Resolve 'keyof' to string valued property names only (no numbers or symbols).")};
        static DiagnosticMessageStore _0_is_declared_but_never_used = {6196, DiagnosticCategory::Error, S("_0_is_declared_but_never_used_6196"), S("'{0}' is declared but never used.")};
        static DiagnosticMessageStore Include_modules_imported_with_json_extension = {6197, DiagnosticCategory::Message, S("Include_modules_imported_with_json_extension_6197"), S("Include modules imported with '.json' extension")};
        static DiagnosticMessageStore All_destructured_elements_are_unused = {6198, DiagnosticCategory::Error, S("All_destructured_elements_are_unused_6198"), S("All destructured elements are unused.")};
        static DiagnosticMessageStore All_variables_are_unused = {6199, DiagnosticCategory::Error, S("All_variables_are_unused_6199"), S("All variables are unused.")};
        static DiagnosticMessageStore Definitions_of_the_following_identifiers_conflict_with_those_in_another_file_Colon_0 = {6200, DiagnosticCategory::Error, S("Definitions_of_the_following_identifiers_conflict_with_those_in_another_file_Colon_0_6200"), S("Definitions of the following identifiers conflict with those in another file: {0}")};
        static DiagnosticMessageStore Conflicts_are_in_this_file = {6201, DiagnosticCategory::Message, S("Conflicts_are_in_this_file_6201"), S("Conflicts are in this file.")};
        static DiagnosticMessageStore Project_references_may_not_form_a_circular_graph_Cycle_detected_Colon_0 = {6202, DiagnosticCategory::Error, S("Project_references_may_not_form_a_circular_graph_Cycle_detected_Colon_0_6202"), S("Project references may not form a circular graph. Cycle detected: {0}")};
        static DiagnosticMessageStore _0_was_also_declared_here = {6203, DiagnosticCategory::Message, S("_0_was_also_declared_here_6203"), S("'{0}' was also declared here.")};
        static DiagnosticMessageStore and_here = {6204, DiagnosticCategory::Message, S("and_here_6204"), S("and here.")};
        static DiagnosticMessageStore All_type_parameters_are_unused = {6205, DiagnosticCategory::Error, S("All_type_parameters_are_unused_6205"), S("All type parameters are unused.")};
        static DiagnosticMessageStore package_json_has_a_typesVersions_field_with_version_specific_path_mappings = {6206, DiagnosticCategory::Message, S("package_json_has_a_typesVersions_field_with_version_specific_path_mappings_6206"), S("'package.json' has a 'typesVersions' field with version-specific path mappings.")};
        static DiagnosticMessageStore package_json_does_not_have_a_typesVersions_entry_that_matches_version_0 = {6207, DiagnosticCategory::Message, S("package_json_does_not_have_a_typesVersions_entry_that_matches_version_0_6207"), S("'package.json' does not have a 'typesVersions' entry that matches version '{0}'.")};
        static DiagnosticMessageStore package_json_has_a_typesVersions_entry_0_that_matches_compiler_version_1_looking_for_a_pattern_to_match_module_name_2 = {6208, DiagnosticCategory::Message, S("package_json_has_a_typesVersions_entry_0_that_matches_compiler_version_1_looking_for_a_pattern_to_ma_6208"), S("'package.json' has a 'typesVersions' entry '{0}' that matches compiler version '{1}', looking for a pattern to match module name '{2}'.")};
        static DiagnosticMessageStore package_json_has_a_typesVersions_entry_0_that_is_not_a_valid_semver_range = {6209, DiagnosticCategory::Message, S("package_json_has_a_typesVersions_entry_0_that_is_not_a_valid_semver_range_6209"), S("'package.json' has a 'typesVersions' entry '{0}' that is not a valid semver range.")};
        static DiagnosticMessageStore An_argument_for_0_was_not_provided = {6210, DiagnosticCategory::Message, S("An_argument_for_0_was_not_provided_6210"), S("An argument for '{0}' was not provided.")};
        static DiagnosticMessageStore An_argument_matching_this_binding_pattern_was_not_provided = {6211, DiagnosticCategory::Message, S("An_argument_matching_this_binding_pattern_was_not_provided_6211"), S("An argument matching this binding pattern was not provided.")};
        static DiagnosticMessageStore Did_you_mean_to_call_this_expression = {6212, DiagnosticCategory::Message, S("Did_you_mean_to_call_this_expression_6212"), S("Did you mean to call this expression?")};
        static DiagnosticMessageStore Did_you_mean_to_use_new_with_this_expression = {6213, DiagnosticCategory::Message, S("Did_you_mean_to_use_new_with_this_expression_6213"), S("Did you mean to use 'new' with this expression?")};
        static DiagnosticMessageStore Enable_strict_bind_call_and_apply_methods_on_functions = {6214, DiagnosticCategory::Message, S("Enable_strict_bind_call_and_apply_methods_on_functions_6214"), S("Enable strict 'bind', 'call', and 'apply' methods on functions.")};
        static DiagnosticMessageStore Using_compiler_options_of_project_reference_redirect_0 = {6215, DiagnosticCategory::Message, S("Using_compiler_options_of_project_reference_redirect_0_6215"), S("Using compiler options of project reference redirect '{0}'.")};
        static DiagnosticMessageStore Found_1_error = {6216, DiagnosticCategory::Message, S("Found_1_error_6216"), S("Found 1 error.")};
        static DiagnosticMessageStore Found_0_errors = {6217, DiagnosticCategory::Message, S("Found_0_errors_6217"), S("Found {0} errors.")};
        static DiagnosticMessageStore Module_name_0_was_successfully_resolved_to_1_with_Package_ID_2 = {6218, DiagnosticCategory::Message, S("Module_name_0_was_successfully_resolved_to_1_with_Package_ID_2_6218"), S("======== Module name '{0}' was successfully resolved to '{1}' with Package ID '{2}'. ========")};
        static DiagnosticMessageStore Type_reference_directive_0_was_successfully_resolved_to_1_with_Package_ID_2_primary_Colon_3 = {6219, DiagnosticCategory::Message, S("Type_reference_directive_0_was_successfully_resolved_to_1_with_Package_ID_2_primary_Colon_3_6219"), S("======== Type reference directive '{0}' was successfully resolved to '{1}' with Package ID '{2}', primary: {3}. ========")};
        static DiagnosticMessageStore package_json_had_a_falsy_0_field = {6220, DiagnosticCategory::Message, S("package_json_had_a_falsy_0_field_6220"), S("'package.json' had a falsy '{0}' field.")};
        static DiagnosticMessageStore Disable_use_of_source_files_instead_of_declaration_files_from_referenced_projects = {6221, DiagnosticCategory::Message, S("Disable_use_of_source_files_instead_of_declaration_files_from_referenced_projects_6221"), S("Disable use of source files instead of declaration files from referenced projects.")};
        static DiagnosticMessageStore Emit_class_fields_with_Define_instead_of_Set = {6222, DiagnosticCategory::Message, S("Emit_class_fields_with_Define_instead_of_Set_6222"), S("Emit class fields with Define instead of Set.")};
        static DiagnosticMessageStore Generates_a_CPU_profile = {6223, DiagnosticCategory::Message, S("Generates_a_CPU_profile_6223"), S("Generates a CPU profile.")};
        static DiagnosticMessageStore Disable_solution_searching_for_this_project = {6224, DiagnosticCategory::Message, S("Disable_solution_searching_for_this_project_6224"), S("Disable solution searching for this project.")};
        static DiagnosticMessageStore Specify_strategy_for_watching_file_Colon_FixedPollingInterval_default_PriorityPollingInterval_DynamicPriorityPolling_UseFsEvents_UseFsEventsOnParentDirectory = {6225, DiagnosticCategory::Message, S("Specify_strategy_for_watching_file_Colon_FixedPollingInterval_default_PriorityPollingInterval_Dynami_6225"), S("Specify strategy for watching file: 'FixedPollingInterval' (default}; 'PriorityPollingInterval', 'DynamicPriorityPolling', 'UseFsEvents', 'UseFsEventsOnParentDirectory'.")};
        static DiagnosticMessageStore Specify_strategy_for_watching_directory_on_platforms_that_don_t_support_recursive_watching_natively_Colon_UseFsEvents_default_FixedPollingInterval_DynamicPriorityPolling = {6226, DiagnosticCategory::Message, S("Specify_strategy_for_watching_directory_on_platforms_that_don_t_support_recursive_watching_natively__6226"), S("Specify strategy for watching directory on platforms that don't support recursive watching natively: 'UseFsEvents' (default}; 'FixedPollingInterval', 'DynamicPriorityPolling'.")};
        static DiagnosticMessageStore Specify_strategy_for_creating_a_polling_watch_when_it_fails_to_create_using_file_system_events_Colon_FixedInterval_default_PriorityInterval_DynamicPriority = {6227, DiagnosticCategory::Message, S("Specify_strategy_for_creating_a_polling_watch_when_it_fails_to_create_using_file_system_events_Colon_6227"), S("Specify strategy for creating a polling watch when it fails to create using file system events: 'FixedInterval' (default}; 'PriorityInterval', 'DynamicPriority'.")};
        static DiagnosticMessageStore Synchronously_call_callbacks_and_update_the_state_of_directory_watchers_on_platforms_that_don_t_support_recursive_watching_natively = {6228, DiagnosticCategory::Message, S("Synchronously_call_callbacks_and_update_the_state_of_directory_watchers_on_platforms_that_don_t_supp_6228"), S("Synchronously call callbacks and update the state of directory watchers on platforms that don't support recursive watching natively.")};
        static DiagnosticMessageStore Tag_0_expects_at_least_1_arguments_but_the_JSX_factory_2_provides_at_most_3 = {6229, DiagnosticCategory::Error, S("Tag_0_expects_at_least_1_arguments_but_the_JSX_factory_2_provides_at_most_3_6229"), S("Tag '{0}' expects at least '{1}' arguments, but the JSX factory '{2}' provides at most '{3}'.")};
        static DiagnosticMessageStore Option_0_can_only_be_specified_in_tsconfig_json_file_or_set_to_false_or_null_on_command_line = {6230, DiagnosticCategory::Error, S("Option_0_can_only_be_specified_in_tsconfig_json_file_or_set_to_false_or_null_on_command_line_6230"), S("Option '{0}' can only be specified in 'tsconfig.json' file or set to 'false' or 'null' on command line.")};
        static DiagnosticMessageStore Could_not_resolve_the_path_0_with_the_extensions_Colon_1 = {6231, DiagnosticCategory::Error, S("Could_not_resolve_the_path_0_with_the_extensions_Colon_1_6231"), S("Could not resolve the path '{0}' with the extensions: {1}.")};
        static DiagnosticMessageStore Declaration_augments_declaration_in_another_file_This_cannot_be_serialized = {6232, DiagnosticCategory::Error, S("Declaration_augments_declaration_in_another_file_This_cannot_be_serialized_6232"), S("Declaration augments declaration in another file. This cannot be serialized.")};
        static DiagnosticMessageStore This_is_the_declaration_being_augmented_Consider_moving_the_augmenting_declaration_into_the_same_file = {6233, DiagnosticCategory::Error, S("This_is_the_declaration_being_augmented_Consider_moving_the_augmenting_declaration_into_the_same_fil_6233"), S("This is the declaration being augmented. Consider moving the augmenting declaration into the same file.")};
        static DiagnosticMessageStore This_expression_is_not_callable_because_it_is_a_get_accessor_Did_you_mean_to_use_it_without = {6234, DiagnosticCategory::Error, S("This_expression_is_not_callable_because_it_is_a_get_accessor_Did_you_mean_to_use_it_without_6234"), S("This expression is not callable because it is a 'get' accessor. Did you mean to use it without '()'?")};
        static DiagnosticMessageStore Disable_loading_referenced_projects = {6235, DiagnosticCategory::Message, S("Disable_loading_referenced_projects_6235"), S("Disable loading referenced projects.")};
        static DiagnosticMessageStore Arguments_for_the_rest_parameter_0_were_not_provided = {6236, DiagnosticCategory::Error, S("Arguments_for_the_rest_parameter_0_were_not_provided_6236"), S("Arguments for the rest parameter '{0}' were not provided.")};
        static DiagnosticMessageStore Generates_an_event_trace_and_a_list_of_types = {6237, DiagnosticCategory::Message, S("Generates_an_event_trace_and_a_list_of_types_6237"), S("Generates an event trace and a list of types.")};
        static DiagnosticMessageStore Specify_the_module_specifier_to_be_used_to_import_the_jsx_and_jsxs_factory_functions_from_eg_react = {6238, DiagnosticCategory::Error, S("Specify_the_module_specifier_to_be_used_to_import_the_jsx_and_jsxs_factory_functions_from_eg_react_6238"), S("Specify the module specifier to be used to import the `jsx` and `jsxs` factory functions from. eg, react")};
        static DiagnosticMessageStore Projects_to_reference = {6300, DiagnosticCategory::Message, S("Projects_to_reference_6300"), S("Projects to reference")};
        static DiagnosticMessageStore Enable_project_compilation = {6302, DiagnosticCategory::Message, S("Enable_project_compilation_6302"), S("Enable project compilation")};
        static DiagnosticMessageStore Composite_projects_may_not_disable_declaration_emit = {6304, DiagnosticCategory::Error, S("Composite_projects_may_not_disable_declaration_emit_6304"), S("Composite projects may not disable declaration emit.")};
        static DiagnosticMessageStore Output_file_0_has_not_been_built_from_source_file_1 = {6305, DiagnosticCategory::Error, S("Output_file_0_has_not_been_built_from_source_file_1_6305"), S("Output file '{0}' has not been built from source file '{1}'.")};
        static DiagnosticMessageStore Referenced_project_0_must_have_setting_composite_Colon_true = {6306, DiagnosticCategory::Error, S("Referenced_project_0_must_have_setting_composite_Colon_true_6306"), S("Referenced project '{0}' must have setting \")composite\": true.")};
        static DiagnosticMessageStore File_0_is_not_listed_within_the_file_list_of_project_1_Projects_must_list_all_files_or_use_an_include_pattern = {6307, DiagnosticCategory::Error, S("File_0_is_not_listed_within_the_file_list_of_project_1_Projects_must_list_all_files_or_use_an_includ_6307"), S("File '{0}' is not listed within the file list of project '{1}'. Projects must list all files or use an 'include' pattern.")};
        static DiagnosticMessageStore Cannot_prepend_project_0_because_it_does_not_have_outFile_set = {6308, DiagnosticCategory::Error, S("Cannot_prepend_project_0_because_it_does_not_have_outFile_set_6308"), S("Cannot prepend project '{0}' because it does not have 'outFile' set")};
        static DiagnosticMessageStore Output_file_0_from_project_1_does_not_exist = {6309, DiagnosticCategory::Error, S("Output_file_0_from_project_1_does_not_exist_6309"), S("Output file '{0}' from project '{1}' does not exist")};
        static DiagnosticMessageStore Referenced_project_0_may_not_disable_emit = {6310, DiagnosticCategory::Error, S("Referenced_project_0_may_not_disable_emit_6310"), S("Referenced project '{0}' may not disable emit.")};
        static DiagnosticMessageStore Project_0_is_out_of_date_because_oldest_output_1_is_older_than_newest_input_2 = {6350, DiagnosticCategory::Message, S("Project_0_is_out_of_date_because_oldest_output_1_is_older_than_newest_input_2_6350"), S("Project '{0}' is out of date because oldest output '{1}' is older than newest input '{2}'")};
        static DiagnosticMessageStore Project_0_is_up_to_date_because_newest_input_1_is_older_than_oldest_output_2 = {6351, DiagnosticCategory::Message, S("Project_0_is_up_to_date_because_newest_input_1_is_older_than_oldest_output_2_6351"), S("Project '{0}' is up to date because newest input '{1}' is older than oldest output '{2}'")};
        static DiagnosticMessageStore Project_0_is_out_of_date_because_output_file_1_does_not_exist = {6352, DiagnosticCategory::Message, S("Project_0_is_out_of_date_because_output_file_1_does_not_exist_6352"), S("Project '{0}' is out of date because output file '{1}' does not exist")};
        static DiagnosticMessageStore Project_0_is_out_of_date_because_its_dependency_1_is_out_of_date = {6353, DiagnosticCategory::Message, S("Project_0_is_out_of_date_because_its_dependency_1_is_out_of_date_6353"), S("Project '{0}' is out of date because its dependency '{1}' is out of date")};
        static DiagnosticMessageStore Project_0_is_up_to_date_with_d_ts_files_from_its_dependencies = {6354, DiagnosticCategory::Message, S("Project_0_is_up_to_date_with_d_ts_files_from_its_dependencies_6354"), S("Project '{0}' is up to date with .d.ts files from its dependencies")};
        static DiagnosticMessageStore Projects_in_this_build_Colon_0 = {6355, DiagnosticCategory::Message, S("Projects_in_this_build_Colon_0_6355"), S("Projects in this build: {0}")};
        static DiagnosticMessageStore A_non_dry_build_would_delete_the_following_files_Colon_0 = {6356, DiagnosticCategory::Message, S("A_non_dry_build_would_delete_the_following_files_Colon_0_6356"), S("A non-dry build would delete the following files: {0}")};
        static DiagnosticMessageStore A_non_dry_build_would_build_project_0 = {6357, DiagnosticCategory::Message, S("A_non_dry_build_would_build_project_0_6357"), S("A non-dry build would build project '{0}'")};
        static DiagnosticMessageStore Building_project_0 = {6358, DiagnosticCategory::Message, S("Building_project_0_6358"), S("Building project '{0}'...")};
        static DiagnosticMessageStore Updating_output_timestamps_of_project_0 = {6359, DiagnosticCategory::Message, S("Updating_output_timestamps_of_project_0_6359"), S("Updating output timestamps of project '{0}'...")};
        static DiagnosticMessageStore delete_this_Project_0_is_up_to_date_because_it_was_previously_built = {6360, DiagnosticCategory::Message, S("delete_this_Project_0_is_up_to_date_because_it_was_previously_built_6360"), S("delete this - Project '{0}' is up to date because it was previously built")};
        static DiagnosticMessageStore Project_0_is_up_to_date = {6361, DiagnosticCategory::Message, S("Project_0_is_up_to_date_6361"), S("Project '{0}' is up to date")};
        static DiagnosticMessageStore Skipping_build_of_project_0_because_its_dependency_1_has_errors = {6362, DiagnosticCategory::Message, S("Skipping_build_of_project_0_because_its_dependency_1_has_errors_6362"), S("Skipping build of project '{0}' because its dependency '{1}' has errors")};
        static DiagnosticMessageStore Project_0_can_t_be_built_because_its_dependency_1_has_errors = {6363, DiagnosticCategory::Message, S("Project_0_can_t_be_built_because_its_dependency_1_has_errors_6363"), S("Project '{0}' can't be built because its dependency '{1}' has errors")};
        static DiagnosticMessageStore Build_one_or_more_projects_and_their_dependencies_if_out_of_date = {6364, DiagnosticCategory::Message, S("Build_one_or_more_projects_and_their_dependencies_if_out_of_date_6364"), S("Build one or more projects and their dependencies, if out of date")};
        static DiagnosticMessageStore Delete_the_outputs_of_all_projects = {6365, DiagnosticCategory::Message, S("Delete_the_outputs_of_all_projects_6365"), S("Delete the outputs of all projects")};
        static DiagnosticMessageStore Enable_verbose_logging = {6366, DiagnosticCategory::Message, S("Enable_verbose_logging_6366"), S("Enable verbose logging")};
        static DiagnosticMessageStore Show_what_would_be_built_or_deleted_if_specified_with_clean = {6367, DiagnosticCategory::Message, S("Show_what_would_be_built_or_deleted_if_specified_with_clean_6367"), S("Show what would be built (or deleted, if specified with '--clean')")};
        static DiagnosticMessageStore Build_all_projects_including_those_that_appear_to_be_up_to_date = {6368, DiagnosticCategory::Message, S("Build_all_projects_including_those_that_appear_to_be_up_to_date_6368"), S("Build all projects, including those that appear to be up to date")};
        static DiagnosticMessageStore Option_build_must_be_the_first_command_line_argument = {6369, DiagnosticCategory::Error, S("Option_build_must_be_the_first_command_line_argument_6369"), S("Option '--build' must be the first command line argument.")};
        static DiagnosticMessageStore Options_0_and_1_cannot_be_combined = {6370, DiagnosticCategory::Error, S("Options_0_and_1_cannot_be_combined_6370"), S("Options '{0}' and '{1}' cannot be combined.")};
        static DiagnosticMessageStore Updating_unchanged_output_timestamps_of_project_0 = {6371, DiagnosticCategory::Message, S("Updating_unchanged_output_timestamps_of_project_0_6371"), S("Updating unchanged output timestamps of project '{0}'...")};
        static DiagnosticMessageStore Project_0_is_out_of_date_because_output_of_its_dependency_1_has_changed = {6372, DiagnosticCategory::Message, S("Project_0_is_out_of_date_because_output_of_its_dependency_1_has_changed_6372"), S("Project '{0}' is out of date because output of its dependency '{1}' has changed")};
        static DiagnosticMessageStore Updating_output_of_project_0 = {6373, DiagnosticCategory::Message, S("Updating_output_of_project_0_6373"), S("Updating output of project '{0}'...")};
        static DiagnosticMessageStore A_non_dry_build_would_update_timestamps_for_output_of_project_0 = {6374, DiagnosticCategory::Message, S("A_non_dry_build_would_update_timestamps_for_output_of_project_0_6374"), S("A non-dry build would update timestamps for output of project '{0}'")};
        static DiagnosticMessageStore A_non_dry_build_would_update_output_of_project_0 = {6375, DiagnosticCategory::Message, S("A_non_dry_build_would_update_output_of_project_0_6375"), S("A non-dry build would update output of project '{0}'")};
        static DiagnosticMessageStore Cannot_update_output_of_project_0_because_there_was_error_reading_file_1 = {6376, DiagnosticCategory::Message, S("Cannot_update_output_of_project_0_because_there_was_error_reading_file_1_6376"), S("Cannot update output of project '{0}' because there was error reading file '{1}'")};
        static DiagnosticMessageStore Cannot_write_file_0_because_it_will_overwrite_tsbuildinfo_file_generated_by_referenced_project_1 = {6377, DiagnosticCategory::Error, S("Cannot_write_file_0_because_it_will_overwrite_tsbuildinfo_file_generated_by_referenced_project_1_6377"), S("Cannot write file '{0}' because it will overwrite '.tsbuildinfo' file generated by referenced project '{1}'")};
        static DiagnosticMessageStore Enable_incremental_compilation = {6378, DiagnosticCategory::Message, S("Enable_incremental_compilation_6378"), S("Enable incremental compilation")};
        static DiagnosticMessageStore Composite_projects_may_not_disable_incremental_compilation = {6379, DiagnosticCategory::Error, S("Composite_projects_may_not_disable_incremental_compilation_6379"), S("Composite projects may not disable incremental compilation.")};
        static DiagnosticMessageStore Specify_file_to_store_incremental_compilation_information = {6380, DiagnosticCategory::Message, S("Specify_file_to_store_incremental_compilation_information_6380"), S("Specify file to store incremental compilation information")};
        static DiagnosticMessageStore Project_0_is_out_of_date_because_output_for_it_was_generated_with_version_1_that_differs_with_current_version_2 = {6381, DiagnosticCategory::Message, S("Project_0_is_out_of_date_because_output_for_it_was_generated_with_version_1_that_differs_with_curren_6381"), S("Project '{0}' is out of date because output for it was generated with version '{1}' that differs with current version '{2}'")};
        static DiagnosticMessageStore Skipping_build_of_project_0_because_its_dependency_1_was_not_built = {6382, DiagnosticCategory::Message, S("Skipping_build_of_project_0_because_its_dependency_1_was_not_built_6382"), S("Skipping build of project '{0}' because its dependency '{1}' was not built")};
        static DiagnosticMessageStore Project_0_can_t_be_built_because_its_dependency_1_was_not_built = {6383, DiagnosticCategory::Message, S("Project_0_can_t_be_built_because_its_dependency_1_was_not_built_6383"), S("Project '{0}' can't be built because its dependency '{1}' was not built")};
        static DiagnosticMessageStore Have_recompiles_in_incremental_and_watch_assume_that_changes_within_a_file_will_only_affect_files_directly_depending_on_it = {6384, DiagnosticCategory::Message, S("Have_recompiles_in_incremental_and_watch_assume_that_changes_within_a_file_will_only_affect_files_di_6384"), S("Have recompiles in '--incremental' and '--watch' assume that changes within a file will only affect files directly depending on it.")};
        static DiagnosticMessageStore _0_is_deprecated = {6385, DiagnosticCategory::Suggestion, S("_0_is_deprecated_6385"), S("'{0}' is deprecated")};
        static DiagnosticMessageStore Performance_timings_for_diagnostics_or_extendedDiagnostics_are_not_available_in_this_session_A_native_implementation_of_the_Web_Performance_API_could_not_be_found = {6386, DiagnosticCategory::Message, S("Performance_timings_for_diagnostics_or_extendedDiagnostics_are_not_available_in_this_session_A_nativ_6386"), S("Performance timings for '--diagnostics' or '--extendedDiagnostics' are not available in this session. A native implementation of the Web Performance API could not be found.")};
        static DiagnosticMessageStore The_expected_type_comes_from_property_0_which_is_declared_here_on_type_1 = {6500, DiagnosticCategory::Message, S("The_expected_type_comes_from_property_0_which_is_declared_here_on_type_1_6500"), S("The expected type comes from property '{0}' which is declared here on type '{1}'")};
        static DiagnosticMessageStore The_expected_type_comes_from_this_index_signature = {6501, DiagnosticCategory::Message, S("The_expected_type_comes_from_this_index_signature_6501"), S("The expected type comes from this index signature.")};
        static DiagnosticMessageStore The_expected_type_comes_from_the_return_type_of_this_signature = {6502, DiagnosticCategory::Message, S("The_expected_type_comes_from_the_return_type_of_this_signature_6502"), S("The expected type comes from the return type of this signature.")};
        static DiagnosticMessageStore Print_names_of_files_that_are_part_of_the_compilation_and_then_stop_processing = {6503, DiagnosticCategory::Message, S("Print_names_of_files_that_are_part_of_the_compilation_and_then_stop_processing_6503"), S("Print names of files that are part of the compilation and then stop processing.")};
        static DiagnosticMessageStore File_0_is_a_JavaScript_file_Did_you_mean_to_enable_the_allowJs_option = {6504, DiagnosticCategory::Error, S("File_0_is_a_JavaScript_file_Did_you_mean_to_enable_the_allowJs_option_6504"), S("File '{0}' is a JavaScript file. Did you mean to enable the 'allowJs' option?")};
        static DiagnosticMessageStore Print_names_of_files_and_the_reason_they_are_part_of_the_compilation = {6505, DiagnosticCategory::Message, S("Print_names_of_files_and_the_reason_they_are_part_of_the_compilation_6505"), S("Print names of files and the reason they are part of the compilation.")};
        static DiagnosticMessageStore Require_undeclared_properties_from_index_signatures_to_use_element_accesses = {6803, DiagnosticCategory::Error, S("Require_undeclared_properties_from_index_signatures_to_use_element_accesses_6803"), S("Require undeclared properties from index signatures to use element accesses.")};
        static DiagnosticMessageStore Include_undefined_in_index_signature_results = {6800, DiagnosticCategory::Message, S("Include_undefined_in_index_signature_results_6800"), S("Include 'undefined' in index signature results")};
        static DiagnosticMessageStore Variable_0_implicitly_has_an_1_type = {7005, DiagnosticCategory::Error, S("Variable_0_implicitly_has_an_1_type_7005"), S("Variable '{0}' implicitly has an '{1}' type.")};
        static DiagnosticMessageStore Parameter_0_implicitly_has_an_1_type = {7006, DiagnosticCategory::Error, S("Parameter_0_implicitly_has_an_1_type_7006"), S("Parameter '{0}' implicitly has an '{1}' type.")};
        static DiagnosticMessageStore Member_0_implicitly_has_an_1_type = {7008, DiagnosticCategory::Error, S("Member_0_implicitly_has_an_1_type_7008"), S("Member '{0}' implicitly has an '{1}' type.")};
        static DiagnosticMessageStore new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type = {7009, DiagnosticCategory::Error, S("new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type_7009"), S("'new' expression, whose target lacks a construct signature, implicitly has an 'any' type.")};
        static DiagnosticMessageStore _0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type = {7010, DiagnosticCategory::Error, S("_0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type_7010"), S("'{0}', which lacks return-type annotation, implicitly has an '{1}' return type.")};
        static DiagnosticMessageStore Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type = {7011, DiagnosticCategory::Error, S("Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type_7011"), S("Function expression, which lacks return-type annotation, implicitly has an '{0}' return type.")};
        static DiagnosticMessageStore Construct_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type = {7013, DiagnosticCategory::Error, S("Construct_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type_7013"), S("Construct signature, which lacks return-type annotation, implicitly has an 'any' return type.")};
        static DiagnosticMessageStore Function_type_which_lacks_return_type_annotation_implicitly_has_an_0_return_type = {7014, DiagnosticCategory::Error, S("Function_type_which_lacks_return_type_annotation_implicitly_has_an_0_return_type_7014"), S("Function type, which lacks return-type annotation, implicitly has an '{0}' return type.")};
        static DiagnosticMessageStore Element_implicitly_has_an_any_type_because_index_expression_is_not_of_type_number = {7015, DiagnosticCategory::Error, S("Element_implicitly_has_an_any_type_because_index_expression_is_not_of_type_number_7015"), S("Element implicitly has an 'any' type because index expression is not of type 'number'.")};
        static DiagnosticMessageStore Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type = {7016, DiagnosticCategory::Error, S("Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type_7016"), S("Could not find a declaration file for module '{0}'. '{1}' implicitly has an 'any' type.")};
        static DiagnosticMessageStore Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature = {7017, DiagnosticCategory::Error, S("Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature_7017"), S("Element implicitly has an 'any' type because type '{0}' has no index signature.")};
        static DiagnosticMessageStore Object_literal_s_property_0_implicitly_has_an_1_type = {7018, DiagnosticCategory::Error, S("Object_literal_s_property_0_implicitly_has_an_1_type_7018"), S("Object literal's property '{0}' implicitly has an '{1}' type.")};
        static DiagnosticMessageStore Rest_parameter_0_implicitly_has_an_any_type = {7019, DiagnosticCategory::Error, S("Rest_parameter_0_implicitly_has_an_any_type_7019"), S("Rest parameter '{0}' implicitly has an 'any[]' type.")};
        static DiagnosticMessageStore Call_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type = {7020, DiagnosticCategory::Error, S("Call_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type_7020"), S("Call signature, which lacks return-type annotation, implicitly has an 'any' return type.")};
        static DiagnosticMessageStore _0_implicitly_has_type_any_because_it_does_not_have_a_type_annotation_and_is_referenced_directly_or_indirectly_in_its_own_initializer = {7022, DiagnosticCategory::Error, S("_0_implicitly_has_type_any_because_it_does_not_have_a_type_annotation_and_is_referenced_directly_or__7022"), S("'{0}' implicitly has type 'any' because it does not have a type annotation and is referenced directly or indirectly in its own initializer.")};
        static DiagnosticMessageStore _0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions = {7023, DiagnosticCategory::Error, S("_0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_reference_7023"), S("'{0}' implicitly has return type 'any' because it does not have a return type annotation and is referenced directly or indirectly in one of its return expressions.")};
        static DiagnosticMessageStore Function_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions = {7024, DiagnosticCategory::Error, S("Function_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_ref_7024"), S("Function implicitly has return type 'any' because it does not have a return type annotation and is referenced directly or indirectly in one of its return expressions.")};
        static DiagnosticMessageStore Generator_implicitly_has_yield_type_0_because_it_does_not_yield_any_values_Consider_supplying_a_return_type_annotation = {7025, DiagnosticCategory::Error, S("Generator_implicitly_has_yield_type_0_because_it_does_not_yield_any_values_Consider_supplying_a_retu_7025"), S("Generator implicitly has yield type '{0}' because it does not yield any values. Consider supplying a return type annotation.")};
        static DiagnosticMessageStore JSX_element_implicitly_has_type_any_because_no_interface_JSX_0_exists = {7026, DiagnosticCategory::Error, S("JSX_element_implicitly_has_type_any_because_no_interface_JSX_0_exists_7026"), S("JSX element implicitly has type 'any' because no interface 'JSX.{0}' exists.")};
        static DiagnosticMessageStore Unreachable_code_detected = {7027, DiagnosticCategory::Error, S("Unreachable_code_detected_7027"), S("Unreachable code detected.")};
        static DiagnosticMessageStore Unused_label = {7028, DiagnosticCategory::Error, S("Unused_label_7028"), S("Unused label.")};
        static DiagnosticMessageStore Fallthrough_case_in_switch = {7029, DiagnosticCategory::Error, S("Fallthrough_case_in_switch_7029"), S("Fallthrough case in switch.")};
        static DiagnosticMessageStore Not_all_code_paths_return_a_value = {7030, DiagnosticCategory::Error, S("Not_all_code_paths_return_a_value_7030"), S("Not all code paths return a value.")};
        static DiagnosticMessageStore Binding_element_0_implicitly_has_an_1_type = {7031, DiagnosticCategory::Error, S("Binding_element_0_implicitly_has_an_1_type_7031"), S("Binding element '{0}' implicitly has an '{1}' type.")};
        static DiagnosticMessageStore Property_0_implicitly_has_type_any_because_its_set_accessor_lacks_a_parameter_type_annotation = {7032, DiagnosticCategory::Error, S("Property_0_implicitly_has_type_any_because_its_set_accessor_lacks_a_parameter_type_annotation_7032"), S("Property '{0}' implicitly has type 'any', because its set accessor lacks a parameter type annotation.")};
        static DiagnosticMessageStore Property_0_implicitly_has_type_any_because_its_get_accessor_lacks_a_return_type_annotation = {7033, DiagnosticCategory::Error, S("Property_0_implicitly_has_type_any_because_its_get_accessor_lacks_a_return_type_annotation_7033"), S("Property '{0}' implicitly has type 'any', because its get accessor lacks a return type annotation.")};
        static DiagnosticMessageStore Variable_0_implicitly_has_type_1_in_some_locations_where_its_type_cannot_be_determined = {7034, DiagnosticCategory::Error, S("Variable_0_implicitly_has_type_1_in_some_locations_where_its_type_cannot_be_determined_7034"), S("Variable '{0}' implicitly has type '{1}' in some locations where its type cannot be determined.")};
        static DiagnosticMessageStore Try_npm_i_save_dev_types_Slash_1_if_it_exists_or_add_a_new_declaration_d_ts_file_containing_declare_module_0 = {7035, DiagnosticCategory::Error, S("Try_npm_i_save_dev_types_Slash_1_if_it_exists_or_add_a_new_declaration_d_ts_file_containing_declare__7035"), S("Try `npm i --save-dev @types/{1}` if it exists or add a new declaration (.d.ts) file containing `declare module '{0}';`")};
        static DiagnosticMessageStore Dynamic_import_s_specifier_must_be_of_type_string_but_here_has_type_0 = {7036, DiagnosticCategory::Error, S("Dynamic_import_s_specifier_must_be_of_type_string_but_here_has_type_0_7036"), S("Dynamic import's specifier must be of type 'string', but here has type '{0}'.")};
        static DiagnosticMessageStore Enables_emit_interoperability_between_CommonJS_and_ES_Modules_via_creation_of_namespace_objects_for_all_imports_Implies_allowSyntheticDefaultImports = {7037, DiagnosticCategory::Message, S("Enables_emit_interoperability_between_CommonJS_and_ES_Modules_via_creation_of_namespace_objects_for__7037"), S("Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'.")};
        static DiagnosticMessageStore Type_originates_at_this_import_A_namespace_style_import_cannot_be_called_or_constructed_and_will_cause_a_failure_at_runtime_Consider_using_a_default_import_or_import_require_here_instead = {7038, DiagnosticCategory::Message, S("Type_originates_at_this_import_A_namespace_style_import_cannot_be_called_or_constructed_and_will_cau_7038"), S("Type originates at this import. A namespace-style import cannot be called or constructed, and will cause a failure at runtime. Consider using a default import or import require here instead.")};
        static DiagnosticMessageStore Mapped_object_type_implicitly_has_an_any_template_type = {7039, DiagnosticCategory::Error, S("Mapped_object_type_implicitly_has_an_any_template_type_7039"), S("Mapped object type implicitly has an 'any' template type.")};
        static DiagnosticMessageStore If_the_0_package_actually_exposes_this_module_consider_sending_a_pull_request_to_amend_https_Colon_Slash_Slashgithub_com_SlashDefinitelyTyped_SlashDefinitelyTyped_Slashtree_Slashmaster_Slashtypes_Slash_1 = {7040, DiagnosticCategory::Error, S("If_the_0_package_actually_exposes_this_module_consider_sending_a_pull_request_to_amend_https_Colon_S_7040"), S("If the '{0}' package actually exposes this module, consider sending a pull request to amend 'https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/{1}`")};
        static DiagnosticMessageStore The_containing_arrow_function_captures_the_global_value_of_this = {7041, DiagnosticCategory::Error, S("The_containing_arrow_function_captures_the_global_value_of_this_7041"), S("The containing arrow function captures the global value of 'this'.")};
        static DiagnosticMessageStore Module_0_was_resolved_to_1_but_resolveJsonModule_is_not_used = {7042, DiagnosticCategory::Error, S("Module_0_was_resolved_to_1_but_resolveJsonModule_is_not_used_7042"), S("Module '{0}' was resolved to '{1}', but '--resolveJsonModule' is not used.")};
        static DiagnosticMessageStore Variable_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage = {7043, DiagnosticCategory::Suggestion, S("Variable_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage_7043"), S("Variable '{0}' implicitly has an '{1}' type, but a better type may be inferred from usage.")};
        static DiagnosticMessageStore Parameter_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage = {7044, DiagnosticCategory::Suggestion, S("Parameter_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage_7044"), S("Parameter '{0}' implicitly has an '{1}' type, but a better type may be inferred from usage.")};
        static DiagnosticMessageStore Member_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage = {7045, DiagnosticCategory::Suggestion, S("Member_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage_7045"), S("Member '{0}' implicitly has an '{1}' type, but a better type may be inferred from usage.")};
        static DiagnosticMessageStore Variable_0_implicitly_has_type_1_in_some_locations_but_a_better_type_may_be_inferred_from_usage = {7046, DiagnosticCategory::Suggestion, S("Variable_0_implicitly_has_type_1_in_some_locations_but_a_better_type_may_be_inferred_from_usage_7046"), S("Variable '{0}' implicitly has type '{1}' in some locations, but a better type may be inferred from usage.")};
        static DiagnosticMessageStore Rest_parameter_0_implicitly_has_an_any_type_but_a_better_type_may_be_inferred_from_usage = {7047, DiagnosticCategory::Suggestion, S("Rest_parameter_0_implicitly_has_an_any_type_but_a_better_type_may_be_inferred_from_usage_7047"), S("Rest parameter '{0}' implicitly has an 'any[]' type, but a better type may be inferred from usage.")};
        static DiagnosticMessageStore Property_0_implicitly_has_type_any_but_a_better_type_for_its_get_accessor_may_be_inferred_from_usage = {7048, DiagnosticCategory::Suggestion, S("Property_0_implicitly_has_type_any_but_a_better_type_for_its_get_accessor_may_be_inferred_from_usage_7048"), S("Property '{0}' implicitly has type 'any', but a better type for its get accessor may be inferred from usage.")};
        static DiagnosticMessageStore Property_0_implicitly_has_type_any_but_a_better_type_for_its_set_accessor_may_be_inferred_from_usage = {7049, DiagnosticCategory::Suggestion, S("Property_0_implicitly_has_type_any_but_a_better_type_for_its_set_accessor_may_be_inferred_from_usage_7049"), S("Property '{0}' implicitly has type 'any', but a better type for its set accessor may be inferred from usage.")};
        static DiagnosticMessageStore _0_implicitly_has_an_1_return_type_but_a_better_type_may_be_inferred_from_usage = {7050, DiagnosticCategory::Suggestion, S("_0_implicitly_has_an_1_return_type_but_a_better_type_may_be_inferred_from_usage_7050"), S("'{0}' implicitly has an '{1}' return type, but a better type may be inferred from usage.")};
        static DiagnosticMessageStore Parameter_has_a_name_but_no_type_Did_you_mean_0_Colon_1 = {7051, DiagnosticCategory::Error, S("Parameter_has_a_name_but_no_type_Did_you_mean_0_Colon_1_7051"), S("Parameter has a name but no type. Did you mean '{0}: {1}'?")};
        static DiagnosticMessageStore Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature_Did_you_mean_to_call_1 = {7052, DiagnosticCategory::Error, S("Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature_Did_you_mean_to_call_1_7052"), S("Element implicitly has an 'any' type because type '{0}' has no index signature. Did you mean to call '{1}'?")};
        static DiagnosticMessageStore Element_implicitly_has_an_any_type_because_expression_of_type_0_can_t_be_used_to_index_type_1 = {7053, DiagnosticCategory::Error, S("Element_implicitly_has_an_any_type_because_expression_of_type_0_can_t_be_used_to_index_type_1_7053"), S("Element implicitly has an 'any' type because expression of type '{0}' can't be used to index type '{1}'.")};
        static DiagnosticMessageStore No_index_signature_with_a_parameter_of_type_0_was_found_on_type_1 = {7054, DiagnosticCategory::Error, S("No_index_signature_with_a_parameter_of_type_0_was_found_on_type_1_7054"), S("No index signature with a parameter of type '{0}' was found on type '{1}'.")};
        static DiagnosticMessageStore _0_which_lacks_return_type_annotation_implicitly_has_an_1_yield_type = {7055, DiagnosticCategory::Error, S("_0_which_lacks_return_type_annotation_implicitly_has_an_1_yield_type_7055"), S("'{0}', which lacks return-type annotation, implicitly has an '{1}' yield type.")};
        static DiagnosticMessageStore The_inferred_type_of_this_node_exceeds_the_maximum_length_the_compiler_will_serialize_An_explicit_type_annotation_is_needed = {7056, DiagnosticCategory::Error, S("The_inferred_type_of_this_node_exceeds_the_maximum_length_the_compiler_will_serialize_An_explicit_ty_7056"), S("The inferred type of this node exceeds the maximum length the compiler will serialize. An explicit type annotation is needed.")};
        static DiagnosticMessageStore yield_expression_implicitly_results_in_an_any_type_because_its_containing_generator_lacks_a_return_type_annotation = {7057, DiagnosticCategory::Error, S("yield_expression_implicitly_results_in_an_any_type_because_its_containing_generator_lacks_a_return_t_7057"), S("'yield' expression implicitly results in an 'any' type because its containing generator lacks a return-type annotation.")};
        static DiagnosticMessageStore You_cannot_rename_this_element = {8000, DiagnosticCategory::Error, S("You_cannot_rename_this_element_8000"), S("You cannot rename this element.")};
        static DiagnosticMessageStore You_cannot_rename_elements_that_are_defined_in_the_standard_TypeScript_library = {8001, DiagnosticCategory::Error, S("You_cannot_rename_elements_that_are_defined_in_the_standard_TypeScript_library_8001"), S("You cannot rename elements that are defined in the standard TypeScript library.")};
        static DiagnosticMessageStore import_can_only_be_used_in_TypeScript_files = {8002, DiagnosticCategory::Error, S("import_can_only_be_used_in_TypeScript_files_8002"), S("'import ... =' can only be used in TypeScript files.")};
        static DiagnosticMessageStore export_can_only_be_used_in_TypeScript_files = {8003, DiagnosticCategory::Error, S("export_can_only_be_used_in_TypeScript_files_8003"), S("'export =' can only be used in TypeScript files.")};
        static DiagnosticMessageStore Type_parameter_declarations_can_only_be_used_in_TypeScript_files = {8004, DiagnosticCategory::Error, S("Type_parameter_declarations_can_only_be_used_in_TypeScript_files_8004"), S("Type parameter declarations can only be used in TypeScript files.")};
        static DiagnosticMessageStore implements_clauses_can_only_be_used_in_TypeScript_files = {8005, DiagnosticCategory::Error, S("implements_clauses_can_only_be_used_in_TypeScript_files_8005"), S("'implements' clauses can only be used in TypeScript files.")};
        static DiagnosticMessageStore _0_declarations_can_only_be_used_in_TypeScript_files = {8006, DiagnosticCategory::Error, S("_0_declarations_can_only_be_used_in_TypeScript_files_8006"), S("'{0}' declarations can only be used in TypeScript files.")};
        static DiagnosticMessageStore Type_aliases_can_only_be_used_in_TypeScript_files = {8008, DiagnosticCategory::Error, S("Type_aliases_can_only_be_used_in_TypeScript_files_8008"), S("Type aliases can only be used in TypeScript files.")};
        static DiagnosticMessageStore The_0_modifier_can_only_be_used_in_TypeScript_files = {8009, DiagnosticCategory::Error, S("The_0_modifier_can_only_be_used_in_TypeScript_files_8009"), S("The '{0}' modifier can only be used in TypeScript files.")};
        static DiagnosticMessageStore Type_annotations_can_only_be_used_in_TypeScript_files = {8010, DiagnosticCategory::Error, S("Type_annotations_can_only_be_used_in_TypeScript_files_8010"), S("Type annotations can only be used in TypeScript files.")};
        static DiagnosticMessageStore Type_arguments_can_only_be_used_in_TypeScript_files = {8011, DiagnosticCategory::Error, S("Type_arguments_can_only_be_used_in_TypeScript_files_8011"), S("Type arguments can only be used in TypeScript files.")};
        static DiagnosticMessageStore Parameter_modifiers_can_only_be_used_in_TypeScript_files = {8012, DiagnosticCategory::Error, S("Parameter_modifiers_can_only_be_used_in_TypeScript_files_8012"), S("Parameter modifiers can only be used in TypeScript files.")};
        static DiagnosticMessageStore Non_null_assertions_can_only_be_used_in_TypeScript_files = {8013, DiagnosticCategory::Error, S("Non_null_assertions_can_only_be_used_in_TypeScript_files_8013"), S("Non-null assertions can only be used in TypeScript files.")};
        static DiagnosticMessageStore Type_assertion_expressions_can_only_be_used_in_TypeScript_files = {8016, DiagnosticCategory::Error, S("Type_assertion_expressions_can_only_be_used_in_TypeScript_files_8016"), S("Type assertion expressions can only be used in TypeScript files.")};
        static DiagnosticMessageStore Octal_literal_types_must_use_ES2015_syntax_Use_the_syntax_0 = {8017, DiagnosticCategory::Error, S("Octal_literal_types_must_use_ES2015_syntax_Use_the_syntax_0_8017"), S("Octal literal types must use ES2015 syntax. Use the syntax '{0}'.")};
        static DiagnosticMessageStore Octal_literals_are_not_allowed_in_enums_members_initializer_Use_the_syntax_0 = {8018, DiagnosticCategory::Error, S("Octal_literals_are_not_allowed_in_enums_members_initializer_Use_the_syntax_0_8018"), S("Octal literals are not allowed in enums members initializer. Use the syntax '{0}'.")};
        static DiagnosticMessageStore Octal_literals_are_not_allowed_Use_the_syntax_0 = {8018, DiagnosticCategory::Error, S("Octal_literals_are_not_allowed_Use_the_syntax_0_1121"), S("Octal literals are not allowed. Use the syntax '{0}'.")};
        static DiagnosticMessageStore Report_errors_in_js_files = {8019, DiagnosticCategory::Message, S("Report_errors_in_js_files_8019"), S("Report errors in .js files.")};
        static DiagnosticMessageStore JSDoc_types_can_only_be_used_inside_documentation_comments = {8020, DiagnosticCategory::Error, S("JSDoc_types_can_only_be_used_inside_documentation_comments_8020"), S("JSDoc types can only be used inside documentation comments.")};
        static DiagnosticMessageStore JSDoc_typedef_tag_should_either_have_a_type_annotation_or_be_followed_by_property_or_member_tags = {8021, DiagnosticCategory::Error, S("JSDoc_typedef_tag_should_either_have_a_type_annotation_or_be_followed_by_property_or_member_tags_8021"), S("JSDoc '@typedef' tag should either have a type annotation or be followed by '@property' or '@member' tags.")};
        static DiagnosticMessageStore JSDoc_0_is_not_attached_to_a_class = {8022, DiagnosticCategory::Error, S("JSDoc_0_is_not_attached_to_a_class_8022"), S("JSDoc '@{0}' is not attached to a class.")};
        static DiagnosticMessageStore JSDoc_0_1_does_not_match_the_extends_2_clause = {8023, DiagnosticCategory::Error, S("JSDoc_0_1_does_not_match_the_extends_2_clause_8023"), S("JSDoc '@{0} {1}' does not match the 'extends {2}' clause.")};
        static DiagnosticMessageStore JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name = {8024, DiagnosticCategory::Error, S("JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name_8024"), S("JSDoc '@param' tag has name '{0}', but there is no parameter with that name.")};
        static DiagnosticMessageStore Class_declarations_cannot_have_more_than_one_augments_or_extends_tag = {8025, DiagnosticCategory::Error, S("Class_declarations_cannot_have_more_than_one_augments_or_extends_tag_8025"), S("Class declarations cannot have more than one `@augments` or `@extends` tag.")};
        static DiagnosticMessageStore Expected_0_type_arguments_provide_these_with_an_extends_tag = {8026, DiagnosticCategory::Error, S("Expected_0_type_arguments_provide_these_with_an_extends_tag_8026"), S("Expected {0} type arguments; provide these with an '@extends' tag.")};
        static DiagnosticMessageStore Expected_0_1_type_arguments_provide_these_with_an_extends_tag = {8027, DiagnosticCategory::Error, S("Expected_0_1_type_arguments_provide_these_with_an_extends_tag_8027"), S("Expected {0}-{1} type arguments; provide these with an '@extends' tag.")};
        static DiagnosticMessageStore JSDoc_may_only_appear_in_the_last_parameter_of_a_signature = {8028, DiagnosticCategory::Error, S("JSDoc_may_only_appear_in_the_last_parameter_of_a_signature_8028"), S("JSDoc '...' may only appear in the last parameter of a signature.")};
        static DiagnosticMessageStore JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name_It_would_match_arguments_if_it_had_an_array_type = {8029, DiagnosticCategory::Error, S("JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name_It_would_match_arguments_if_it_h_8029"), S("JSDoc '@param' tag has name '{0}', but there is no parameter with that name. It would match 'arguments' if it had an array type.")};
        static DiagnosticMessageStore The_type_of_a_function_declaration_must_match_the_function_s_signature = {8030, DiagnosticCategory::Error, S("The_type_of_a_function_declaration_must_match_the_function_s_signature_8030"), S("The type of a function declaration must match the function's signature.")};
        static DiagnosticMessageStore You_cannot_rename_a_module_via_a_global_import = {8031, DiagnosticCategory::Error, S("You_cannot_rename_a_module_via_a_global_import_8031"), S("You cannot rename a module via a global import.")};
        static DiagnosticMessageStore Qualified_name_0_is_not_allowed_without_a_leading_param_object_1 = {8032, DiagnosticCategory::Error, S("Qualified_name_0_is_not_allowed_without_a_leading_param_object_1_8032"), S("Qualified name '{0}' is not allowed without a leading '@param {object} {1}'.")};
        static DiagnosticMessageStore A_JSDoc_typedef_comment_may_not_contain_multiple_type_tags = {8033, DiagnosticCategory::Error, S("A_JSDoc_typedef_comment_may_not_contain_multiple_type_tags_8033"), S("A JSDoc '@typedef' comment may not contain multiple '@type' tags.")};
        static DiagnosticMessageStore The_tag_was_first_specified_here = {8034, DiagnosticCategory::Error, S("The_tag_was_first_specified_here_8034"), S("The tag was first specified here.")};
        static DiagnosticMessageStore Only_identifiers_Slashqualified_names_with_optional_type_arguments_are_currently_supported_in_a_class_extends_clause = {9002, DiagnosticCategory::Error, S("Only_identifiers_Slashqualified_names_with_optional_type_arguments_are_currently_supported_in_a_clas_9002"), S("Only identifiers/qualified-names with optional type arguments are currently supported in a class 'extends' clause.")};
        static DiagnosticMessageStore class_expressions_are_not_currently_supported = {9003, DiagnosticCategory::Error, S("class_expressions_are_not_currently_supported_9003"), S("'class' expressions are not currently supported.")};
        static DiagnosticMessageStore Language_service_is_disabled = {9004, DiagnosticCategory::Error, S("Language_service_is_disabled_9004"), S("Language service is disabled.")};
        static DiagnosticMessageStore Declaration_emit_for_this_file_requires_using_private_name_0_An_explicit_type_annotation_may_unblock_declaration_emit = {9005, DiagnosticCategory::Error, S("Declaration_emit_for_this_file_requires_using_private_name_0_An_explicit_type_annotation_may_unblock_9005"), S("Declaration emit for this file requires using private name '{0}'. An explicit type annotation may unblock declaration emit.")};
        static DiagnosticMessageStore Declaration_emit_for_this_file_requires_using_private_name_0_from_module_1_An_explicit_type_annotation_may_unblock_declaration_emit = {9006, DiagnosticCategory::Error, S("Declaration_emit_for_this_file_requires_using_private_name_0_from_module_1_An_explicit_type_annotati_9006"), S("Declaration emit for this file requires using private name '{0}' from module '{1}'. An explicit type annotation may unblock declaration emit.")};
        static DiagnosticMessageStore JSX_attributes_must_only_be_assigned_a_non_empty_expression = {17000, DiagnosticCategory::Error, S("JSX_attributes_must_only_be_assigned_a_non_empty_expression_17000"), S("JSX attributes must only be assigned a non-empty 'expression'.")};
        static DiagnosticMessageStore JSX_elements_cannot_have_multiple_attributes_with_the_same_name = {17001, DiagnosticCategory::Error, S("JSX_elements_cannot_have_multiple_attributes_with_the_same_name_17001"), S("JSX elements cannot have multiple attributes with the same name.")};
        static DiagnosticMessageStore Expected_corresponding_JSX_closing_tag_for_0 = {17002, DiagnosticCategory::Error, S("Expected_corresponding_JSX_closing_tag_for_0_17002"), S("Expected corresponding JSX closing tag for '{0}'.")};
        static DiagnosticMessageStore JSX_attribute_expected = {17003, DiagnosticCategory::Error, S("JSX_attribute_expected_17003"), S("JSX attribute expected.")};
        static DiagnosticMessageStore Cannot_use_JSX_unless_the_jsx_flag_is_provided = {17004, DiagnosticCategory::Error, S("Cannot_use_JSX_unless_the_jsx_flag_is_provided_17004"), S("Cannot use JSX unless the '--jsx' flag is provided.")};
        static DiagnosticMessageStore A_constructor_cannot_contain_a_super_call_when_its_class_extends_null = {17005, DiagnosticCategory::Error, S("A_constructor_cannot_contain_a_super_call_when_its_class_extends_null_17005"), S("A constructor cannot contain a 'super' call when its class extends 'null'.")};
        static DiagnosticMessageStore An_unary_expression_with_the_0_operator_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_Consider_enclosing_the_expression_in_parentheses = {17006, DiagnosticCategory::Error, S("An_unary_expression_with_the_0_operator_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_ex_17006"), S("An unary expression with the '{0}' operator is not allowed in the left-hand side of an exponentiation expression. Consider enclosing the expression in parentheses.")};
        static DiagnosticMessageStore A_type_assertion_expression_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_Consider_enclosing_the_expression_in_parentheses = {17007, DiagnosticCategory::Error, S("A_type_assertion_expression_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_Con_17007"), S("A type assertion expression is not allowed in the left-hand side of an exponentiation expression. Consider enclosing the expression in parentheses.")};
        static DiagnosticMessageStore JSX_element_0_has_no_corresponding_closing_tag = {17008, DiagnosticCategory::Error, S("JSX_element_0_has_no_corresponding_closing_tag_17008"), S("JSX element '{0}' has no corresponding closing tag.")};
        static DiagnosticMessageStore super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class = {17009, DiagnosticCategory::Error, S("super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class_17009"), S("'super' must be called before accessing 'this' in the constructor of a derived class.")};
        static DiagnosticMessageStore Unknown_type_acquisition_option_0 = {17010, DiagnosticCategory::Error, S("Unknown_type_acquisition_option_0_17010"), S("Unknown type acquisition option '{0}'.")};
        static DiagnosticMessageStore super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class = {17011, DiagnosticCategory::Error, S("super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class_17011"), S("'super' must be called before accessing a property of 'super' in the constructor of a derived class.")};
        static DiagnosticMessageStore _0_is_not_a_valid_meta_property_for_keyword_1_Did_you_mean_2 = {17012, DiagnosticCategory::Error, S("_0_is_not_a_valid_meta_property_for_keyword_1_Did_you_mean_2_17012"), S("'{0}' is not a valid meta-property for keyword '{1}'. Did you mean '{2}'?")};
        static DiagnosticMessageStore Meta_property_0_is_only_allowed_in_the_body_of_a_function_declaration_function_expression_or_constructor = {17013, DiagnosticCategory::Error, S("Meta_property_0_is_only_allowed_in_the_body_of_a_function_declaration_function_expression_or_constru_17013"), S("Meta-property '{0}' is only allowed in the body of a function declaration, function expression, or constructor.")};
        static DiagnosticMessageStore JSX_fragment_has_no_corresponding_closing_tag = {17014, DiagnosticCategory::Error, S("JSX_fragment_has_no_corresponding_closing_tag_17014"), S("JSX fragment has no corresponding closing tag.")};
        static DiagnosticMessageStore Expected_corresponding_closing_tag_for_JSX_fragment = {17015, DiagnosticCategory::Error, S("Expected_corresponding_closing_tag_for_JSX_fragment_17015"), S("Expected corresponding closing tag for JSX fragment.")};
        static DiagnosticMessageStore The_jsxFragmentFactory_compiler_option_must_be_provided_to_use_JSX_fragments_with_the_jsxFactory_compiler_option = {17016, DiagnosticCategory::Error, S("The_jsxFragmentFactory_compiler_option_must_be_provided_to_use_JSX_fragments_with_the_jsxFactory_com_17016"), S("The 'jsxFragmentFactory' compiler option must be provided to use JSX fragments with the 'jsxFactory' compiler option.")};
        static DiagnosticMessageStore An_jsxFrag_pragma_is_required_when_using_an_jsx_pragma_with_JSX_fragments = {17017, DiagnosticCategory::Error, S("An_jsxFrag_pragma_is_required_when_using_an_jsx_pragma_with_JSX_fragments_17017"), S("An @jsxFrag pragma is required when using an @jsx pragma with JSX fragments.")};
        static DiagnosticMessageStore Unknown_type_acquisition_option_0_Did_you_mean_1 = {17018, DiagnosticCategory::Error, S("Unknown_type_acquisition_option_0_Did_you_mean_1_17018"), S("Unknown type acquisition option '{0}'. Did you mean '{1}'?")};
        static DiagnosticMessageStore Circularity_detected_while_resolving_configuration_Colon_0 = {18000, DiagnosticCategory::Error, S("Circularity_detected_while_resolving_configuration_Colon_0_18000"), S("Circularity detected while resolving configuration: {0}")};
        static DiagnosticMessageStore A_path_in_an_extends_option_must_be_relative_or_rooted_but_0_is_not = {18001, DiagnosticCategory::Error, S("A_path_in_an_extends_option_must_be_relative_or_rooted_but_0_is_not_18001"), S("A path in an 'extends' option must be relative or rooted, but '{0}' is not.")};
        static DiagnosticMessageStore The_files_list_in_config_file_0_is_empty = {18002, DiagnosticCategory::Error, S("The_files_list_in_config_file_0_is_empty_18002"), S("The 'files' list in config file '{0}' is empty.")};
        static DiagnosticMessageStore No_inputs_were_found_in_config_file_0_Specified_include_paths_were_1_and_exclude_paths_were_2 = {18003, DiagnosticCategory::Error, S("No_inputs_were_found_in_config_file_0_Specified_include_paths_were_1_and_exclude_paths_were_2_18003"), S("No inputs were found in config file '{0}'. Specified 'include' paths were '{1}' and 'exclude' paths were '{2}'.")};
        static DiagnosticMessageStore File_is_a_CommonJS_module_it_may_be_converted_to_an_ES6_module = {80001, DiagnosticCategory::Suggestion, S("File_is_a_CommonJS_module_it_may_be_converted_to_an_ES6_module_80001"), S("File is a CommonJS module; it may be converted to an ES6 module.")};
        static DiagnosticMessageStore This_constructor_function_may_be_converted_to_a_class_declaration = {80002, DiagnosticCategory::Suggestion, S("This_constructor_function_may_be_converted_to_a_class_declaration_80002"), S("This constructor function may be converted to a class declaration.")};
        static DiagnosticMessageStore Import_may_be_converted_to_a_default_import = {80003, DiagnosticCategory::Suggestion, S("Import_may_be_converted_to_a_default_import_80003"), S("Import may be converted to a default import.")};
        static DiagnosticMessageStore JSDoc_types_may_be_moved_to_TypeScript_types = {80004, DiagnosticCategory::Suggestion, S("JSDoc_types_may_be_moved_to_TypeScript_types_80004"), S("JSDoc types may be moved to TypeScript types.")};
        static DiagnosticMessageStore require_call_may_be_converted_to_an_import = {80005, DiagnosticCategory::Suggestion, S("require_call_may_be_converted_to_an_import_80005"), S("'require' call may be converted to an import.")};
        static DiagnosticMessageStore This_may_be_converted_to_an_async_function = {80006, DiagnosticCategory::Suggestion, S("This_may_be_converted_to_an_async_function_80006"), S("This may be converted to an async function.")};
        static DiagnosticMessageStore await_has_no_effect_on_the_type_of_this_expression = {80007, DiagnosticCategory::Suggestion, S("await_has_no_effect_on_the_type_of_this_expression_80007"), S("'await' has no effect on the type of this expression.")};
        static DiagnosticMessageStore Numeric_literals_with_absolute_values_equal_to_2_53_or_greater_are_too_large_to_be_represented_accurately_as_integers = {80008, DiagnosticCategory::Suggestion, S("Numeric_literals_with_absolute_values_equal_to_2_53_or_greater_are_too_large_to_be_represented_accur_80008"), S("Numeric literals with absolute values equal to 2^53 or greater are too large to be represented accurately as integers.")};
        static DiagnosticMessageStore Add_missing_super_call = {90001, DiagnosticCategory::Message, S("Add_missing_super_call_90001"), S("Add missing 'super()' call")};
        static DiagnosticMessageStore Make_super_call_the_first_statement_in_the_constructor = {90002, DiagnosticCategory::Message, S("Make_super_call_the_first_statement_in_the_constructor_90002"), S("Make 'super()' call the first statement in the constructor")};
        static DiagnosticMessageStore Change_extends_to_implements = {90003, DiagnosticCategory::Message, S("Change_extends_to_implements_90003"), S("Change 'extends' to 'implements'")};
        static DiagnosticMessageStore Remove_unused_declaration_for_Colon_0 = {90004, DiagnosticCategory::Message, S("Remove_unused_declaration_for_Colon_0_90004"), S("Remove unused declaration for: '{0}'")};
        static DiagnosticMessageStore Remove_import_from_0 = {90005, DiagnosticCategory::Message, S("Remove_import_from_0_90005"), S("Remove import from '{0}'")};
        static DiagnosticMessageStore Implement_interface_0 = {90006, DiagnosticCategory::Message, S("Implement_interface_0_90006"), S("Implement interface '{0}'")};
        static DiagnosticMessageStore Implement_inherited_abstract_class = {90007, DiagnosticCategory::Message, S("Implement_inherited_abstract_class_90007"), S("Implement inherited abstract class")};
        static DiagnosticMessageStore Add_0_to_unresolved_variable = {90008, DiagnosticCategory::Message, S("Add_0_to_unresolved_variable_90008"), S("Add '{0}.' to unresolved variable")};
        static DiagnosticMessageStore Remove_variable_statement = {90010, DiagnosticCategory::Message, S("Remove_variable_statement_90010"), S("Remove variable statement")};
        static DiagnosticMessageStore Remove_template_tag = {90011, DiagnosticCategory::Message, S("Remove_template_tag_90011"), S("Remove template tag")};
        static DiagnosticMessageStore Remove_type_parameters = {90012, DiagnosticCategory::Message, S("Remove_type_parameters_90012"), S("Remove type parameters")};
        static DiagnosticMessageStore Import_0_from_module_1 = {90013, DiagnosticCategory::Message, S("Import_0_from_module_1_90013"), S("Import '{0}' from module \"){1}\"")};
        static DiagnosticMessageStore Change_0_to_1 = {90014, DiagnosticCategory::Message, S("Change_0_to_1_90014"), S("Change '{0}' to '{1}'")};
        static DiagnosticMessageStore Add_0_to_existing_import_declaration_from_1 = {90015, DiagnosticCategory::Message, S("Add_0_to_existing_import_declaration_from_1_90015"), S("Add '{0}' to existing import declaration from \"){1}\"")};
        static DiagnosticMessageStore Declare_property_0 = {90016, DiagnosticCategory::Message, S("Declare_property_0_90016"), S("Declare property '{0}'")};
        static DiagnosticMessageStore Add_index_signature_for_property_0 = {90017, DiagnosticCategory::Message, S("Add_index_signature_for_property_0_90017"), S("Add index signature for property '{0}'")};
        static DiagnosticMessageStore Disable_checking_for_this_file = {90018, DiagnosticCategory::Message, S("Disable_checking_for_this_file_90018"), S("Disable checking for this file")};
        static DiagnosticMessageStore Ignore_this_error_message = {90019, DiagnosticCategory::Message, S("Ignore_this_error_message_90019"), S("Ignore this error message")};
        static DiagnosticMessageStore Initialize_property_0_in_the_constructor = {90020, DiagnosticCategory::Message, S("Initialize_property_0_in_the_constructor_90020"), S("Initialize property '{0}' in the constructor")};
        static DiagnosticMessageStore Initialize_static_property_0 = {90021, DiagnosticCategory::Message, S("Initialize_static_property_0_90021"), S("Initialize static property '{0}'")};
        static DiagnosticMessageStore Change_spelling_to_0 = {90022, DiagnosticCategory::Message, S("Change_spelling_to_0_90022"), S("Change spelling to '{0}'")};
        static DiagnosticMessageStore Declare_method_0 = {90023, DiagnosticCategory::Message, S("Declare_method_0_90023"), S("Declare method '{0}'")};
        static DiagnosticMessageStore Declare_static_method_0 = {90024, DiagnosticCategory::Message, S("Declare_static_method_0_90024"), S("Declare static method '{0}'")};
        static DiagnosticMessageStore Prefix_0_with_an_underscore = {90025, DiagnosticCategory::Message, S("Prefix_0_with_an_underscore_90025"), S("Prefix '{0}' with an underscore")};
        static DiagnosticMessageStore Rewrite_as_the_indexed_access_type_0 = {90026, DiagnosticCategory::Message, S("Rewrite_as_the_indexed_access_type_0_90026"), S("Rewrite as the indexed access type '{0}'")};
        static DiagnosticMessageStore Declare_static_property_0 = {90027, DiagnosticCategory::Message, S("Declare_static_property_0_90027"), S("Declare static property '{0}'")};
        static DiagnosticMessageStore Call_decorator_expression = {90028, DiagnosticCategory::Message, S("Call_decorator_expression_90028"), S("Call decorator expression")};
        static DiagnosticMessageStore Add_async_modifier_to_containing_function = {90029, DiagnosticCategory::Message, S("Add_async_modifier_to_containing_function_90029"), S("Add async modifier to containing function")};
        static DiagnosticMessageStore Replace_infer_0_with_unknown = {90030, DiagnosticCategory::Message, S("Replace_infer_0_with_unknown_90030"), S("Replace 'infer {0}' with 'unknown'")};
        static DiagnosticMessageStore Replace_all_unused_infer_with_unknown = {90031, DiagnosticCategory::Message, S("Replace_all_unused_infer_with_unknown_90031"), S("Replace all unused 'infer' with 'unknown'")};
        static DiagnosticMessageStore Import_default_0_from_module_1 = {90032, DiagnosticCategory::Message, S("Import_default_0_from_module_1_90032"), S("Import default '{0}' from module \"){1}\"")};
        static DiagnosticMessageStore Add_default_import_0_to_existing_import_declaration_from_1 = {90033, DiagnosticCategory::Message, S("Add_default_import_0_to_existing_import_declaration_from_1_90033"), S("Add default import '{0}' to existing import declaration from \"){1}\"")};
        static DiagnosticMessageStore Add_parameter_name = {90034, DiagnosticCategory::Message, S("Add_parameter_name_90034"), S("Add parameter name")};
        static DiagnosticMessageStore Declare_private_property_0 = {90035, DiagnosticCategory::Message, S("Declare_private_property_0_90035"), S("Declare private property '{0}'")};
        static DiagnosticMessageStore Replace_0_with_Promise_1 = {90036, DiagnosticCategory::Message, S("Replace_0_with_Promise_1_90036"), S("Replace '{0}' with 'Promise<{1}>'")};
        static DiagnosticMessageStore Fix_all_incorrect_return_type_of_an_async_functions = {90037, DiagnosticCategory::Message, S("Fix_all_incorrect_return_type_of_an_async_functions_90037"), S("Fix all incorrect return type of an async functions")};
        static DiagnosticMessageStore Declare_private_method_0 = {90038, DiagnosticCategory::Message, S("Declare_private_method_0_90038"), S("Declare private method '{0}'")};
        static DiagnosticMessageStore Remove_unused_destructuring_declaration = {90039, DiagnosticCategory::Message, S("Remove_unused_destructuring_declaration_90039"), S("Remove unused destructuring declaration")};
        static DiagnosticMessageStore Remove_unused_declarations_for_Colon_0 = {90041, DiagnosticCategory::Message, S("Remove_unused_declarations_for_Colon_0_90041"), S("Remove unused declarations for: '{0}'")};
        static DiagnosticMessageStore Declare_a_private_field_named_0 = {90053, DiagnosticCategory::Message, S("Declare_a_private_field_named_0_90053"), S("Declare a private field named '{0}'.")};
        static DiagnosticMessageStore Convert_function_to_an_ES2015_class = {95001, DiagnosticCategory::Message, S("Convert_function_to_an_ES2015_class_95001"), S("Convert function to an ES2015 class")};
        static DiagnosticMessageStore Convert_function_0_to_class = {95002, DiagnosticCategory::Message, S("Convert_function_0_to_class_95002"), S("Convert function '{0}' to class")};
        static DiagnosticMessageStore Convert_0_to_1_in_0 = {95003, DiagnosticCategory::Message, S("Convert_0_to_1_in_0_95003"), S("Convert '{0}' to '{1} in {0}'")};
        static DiagnosticMessageStore Extract_to_0_in_1 = {95004, DiagnosticCategory::Message, S("Extract_to_0_in_1_95004"), S("Extract to {0} in {1}")};
        static DiagnosticMessageStore Extract_function = {95005, DiagnosticCategory::Message, S("Extract_function_95005"), S("Extract function")};
        static DiagnosticMessageStore Extract_constant = {95006, DiagnosticCategory::Message, S("Extract_constant_95006"), S("Extract constant")};
        static DiagnosticMessageStore Extract_to_0_in_enclosing_scope = {95007, DiagnosticCategory::Message, S("Extract_to_0_in_enclosing_scope_95007"), S("Extract to {0} in enclosing scope")};
        static DiagnosticMessageStore Extract_to_0_in_1_scope = {95008, DiagnosticCategory::Message, S("Extract_to_0_in_1_scope_95008"), S("Extract to {0} in {1} scope")};
        static DiagnosticMessageStore Annotate_with_type_from_JSDoc = {95009, DiagnosticCategory::Message, S("Annotate_with_type_from_JSDoc_95009"), S("Annotate with type from JSDoc")};
        static DiagnosticMessageStore Annotate_with_types_from_JSDoc = {95010, DiagnosticCategory::Message, S("Annotate_with_types_from_JSDoc_95010"), S("Annotate with types from JSDoc")};
        static DiagnosticMessageStore Infer_type_of_0_from_usage = {95011, DiagnosticCategory::Message, S("Infer_type_of_0_from_usage_95011"), S("Infer type of '{0}' from usage")};
        static DiagnosticMessageStore Infer_parameter_types_from_usage = {95012, DiagnosticCategory::Message, S("Infer_parameter_types_from_usage_95012"), S("Infer parameter types from usage")};
        static DiagnosticMessageStore Convert_to_default_import = {95013, DiagnosticCategory::Message, S("Convert_to_default_import_95013"), S("Convert to default import")};
        static DiagnosticMessageStore Install_0 = {95014, DiagnosticCategory::Message, S("Install_0_95014"), S("Install '{0}'")};
        static DiagnosticMessageStore Replace_import_with_0 = {95015, DiagnosticCategory::Message, S("Replace_import_with_0_95015"), S("Replace import with '{0}'.")};
        static DiagnosticMessageStore Use_synthetic_default_member = {95016, DiagnosticCategory::Message, S("Use_synthetic_default_member_95016"), S("Use synthetic 'default' member.")};
        static DiagnosticMessageStore Convert_to_ES6_module = {95017, DiagnosticCategory::Message, S("Convert_to_ES6_module_95017"), S("Convert to ES6 module")};
        static DiagnosticMessageStore Add_undefined_type_to_property_0 = {95018, DiagnosticCategory::Message, S("Add_undefined_type_to_property_0_95018"), S("Add 'undefined' type to property '{0}'")};
        static DiagnosticMessageStore Add_initializer_to_property_0 = {95019, DiagnosticCategory::Message, S("Add_initializer_to_property_0_95019"), S("Add initializer to property '{0}'")};
        static DiagnosticMessageStore Add_definite_assignment_assertion_to_property_0 = {95020, DiagnosticCategory::Message, S("Add_definite_assignment_assertion_to_property_0_95020"), S("Add definite assignment assertion to property '{0}'")};
        static DiagnosticMessageStore Convert_all_type_literals_to_mapped_type = {95021, DiagnosticCategory::Message, S("Convert_all_type_literals_to_mapped_type_95021"), S("Convert all type literals to mapped type")};
        static DiagnosticMessageStore Add_all_missing_members = {95022, DiagnosticCategory::Message, S("Add_all_missing_members_95022"), S("Add all missing members")};
        static DiagnosticMessageStore Infer_all_types_from_usage = {95023, DiagnosticCategory::Message, S("Infer_all_types_from_usage_95023"), S("Infer all types from usage")};
        static DiagnosticMessageStore Delete_all_unused_declarations = {95024, DiagnosticCategory::Message, S("Delete_all_unused_declarations_95024"), S("Delete all unused declarations")};
        static DiagnosticMessageStore Prefix_all_unused_declarations_with_where_possible = {95025, DiagnosticCategory::Message, S("Prefix_all_unused_declarations_with_where_possible_95025"), S("Prefix all unused declarations with '_' where possible")};
        static DiagnosticMessageStore Fix_all_detected_spelling_errors = {95026, DiagnosticCategory::Message, S("Fix_all_detected_spelling_errors_95026"), S("Fix all detected spelling errors")};
        static DiagnosticMessageStore Add_initializers_to_all_uninitialized_properties = {95027, DiagnosticCategory::Message, S("Add_initializers_to_all_uninitialized_properties_95027"), S("Add initializers to all uninitialized properties")};
        static DiagnosticMessageStore Add_definite_assignment_assertions_to_all_uninitialized_properties = {95028, DiagnosticCategory::Message, S("Add_definite_assignment_assertions_to_all_uninitialized_properties_95028"), S("Add definite assignment assertions to all uninitialized properties")};
        static DiagnosticMessageStore Add_undefined_type_to_all_uninitialized_properties = {95029, DiagnosticCategory::Message, S("Add_undefined_type_to_all_uninitialized_properties_95029"), S("Add undefined type to all uninitialized properties")};
        static DiagnosticMessageStore Change_all_jsdoc_style_types_to_TypeScript = {95030, DiagnosticCategory::Message, S("Change_all_jsdoc_style_types_to_TypeScript_95030"), S("Change all jsdoc-style types to TypeScript")};
        static DiagnosticMessageStore Change_all_jsdoc_style_types_to_TypeScript_and_add_undefined_to_nullable_types = {95031, DiagnosticCategory::Message, S("Change_all_jsdoc_style_types_to_TypeScript_and_add_undefined_to_nullable_types_95031"), S("Change all jsdoc-style types to TypeScript (and add '| undefined' to nullable types)")};
        static DiagnosticMessageStore Implement_all_unimplemented_interfaces = {95032, DiagnosticCategory::Message, S("Implement_all_unimplemented_interfaces_95032"), S("Implement all unimplemented interfaces")};
        static DiagnosticMessageStore Install_all_missing_types_packages = {95033, DiagnosticCategory::Message, S("Install_all_missing_types_packages_95033"), S("Install all missing types packages")};
        static DiagnosticMessageStore Rewrite_all_as_indexed_access_types = {95034, DiagnosticCategory::Message, S("Rewrite_all_as_indexed_access_types_95034"), S("Rewrite all as indexed access types")};
        static DiagnosticMessageStore Convert_all_to_default_imports = {95035, DiagnosticCategory::Message, S("Convert_all_to_default_imports_95035"), S("Convert all to default imports")};
        static DiagnosticMessageStore Make_all_super_calls_the_first_statement_in_their_constructor = {95036, DiagnosticCategory::Message, S("Make_all_super_calls_the_first_statement_in_their_constructor_95036"), S("Make all 'super()' calls the first statement in their constructor")};
        static DiagnosticMessageStore Add_qualifier_to_all_unresolved_variables_matching_a_member_name = {95037, DiagnosticCategory::Message, S("Add_qualifier_to_all_unresolved_variables_matching_a_member_name_95037"), S("Add qualifier to all unresolved variables matching a member name")};
        static DiagnosticMessageStore Change_all_extended_interfaces_to_implements = {95038, DiagnosticCategory::Message, S("Change_all_extended_interfaces_to_implements_95038"), S("Change all extended interfaces to 'implements'")};
        static DiagnosticMessageStore Add_all_missing_super_calls = {95039, DiagnosticCategory::Message, S("Add_all_missing_super_calls_95039"), S("Add all missing super calls")};
        static DiagnosticMessageStore Implement_all_inherited_abstract_classes = {95040, DiagnosticCategory::Message, S("Implement_all_inherited_abstract_classes_95040"), S("Implement all inherited abstract classes")};
        static DiagnosticMessageStore Add_all_missing_async_modifiers = {95041, DiagnosticCategory::Message, S("Add_all_missing_async_modifiers_95041"), S("Add all missing 'async' modifiers")};
        static DiagnosticMessageStore Add_ts_ignore_to_all_error_messages = {95042, DiagnosticCategory::Message, S("Add_ts_ignore_to_all_error_messages_95042"), S("Add '@ts-ignore' to all error messages")};
        static DiagnosticMessageStore Annotate_everything_with_types_from_JSDoc = {95043, DiagnosticCategory::Message, S("Annotate_everything_with_types_from_JSDoc_95043"), S("Annotate everything with types from JSDoc")};
        static DiagnosticMessageStore Add_to_all_uncalled_decorators = {95044, DiagnosticCategory::Message, S("Add_to_all_uncalled_decorators_95044"), S("Add '()' to all uncalled decorators")};
        static DiagnosticMessageStore Convert_all_constructor_functions_to_classes = {95045, DiagnosticCategory::Message, S("Convert_all_constructor_functions_to_classes_95045"), S("Convert all constructor functions to classes")};
        static DiagnosticMessageStore Generate_get_and_set_accessors = {95046, DiagnosticCategory::Message, S("Generate_get_and_set_accessors_95046"), S("Generate 'get' and 'set' accessors")};
        static DiagnosticMessageStore Convert_require_to_import = {95047, DiagnosticCategory::Message, S("Convert_require_to_import_95047"), S("Convert 'require' to 'import'")};
        static DiagnosticMessageStore Convert_all_require_to_import = {95048, DiagnosticCategory::Message, S("Convert_all_require_to_import_95048"), S("Convert all 'require' to 'import'")};
        static DiagnosticMessageStore Move_to_a_new_file = {95049, DiagnosticCategory::Message, S("Move_to_a_new_file_95049"), S("Move to a new file")};
        static DiagnosticMessageStore Remove_unreachable_code = {95050, DiagnosticCategory::Message, S("Remove_unreachable_code_95050"), S("Remove unreachable code")};
        static DiagnosticMessageStore Remove_all_unreachable_code = {95051, DiagnosticCategory::Message, S("Remove_all_unreachable_code_95051"), S("Remove all unreachable code")};
        static DiagnosticMessageStore Add_missing_typeof = {95052, DiagnosticCategory::Message, S("Add_missing_typeof_95052"), S("Add missing 'typeof'")};
        static DiagnosticMessageStore Remove_unused_label = {95053, DiagnosticCategory::Message, S("Remove_unused_label_95053"), S("Remove unused label")};
        static DiagnosticMessageStore Remove_all_unused_labels = {95054, DiagnosticCategory::Message, S("Remove_all_unused_labels_95054"), S("Remove all unused labels")};
        static DiagnosticMessageStore Convert_0_to_mapped_object_type = {95055, DiagnosticCategory::Message, S("Convert_0_to_mapped_object_type_95055"), S("Convert '{0}' to mapped object type")};
        static DiagnosticMessageStore Convert_namespace_import_to_named_imports = {95056, DiagnosticCategory::Message, S("Convert_namespace_import_to_named_imports_95056"), S("Convert namespace import to named imports")};
        static DiagnosticMessageStore Convert_named_imports_to_namespace_import = {95057, DiagnosticCategory::Message, S("Convert_named_imports_to_namespace_import_95057"), S("Convert named imports to namespace import")};
        static DiagnosticMessageStore Add_or_remove_braces_in_an_arrow_function = {95058, DiagnosticCategory::Message, S("Add_or_remove_braces_in_an_arrow_function_95058"), S("Add or remove braces in an arrow function")};
        static DiagnosticMessageStore Add_braces_to_arrow_function = {95059, DiagnosticCategory::Message, S("Add_braces_to_arrow_function_95059"), S("Add braces to arrow function")};
        static DiagnosticMessageStore Remove_braces_from_arrow_function = {95060, DiagnosticCategory::Message, S("Remove_braces_from_arrow_function_95060"), S("Remove braces from arrow function")};
        static DiagnosticMessageStore Convert_default_export_to_named_export = {95061, DiagnosticCategory::Message, S("Convert_default_export_to_named_export_95061"), S("Convert default export to named export")};
        static DiagnosticMessageStore Convert_named_export_to_default_export = {95062, DiagnosticCategory::Message, S("Convert_named_export_to_default_export_95062"), S("Convert named export to default export")};
        static DiagnosticMessageStore Add_missing_enum_member_0 = {95063, DiagnosticCategory::Message, S("Add_missing_enum_member_0_95063"), S("Add missing enum member '{0}'")};
        static DiagnosticMessageStore Add_all_missing_imports = {95064, DiagnosticCategory::Message, S("Add_all_missing_imports_95064"), S("Add all missing imports")};
        static DiagnosticMessageStore Convert_to_async_function = {95065, DiagnosticCategory::Message, S("Convert_to_async_function_95065"), S("Convert to async function")};
        static DiagnosticMessageStore Convert_all_to_async_functions = {95066, DiagnosticCategory::Message, S("Convert_all_to_async_functions_95066"), S("Convert all to async functions")};
        static DiagnosticMessageStore Add_missing_call_parentheses = {95067, DiagnosticCategory::Message, S("Add_missing_call_parentheses_95067"), S("Add missing call parentheses")};
        static DiagnosticMessageStore Add_all_missing_call_parentheses = {95068, DiagnosticCategory::Message, S("Add_all_missing_call_parentheses_95068"), S("Add all missing call parentheses")};
        static DiagnosticMessageStore Add_unknown_conversion_for_non_overlapping_types = {95069, DiagnosticCategory::Message, S("Add_unknown_conversion_for_non_overlapping_types_95069"), S("Add 'unknown' conversion for non-overlapping types")};
        static DiagnosticMessageStore Add_unknown_to_all_conversions_of_non_overlapping_types = {95070, DiagnosticCategory::Message, S("Add_unknown_to_all_conversions_of_non_overlapping_types_95070"), S("Add 'unknown' to all conversions of non-overlapping types")};
        static DiagnosticMessageStore Add_missing_new_operator_to_call = {95071, DiagnosticCategory::Message, S("Add_missing_new_operator_to_call_95071"), S("Add missing 'new' operator to call")};
        static DiagnosticMessageStore Add_missing_new_operator_to_all_calls = {95072, DiagnosticCategory::Message, S("Add_missing_new_operator_to_all_calls_95072"), S("Add missing 'new' operator to all calls")};
        static DiagnosticMessageStore Add_names_to_all_parameters_without_names = {95073, DiagnosticCategory::Message, S("Add_names_to_all_parameters_without_names_95073"), S("Add names to all parameters without names")};
        static DiagnosticMessageStore Enable_the_experimentalDecorators_option_in_your_configuration_file = {95074, DiagnosticCategory::Message, S("Enable_the_experimentalDecorators_option_in_your_configuration_file_95074"), S("Enable the 'experimentalDecorators' option in your configuration file")};
        static DiagnosticMessageStore Convert_parameters_to_destructured_object = {95075, DiagnosticCategory::Message, S("Convert_parameters_to_destructured_object_95075"), S("Convert parameters to destructured object")};
        static DiagnosticMessageStore Allow_accessing_UMD_globals_from_modules = {95076, DiagnosticCategory::Message, S("Allow_accessing_UMD_globals_from_modules_95076"), S("Allow accessing UMD globals from modules.")};
        static DiagnosticMessageStore Extract_type = {95077, DiagnosticCategory::Message, S("Extract_type_95077"), S("Extract type")};
        static DiagnosticMessageStore Extract_to_type_alias = {95078, DiagnosticCategory::Message, S("Extract_to_type_alias_95078"), S("Extract to type alias")};
        static DiagnosticMessageStore Extract_to_typedef = {95079, DiagnosticCategory::Message, S("Extract_to_typedef_95079"), S("Extract to typedef")};
        static DiagnosticMessageStore Infer_this_type_of_0_from_usage = {95080, DiagnosticCategory::Message, S("Infer_this_type_of_0_from_usage_95080"), S("Infer 'this' type of '{0}' from usage")};
        static DiagnosticMessageStore Add_const_to_unresolved_variable = {95081, DiagnosticCategory::Message, S("Add_const_to_unresolved_variable_95081"), S("Add 'const' to unresolved variable")};
        static DiagnosticMessageStore Add_const_to_all_unresolved_variables = {95082, DiagnosticCategory::Message, S("Add_const_to_all_unresolved_variables_95082"), S("Add 'const' to all unresolved variables")};
        static DiagnosticMessageStore Add_await = {95083, DiagnosticCategory::Message, S("Add_await_95083"), S("Add 'await'")};
        static DiagnosticMessageStore Add_await_to_initializer_for_0 = {95084, DiagnosticCategory::Message, S("Add_await_to_initializer_for_0_95084"), S("Add 'await' to initializer for '{0}'")};
        static DiagnosticMessageStore Fix_all_expressions_possibly_missing_await = {95085, DiagnosticCategory::Message, S("Fix_all_expressions_possibly_missing_await_95085"), S("Fix all expressions possibly missing 'await'")};
        static DiagnosticMessageStore Remove_unnecessary_await = {95086, DiagnosticCategory::Message, S("Remove_unnecessary_await_95086"), S("Remove unnecessary 'await'")};
        static DiagnosticMessageStore Remove_all_unnecessary_uses_of_await = {95087, DiagnosticCategory::Message, S("Remove_all_unnecessary_uses_of_await_95087"), S("Remove all unnecessary uses of 'await'")};
        static DiagnosticMessageStore Enable_the_jsx_flag_in_your_configuration_file = {95088, DiagnosticCategory::Message, S("Enable_the_jsx_flag_in_your_configuration_file_95088"), S("Enable the '--jsx' flag in your configuration file")};
        static DiagnosticMessageStore Add_await_to_initializers = {95089, DiagnosticCategory::Message, S("Add_await_to_initializers_95089"), S("Add 'await' to initializers")};
        static DiagnosticMessageStore Extract_to_interface = {95090, DiagnosticCategory::Message, S("Extract_to_interface_95090"), S("Extract to interface")};
        static DiagnosticMessageStore Convert_to_a_bigint_numeric_literal = {95091, DiagnosticCategory::Message, S("Convert_to_a_bigint_numeric_literal_95091"), S("Convert to a bigint numeric literal")};
        static DiagnosticMessageStore Convert_all_to_bigint_numeric_literals = {95092, DiagnosticCategory::Message, S("Convert_all_to_bigint_numeric_literals_95092"), S("Convert all to bigint numeric literals")};
        static DiagnosticMessageStore Convert_const_to_let = {95093, DiagnosticCategory::Message, S("Convert_const_to_let_95093"), S("Convert 'const' to 'let'")};
        static DiagnosticMessageStore Prefix_with_declare = {95094, DiagnosticCategory::Message, S("Prefix_with_declare_95094"), S("Prefix with 'declare'")};
        static DiagnosticMessageStore Prefix_all_incorrect_property_declarations_with_declare = {95095, DiagnosticCategory::Message, S("Prefix_all_incorrect_property_declarations_with_declare_95095"), S("Prefix all incorrect property declarations with 'declare'")};
        static DiagnosticMessageStore Convert_to_template_string = {95096, DiagnosticCategory::Message, S("Convert_to_template_string_95096"), S("Convert to template string")};
        static DiagnosticMessageStore Add_export_to_make_this_file_into_a_module = {95097, DiagnosticCategory::Message, S("Add_export_to_make_this_file_into_a_module_95097"), S("Add 'export {}' to make this file into a module")};
        static DiagnosticMessageStore Set_the_target_option_in_your_configuration_file_to_0 = {95098, DiagnosticCategory::Message, S("Set_the_target_option_in_your_configuration_file_to_0_95098"), S("Set the 'target' option in your configuration file to '{0}'")};
        static DiagnosticMessageStore Set_the_module_option_in_your_configuration_file_to_0 = {95099, DiagnosticCategory::Message, S("Set_the_module_option_in_your_configuration_file_to_0_95099"), S("Set the 'module' option in your configuration file to '{0}'")};
        static DiagnosticMessageStore Convert_invalid_character_to_its_html_entity_code = {95100, DiagnosticCategory::Message, S("Convert_invalid_character_to_its_html_entity_code_95100"), S("Convert invalid character to its html entity code")};
        static DiagnosticMessageStore Convert_all_invalid_characters_to_HTML_entity_code = {95101, DiagnosticCategory::Message, S("Convert_all_invalid_characters_to_HTML_entity_code_95101"), S("Convert all invalid characters to HTML entity code")};
        static DiagnosticMessageStore Add_class_tag = {95102, DiagnosticCategory::Message, S("Add_class_tag_95102"), S("Add '@class' tag")};
        static DiagnosticMessageStore Add_this_tag = {95103, DiagnosticCategory::Message, S("Add_this_tag_95103"), S("Add '@this' tag")};
        static DiagnosticMessageStore Add_this_parameter = {95104, DiagnosticCategory::Message, S("Add_this_parameter_95104"), S("Add 'this' parameter.")};
        static DiagnosticMessageStore Convert_function_expression_0_to_arrow_function = {95105, DiagnosticCategory::Message, S("Convert_function_expression_0_to_arrow_function_95105"), S("Convert function expression '{0}' to arrow function")};
        static DiagnosticMessageStore Convert_function_declaration_0_to_arrow_function = {95106, DiagnosticCategory::Message, S("Convert_function_declaration_0_to_arrow_function_95106"), S("Convert function declaration '{0}' to arrow function")};
        static DiagnosticMessageStore Fix_all_implicit_this_errors = {95107, DiagnosticCategory::Message, S("Fix_all_implicit_this_errors_95107"), S("Fix all implicit-'this' errors")};
        static DiagnosticMessageStore Wrap_invalid_character_in_an_expression_container = {95108, DiagnosticCategory::Message, S("Wrap_invalid_character_in_an_expression_container_95108"), S("Wrap invalid character in an expression container")};
        static DiagnosticMessageStore Wrap_all_invalid_characters_in_an_expression_container = {95109, DiagnosticCategory::Message, S("Wrap_all_invalid_characters_in_an_expression_container_95109"), S("Wrap all invalid characters in an expression container")};
        static DiagnosticMessageStore Visit_https_Colon_Slash_Slashaka_ms_Slashtsconfig_json_to_read_more_about_this_file = {95110, DiagnosticCategory::Message, S("Visit_https_Colon_Slash_Slashaka_ms_Slashtsconfig_json_to_read_more_about_this_file_95110"), S("Visit https://aka.ms/tsconfig.json to read more about this file")};
        static DiagnosticMessageStore Add_a_return_statement = {95111, DiagnosticCategory::Message, S("Add_a_return_statement_95111"), S("Add a return statement")};
        static DiagnosticMessageStore Remove_braces_from_arrow_function_body = {95112, DiagnosticCategory::Message, S("Remove_braces_from_arrow_function_body_95112"), S("Remove braces from arrow function body")};
        static DiagnosticMessageStore Wrap_the_following_body_with_parentheses_which_should_be_an_object_literal = {95113, DiagnosticCategory::Message, S("Wrap_the_following_body_with_parentheses_which_should_be_an_object_literal_95113"), S("Wrap the following body with parentheses which should be an object literal")};
        static DiagnosticMessageStore Add_all_missing_return_statement = {95114, DiagnosticCategory::Message, S("Add_all_missing_return_statement_95114"), S("Add all missing return statement")};
        static DiagnosticMessageStore Remove_braces_from_all_arrow_function_bodies_with_relevant_issues = {95115, DiagnosticCategory::Message, S("Remove_braces_from_all_arrow_function_bodies_with_relevant_issues_95115"), S("Remove braces from all arrow function bodies with relevant issues")};
        static DiagnosticMessageStore Wrap_all_object_literal_with_parentheses = {95116, DiagnosticCategory::Message, S("Wrap_all_object_literal_with_parentheses_95116"), S("Wrap all object literal with parentheses")};
        static DiagnosticMessageStore Move_labeled_tuple_element_modifiers_to_labels = {95117, DiagnosticCategory::Message, S("Move_labeled_tuple_element_modifiers_to_labels_95117"), S("Move labeled tuple element modifiers to labels")};
        static DiagnosticMessageStore Convert_overload_list_to_single_signature = {95118, DiagnosticCategory::Message, S("Convert_overload_list_to_single_signature_95118"), S("Convert overload list to single signature")};
        static DiagnosticMessageStore Generate_get_and_set_accessors_for_all_overriding_properties = {95119, DiagnosticCategory::Message, S("Generate_get_and_set_accessors_for_all_overriding_properties_95119"), S("Generate 'get' and 'set' accessors for all overriding properties")};
        static DiagnosticMessageStore Wrap_in_JSX_fragment = {95120, DiagnosticCategory::Message, S("Wrap_in_JSX_fragment_95120"), S("Wrap in JSX fragment")};
        static DiagnosticMessageStore Wrap_all_unparented_JSX_in_JSX_fragment = {95121, DiagnosticCategory::Message, S("Wrap_all_unparented_JSX_in_JSX_fragment_95121"), S("Wrap all unparented JSX in JSX fragment")};
        static DiagnosticMessageStore Convert_arrow_function_or_function_expression = {95122, DiagnosticCategory::Message, S("Convert_arrow_function_or_function_expression_95122"), S("Convert arrow function or function expression")};
        static DiagnosticMessageStore Convert_to_anonymous_function = {95123, DiagnosticCategory::Message, S("Convert_to_anonymous_function_95123"), S("Convert to anonymous function")};
        static DiagnosticMessageStore Convert_to_named_function = {95124, DiagnosticCategory::Message, S("Convert_to_named_function_95124"), S("Convert to named function")};
        static DiagnosticMessageStore Convert_to_arrow_function = {95125, DiagnosticCategory::Message, S("Convert_to_arrow_function_95125"), S("Convert to arrow function")};
        static DiagnosticMessageStore Remove_parentheses = {95126, DiagnosticCategory::Message, S("Remove_parentheses_95126"), S("Remove parentheses")};
        static DiagnosticMessageStore Could_not_find_a_containing_arrow_function = {95127, DiagnosticCategory::Message, S("Could_not_find_a_containing_arrow_function_95127"), S("Could not find a containing arrow function")};
        static DiagnosticMessageStore Containing_function_is_not_an_arrow_function = {95128, DiagnosticCategory::Message, S("Containing_function_is_not_an_arrow_function_95128"), S("Containing function is not an arrow function")};
        static DiagnosticMessageStore Could_not_find_export_statement = {95129, DiagnosticCategory::Message, S("Could_not_find_export_statement_95129"), S("Could not find export statement")};
        static DiagnosticMessageStore This_file_already_has_a_default_export = {95130, DiagnosticCategory::Message, S("This_file_already_has_a_default_export_95130"), S("This file already has a default export")};
        static DiagnosticMessageStore Could_not_find_import_clause = {95131, DiagnosticCategory::Message, S("Could_not_find_import_clause_95131"), S("Could not find import clause")};
        static DiagnosticMessageStore Could_not_find_namespace_import_or_named_imports = {95132, DiagnosticCategory::Message, S("Could_not_find_namespace_import_or_named_imports_95132"), S("Could not find namespace import or named imports")};
        static DiagnosticMessageStore Selection_is_not_a_valid_type_node = {95133, DiagnosticCategory::Message, S("Selection_is_not_a_valid_type_node_95133"), S("Selection is not a valid type node")};
        static DiagnosticMessageStore No_type_could_be_extracted_from_this_type_node = {95134, DiagnosticCategory::Message, S("No_type_could_be_extracted_from_this_type_node_95134"), S("No type could be extracted from this type node")};
        static DiagnosticMessageStore Could_not_find_property_for_which_to_generate_accessor = {95135, DiagnosticCategory::Message, S("Could_not_find_property_for_which_to_generate_accessor_95135"), S("Could not find property for which to generate accessor")};
        static DiagnosticMessageStore Name_is_not_valid = {95136, DiagnosticCategory::Message, S("Name_is_not_valid_95136"), S("Name is not valid")};
        static DiagnosticMessageStore Can_only_convert_property_with_modifier = {95137, DiagnosticCategory::Message, S("Can_only_convert_property_with_modifier_95137"), S("Can only convert property with modifier")};
        static DiagnosticMessageStore Switch_each_misused_0_to_1 = {95138, DiagnosticCategory::Message, S("Switch_each_misused_0_to_1_95138"), S("Switch each misused '{0}' to '{1}'")};
        static DiagnosticMessageStore Convert_to_optional_chain_expression = {95139, DiagnosticCategory::Message, S("Convert_to_optional_chain_expression_95139"), S("Convert to optional chain expression")};
        static DiagnosticMessageStore Could_not_find_convertible_access_expression = {95140, DiagnosticCategory::Message, S("Could_not_find_convertible_access_expression_95140"), S("Could not find convertible access expression")};
        static DiagnosticMessageStore Could_not_find_matching_access_expressions = {95141, DiagnosticCategory::Message, S("Could_not_find_matching_access_expressions_95141"), S("Could not find matching access expressions")};
        static DiagnosticMessageStore Can_only_convert_logical_AND_access_chains = {95142, DiagnosticCategory::Message, S("Can_only_convert_logical_AND_access_chains_95142"), S("Can only convert logical AND access chains")};
        static DiagnosticMessageStore Add_void_to_Promise_resolved_without_a_value = {95143, DiagnosticCategory::Message, S("Add_void_to_Promise_resolved_without_a_value_95143"), S("Add 'void' to Promise resolved without a value")};
        static DiagnosticMessageStore Add_void_to_all_Promises_resolved_without_a_value = {95144, DiagnosticCategory::Message, S("Add_void_to_all_Promises_resolved_without_a_value_95144"), S("Add 'void' to all Promises resolved without a value")};
        static DiagnosticMessageStore Use_element_access_for_0 = {95145, DiagnosticCategory::Message, S("Use_element_access_for_0_95145"), S("Use element access for '{0}'")};
        static DiagnosticMessageStore Use_element_access_for_all_undeclared_properties = {95146, DiagnosticCategory::Message, S("Use_element_access_for_all_undeclared_properties_95146"), S("Use element access for all undeclared properties.")};
        static DiagnosticMessageStore Delete_all_unused_imports = {95147, DiagnosticCategory::Message, S("Delete_all_unused_imports_95147"), S("Delete all unused imports")};
        static DiagnosticMessageStore Infer_function_return_type = {95148, DiagnosticCategory::Message, S("Infer_function_return_type_95148"), S("Infer function return type")};
        static DiagnosticMessageStore Return_type_must_be_inferred_from_a_function = {95149, DiagnosticCategory::Message, S("Return_type_must_be_inferred_from_a_function_95149"), S("Return type must be inferred from a function")};
        static DiagnosticMessageStore Could_not_determine_function_return_type = {95150, DiagnosticCategory::Message, S("Could_not_determine_function_return_type_95150"), S("Could not determine function return type")};
        static DiagnosticMessageStore Could_not_convert_to_arrow_function = {95151, DiagnosticCategory::Message, S("Could_not_convert_to_arrow_function_95151"), S("Could not convert to arrow function")};
        static DiagnosticMessageStore Could_not_convert_to_named_function = {95152, DiagnosticCategory::Message, S("Could_not_convert_to_named_function_95152"), S("Could not convert to named function")};
        static DiagnosticMessageStore Could_not_convert_to_anonymous_function = {95153, DiagnosticCategory::Message, S("Could_not_convert_to_anonymous_function_95153"), S("Could not convert to anonymous function")};
        static DiagnosticMessageStore Can_only_convert_string_concatenation = {95154, DiagnosticCategory::Message, S("Can_only_convert_string_concatenation_95154"), S("Can only convert string concatenation")};
        static DiagnosticMessageStore Selection_is_not_a_valid_statement_or_statements = {95155, DiagnosticCategory::Message, S("Selection_is_not_a_valid_statement_or_statements_95155"), S("Selection is not a valid statement or statements")};
        static DiagnosticMessageStore Add_missing_function_declaration_0 = {95156, DiagnosticCategory::Message, S("Add_missing_function_declaration_0_95156"), S("Add missing function declaration '{0}'")};
        static DiagnosticMessageStore Add_all_missing_function_declarations = {95157, DiagnosticCategory::Message, S("Add_all_missing_function_declarations_95157"), S("Add all missing function declarations")};
        static DiagnosticMessageStore Method_not_implemented = {95158, DiagnosticCategory::Message, S("Method_not_implemented_95158"), S("Method not implemented.")};
        static DiagnosticMessageStore Function_not_implemented = {95159, DiagnosticCategory::Message, S("Function_not_implemented_95159"), S("Function not implemented.")};
        static DiagnosticMessageStore No_value_exists_in_scope_for_the_shorthand_property_0_Either_declare_one_or_provide_an_initializer = {18004, DiagnosticCategory::Error, S("No_value_exists_in_scope_for_the_shorthand_property_0_Either_declare_one_or_provide_an_initializer_18004"), S("No value exists in scope for the shorthand property '{0}'. Either declare one or provide an initializer.")};
        static DiagnosticMessageStore Classes_may_not_have_a_field_named_constructor = {18006, DiagnosticCategory::Error, S("Classes_may_not_have_a_field_named_constructor_18006"), S("Classes may not have a field named 'constructor'.")};
        static DiagnosticMessageStore JSX_expressions_may_not_use_the_comma_operator_Did_you_mean_to_write_an_array = {18007, DiagnosticCategory::Error, S("JSX_expressions_may_not_use_the_comma_operator_Did_you_mean_to_write_an_array_18007"), S("JSX expressions may not use the comma operator. Did you mean to write an array?")};
        static DiagnosticMessageStore Private_identifiers_cannot_be_used_as_parameters = {18009, DiagnosticCategory::Error, S("Private_identifiers_cannot_be_used_as_parameters_18009"), S("Private identifiers cannot be used as parameters.")};
        static DiagnosticMessageStore An_accessibility_modifier_cannot_be_used_with_a_private_identifier = {18010, DiagnosticCategory::Error, S("An_accessibility_modifier_cannot_be_used_with_a_private_identifier_18010"), S("An accessibility modifier cannot be used with a private identifier.")};
        static DiagnosticMessageStore The_operand_of_a_delete_operator_cannot_be_a_private_identifier = {18011, DiagnosticCategory::Error, S("The_operand_of_a_delete_operator_cannot_be_a_private_identifier_18011"), S("The operand of a 'delete' operator cannot be a private identifier.")};
        static DiagnosticMessageStore constructor_is_a_reserved_word = {18012, DiagnosticCategory::Error, S("constructor_is_a_reserved_word_18012"), S("'#constructor' is a reserved word.")};
        static DiagnosticMessageStore Property_0_is_not_accessible_outside_class_1_because_it_has_a_private_identifier = {18013, DiagnosticCategory::Error, S("Property_0_is_not_accessible_outside_class_1_because_it_has_a_private_identifier_18013"), S("Property '{0}' is not accessible outside class '{1}' because it has a private identifier.")};
        static DiagnosticMessageStore The_property_0_cannot_be_accessed_on_type_1_within_this_class_because_it_is_shadowed_by_another_private_identifier_with_the_same_spelling = {18014, DiagnosticCategory::Error, S("The_property_0_cannot_be_accessed_on_type_1_within_this_class_because_it_is_shadowed_by_another_priv_18014"), S("The property '{0}' cannot be accessed on type '{1}' within this class because it is shadowed by another private identifier with the same spelling.")};
        static DiagnosticMessageStore Property_0_in_type_1_refers_to_a_different_member_that_cannot_be_accessed_from_within_type_2 = {18015, DiagnosticCategory::Error, S("Property_0_in_type_1_refers_to_a_different_member_that_cannot_be_accessed_from_within_type_2_18015"), S("Property '{0}' in type '{1}' refers to a different member that cannot be accessed from within type '{2}'.")};
        static DiagnosticMessageStore Private_identifiers_are_not_allowed_outside_class_bodies = {18016, DiagnosticCategory::Error, S("Private_identifiers_are_not_allowed_outside_class_bodies_18016"), S("Private identifiers are not allowed outside class bodies.")};
        static DiagnosticMessageStore The_shadowing_declaration_of_0_is_defined_here = {18017, DiagnosticCategory::Error, S("The_shadowing_declaration_of_0_is_defined_here_18017"), S("The shadowing declaration of '{0}' is defined here")};
        static DiagnosticMessageStore The_declaration_of_0_that_you_probably_intended_to_use_is_defined_here = {18018, DiagnosticCategory::Error, S("The_declaration_of_0_that_you_probably_intended_to_use_is_defined_here_18018"), S("The declaration of '{0}' that you probably intended to use is defined here")};
        static DiagnosticMessageStore _0_modifier_cannot_be_used_with_a_private_identifier = {18019, DiagnosticCategory::Error, S("_0_modifier_cannot_be_used_with_a_private_identifier_18019"), S("'{0}' modifier cannot be used with a private identifier.")};
        static DiagnosticMessageStore A_method_cannot_be_named_with_a_private_identifier = {18022, DiagnosticCategory::Error, S("A_method_cannot_be_named_with_a_private_identifier_18022"), S("A method cannot be named with a private identifier.")};
        static DiagnosticMessageStore An_accessor_cannot_be_named_with_a_private_identifier = {18023, DiagnosticCategory::Error, S("An_accessor_cannot_be_named_with_a_private_identifier_18023"), S("An accessor cannot be named with a private identifier.")};
        static DiagnosticMessageStore An_enum_member_cannot_be_named_with_a_private_identifier = {18024, DiagnosticCategory::Error, S("An_enum_member_cannot_be_named_with_a_private_identifier_18024"), S("An enum member cannot be named with a private identifier.")};
        static DiagnosticMessageStore can_only_be_used_at_the_start_of_a_file = {18026, DiagnosticCategory::Error, S("can_only_be_used_at_the_start_of_a_file_18026"), S("'#!' can only be used at the start of a file.")};
        static DiagnosticMessageStore Compiler_reserves_name_0_when_emitting_private_identifier_downlevel = {18027, DiagnosticCategory::Error, S("Compiler_reserves_name_0_when_emitting_private_identifier_downlevel_18027"), S("Compiler reserves name '{0}' when emitting private identifier downlevel.")};
        static DiagnosticMessageStore Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher = {18028, DiagnosticCategory::Error, S("Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher_18028"), S("Private identifiers are only available when targeting ECMAScript 2015 and higher.")};
        static DiagnosticMessageStore Private_identifiers_are_not_allowed_in_variable_declarations = {18029, DiagnosticCategory::Error, S("Private_identifiers_are_not_allowed_in_variable_declarations_18029"), S("Private identifiers are not allowed in variable declarations.")};
        static DiagnosticMessageStore An_optional_chain_cannot_contain_private_identifiers = {18030, DiagnosticCategory::Error, S("An_optional_chain_cannot_contain_private_identifiers_18030"), S("An optional chain cannot contain private identifiers.")};
        static DiagnosticMessageStore The_intersection_0_was_reduced_to_never_because_property_1_has_conflicting_types_in_some_constituents = {18031, DiagnosticCategory::Error, S("The_intersection_0_was_reduced_to_never_because_property_1_has_conflicting_types_in_some_constituent_18031"), S("The intersection '{0}' was reduced to 'never' because property '{1}' has conflicting types in some constituents.")};
        static DiagnosticMessageStore The_intersection_0_was_reduced_to_never_because_property_1_exists_in_multiple_constituents_and_is_private_in_some = {18032, DiagnosticCategory::Error, S("The_intersection_0_was_reduced_to_never_because_property_1_exists_in_multiple_constituents_and_is_pr_18032"), S("The intersection '{0}' was reduced to 'never' because property '{1}' exists in multiple constituents and is private in some.")};
        static DiagnosticMessageStore Only_numeric_enums_can_have_computed_members_but_this_expression_has_type_0_If_you_do_not_need_exhaustiveness_checks_consider_using_an_object_literal_instead = {18033, DiagnosticCategory::Error, S("Only_numeric_enums_can_have_computed_members_but_this_expression_has_type_0_If_you_do_not_need_exhau_18033"), S("Only numeric enums can have computed members, but this expression has type '{0}'. If you do not need exhaustiveness checks, consider using an object literal instead.")};
        static DiagnosticMessageStore Specify_the_JSX_fragment_factory_function_to_use_when_targeting_react_JSX_emit_with_jsxFactory_compiler_option_is_specified_e_g_Fragment = {18034, DiagnosticCategory::Message, S("Specify_the_JSX_fragment_factory_function_to_use_when_targeting_react_JSX_emit_with_jsxFactory_compi_18034"), S("Specify the JSX fragment factory function to use when targeting 'react' JSX emit with 'jsxFactory' compiler option is specified, e.g. 'Fragment'.")};
        static DiagnosticMessageStore Invalid_value_for_jsxFragmentFactory_0_is_not_a_valid_identifier_or_qualified_name = {18035, DiagnosticCategory::Error, S("Invalid_value_for_jsxFragmentFactory_0_is_not_a_valid_identifier_or_qualified_name_18035"), S("Invalid value for 'jsxFragmentFactory'. '{0}' is not a valid identifier or qualified-name.")};
    }

} // namespace ts