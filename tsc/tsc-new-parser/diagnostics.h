#include "config.h"
#include "enums.h"
#include "types.h"

namespace ts
{
    namespace Diagnostics
    {
        static DiagnosticMessageStore Unterminated_string_literal = {1002, DiagnosticCategory::Error, S("Unterminated_string_literal_1002"), S("Unterminated string literal.")};
        static DiagnosticMessageStore Identifier_expected = {1003, DiagnosticCategory::Error, S("Identifier_expected_1003"), S("Identifier expected.")};
        static DiagnosticMessageStore _0_expected = {1005, DiagnosticCategory::Error, S("_0_expected_1005"), S("'{0}' expected.")};
        static DiagnosticMessageStore A_file_cannot_have_a_reference_to_itself = {1006, DiagnosticCategory::Error, S("A_file_cannot_have_a_reference_to_itself_1006"), S("A file cannot have a reference to itself.")};
        static DiagnosticMessageStore The_parser_expected_to_find_a_1_to_match_the_0_token_here = {1007, DiagnosticCategory::Error, S("The_parser_expected_to_find_a_1_to_match_the_0_token_here_1007"), S("The parser expected to find a '{1}' to match the '{0}' token here.")};
        static DiagnosticMessageStore Trailing_comma_not_allowed = {1009, DiagnosticCategory::Error, S("Trailing_comma_not_allowed_1009"), S("Trailing comma not allowed.")};
        static DiagnosticMessageStore Asterisk_Slash_expected = {1010, DiagnosticCategory::Error, S("Asterisk_Slash_expected_1010"), S("'*/' expected.")};
        static DiagnosticMessageStore An_element_access_expression_should_take_an_argument = {1011, DiagnosticCategory::Error, S("An_element_access_expression_should_take_an_argument_1011"), S("An element access expression should take an argument.")};
        static DiagnosticMessageStore Unexpected_token = {1012, DiagnosticCategory::Error, S("Unexpected_token_1012"), S("Unexpected token.")};
        static DiagnosticMessageStore A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma = {1013, DiagnosticCategory::Error, S("A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma_1013"), S("A rest parameter or binding pattern may not have a trailing comma.")};
        static DiagnosticMessageStore A_rest_parameter_must_be_last_in_a_parameter_list = {1014, DiagnosticCategory::Error, S("A_rest_parameter_must_be_last_in_a_parameter_list_1014"), S("A rest parameter must be last in a parameter list.")};
        static DiagnosticMessageStore Parameter_cannot_have_question_mark_and_initializer = {1015, DiagnosticCategory::Error, S("Parameter_cannot_have_question_mark_and_initializer_1015"), S("Parameter cannot have question mark and initializer.")};
        static DiagnosticMessageStore A_required_parameter_cannot_follow_an_optional_parameter = {1016, DiagnosticCategory::Error, S("A_required_parameter_cannot_follow_an_optional_parameter_1016"), S("A required parameter cannot follow an optional parameter.")};
        static DiagnosticMessageStore An_index_signature_cannot_have_a_rest_parameter = {1017, DiagnosticCategory::Error, S("An_index_signature_cannot_have_a_rest_parameter_1017"), S("An index signature cannot have a rest parameter.")};
        static DiagnosticMessageStore An_index_signature_parameter_cannot_have_an_accessibility_modifier = {1018, DiagnosticCategory::Error, S("An_index_signature_parameter_cannot_have_an_accessibility_modifier_1018"), S("An index signature parameter cannot have an accessibility modifier.")};
        static DiagnosticMessageStore An_index_signature_parameter_cannot_have_a_question_mark = {1019, DiagnosticCategory::Error, S("An_index_signature_parameter_cannot_have_a_question_mark_1019"), S("An index signature parameter cannot have a question mark.")};
        static DiagnosticMessageStore An_index_signature_parameter_cannot_have_an_initializer = {1020, DiagnosticCategory::Error, S("An_index_signature_parameter_cannot_have_an_initializer_1020"), S("An index signature parameter cannot have an initializer.")};
        static DiagnosticMessageStore An_index_signature_must_have_a_type_annotation = {1021, DiagnosticCategory::Error, S("An_index_signature_must_have_a_type_annotation_1021"), S("An index signature must have a type annotation.")};
        static DiagnosticMessageStore An_index_signature_parameter_must_have_a_type_annotation = {1022, DiagnosticCategory::Error, S("An_index_signature_parameter_must_have_a_type_annotation_1022"), S("An index signature parameter must have a type annotation.")};
        static DiagnosticMessageStore readonly_modifier_can_only_appear_on_a_property_declaration_or_index_signature = {1024, DiagnosticCategory::Error, S("readonly_modifier_can_only_appear_on_a_property_declaration_or_index_signature_1024"), S("'readonly' modifier can only appear on a property declaration or index signature.")};
        static DiagnosticMessageStore An_index_signature_cannot_have_a_trailing_comma = {1025, DiagnosticCategory::Error, S("An_index_signature_cannot_have_a_trailing_comma_1025"), S("An index signature cannot have a trailing comma.")};
        static DiagnosticMessageStore Accessibility_modifier_already_seen = {1028, DiagnosticCategory::Error, S("Accessibility_modifier_already_seen_1028"), S("Accessibility modifier already seen.")};
        static DiagnosticMessageStore _0_modifier_must_precede_1_modifier = {1029, DiagnosticCategory::Error, S("_0_modifier_must_precede_1_modifier_1029"), S("'{0}' modifier must precede '{1}' modifier.")};
        static DiagnosticMessageStore _0_modifier_already_seen = {1030, DiagnosticCategory::Error, S("_0_modifier_already_seen_1030"), S("'{0}' modifier already seen.")};
        static DiagnosticMessageStore _0_modifier_cannot_appear_on_class_elements_of_this_kind = {1031, DiagnosticCategory::Error, S("_0_modifier_cannot_appear_on_class_elements_of_this_kind_1031"), S("'{0}' modifier cannot appear on class elements of this kind.")};
        static DiagnosticMessageStore super_must_be_followed_by_an_argument_list_or_member_access = {1034, DiagnosticCategory::Error, S("super_must_be_followed_by_an_argument_list_or_member_access_1034"), S("'super' must be followed by an argument list or member access.")};
        static DiagnosticMessageStore Only_ambient_modules_can_use_quoted_names = {1035, DiagnosticCategory::Error, S("Only_ambient_modules_can_use_quoted_names_1035"), S("Only ambient modules can use quoted names.")};
        static DiagnosticMessageStore Statements_are_not_allowed_in_ambient_contexts = {1036, DiagnosticCategory::Error, S("Statements_are_not_allowed_in_ambient_contexts_1036"), S("Statements are not allowed in ambient contexts.")};
        static DiagnosticMessageStore A_declare_modifier_cannot_be_used_in_an_already_ambient_context = {1038, DiagnosticCategory::Error, S("A_declare_modifier_cannot_be_used_in_an_already_ambient_context_1038"), S("A 'declare' modifier cannot be used in an already ambient context.")};
        static DiagnosticMessageStore Initializers_are_not_allowed_in_ambient_contexts = {1039, DiagnosticCategory::Error, S("Initializers_are_not_allowed_in_ambient_contexts_1039"), S("Initializers are not allowed in ambient contexts.")};
        static DiagnosticMessageStore _0_modifier_cannot_be_used_in_an_ambient_context = {1040, DiagnosticCategory::Error, S("_0_modifier_cannot_be_used_in_an_ambient_context_1040"), S("'{0}' modifier cannot be used in an ambient context.")};
        static DiagnosticMessageStore _0_modifier_cannot_be_used_here = {1042, DiagnosticCategory::Error, S("_0_modifier_cannot_be_used_here_1042"), S("'{0}' modifier cannot be used here.")};
        static DiagnosticMessageStore _0_modifier_cannot_appear_on_a_module_or_namespace_element = {1044, DiagnosticCategory::Error, S("_0_modifier_cannot_appear_on_a_module_or_namespace_element_1044"), S("'{0}' modifier cannot appear on a module or namespace element.")};
        static DiagnosticMessageStore Top_level_declarations_in_d_ts_files_must_start_with_either_a_declare_or_export_modifier = {1046, DiagnosticCategory::Error, S("Top_level_declarations_in_d_ts_files_must_start_with_either_a_declare_or_export_modifier_1046"), S("Top-level declarations in .d.ts files must start with either a 'declare' or 'export' modifier.")};
        static DiagnosticMessageStore A_rest_parameter_cannot_be_optional = {1047, DiagnosticCategory::Error, S("A_rest_parameter_cannot_be_optional_1047"), S("A rest parameter cannot be optional.")};
        static DiagnosticMessageStore A_rest_parameter_cannot_have_an_initializer = {1048, DiagnosticCategory::Error, S("A_rest_parameter_cannot_have_an_initializer_1048"), S("A rest parameter cannot have an initializer.")};
        static DiagnosticMessageStore A_set_accessor_must_have_exactly_one_parameter = {1049, DiagnosticCategory::Error, S("A_set_accessor_must_have_exactly_one_parameter_1049"), S("A 'set' accessor must have exactly one parameter.")};
        static DiagnosticMessageStore A_set_accessor_cannot_have_an_optional_parameter = {1051, DiagnosticCategory::Error, S("A_set_accessor_cannot_have_an_optional_parameter_1051"), S("A 'set' accessor cannot have an optional parameter.")};
        static DiagnosticMessageStore A_set_accessor_parameter_cannot_have_an_initializer = {1052, DiagnosticCategory::Error, S("A_set_accessor_parameter_cannot_have_an_initializer_1052"), S("A 'set' accessor parameter cannot have an initializer.")};
        static DiagnosticMessageStore A_set_accessor_cannot_have_rest_parameter = {1053, DiagnosticCategory::Error, S("A_set_accessor_cannot_have_rest_parameter_1053"), S("A 'set' accessor cannot have rest parameter.")};
        static DiagnosticMessageStore A_get_accessor_cannot_have_parameters = {1054, DiagnosticCategory::Error, S("A_get_accessor_cannot_have_parameters_1054"), S("A 'get' accessor cannot have parameters.")};
        static DiagnosticMessageStore Type_0_is_not_a_valid_async_function_return_type_in_ES5_SlashES3_because_it_does_not_refer_to_a_Promise_compatible_constructor_value = {1055, DiagnosticCategory::Error, S("Type_0_is_not_a_valid_async_function_return_type_in_ES5_SlashES3_because_it_does_not_refer_to_a_Prom_1055"), S("Type '{0}' is not a valid async function return type in ES5/ES3 because it does not refer to a Promise-compatible constructor value.")};
        static DiagnosticMessageStore Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher = {1056, DiagnosticCategory::Error, S("Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher_1056"), S("Accessors are only available when targeting ECMAScript 5 and higher.")};
        static DiagnosticMessageStore The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member = {1058, DiagnosticCategory::Error, S("The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_t_1058"), S("The return type of an async function must either be a valid promise or must not contain a callable 'then' member.")};
        static DiagnosticMessageStore A_promise_must_have_a_then_method = {1059, DiagnosticCategory::Error, S("A_promise_must_have_a_then_method_1059"), S("A promise must have a 'then' method.")};
        static DiagnosticMessageStore The_first_parameter_of_the_then_method_of_a_promise_must_be_a_callback = {1060, DiagnosticCategory::Error, S("The_first_parameter_of_the_then_method_of_a_promise_must_be_a_callback_1060"), S("The first parameter of the 'then' method of a promise must be a callback.")};
        static DiagnosticMessageStore Enum_member_must_have_initializer = {1061, DiagnosticCategory::Error, S("Enum_member_must_have_initializer_1061"), S("Enum member must have initializer.")};
        static DiagnosticMessageStore Type_is_referenced_directly_or_indirectly_in_the_fulfillment_callback_of_its_own_then_method = {1062, DiagnosticCategory::Error, S("Type_is_referenced_directly_or_indirectly_in_the_fulfillment_callback_of_its_own_then_method_1062"), S("Type is referenced directly or indirectly in the fulfillment callback of its own 'then' method.")};
        static DiagnosticMessageStore An_export_assignment_cannot_be_used_in_a_namespace = {1063, DiagnosticCategory::Error, S("An_export_assignment_cannot_be_used_in_a_namespace_1063"), S("An export assignment cannot be used in a namespace.")};
        static DiagnosticMessageStore The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type_Did_you_mean_to_write_Promise_0 = {1064, DiagnosticCategory::Error, S("The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type_Did_you_mean_to_wri_1064"), S("The return type of an async function or method must be the global Promise<T> type. Did you mean to write 'Promise<{0}>'?")};
        static DiagnosticMessageStore The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type = {1065, DiagnosticCategory::Error, S("The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type_1065"), S("The return type of an async function or method must be the global Promise<T> type.")};
        static DiagnosticMessageStore In_ambient_enum_declarations_member_initializer_must_be_constant_expression = {1066, DiagnosticCategory::Error, S("In_ambient_enum_declarations_member_initializer_must_be_constant_expression_1066"), S("In ambient enum declarations member initializer must be constant expression.")};
        static DiagnosticMessageStore Unexpected_token_A_constructor_method_accessor_or_property_was_expected = {1068, DiagnosticCategory::Error, S("Unexpected_token_A_constructor_method_accessor_or_property_was_expected_1068"), S("Unexpected token. A constructor, method, accessor, or property was expected.")};
        static DiagnosticMessageStore Unexpected_token_A_type_parameter_name_was_expected_without_curly_braces = {1069, DiagnosticCategory::Error, S("Unexpected_token_A_type_parameter_name_was_expected_without_curly_braces_1069"), S("Unexpected token. A type parameter name was expected without curly braces.")};
        static DiagnosticMessageStore _0_modifier_cannot_appear_on_a_type_member = {1070, DiagnosticCategory::Error, S("_0_modifier_cannot_appear_on_a_type_member_1070"), S("'{0}' modifier cannot appear on a type member.")};
        static DiagnosticMessageStore _0_modifier_cannot_appear_on_an_index_signature = {1071, DiagnosticCategory::Error, S("_0_modifier_cannot_appear_on_an_index_signature_1071"), S("'{0}' modifier cannot appear on an index signature.")};
        static DiagnosticMessageStore A_0_modifier_cannot_be_used_with_an_import_declaration = {1079, DiagnosticCategory::Error, S("A_0_modifier_cannot_be_used_with_an_import_declaration_1079"), S("A '{0}' modifier cannot be used with an import declaration.")};
        static DiagnosticMessageStore Invalid_reference_directive_syntax = {1084, DiagnosticCategory::Error, S("Invalid_reference_directive_syntax_1084"), S("Invalid 'reference' directive syntax.")};
        static DiagnosticMessageStore _0_modifier_cannot_appear_on_a_constructor_declaration = {1089, DiagnosticCategory::Error, S("_0_modifier_cannot_appear_on_a_constructor_declaration_1089"), S("'{0}' modifier cannot appear on a constructor declaration.")};
        static DiagnosticMessageStore _0_modifier_cannot_appear_on_a_parameter = {1090, DiagnosticCategory::Error, S("_0_modifier_cannot_appear_on_a_parameter_1090"), S("'{0}' modifier cannot appear on a parameter.")};
        static DiagnosticMessageStore Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement = {1091, DiagnosticCategory::Error, S("Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement_1091"), S("Only a single variable declaration is allowed in a 'for...in' statement.")};
        static DiagnosticMessageStore Type_parameters_cannot_appear_on_a_constructor_declaration = {1092, DiagnosticCategory::Error, S("Type_parameters_cannot_appear_on_a_constructor_declaration_1092"), S("Type parameters cannot appear on a constructor declaration.")};
        static DiagnosticMessageStore Type_annotation_cannot_appear_on_a_constructor_declaration = {1093, DiagnosticCategory::Error, S("Type_annotation_cannot_appear_on_a_constructor_declaration_1093"), S("Type annotation cannot appear on a constructor declaration.")};
        static DiagnosticMessageStore An_accessor_cannot_have_type_parameters = {1094, DiagnosticCategory::Error, S("An_accessor_cannot_have_type_parameters_1094"), S("An accessor cannot have type parameters.")};
        static DiagnosticMessageStore A_set_accessor_cannot_have_a_return_type_annotation = {1095, DiagnosticCategory::Error, S("A_set_accessor_cannot_have_a_return_type_annotation_1095"), S("A 'set' accessor cannot have a return type annotation.")};
        static DiagnosticMessageStore An_index_signature_must_have_exactly_one_parameter = {1096, DiagnosticCategory::Error, S("An_index_signature_must_have_exactly_one_parameter_1096"), S("An index signature must have exactly one parameter.")};
        static DiagnosticMessageStore _0_list_cannot_be_empty = {1097, DiagnosticCategory::Error, S("_0_list_cannot_be_empty_1097"), S("'{0}' list cannot be empty.")};
        static DiagnosticMessageStore Type_parameter_list_cannot_be_empty = {1098, DiagnosticCategory::Error, S("Type_parameter_list_cannot_be_empty_1098"), S("Type parameter list cannot be empty.")};
        static DiagnosticMessageStore Type_argument_list_cannot_be_empty = {1099, DiagnosticCategory::Error, S("Type_argument_list_cannot_be_empty_1099"), S("Type argument list cannot be empty.")};
        static DiagnosticMessageStore Invalid_use_of_0_in_strict_mode = {1100, DiagnosticCategory::Error, S("Invalid_use_of_0_in_strict_mode_1100"), S("Invalid use of '{0}' in strict mode.")};
        static DiagnosticMessageStore with_statements_are_not_allowed_in_strict_mode = {1101, DiagnosticCategory::Error, S("with_statements_are_not_allowed_in_strict_mode_1101"), S("'with' statements are not allowed in strict mode.")};
        static DiagnosticMessageStore delete_cannot_be_called_on_an_identifier_in_strict_mode = {1102, DiagnosticCategory::Error, S("delete_cannot_be_called_on_an_identifier_in_strict_mode_1102"), S("'delete' cannot be called on an identifier in strict mode.")};
        static DiagnosticMessageStore for_await_loops_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules = {1103, DiagnosticCategory::Error, S("for_await_loops_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules_1103"), S("'for await' loops are only allowed within async functions and at the top levels of modules.")};
        static DiagnosticMessageStore A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement = {1104, DiagnosticCategory::Error, S("A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement_1104"), S("A 'continue' statement can only be used within an enclosing iteration statement.")};
        static DiagnosticMessageStore A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement = {1105, DiagnosticCategory::Error, S("A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement_1105"), S("A 'break' statement can only be used within an enclosing iteration or switch statement.")};
        static DiagnosticMessageStore The_left_hand_side_of_a_for_of_statement_may_not_be_async = {1106, DiagnosticCategory::Error, S("The_left_hand_side_of_a_for_of_statement_may_not_be_async_1106"), S("The left-hand side of a 'for...of' statement may not be 'async'.")};
        static DiagnosticMessageStore Jump_target_cannot_cross_function_boundary = {1107, DiagnosticCategory::Error, S("Jump_target_cannot_cross_function_boundary_1107"), S("Jump target cannot cross function boundary.")};
        static DiagnosticMessageStore A_return_statement_can_only_be_used_within_a_function_body = {1108, DiagnosticCategory::Error, S("A_return_statement_can_only_be_used_within_a_function_body_1108"), S("A 'return' statement can only be used within a function body.")};
        static DiagnosticMessageStore Expression_expected = {1109, DiagnosticCategory::Error, S("Expression_expected_1109"), S("Expression expected.")};
        static DiagnosticMessageStore Type_expected = {1110, DiagnosticCategory::Error, S("Type_expected_1110"), S("Type expected.")};
        static DiagnosticMessageStore Private_field_0_must_be_declared_in_an_enclosing_class = {1111, DiagnosticCategory::Error, S("Private_field_0_must_be_declared_in_an_enclosing_class_1111"), S("Private field '{0}' must be declared in an enclosing class.")};
        static DiagnosticMessageStore A_default_clause_cannot_appear_more_than_once_in_a_switch_statement = {1113, DiagnosticCategory::Error, S("A_default_clause_cannot_appear_more_than_once_in_a_switch_statement_1113"), S("A 'default' clause cannot appear more than once in a 'switch' statement.")};
        static DiagnosticMessageStore Duplicate_label_0 = {1114, DiagnosticCategory::Error, S("Duplicate_label_0_1114"), S("Duplicate label '{0}'.")};
        static DiagnosticMessageStore A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement = {1115, DiagnosticCategory::Error, S("A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement_1115"), S("A 'continue' statement can only jump to a label of an enclosing iteration statement.")};
        static DiagnosticMessageStore A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement = {1116, DiagnosticCategory::Error, S("A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement_1116"), S("A 'break' statement can only jump to a label of an enclosing statement.")};
        static DiagnosticMessageStore An_object_literal_cannot_have_multiple_properties_with_the_same_name = {1117, DiagnosticCategory::Error, S("An_object_literal_cannot_have_multiple_properties_with_the_same_name_1117"), S("An object literal cannot have multiple properties with the same name.")};
        static DiagnosticMessageStore An_object_literal_cannot_have_multiple_get_Slashset_accessors_with_the_same_name = {1118, DiagnosticCategory::Error, S("An_object_literal_cannot_have_multiple_get_Slashset_accessors_with_the_same_name_1118"), S("An object literal cannot have multiple get/set accessors with the same name.")};
        static DiagnosticMessageStore An_object_literal_cannot_have_property_and_accessor_with_the_same_name = {1119, DiagnosticCategory::Error, S("An_object_literal_cannot_have_property_and_accessor_with_the_same_name_1119"), S("An object literal cannot have property and accessor with the same name.")};
        static DiagnosticMessageStore An_export_assignment_cannot_have_modifiers = {1120, DiagnosticCategory::Error, S("An_export_assignment_cannot_have_modifiers_1120"), S("An export assignment cannot have modifiers.")};
        static DiagnosticMessageStore Octal_literals_are_not_allowed_Use_the_syntax_0 = {1121, DiagnosticCategory::Error, S("Octal_literals_are_not_allowed_Use_the_syntax_0_1121"), S("Octal literals are not allowed. Use the syntax '{0}'.")};
        static DiagnosticMessageStore Variable_declaration_list_cannot_be_empty = {1123, DiagnosticCategory::Error, S("Variable_declaration_list_cannot_be_empty_1123"), S("Variable declaration list cannot be empty.")};
        static DiagnosticMessageStore Digit_expected = {1124, DiagnosticCategory::Error, S("Digit_expected_1124"), S("Digit expected.")};
        static DiagnosticMessageStore Hexadecimal_digit_expected = {1125, DiagnosticCategory::Error, S("Hexadecimal_digit_expected_1125"), S("Hexadecimal digit expected.")};
        static DiagnosticMessageStore Unexpected_end_of_text = {1126, DiagnosticCategory::Error, S("Unexpected_end_of_text_1126"), S("Unexpected end of text.")};
        static DiagnosticMessageStore Invalid_character = {1127, DiagnosticCategory::Error, S("Invalid_character_1127"), S("Invalid character.")};
        static DiagnosticMessageStore Declaration_or_statement_expected = {1128, DiagnosticCategory::Error, S("Declaration_or_statement_expected_1128"), S("Declaration or statement expected.")};
        static DiagnosticMessageStore Statement_expected = {1129, DiagnosticCategory::Error, S("Statement_expected_1129"), S("Statement expected.")};
        static DiagnosticMessageStore case_or_default_expected = {1130, DiagnosticCategory::Error, S("case_or_default_expected_1130"), S("'case' or 'default' expected.")};
        static DiagnosticMessageStore Property_or_signature_expected = {1131, DiagnosticCategory::Error, S("Property_or_signature_expected_1131"), S("Property or signature expected.")};
        static DiagnosticMessageStore Enum_member_expected = {1132, DiagnosticCategory::Error, S("Enum_member_expected_1132"), S("Enum member expected.")};
        static DiagnosticMessageStore Variable_declaration_expected = {1134, DiagnosticCategory::Error, S("Variable_declaration_expected_1134"), S("Variable declaration expected.")};
        static DiagnosticMessageStore Argument_expression_expected = {1135, DiagnosticCategory::Error, S("Argument_expression_expected_1135"), S("Argument expression expected.")};
        static DiagnosticMessageStore Property_assignment_expected = {1136, DiagnosticCategory::Error, S("Property_assignment_expected_1136"), S("Property assignment expected.")};
        static DiagnosticMessageStore Expression_or_comma_expected = {1137, DiagnosticCategory::Error, S("Expression_or_comma_expected_1137"), S("Expression or comma expected.")};
        static DiagnosticMessageStore Parameter_declaration_expected = {1138, DiagnosticCategory::Error, S("Parameter_declaration_expected_1138"), S("Parameter declaration expected.")};
        static DiagnosticMessageStore Type_parameter_declaration_expected = {1139, DiagnosticCategory::Error, S("Type_parameter_declaration_expected_1139"), S("Type parameter declaration expected.")};
        static DiagnosticMessageStore Type_argument_expected = {1140, DiagnosticCategory::Error, S("Type_argument_expected_1140"), S("Type argument expected.")};
        static DiagnosticMessageStore String_literal_expected = {1141, DiagnosticCategory::Error, S("String_literal_expected_1141"), S("String literal expected.")};
        static DiagnosticMessageStore Line_break_not_permitted_here = {1142, DiagnosticCategory::Error, S("Line_break_not_permitted_here_1142"), S("Line break not permitted here.")};
        static DiagnosticMessageStore or_expected = {1144, DiagnosticCategory::Error, S("or_expected_1144"), S("'{' or ';' expected.")};
        static DiagnosticMessageStore or_JSX_element_expected = {1145, DiagnosticCategory::Error, S("or_JSX_element_expected_1145"), S("'{' or JSX element expected.")};
        static DiagnosticMessageStore Declaration_expected = {1146, DiagnosticCategory::Error, S("Declaration_expected_1146"), S("Declaration expected.")};
        static DiagnosticMessageStore Import_declarations_in_a_namespace_cannot_reference_a_module = {1147, DiagnosticCategory::Error, S("Import_declarations_in_a_namespace_cannot_reference_a_module_1147"), S("Import declarations in a namespace cannot reference a module.")};
        static DiagnosticMessageStore Cannot_use_imports_exports_or_module_augmentations_when_module_is_none = {1148, DiagnosticCategory::Error, S("Cannot_use_imports_exports_or_module_augmentations_when_module_is_none_1148"), S("Cannot use imports, exports, or module augmentations when '--module' is 'none'.")};
        static DiagnosticMessageStore File_name_0_differs_from_already_included_file_name_1_only_in_casing = {1149, DiagnosticCategory::Error, S("File_name_0_differs_from_already_included_file_name_1_only_in_casing_1149"), S("File name '{0}' differs from already included file name '{1}' only in casing.")};
        static DiagnosticMessageStore _0_declarations_must_be_initialized = {1155, DiagnosticCategory::Error, S("_0_declarations_must_be_initialized_1155"), S("'{0}' declarations must be initialized.")};
        static DiagnosticMessageStore _0_declarations_can_only_be_declared_inside_a_block = {1156, DiagnosticCategory::Error, S("_0_declarations_can_only_be_declared_inside_a_block_1156"), S("'{0}' declarations can only be declared inside a block.")};
        static DiagnosticMessageStore Unterminated_template_literal = {1160, DiagnosticCategory::Error, S("Unterminated_template_literal_1160"), S("Unterminated template literal.")};
        static DiagnosticMessageStore Unterminated_regular_expression_literal = {1161, DiagnosticCategory::Error, S("Unterminated_regular_expression_literal_1161"), S("Unterminated regular expression literal.")};
        static DiagnosticMessageStore An_object_member_cannot_be_declared_optional = {1162, DiagnosticCategory::Error, S("An_object_member_cannot_be_declared_optional_1162"), S("An object member cannot be declared optional.")};
        static DiagnosticMessageStore A_yield_expression_is_only_allowed_in_a_generator_body = {1163, DiagnosticCategory::Error, S("A_yield_expression_is_only_allowed_in_a_generator_body_1163"), S("A 'yield' expression is only allowed in a generator body.")};
        static DiagnosticMessageStore Computed_property_names_are_not_allowed_in_enums = {1164, DiagnosticCategory::Error, S("Computed_property_names_are_not_allowed_in_enums_1164"), S("Computed property names are not allowed in enums.")};
        static DiagnosticMessageStore A_computed_property_name_in_an_ambient_context_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type = {1165, DiagnosticCategory::Error, S("A_computed_property_name_in_an_ambient_context_must_refer_to_an_expression_whose_type_is_a_literal_t_1165"), S("A computed property name in an ambient context must refer to an expression whose type is a literal type or a 'unique symbol' type.")};
        static DiagnosticMessageStore A_computed_property_name_in_a_class_property_declaration_must_have_a_simple_literal_type_or_a_unique_symbol_type = {1166, DiagnosticCategory::Error, S("A_computed_property_name_in_a_class_property_declaration_must_have_a_simple_literal_type_or_a_unique_1166"), S("A computed property name in a class property declaration must have a simple literal type or a 'unique symbol' type.")};
        static DiagnosticMessageStore A_computed_property_name_in_a_method_overload_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type = {1168, DiagnosticCategory::Error, S("A_computed_property_name_in_a_method_overload_must_refer_to_an_expression_whose_type_is_a_literal_ty_1168"), S("A computed property name in a method overload must refer to an expression whose type is a literal type or a 'unique symbol' type.")};
        static DiagnosticMessageStore A_computed_property_name_in_an_interface_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type = {1169, DiagnosticCategory::Error, S("A_computed_property_name_in_an_interface_must_refer_to_an_expression_whose_type_is_a_literal_type_or_1169"), S("A computed property name in an interface must refer to an expression whose type is a literal type or a 'unique symbol' type.")};
        static DiagnosticMessageStore A_computed_property_name_in_a_type_literal_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type = {1170, DiagnosticCategory::Error, S("A_computed_property_name_in_a_type_literal_must_refer_to_an_expression_whose_type_is_a_literal_type__1170"), S("A computed property name in a type literal must refer to an expression whose type is a literal type or a 'unique symbol' type.")};
        static DiagnosticMessageStore A_comma_expression_is_not_allowed_in_a_computed_property_name = {1171, DiagnosticCategory::Error, S("A_comma_expression_is_not_allowed_in_a_computed_property_name_1171"), S("A comma expression is not allowed in a computed property name.")};
        static DiagnosticMessageStore extends_clause_already_seen = {1172, DiagnosticCategory::Error, S("extends_clause_already_seen_1172"), S("'extends' clause already seen.")};
        static DiagnosticMessageStore extends_clause_must_precede_implements_clause = {1173, DiagnosticCategory::Error, S("extends_clause_must_precede_implements_clause_1173"), S("'extends' clause must precede 'implements' clause.")};
        static DiagnosticMessageStore Classes_can_only_extend_a_single_class = {1174, DiagnosticCategory::Error, S("Classes_can_only_extend_a_single_class_1174"), S("Classes can only extend a single class.")};
        static DiagnosticMessageStore implements_clause_already_seen = {1175, DiagnosticCategory::Error, S("implements_clause_already_seen_1175"), S("'implements' clause already seen.")};
        static DiagnosticMessageStore Interface_declaration_cannot_have_implements_clause = {1176, DiagnosticCategory::Error, S("Interface_declaration_cannot_have_implements_clause_1176"), S("Interface declaration cannot have 'implements' clause.")};
        static DiagnosticMessageStore Binary_digit_expected = {1177, DiagnosticCategory::Error, S("Binary_digit_expected_1177"), S("Binary digit expected.")};
        static DiagnosticMessageStore Octal_digit_expected = {1178, DiagnosticCategory::Error, S("Octal_digit_expected_1178"), S("Octal digit expected.")};
        static DiagnosticMessageStore Unexpected_token_expected = {1179, DiagnosticCategory::Error, S("Unexpected_token_expected_1179"), S("Unexpected token. '{' expected.")};
        static DiagnosticMessageStore Property_destructuring_pattern_expected = {1180, DiagnosticCategory::Error, S("Property_destructuring_pattern_expected_1180"), S("Property destructuring pattern expected.")};
        static DiagnosticMessageStore Array_element_destructuring_pattern_expected = {1181, DiagnosticCategory::Error, S("Array_element_destructuring_pattern_expected_1181"), S("Array element destructuring pattern expected.")};
        static DiagnosticMessageStore A_destructuring_declaration_must_have_an_initializer = {1182, DiagnosticCategory::Error, S("A_destructuring_declaration_must_have_an_initializer_1182"), S("A destructuring declaration must have an initializer.")};
        static DiagnosticMessageStore An_implementation_cannot_be_declared_in_ambient_contexts = {1183, DiagnosticCategory::Error, S("An_implementation_cannot_be_declared_in_ambient_contexts_1183"), S("An implementation cannot be declared in ambient contexts.")};
        static DiagnosticMessageStore Modifiers_cannot_appear_here = {1184, DiagnosticCategory::Error, S("Modifiers_cannot_appear_here_1184"), S("Modifiers cannot appear here.")};
        static DiagnosticMessageStore Merge_conflict_marker_encountered = {1185, DiagnosticCategory::Error, S("Merge_conflict_marker_encountered_1185"), S("Merge conflict marker encountered.")};
        static DiagnosticMessageStore A_rest_element_cannot_have_an_initializer = {1186, DiagnosticCategory::Error, S("A_rest_element_cannot_have_an_initializer_1186"), S("A rest element cannot have an initializer.")};
        static DiagnosticMessageStore A_parameter_property_may_not_be_declared_using_a_binding_pattern = {1187, DiagnosticCategory::Error, S("A_parameter_property_may_not_be_declared_using_a_binding_pattern_1187"), S("A parameter property may not be declared using a binding pattern.")};
        static DiagnosticMessageStore Only_a_single_variable_declaration_is_allowed_in_a_for_of_statement = {1188, DiagnosticCategory::Error, S("Only_a_single_variable_declaration_is_allowed_in_a_for_of_statement_1188"), S("Only a single variable declaration is allowed in a 'for...of' statement.")};
        static DiagnosticMessageStore The_variable_declaration_of_a_for_in_statement_cannot_have_an_initializer = {1189, DiagnosticCategory::Error, S("The_variable_declaration_of_a_for_in_statement_cannot_have_an_initializer_1189"), S("The variable declaration of a 'for...in' statement cannot have an initializer.")};
        static DiagnosticMessageStore The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer = {1190, DiagnosticCategory::Error, S("The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer_1190"), S("The variable declaration of a 'for...of' statement cannot have an initializer.")};
        static DiagnosticMessageStore An_import_declaration_cannot_have_modifiers = {1191, DiagnosticCategory::Error, S("An_import_declaration_cannot_have_modifiers_1191"), S("An import declaration cannot have modifiers.")};
        static DiagnosticMessageStore Module_0_has_no_default_export = {1192, DiagnosticCategory::Error, S("Module_0_has_no_default_export_1192"), S("Module '{0}' has no default export.")};
        static DiagnosticMessageStore An_export_declaration_cannot_have_modifiers = {1193, DiagnosticCategory::Error, S("An_export_declaration_cannot_have_modifiers_1193"), S("An export declaration cannot have modifiers.")};
        static DiagnosticMessageStore Export_declarations_are_not_permitted_in_a_namespace = {1194, DiagnosticCategory::Error, S("Export_declarations_are_not_permitted_in_a_namespace_1194"), S("Export declarations are not permitted in a namespace.")};
        static DiagnosticMessageStore export_Asterisk_does_not_re_export_a_default = {1195, DiagnosticCategory::Error, S("export_Asterisk_does_not_re_export_a_default_1195"), S("'export *' does not re-export a default.")};
        static DiagnosticMessageStore Catch_clause_variable_type_annotation_must_be_any_or_unknown_if_specified = {1196, DiagnosticCategory::Error, S("Catch_clause_variable_type_annotation_must_be_any_or_unknown_if_specified_1196"), S("Catch clause variable type annotation must be 'any' or 'unknown' if specified.")};
        static DiagnosticMessageStore Catch_clause_variable_cannot_have_an_initializer = {1197, DiagnosticCategory::Error, S("Catch_clause_variable_cannot_have_an_initializer_1197"), S("Catch clause variable cannot have an initializer.")};
        static DiagnosticMessageStore An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive = {1198, DiagnosticCategory::Error, S("An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive_1198"), S("An extended Unicode escape value must be between 0x0 and 0x10FFFF inclusive.")};
        static DiagnosticMessageStore Unterminated_Unicode_escape_sequence = {1199, DiagnosticCategory::Error, S("Unterminated_Unicode_escape_sequence_1199"), S("Unterminated Unicode escape sequence.")};
        static DiagnosticMessageStore Line_terminator_not_permitted_before_arrow = {1200, DiagnosticCategory::Error, S("Line_terminator_not_permitted_before_arrow_1200"), S("Line terminator not permitted before arrow.")};
        static DiagnosticMessageStore Import_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_import_Asterisk_as_ns_from_mod_import_a_from_mod_import_d_from_mod_or_another_module_format_instead = {1202, DiagnosticCategory::Error, S("Import_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_import_Asterisk_as_1202"), S("Import assignment cannot be used when targeting ECMAScript modules. Consider using 'import * as ns from \"mod\"', 'import {a} from \"mod\"', 'import d from \"mod\"', or another module format instead.")};
        static DiagnosticMessageStore Export_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_export_default_or_another_module_format_instead = {1203, DiagnosticCategory::Error, S("Export_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_export_default_or__1203"), S("Export assignment cannot be used when targeting ECMAScript modules. Consider using 'export default' or another module format instead.")};
        static DiagnosticMessageStore Re_exporting_a_type_when_0_is_enabled_requires_using_export_type = {1205, DiagnosticCategory::Error, S("Re_exporting_a_type_when_0_is_enabled_requires_using_export_type_1205"), S("Re-exporting a type when '{0}' is enabled requires using 'export type'.")};
        static DiagnosticMessageStore Decorators_are_not_valid_here = {1206, DiagnosticCategory::Error, S("Decorators_are_not_valid_here_1206"), S("Decorators are not valid here.")};
        static DiagnosticMessageStore Decorators_cannot_be_applied_to_multiple_get_Slashset_accessors_of_the_same_name = {1207, DiagnosticCategory::Error, S("Decorators_cannot_be_applied_to_multiple_get_Slashset_accessors_of_the_same_name_1207"), S("Decorators cannot be applied to multiple get/set accessors of the same name.")};
        static DiagnosticMessageStore Invalid_optional_chain_from_new_expression_Did_you_mean_to_call_0 = {1209, DiagnosticCategory::Error, S("Invalid_optional_chain_from_new_expression_Did_you_mean_to_call_0_1209"), S("Invalid optional chain from new expression. Did you mean to call '{0}()'?")};
        static DiagnosticMessageStore Code_contained_in_a_class_is_evaluated_in_JavaScript_s_strict_mode_which_does_not_allow_this_use_of_0_For_more_information_see_https_Colon_Slash_Slashdeveloper_mozilla_org_Slashen_US_Slashdocs_SlashWeb_SlashJavaScript_SlashReference_SlashStrict_mode = {1210, DiagnosticCategory::Error, S("Code_contained_in_a_class_is_evaluated_in_JavaScript_s_strict_mode_which_does_not_allow_this_use_of__1210"), S("Code contained in a class is evaluated in JavaScript's strict mode which does not allow this use of '{0}'. For more information, see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode.")};
        static DiagnosticMessageStore A_class_declaration_without_the_default_modifier_must_have_a_name = {1211, DiagnosticCategory::Error, S("A_class_declaration_without_the_default_modifier_must_have_a_name_1211"), S("A class declaration without the 'default' modifier must have a name.")};
        static DiagnosticMessageStore Identifier_expected_0_is_a_reserved_word_in_strict_mode = {1212, DiagnosticCategory::Error, S("Identifier_expected_0_is_a_reserved_word_in_strict_mode_1212"), S("Identifier expected. '{0}' is a reserved word in strict mode.")};
        static DiagnosticMessageStore Identifier_expected_0_is_a_reserved_word_in_strict_mode_Class_definitions_are_automatically_in_strict_mode = {1213, DiagnosticCategory::Error, S("Identifier_expected_0_is_a_reserved_word_in_strict_mode_Class_definitions_are_automatically_in_stric_1213"), S("Identifier expected. '{0}' is a reserved word in strict mode. Class definitions are automatically in strict mode.")};
        static DiagnosticMessageStore Identifier_expected_0_is_a_reserved_word_in_strict_mode_Modules_are_automatically_in_strict_mode = {1214, DiagnosticCategory::Error, S("Identifier_expected_0_is_a_reserved_word_in_strict_mode_Modules_are_automatically_in_strict_mode_1214"), S("Identifier expected. '{0}' is a reserved word in strict mode. Modules are automatically in strict mode.")};
        static DiagnosticMessageStore Invalid_use_of_0_Modules_are_automatically_in_strict_mode = {1215, DiagnosticCategory::Error, S("Invalid_use_of_0_Modules_are_automatically_in_strict_mode_1215"), S("Invalid use of '{0}'. Modules are automatically in strict mode.")};
        static DiagnosticMessageStore Identifier_expected_esModule_is_reserved_as_an_exported_marker_when_transforming_ECMAScript_modules = {1216, DiagnosticCategory::Error, S("Identifier_expected_esModule_is_reserved_as_an_exported_marker_when_transforming_ECMAScript_modules_1216"), S("Identifier expected. '__esModule' is reserved as an exported marker when transforming ECMAScript modules.")};
        static DiagnosticMessageStore Export_assignment_is_not_supported_when_module_flag_is_system = {1218, DiagnosticCategory::Error, S("Export_assignment_is_not_supported_when_module_flag_is_system_1218"), S("Export assignment is not supported when '--module' flag is 'system'.")};
        static DiagnosticMessageStore Generators_are_not_allowed_in_an_ambient_context = {1221, DiagnosticCategory::Error, S("Generators_are_not_allowed_in_an_ambient_context_1221"), S("Generators are not allowed in an ambient context.")};
        static DiagnosticMessageStore An_overload_signature_cannot_be_declared_as_a_generator = {1222, DiagnosticCategory::Error, S("An_overload_signature_cannot_be_declared_as_a_generator_1222"), S("An overload signature cannot be declared as a generator.")};
        static DiagnosticMessageStore _0_tag_already_specified = {1223, DiagnosticCategory::Error, S("_0_tag_already_specified_1223"), S("'{0}' tag already specified.")};
        static DiagnosticMessageStore Signature_0_must_be_a_type_predicate = {1224, DiagnosticCategory::Error, S("Signature_0_must_be_a_type_predicate_1224"), S("Signature '{0}' must be a type predicate.")};
        static DiagnosticMessageStore Cannot_find_parameter_0 = {1225, DiagnosticCategory::Error, S("Cannot_find_parameter_0_1225"), S("Cannot find parameter '{0}'.")};
        static DiagnosticMessageStore Type_predicate_0_is_not_assignable_to_1 = {1226, DiagnosticCategory::Error, S("Type_predicate_0_is_not_assignable_to_1_1226"), S("Type predicate '{0}' is not assignable to '{1}'.")};
        static DiagnosticMessageStore Parameter_0_is_not_in_the_same_position_as_parameter_1 = {1227, DiagnosticCategory::Error, S("Parameter_0_is_not_in_the_same_position_as_parameter_1_1227"), S("Parameter '{0}' is not in the same position as parameter '{1}'.")};
        static DiagnosticMessageStore A_type_predicate_is_only_allowed_in_return_type_position_for_functions_and_methods = {1228, DiagnosticCategory::Error, S("A_type_predicate_is_only_allowed_in_return_type_position_for_functions_and_methods_1228"), S("A type predicate is only allowed in return type position for functions and methods.")};
        static DiagnosticMessageStore A_type_predicate_cannot_reference_a_rest_parameter = {1229, DiagnosticCategory::Error, S("A_type_predicate_cannot_reference_a_rest_parameter_1229"), S("A type predicate cannot reference a rest parameter.")};
        static DiagnosticMessageStore A_type_predicate_cannot_reference_element_0_in_a_binding_pattern = {1230, DiagnosticCategory::Error, S("A_type_predicate_cannot_reference_element_0_in_a_binding_pattern_1230"), S("A type predicate cannot reference element '{0}' in a binding pattern.")};
        static DiagnosticMessageStore An_export_assignment_must_be_at_the_top_level_of_a_file_or_module_declaration = {1231, DiagnosticCategory::Error, S("An_export_assignment_must_be_at_the_top_level_of_a_file_or_module_declaration_1231"), S("An export assignment must be at the top level of a file or module declaration.")};
        static DiagnosticMessageStore An_import_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module = {1232, DiagnosticCategory::Error, S("An_import_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module_1232"), S("An import declaration can only be used at the top level of a namespace or module.")};
        static DiagnosticMessageStore An_export_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module = {1233, DiagnosticCategory::Error, S("An_export_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module_1233"), S("An export declaration can only be used at the top level of a namespace or module.")};
        static DiagnosticMessageStore An_ambient_module_declaration_is_only_allowed_at_the_top_level_in_a_file = {1234, DiagnosticCategory::Error, S("An_ambient_module_declaration_is_only_allowed_at_the_top_level_in_a_file_1234"), S("An ambient module declaration is only allowed at the top level in a file.")};
        static DiagnosticMessageStore A_namespace_declaration_is_only_allowed_at_the_top_level_of_a_namespace_or_module = {1235, DiagnosticCategory::Error, S("A_namespace_declaration_is_only_allowed_at_the_top_level_of_a_namespace_or_module_1235"), S("A namespace declaration is only allowed at the top level of a namespace or module.")};
        static DiagnosticMessageStore The_return_type_of_a_property_decorator_function_must_be_either_void_or_any = {1236, DiagnosticCategory::Error, S("The_return_type_of_a_property_decorator_function_must_be_either_void_or_any_1236"), S("The return type of a property decorator function must be either 'void' or 'any'.")};
        static DiagnosticMessageStore The_return_type_of_a_parameter_decorator_function_must_be_either_void_or_any = {1237, DiagnosticCategory::Error, S("The_return_type_of_a_parameter_decorator_function_must_be_either_void_or_any_1237"), S("The return type of a parameter decorator function must be either 'void' or 'any'.")};
        static DiagnosticMessageStore Unable_to_resolve_signature_of_class_decorator_when_called_as_an_expression = {1238, DiagnosticCategory::Error, S("Unable_to_resolve_signature_of_class_decorator_when_called_as_an_expression_1238"), S("Unable to resolve signature of class decorator when called as an expression.")};
        static DiagnosticMessageStore Unable_to_resolve_signature_of_parameter_decorator_when_called_as_an_expression = {1239, DiagnosticCategory::Error, S("Unable_to_resolve_signature_of_parameter_decorator_when_called_as_an_expression_1239"), S("Unable to resolve signature of parameter decorator when called as an expression.")};
        static DiagnosticMessageStore Unable_to_resolve_signature_of_property_decorator_when_called_as_an_expression = {1240, DiagnosticCategory::Error, S("Unable_to_resolve_signature_of_property_decorator_when_called_as_an_expression_1240"), S("Unable to resolve signature of property decorator when called as an expression.")};
        static DiagnosticMessageStore Unable_to_resolve_signature_of_method_decorator_when_called_as_an_expression = {1241, DiagnosticCategory::Error, S("Unable_to_resolve_signature_of_method_decorator_when_called_as_an_expression_1241"), S("Unable to resolve signature of method decorator when called as an expression.")};
        static DiagnosticMessageStore abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration = {1242, DiagnosticCategory::Error, S("abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration_1242"), S("'abstract' modifier can only appear on a class, method, or property declaration.")};
        static DiagnosticMessageStore _0_modifier_cannot_be_used_with_1_modifier = {1243, DiagnosticCategory::Error, S("_0_modifier_cannot_be_used_with_1_modifier_1243"), S("'{0}' modifier cannot be used with '{1}' modifier.")};
        static DiagnosticMessageStore Abstract_methods_can_only_appear_within_an_abstract_class = {1244, DiagnosticCategory::Error, S("Abstract_methods_can_only_appear_within_an_abstract_class_1244"), S("Abstract methods can only appear within an abstract class.")};
        static DiagnosticMessageStore Method_0_cannot_have_an_implementation_because_it_is_marked_abstract = {1245, DiagnosticCategory::Error, S("Method_0_cannot_have_an_implementation_because_it_is_marked_abstract_1245"), S("Method '{0}' cannot have an implementation because it is marked abstract.")};
        static DiagnosticMessageStore An_interface_property_cannot_have_an_initializer = {1246, DiagnosticCategory::Error, S("An_interface_property_cannot_have_an_initializer_1246"), S("An interface property cannot have an initializer.")};
        static DiagnosticMessageStore A_type_literal_property_cannot_have_an_initializer = {1247, DiagnosticCategory::Error, S("A_type_literal_property_cannot_have_an_initializer_1247"), S("A type literal property cannot have an initializer.")};
        static DiagnosticMessageStore A_class_member_cannot_have_the_0_keyword = {1248, DiagnosticCategory::Error, S("A_class_member_cannot_have_the_0_keyword_1248"), S("A class member cannot have the '{0}' keyword.")};
        static DiagnosticMessageStore A_decorator_can_only_decorate_a_method_implementation_not_an_overload = {1249, DiagnosticCategory::Error, S("A_decorator_can_only_decorate_a_method_implementation_not_an_overload_1249"), S("A decorator can only decorate a method implementation, not an overload.")};
        static DiagnosticMessageStore Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5 = {1250, DiagnosticCategory::Error, S("Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5_1250"), S("Function declarations are not allowed inside blocks in strict mode when targeting 'ES3' or 'ES5'.")};
        static DiagnosticMessageStore Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5_Class_definitions_are_automatically_in_strict_mode = {1251, DiagnosticCategory::Error, S("Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5_Class_d_1251"), S("Function declarations are not allowed inside blocks in strict mode when targeting 'ES3' or 'ES5'. Class definitions are automatically in strict mode.")};
        static DiagnosticMessageStore Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5_Modules_are_automatically_in_strict_mode = {1252, DiagnosticCategory::Error, S("Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5_Modules_1252"), S("Function declarations are not allowed inside blocks in strict mode when targeting 'ES3' or 'ES5'. Modules are automatically in strict mode.")};
        static DiagnosticMessageStore Abstract_properties_can_only_appear_within_an_abstract_class = {1253, DiagnosticCategory::Error, S("Abstract_properties_can_only_appear_within_an_abstract_class_1253"), S("Abstract properties can only appear within an abstract class.")};
        static DiagnosticMessageStore A_const_initializer_in_an_ambient_context_must_be_a_string_or_numeric_literal_or_literal_enum_reference = {1254, DiagnosticCategory::Error, S("A_const_initializer_in_an_ambient_context_must_be_a_string_or_numeric_literal_or_literal_enum_refere_1254"), S("A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.")};
        static DiagnosticMessageStore A_definite_assignment_assertion_is_not_permitted_in_this_context = {1255, DiagnosticCategory::Error, S("A_definite_assignment_assertion_is_not_permitted_in_this_context_1255"), S("A definite assignment assertion '!' is not permitted in this context.")};
        static DiagnosticMessageStore A_required_element_cannot_follow_an_optional_element = {1257, DiagnosticCategory::Error, S("A_required_element_cannot_follow_an_optional_element_1257"), S("A required element cannot follow an optional element.")};
        static DiagnosticMessageStore A_default_export_must_be_at_the_top_level_of_a_file_or_module_declaration = {1258, DiagnosticCategory::Error, S("A_default_export_must_be_at_the_top_level_of_a_file_or_module_declaration_1258"), S("A default export must be at the top level of a file or module declaration.")};
        static DiagnosticMessageStore Module_0_can_only_be_default_imported_using_the_1_flag = {1259, DiagnosticCategory::Error, S("Module_0_can_only_be_default_imported_using_the_1_flag_1259"), S("Module '{0}' can only be default-imported using the '{1}' flag")};
        static DiagnosticMessageStore Keywords_cannot_contain_escape_characters = {1260, DiagnosticCategory::Error, S("Keywords_cannot_contain_escape_characters_1260"), S("Keywords cannot contain escape characters.")};
        static DiagnosticMessageStore Already_included_file_name_0_differs_from_file_name_1_only_in_casing = {1261, DiagnosticCategory::Error, S("Already_included_file_name_0_differs_from_file_name_1_only_in_casing_1261"), S("Already included file name '{0}' differs from file name '{1}' only in casing.")};
        static DiagnosticMessageStore Identifier_expected_0_is_a_reserved_word_at_the_top_level_of_a_module = {1262, DiagnosticCategory::Error, S("Identifier_expected_0_is_a_reserved_word_at_the_top_level_of_a_module_1262"), S("Identifier expected. '{0}' is a reserved word at the top-level of a module.")};
        static DiagnosticMessageStore Declarations_with_initializers_cannot_also_have_definite_assignment_assertions = {1263, DiagnosticCategory::Error, S("Declarations_with_initializers_cannot_also_have_definite_assignment_assertions_1263"), S("Declarations with initializers cannot also have definite assignment assertions.")};
        static DiagnosticMessageStore Declarations_with_definite_assignment_assertions_must_also_have_type_annotations = {1264, DiagnosticCategory::Error, S("Declarations_with_definite_assignment_assertions_must_also_have_type_annotations_1264"), S("Declarations with definite assignment assertions must also have type annotations.")};
        static DiagnosticMessageStore A_rest_element_cannot_follow_another_rest_element = {1265, DiagnosticCategory::Error, S("A_rest_element_cannot_follow_another_rest_element_1265"), S("A rest element cannot follow another rest element.")};
        static DiagnosticMessageStore An_optional_element_cannot_follow_a_rest_element = {1266, DiagnosticCategory::Error, S("An_optional_element_cannot_follow_a_rest_element_1266"), S("An optional element cannot follow a rest element.")};
        static DiagnosticMessageStore Property_0_cannot_have_an_initializer_because_it_is_marked_abstract = {1267, DiagnosticCategory::Error, S("Property_0_cannot_have_an_initializer_because_it_is_marked_abstract_1267"), S("Property '{0}' cannot have an initializer because it is marked abstract.")};
        static DiagnosticMessageStore An_index_signature_parameter_type_must_be_string_number_symbol_or_a_template_literal_type = {1268, DiagnosticCategory::Error, S("An_index_signature_parameter_type_must_be_string_number_symbol_or_a_template_literal_type_1268"), S("An index signature parameter type must be 'string', 'number', 'symbol', or a template literal type.")};
        static DiagnosticMessageStore Cannot_use_export_import_on_a_type_or_type_only_namespace_when_0_is_enabled = {1269, DiagnosticCategory::Error, S("Cannot_use_export_import_on_a_type_or_type_only_namespace_when_0_is_enabled_1269"), S("Cannot use 'export import' on a type or type-only namespace when '{0}' is enabled.")};
        static DiagnosticMessageStore Decorator_function_return_type_0_is_not_assignable_to_type_1 = {1270, DiagnosticCategory::Error, S("Decorator_function_return_type_0_is_not_assignable_to_type_1_1270"), S("Decorator function return type '{0}' is not assignable to type '{1}'.")};
        static DiagnosticMessageStore Decorator_function_return_type_is_0_but_is_expected_to_be_void_or_any = {1271, DiagnosticCategory::Error, S("Decorator_function_return_type_is_0_but_is_expected_to_be_void_or_any_1271"), S("Decorator function return type is '{0}' but is expected to be 'void' or 'any'.")};
        static DiagnosticMessageStore A_type_referenced_in_a_decorated_signature_must_be_imported_with_import_type_or_a_namespace_import_when_isolatedModules_and_emitDecoratorMetadata_are_enabled = {1272, DiagnosticCategory::Error, S("A_type_referenced_in_a_decorated_signature_must_be_imported_with_import_type_or_a_namespace_import_w_1272"), S("A type referenced in a decorated signature must be imported with 'import type' or a namespace import when 'isolatedModules' and 'emitDecoratorMetadata' are enabled.")};
        static DiagnosticMessageStore _0_modifier_cannot_appear_on_a_type_parameter = {1273, DiagnosticCategory::Error, S("_0_modifier_cannot_appear_on_a_type_parameter_1273"), S("'{0}' modifier cannot appear on a type parameter")};
        static DiagnosticMessageStore _0_modifier_can_only_appear_on_a_type_parameter_of_a_class_interface_or_type_alias = {1274, DiagnosticCategory::Error, S("_0_modifier_can_only_appear_on_a_type_parameter_of_a_class_interface_or_type_alias_1274"), S("'{0}' modifier can only appear on a type parameter of a class, interface or type alias")};
        static DiagnosticMessageStore accessor_modifier_can_only_appear_on_a_property_declaration = {1275, DiagnosticCategory::Error, S("accessor_modifier_can_only_appear_on_a_property_declaration_1275"), S("'accessor' modifier can only appear on a property declaration.")};
        static DiagnosticMessageStore An_accessor_property_cannot_be_declared_optional = {1276, DiagnosticCategory::Error, S("An_accessor_property_cannot_be_declared_optional_1276"), S("An 'accessor' property cannot be declared optional.")};
        static DiagnosticMessageStore _0_modifier_can_only_appear_on_a_type_parameter_of_a_function_method_or_class = {1277, DiagnosticCategory::Error, S("_0_modifier_can_only_appear_on_a_type_parameter_of_a_function_method_or_class_1277"), S("'{0}' modifier can only appear on a type parameter of a function, method or class")};
        static DiagnosticMessageStore The_runtime_will_invoke_the_decorator_with_1_arguments_but_the_decorator_expects_0 = {1278, DiagnosticCategory::Error, S("The_runtime_will_invoke_the_decorator_with_1_arguments_but_the_decorator_expects_0_1278"), S("The runtime will invoke the decorator with {1} arguments, but the decorator expects {0}.")};
        static DiagnosticMessageStore The_runtime_will_invoke_the_decorator_with_1_arguments_but_the_decorator_expects_at_least_0 = {1279, DiagnosticCategory::Error, S("The_runtime_will_invoke_the_decorator_with_1_arguments_but_the_decorator_expects_at_least_0_1279"), S("The runtime will invoke the decorator with {1} arguments, but the decorator expects at least {0}.")};
        static DiagnosticMessageStore Namespaces_are_not_allowed_in_global_script_files_when_0_is_enabled_If_this_file_is_not_intended_to_be_a_global_script_set_moduleDetection_to_force_or_add_an_empty_export_statement = {1280, DiagnosticCategory::Error, S("Namespaces_are_not_allowed_in_global_script_files_when_0_is_enabled_If_this_file_is_not_intended_to__1280"), S("Namespaces are not allowed in global script files when '{0}' is enabled. If this file is not intended to be a global script, set 'moduleDetection' to 'force' or add an empty 'export {}' statement.")};
        static DiagnosticMessageStore Cannot_access_0_from_another_file_without_qualification_when_1_is_enabled_Use_2_instead = {1281, DiagnosticCategory::Error, S("Cannot_access_0_from_another_file_without_qualification_when_1_is_enabled_Use_2_instead_1281"), S("Cannot access '{0}' from another file without qualification when '{1}' is enabled. Use '{2}' instead.")};
        static DiagnosticMessageStore An_export_declaration_must_reference_a_value_when_verbatimModuleSyntax_is_enabled_but_0_only_refers_to_a_type = {1282, DiagnosticCategory::Error, S("An_export_declaration_must_reference_a_value_when_verbatimModuleSyntax_is_enabled_but_0_only_refers__1282"), S("An 'export =' declaration must reference a value when 'verbatimModuleSyntax' is enabled, but '{0}' only refers to a type.")};
        static DiagnosticMessageStore An_export_declaration_must_reference_a_real_value_when_verbatimModuleSyntax_is_enabled_but_0_resolves_to_a_type_only_declaration = {1283, DiagnosticCategory::Error, S("An_export_declaration_must_reference_a_real_value_when_verbatimModuleSyntax_is_enabled_but_0_resolve_1283"), S("An 'export =' declaration must reference a real value when 'verbatimModuleSyntax' is enabled, but '{0}' resolves to a type-only declaration.")};
        static DiagnosticMessageStore An_export_default_must_reference_a_value_when_verbatimModuleSyntax_is_enabled_but_0_only_refers_to_a_type = {1284, DiagnosticCategory::Error, S("An_export_default_must_reference_a_value_when_verbatimModuleSyntax_is_enabled_but_0_only_refers_to_a_1284"), S("An 'export default' must reference a value when 'verbatimModuleSyntax' is enabled, but '{0}' only refers to a type.")};
        static DiagnosticMessageStore An_export_default_must_reference_a_real_value_when_verbatimModuleSyntax_is_enabled_but_0_resolves_to_a_type_only_declaration = {1285, DiagnosticCategory::Error, S("An_export_default_must_reference_a_real_value_when_verbatimModuleSyntax_is_enabled_but_0_resolves_to_1285"), S("An 'export default' must reference a real value when 'verbatimModuleSyntax' is enabled, but '{0}' resolves to a type-only declaration.")};
        static DiagnosticMessageStore ESM_syntax_is_not_allowed_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled = {1286, DiagnosticCategory::Error, S("ESM_syntax_is_not_allowed_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled_1286"), S("ESM syntax is not allowed in a CommonJS module when 'verbatimModuleSyntax' is enabled.")};
        static DiagnosticMessageStore A_top_level_export_modifier_cannot_be_used_on_value_declarations_in_a_CommonJS_module_when_verbatimModuleSyntax_is_enabled = {1287, DiagnosticCategory::Error, S("A_top_level_export_modifier_cannot_be_used_on_value_declarations_in_a_CommonJS_module_when_verbatimM_1287"), S("A top-level 'export' modifier cannot be used on value declarations in a CommonJS module when 'verbatimModuleSyntax' is enabled.")};
        static DiagnosticMessageStore An_import_alias_cannot_resolve_to_a_type_or_type_only_declaration_when_verbatimModuleSyntax_is_enabled = {1288, DiagnosticCategory::Error, S("An_import_alias_cannot_resolve_to_a_type_or_type_only_declaration_when_verbatimModuleSyntax_is_enabl_1288"), S("An import alias cannot resolve to a type or type-only declaration when 'verbatimModuleSyntax' is enabled.")};
        static DiagnosticMessageStore with_statements_are_not_allowed_in_an_async_function_block = {1300, DiagnosticCategory::Error, S("with_statements_are_not_allowed_in_an_async_function_block_1300"), S("'with' statements are not allowed in an async function block.")};
        static DiagnosticMessageStore await_expressions_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules = {1308, DiagnosticCategory::Error, S("await_expressions_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules_1308"), S("'await' expressions are only allowed within async functions and at the top levels of modules.")};
        static DiagnosticMessageStore The_current_file_is_a_CommonJS_module_and_cannot_use_await_at_the_top_level = {1309, DiagnosticCategory::Error, S("The_current_file_is_a_CommonJS_module_and_cannot_use_await_at_the_top_level_1309"), S("The current file is a CommonJS module and cannot use 'await' at the top level.")};
        static DiagnosticMessageStore Did_you_mean_to_use_a_Colon_An_can_only_follow_a_property_name_when_the_containing_object_literal_is_part_of_a_destructuring_pattern = {1312, DiagnosticCategory::Error, S("Did_you_mean_to_use_a_Colon_An_can_only_follow_a_property_name_when_the_containing_object_literal_is_1312"), S("Did you mean to use a ':'? An '=' can only follow a property name when the containing object literal is part of a destructuring pattern.")};
        static DiagnosticMessageStore The_body_of_an_if_statement_cannot_be_the_empty_statement = {1313, DiagnosticCategory::Error, S("The_body_of_an_if_statement_cannot_be_the_empty_statement_1313"), S("The body of an 'if' statement cannot be the empty statement.")};
        static DiagnosticMessageStore Global_module_exports_may_only_appear_in_module_files = {1314, DiagnosticCategory::Error, S("Global_module_exports_may_only_appear_in_module_files_1314"), S("Global module exports may only appear in module files.")};
        static DiagnosticMessageStore Global_module_exports_may_only_appear_in_declaration_files = {1315, DiagnosticCategory::Error, S("Global_module_exports_may_only_appear_in_declaration_files_1315"), S("Global module exports may only appear in declaration files.")};
        static DiagnosticMessageStore Global_module_exports_may_only_appear_at_top_level = {1316, DiagnosticCategory::Error, S("Global_module_exports_may_only_appear_at_top_level_1316"), S("Global module exports may only appear at top level.")};
        static DiagnosticMessageStore A_parameter_property_cannot_be_declared_using_a_rest_parameter = {1317, DiagnosticCategory::Error, S("A_parameter_property_cannot_be_declared_using_a_rest_parameter_1317"), S("A parameter property cannot be declared using a rest parameter.")};
        static DiagnosticMessageStore An_abstract_accessor_cannot_have_an_implementation = {1318, DiagnosticCategory::Error, S("An_abstract_accessor_cannot_have_an_implementation_1318"), S("An abstract accessor cannot have an implementation.")};
        static DiagnosticMessageStore A_default_export_can_only_be_used_in_an_ECMAScript_style_module = {1319, DiagnosticCategory::Error, S("A_default_export_can_only_be_used_in_an_ECMAScript_style_module_1319"), S("A default export can only be used in an ECMAScript-style module.")};
        static DiagnosticMessageStore Type_of_await_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member = {1320, DiagnosticCategory::Error, S("Type_of_await_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member_1320"), S("Type of 'await' operand must either be a valid promise or must not contain a callable 'then' member.")};
        static DiagnosticMessageStore Type_of_yield_operand_in_an_async_generator_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member = {1321, DiagnosticCategory::Error, S("Type_of_yield_operand_in_an_async_generator_must_either_be_a_valid_promise_or_must_not_contain_a_cal_1321"), S("Type of 'yield' operand in an async generator must either be a valid promise or must not contain a callable 'then' member.")};
        static DiagnosticMessageStore Type_of_iterated_elements_of_a_yield_Asterisk_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member = {1322, DiagnosticCategory::Error, S("Type_of_iterated_elements_of_a_yield_Asterisk_operand_must_either_be_a_valid_promise_or_must_not_con_1322"), S("Type of iterated elements of a 'yield*' operand must either be a valid promise or must not contain a callable 'then' member.")};
        static DiagnosticMessageStore Dynamic_imports_are_only_supported_when_the_module_flag_is_set_to_es2020_es2022_esnext_commonjs_amd_system_umd_node16_or_nodenext = {1323, DiagnosticCategory::Error, S("Dynamic_imports_are_only_supported_when_the_module_flag_is_set_to_es2020_es2022_esnext_commonjs_amd__1323"), S("Dynamic imports are only supported when the '--module' flag is set to 'es2020', 'es2022', 'esnext', 'commonjs', 'amd', 'system', 'umd', 'node16', or 'nodenext'.")};
        static DiagnosticMessageStore Dynamic_imports_only_support_a_second_argument_when_the_module_option_is_set_to_esnext_node16_or_nodenext = {1324, DiagnosticCategory::Error, S("Dynamic_imports_only_support_a_second_argument_when_the_module_option_is_set_to_esnext_node16_or_nod_1324"), S("Dynamic imports only support a second argument when the '--module' option is set to 'esnext', 'node16', or 'nodenext'.")};
        static DiagnosticMessageStore Argument_of_dynamic_import_cannot_be_spread_element = {1325, DiagnosticCategory::Error, S("Argument_of_dynamic_import_cannot_be_spread_element_1325"), S("Argument of dynamic import cannot be spread element.")};
        static DiagnosticMessageStore This_use_of_import_is_invalid_import_calls_can_be_written_but_they_must_have_parentheses_and_cannot_have_type_arguments = {1326, DiagnosticCategory::Error, S("This_use_of_import_is_invalid_import_calls_can_be_written_but_they_must_have_parentheses_and_cannot__1326"), S("This use of 'import' is invalid. 'import()' calls can be written, but they must have parentheses and cannot have type arguments.")};
        static DiagnosticMessageStore String_literal_with_double_quotes_expected = {1327, DiagnosticCategory::Error, S("String_literal_with_double_quotes_expected_1327"), S("String literal with double quotes expected.")};
        static DiagnosticMessageStore Property_value_can_only_be_string_literal_numeric_literal_true_false_null_object_literal_or_array_literal = {1328, DiagnosticCategory::Error, S("Property_value_can_only_be_string_literal_numeric_literal_true_false_null_object_literal_or_array_li_1328"), S("Property value can only be string literal, numeric literal, 'true', 'false', 'null', object literal or array literal.")};
        static DiagnosticMessageStore _0_accepts_too_few_arguments_to_be_used_as_a_decorator_here_Did_you_mean_to_call_it_first_and_write_0 = {1329, DiagnosticCategory::Error, S("_0_accepts_too_few_arguments_to_be_used_as_a_decorator_here_Did_you_mean_to_call_it_first_and_write__1329"), S("'{0}' accepts too few arguments to be used as a decorator here. Did you mean to call it first and write '@{0}()'?")};
        static DiagnosticMessageStore A_property_of_an_interface_or_type_literal_whose_type_is_a_unique_symbol_type_must_be_readonly = {1330, DiagnosticCategory::Error, S("A_property_of_an_interface_or_type_literal_whose_type_is_a_unique_symbol_type_must_be_readonly_1330"), S("A property of an interface or type literal whose type is a 'unique symbol' type must be 'readonly'.")};
        static DiagnosticMessageStore A_property_of_a_class_whose_type_is_a_unique_symbol_type_must_be_both_static_and_readonly = {1331, DiagnosticCategory::Error, S("A_property_of_a_class_whose_type_is_a_unique_symbol_type_must_be_both_static_and_readonly_1331"), S("A property of a class whose type is a 'unique symbol' type must be both 'static' and 'readonly'.")};
        static DiagnosticMessageStore A_variable_whose_type_is_a_unique_symbol_type_must_be_const = {1332, DiagnosticCategory::Error, S("A_variable_whose_type_is_a_unique_symbol_type_must_be_const_1332"), S("A variable whose type is a 'unique symbol' type must be 'const'.")};
        static DiagnosticMessageStore unique_symbol_types_may_not_be_used_on_a_variable_declaration_with_a_binding_name = {1333, DiagnosticCategory::Error, S("unique_symbol_types_may_not_be_used_on_a_variable_declaration_with_a_binding_name_1333"), S("'unique symbol' types may not be used on a variable declaration with a binding name.")};
        static DiagnosticMessageStore unique_symbol_types_are_only_allowed_on_variables_in_a_variable_statement = {1334, DiagnosticCategory::Error, S("unique_symbol_types_are_only_allowed_on_variables_in_a_variable_statement_1334"), S("'unique symbol' types are only allowed on variables in a variable statement.")};
        static DiagnosticMessageStore unique_symbol_types_are_not_allowed_here = {1335, DiagnosticCategory::Error, S("unique_symbol_types_are_not_allowed_here_1335"), S("'unique symbol' types are not allowed here.")};
        static DiagnosticMessageStore An_index_signature_parameter_type_cannot_be_a_literal_type_or_generic_type_Consider_using_a_mapped_object_type_instead = {1337, DiagnosticCategory::Error, S("An_index_signature_parameter_type_cannot_be_a_literal_type_or_generic_type_Consider_using_a_mapped_o_1337"), S("An index signature parameter type cannot be a literal type or generic type. Consider using a mapped object type instead.")};
        static DiagnosticMessageStore infer_declarations_are_only_permitted_in_the_extends_clause_of_a_conditional_type = {1338, DiagnosticCategory::Error, S("infer_declarations_are_only_permitted_in_the_extends_clause_of_a_conditional_type_1338"), S("'infer' declarations are only permitted in the 'extends' clause of a conditional type.")};
        static DiagnosticMessageStore Module_0_does_not_refer_to_a_value_but_is_used_as_a_value_here = {1339, DiagnosticCategory::Error, S("Module_0_does_not_refer_to_a_value_but_is_used_as_a_value_here_1339"), S("Module '{0}' does not refer to a value, but is used as a value here.")};
        static DiagnosticMessageStore Module_0_does_not_refer_to_a_type_but_is_used_as_a_type_here_Did_you_mean_typeof_import_0 = {1340, DiagnosticCategory::Error, S("Module_0_does_not_refer_to_a_type_but_is_used_as_a_type_here_Did_you_mean_typeof_import_0_1340"), S("Module '{0}' does not refer to a type, but is used as a type here. Did you mean 'typeof import('{0}')'?")};
        static DiagnosticMessageStore Class_constructor_may_not_be_an_accessor = {1341, DiagnosticCategory::Error, S("Class_constructor_may_not_be_an_accessor_1341"), S("Class constructor may not be an accessor.")};
        static DiagnosticMessageStore The_import_meta_meta_property_is_only_allowed_when_the_module_option_is_es2020_es2022_esnext_system_node16_or_nodenext = {1343, DiagnosticCategory::Error, S("The_import_meta_meta_property_is_only_allowed_when_the_module_option_is_es2020_es2022_esnext_system__1343"), S("The 'import.meta' meta-property is only allowed when the '--module' option is 'es2020', 'es2022', 'esnext', 'system', 'node16', or 'nodenext'.")};
        static DiagnosticMessageStore A_label_is_not_allowed_here = {1344, DiagnosticCategory::Error, S("A_label_is_not_allowed_here_1344"), S("'A label is not allowed here.")};
        static DiagnosticMessageStore An_expression_of_type_void_cannot_be_tested_for_truthiness = {1345, DiagnosticCategory::Error, S("An_expression_of_type_void_cannot_be_tested_for_truthiness_1345"), S("An expression of type 'void' cannot be tested for truthiness.")};
        static DiagnosticMessageStore This_parameter_is_not_allowed_with_use_strict_directive = {1346, DiagnosticCategory::Error, S("This_parameter_is_not_allowed_with_use_strict_directive_1346"), S("This parameter is not allowed with 'use strict' directive.")};
        static DiagnosticMessageStore use_strict_directive_cannot_be_used_with_non_simple_parameter_list = {1347, DiagnosticCategory::Error, S("use_strict_directive_cannot_be_used_with_non_simple_parameter_list_1347"), S("'use strict' directive cannot be used with non-simple parameter list.")};
        static DiagnosticMessageStore Non_simple_parameter_declared_here = {1348, DiagnosticCategory::Error, S("Non_simple_parameter_declared_here_1348"), S("Non-simple parameter declared here.")};
        static DiagnosticMessageStore use_strict_directive_used_here = {1349, DiagnosticCategory::Error, S("use_strict_directive_used_here_1349"), S("'use strict' directive used here.")};
        static DiagnosticMessageStore Print_the_final_configuration_instead_of_building = {1350, DiagnosticCategory::Message, S("Print_the_final_configuration_instead_of_building_1350"), S("Print the final configuration instead of building.")};
        static DiagnosticMessageStore An_identifier_or_keyword_cannot_immediately_follow_a_numeric_literal = {1351, DiagnosticCategory::Error, S("An_identifier_or_keyword_cannot_immediately_follow_a_numeric_literal_1351"), S("An identifier or keyword cannot immediately follow a numeric literal.")};
        static DiagnosticMessageStore A_bigint_literal_cannot_use_exponential_notation = {1352, DiagnosticCategory::Error, S("A_bigint_literal_cannot_use_exponential_notation_1352"), S("A bigint literal cannot use exponential notation.")};
        static DiagnosticMessageStore A_bigint_literal_must_be_an_integer = {1353, DiagnosticCategory::Error, S("A_bigint_literal_must_be_an_integer_1353"), S("A bigint literal must be an integer.")};
        static DiagnosticMessageStore readonly_type_modifier_is_only_permitted_on_array_and_tuple_literal_types = {1354, DiagnosticCategory::Error, S("readonly_type_modifier_is_only_permitted_on_array_and_tuple_literal_types_1354"), S("'readonly' type modifier is only permitted on array and tuple literal types.")};
        static DiagnosticMessageStore A_const_assertions_can_only_be_applied_to_references_to_enum_members_or_string_number_boolean_array_or_object_literals = {1355, DiagnosticCategory::Error, S("A_const_assertions_can_only_be_applied_to_references_to_enum_members_or_string_number_boolean_array__1355"), S("A 'const' assertions can only be applied to references to enum members, or string, number, boolean, array, or object literals.")};
        static DiagnosticMessageStore Did_you_mean_to_mark_this_function_as_async = {1356, DiagnosticCategory::Error, S("Did_you_mean_to_mark_this_function_as_async_1356"), S("Did you mean to mark this function as 'async'?")};
        static DiagnosticMessageStore An_enum_member_name_must_be_followed_by_a_or = {1357, DiagnosticCategory::Error, S("An_enum_member_name_must_be_followed_by_a_or_1357"), S("An enum member name must be followed by a ',', '=', or '}'.")};
        static DiagnosticMessageStore Tagged_template_expressions_are_not_permitted_in_an_optional_chain = {1358, DiagnosticCategory::Error, S("Tagged_template_expressions_are_not_permitted_in_an_optional_chain_1358"), S("Tagged template expressions are not permitted in an optional chain.")};
        static DiagnosticMessageStore Identifier_expected_0_is_a_reserved_word_that_cannot_be_used_here = {1359, DiagnosticCategory::Error, S("Identifier_expected_0_is_a_reserved_word_that_cannot_be_used_here_1359"), S("Identifier expected. '{0}' is a reserved word that cannot be used here.")};
        static DiagnosticMessageStore Type_0_does_not_satisfy_the_expected_type_1 = {1360, DiagnosticCategory::Error, S("Type_0_does_not_satisfy_the_expected_type_1_1360"), S("Type '{0}' does not satisfy the expected type '{1}'.")};
        static DiagnosticMessageStore _0_cannot_be_used_as_a_value_because_it_was_imported_using_import_type = {1361, DiagnosticCategory::Error, S("_0_cannot_be_used_as_a_value_because_it_was_imported_using_import_type_1361"), S("'{0}' cannot be used as a value because it was imported using 'import type'.")};
        static DiagnosticMessageStore _0_cannot_be_used_as_a_value_because_it_was_exported_using_export_type = {1362, DiagnosticCategory::Error, S("_0_cannot_be_used_as_a_value_because_it_was_exported_using_export_type_1362"), S("'{0}' cannot be used as a value because it was exported using 'export type'.")};
        static DiagnosticMessageStore A_type_only_import_can_specify_a_default_import_or_named_bindings_but_not_both = {1363, DiagnosticCategory::Error, S("A_type_only_import_can_specify_a_default_import_or_named_bindings_but_not_both_1363"), S("A type-only import can specify a default import or named bindings, but not both.")};
        static DiagnosticMessageStore Convert_to_type_only_export = {1364, DiagnosticCategory::Message, S("Convert_to_type_only_export_1364"), S("Convert to type-only export")};
        static DiagnosticMessageStore Convert_all_re_exported_types_to_type_only_exports = {1365, DiagnosticCategory::Message, S("Convert_all_re_exported_types_to_type_only_exports_1365"), S("Convert all re-exported types to type-only exports")};
        static DiagnosticMessageStore Split_into_two_separate_import_declarations = {1366, DiagnosticCategory::Message, S("Split_into_two_separate_import_declarations_1366"), S("Split into two separate import declarations")};
        static DiagnosticMessageStore Split_all_invalid_type_only_imports = {1367, DiagnosticCategory::Message, S("Split_all_invalid_type_only_imports_1367"), S("Split all invalid type-only imports")};
        static DiagnosticMessageStore Class_constructor_may_not_be_a_generator = {1368, DiagnosticCategory::Error, S("Class_constructor_may_not_be_a_generator_1368"), S("Class constructor may not be a generator.")};
        static DiagnosticMessageStore Did_you_mean_0 = {1369, DiagnosticCategory::Message, S("Did_you_mean_0_1369"), S("Did you mean '{0}'?")};
        static DiagnosticMessageStore This_import_is_never_used_as_a_value_and_must_use_import_type_because_importsNotUsedAsValues_is_set_to_error = {1371, DiagnosticCategory::Error, S("This_import_is_never_used_as_a_value_and_must_use_import_type_because_importsNotUsedAsValues_is_set__1371"), S("This import is never used as a value and must use 'import type' because 'importsNotUsedAsValues' is set to 'error'.")};
        static DiagnosticMessageStore await_expressions_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module = {1375, DiagnosticCategory::Error, S("await_expressions_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_fi_1375"), S("'await' expressions are only allowed at the top level of a file when that file is a module, but this file has no imports or exports. Consider adding an empty 'export {}' to make this file a module.")};
        static DiagnosticMessageStore _0_was_imported_here = {1376, DiagnosticCategory::Message, S("_0_was_imported_here_1376"), S("'{0}' was imported here.")};
        static DiagnosticMessageStore _0_was_exported_here = {1377, DiagnosticCategory::Message, S("_0_was_exported_here_1377"), S("'{0}' was exported here.")};
        static DiagnosticMessageStore Top_level_await_expressions_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_node16_or_nodenext_and_the_target_option_is_set_to_es2017_or_higher = {1378, DiagnosticCategory::Error, S("Top_level_await_expressions_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_n_1378"), S("Top-level 'await' expressions are only allowed when the 'module' option is set to 'es2022', 'esnext', 'system', 'node16', or 'nodenext', and the 'target' option is set to 'es2017' or higher.")};
        static DiagnosticMessageStore An_import_alias_cannot_reference_a_declaration_that_was_exported_using_export_type = {1379, DiagnosticCategory::Error, S("An_import_alias_cannot_reference_a_declaration_that_was_exported_using_export_type_1379"), S("An import alias cannot reference a declaration that was exported using 'export type'.")};
        static DiagnosticMessageStore An_import_alias_cannot_reference_a_declaration_that_was_imported_using_import_type = {1380, DiagnosticCategory::Error, S("An_import_alias_cannot_reference_a_declaration_that_was_imported_using_import_type_1380"), S("An import alias cannot reference a declaration that was imported using 'import type'.")};
        static DiagnosticMessageStore Unexpected_token_Did_you_mean_or_rbrace = {1381, DiagnosticCategory::Error, S("Unexpected_token_Did_you_mean_or_rbrace_1381"), S("Unexpected token. Did you mean `{'}'}` or `&rbrace;`?")};
        static DiagnosticMessageStore Unexpected_token_Did_you_mean_or_gt = {1382, DiagnosticCategory::Error, S("Unexpected_token_Did_you_mean_or_gt_1382"), S("Unexpected token. Did you mean `{'>'}` or `&gt;`?")};
        static DiagnosticMessageStore Function_type_notation_must_be_parenthesized_when_used_in_a_union_type = {1385, DiagnosticCategory::Error, S("Function_type_notation_must_be_parenthesized_when_used_in_a_union_type_1385"), S("Function type notation must be parenthesized when used in a union type.")};
        static DiagnosticMessageStore Constructor_type_notation_must_be_parenthesized_when_used_in_a_union_type = {1386, DiagnosticCategory::Error, S("Constructor_type_notation_must_be_parenthesized_when_used_in_a_union_type_1386"), S("Constructor type notation must be parenthesized when used in a union type.")};
        static DiagnosticMessageStore Function_type_notation_must_be_parenthesized_when_used_in_an_intersection_type = {1387, DiagnosticCategory::Error, S("Function_type_notation_must_be_parenthesized_when_used_in_an_intersection_type_1387"), S("Function type notation must be parenthesized when used in an intersection type.")};
        static DiagnosticMessageStore Constructor_type_notation_must_be_parenthesized_when_used_in_an_intersection_type = {1388, DiagnosticCategory::Error, S("Constructor_type_notation_must_be_parenthesized_when_used_in_an_intersection_type_1388"), S("Constructor type notation must be parenthesized when used in an intersection type.")};
        static DiagnosticMessageStore _0_is_not_allowed_as_a_variable_declaration_name = {1389, DiagnosticCategory::Error, S("_0_is_not_allowed_as_a_variable_declaration_name_1389"), S("'{0}' is not allowed as a variable declaration name.")};
        static DiagnosticMessageStore _0_is_not_allowed_as_a_parameter_name = {1390, DiagnosticCategory::Error, S("_0_is_not_allowed_as_a_parameter_name_1390"), S("'{0}' is not allowed as a parameter name.")};
        static DiagnosticMessageStore An_import_alias_cannot_use_import_type = {1392, DiagnosticCategory::Error, S("An_import_alias_cannot_use_import_type_1392"), S("An import alias cannot use 'import type'")};
        static DiagnosticMessageStore Imported_via_0_from_file_1 = {1393, DiagnosticCategory::Message, S("Imported_via_0_from_file_1_1393"), S("Imported via {0} from file '{1}'")};
        static DiagnosticMessageStore Imported_via_0_from_file_1_with_packageId_2 = {1394, DiagnosticCategory::Message, S("Imported_via_0_from_file_1_with_packageId_2_1394"), S("Imported via {0} from file '{1}' with packageId '{2}'")};
        static DiagnosticMessageStore Imported_via_0_from_file_1_to_import_importHelpers_as_specified_in_compilerOptions = {1395, DiagnosticCategory::Message, S("Imported_via_0_from_file_1_to_import_importHelpers_as_specified_in_compilerOptions_1395"), S("Imported via {0} from file '{1}' to import 'importHelpers' as specified in compilerOptions")};
        static DiagnosticMessageStore Imported_via_0_from_file_1_with_packageId_2_to_import_importHelpers_as_specified_in_compilerOptions = {1396, DiagnosticCategory::Message, S("Imported_via_0_from_file_1_with_packageId_2_to_import_importHelpers_as_specified_in_compilerOptions_1396"), S("Imported via {0} from file '{1}' with packageId '{2}' to import 'importHelpers' as specified in compilerOptions")};
        static DiagnosticMessageStore Imported_via_0_from_file_1_to_import_jsx_and_jsxs_factory_functions = {1397, DiagnosticCategory::Message, S("Imported_via_0_from_file_1_to_import_jsx_and_jsxs_factory_functions_1397"), S("Imported via {0} from file '{1}' to import 'jsx' and 'jsxs' factory functions")};
        static DiagnosticMessageStore Imported_via_0_from_file_1_with_packageId_2_to_import_jsx_and_jsxs_factory_functions = {1398, DiagnosticCategory::Message, S("Imported_via_0_from_file_1_with_packageId_2_to_import_jsx_and_jsxs_factory_functions_1398"), S("Imported via {0} from file '{1}' with packageId '{2}' to import 'jsx' and 'jsxs' factory functions")};
        static DiagnosticMessageStore File_is_included_via_import_here = {1399, DiagnosticCategory::Message, S("File_is_included_via_import_here_1399"), S("File is included via import here.")};
        static DiagnosticMessageStore Referenced_via_0_from_file_1 = {1400, DiagnosticCategory::Message, S("Referenced_via_0_from_file_1_1400"), S("Referenced via '{0}' from file '{1}'")};
        static DiagnosticMessageStore File_is_included_via_reference_here = {1401, DiagnosticCategory::Message, S("File_is_included_via_reference_here_1401"), S("File is included via reference here.")};
        static DiagnosticMessageStore Type_library_referenced_via_0_from_file_1 = {1402, DiagnosticCategory::Message, S("Type_library_referenced_via_0_from_file_1_1402"), S("Type library referenced via '{0}' from file '{1}'")};
        static DiagnosticMessageStore Type_library_referenced_via_0_from_file_1_with_packageId_2 = {1403, DiagnosticCategory::Message, S("Type_library_referenced_via_0_from_file_1_with_packageId_2_1403"), S("Type library referenced via '{0}' from file '{1}' with packageId '{2}'")};
        static DiagnosticMessageStore File_is_included_via_type_library_reference_here = {1404, DiagnosticCategory::Message, S("File_is_included_via_type_library_reference_here_1404"), S("File is included via type library reference here.")};
        static DiagnosticMessageStore Library_referenced_via_0_from_file_1 = {1405, DiagnosticCategory::Message, S("Library_referenced_via_0_from_file_1_1405"), S("Library referenced via '{0}' from file '{1}'")};
        static DiagnosticMessageStore File_is_included_via_library_reference_here = {1406, DiagnosticCategory::Message, S("File_is_included_via_library_reference_here_1406"), S("File is included via library reference here.")};
        static DiagnosticMessageStore Matched_by_include_pattern_0_in_1 = {1407, DiagnosticCategory::Message, S("Matched_by_include_pattern_0_in_1_1407"), S("Matched by include pattern '{0}' in '{1}'")};
        static DiagnosticMessageStore File_is_matched_by_include_pattern_specified_here = {1408, DiagnosticCategory::Message, S("File_is_matched_by_include_pattern_specified_here_1408"), S("File is matched by include pattern specified here.")};
        static DiagnosticMessageStore Part_of_files_list_in_tsconfig_json = {1409, DiagnosticCategory::Message, S("Part_of_files_list_in_tsconfig_json_1409"), S("Part of 'files' list in tsconfig.json")};
        static DiagnosticMessageStore File_is_matched_by_files_list_specified_here = {1410, DiagnosticCategory::Message, S("File_is_matched_by_files_list_specified_here_1410"), S("File is matched by 'files' list specified here.")};
        static DiagnosticMessageStore Output_from_referenced_project_0_included_because_1_specified = {1411, DiagnosticCategory::Message, S("Output_from_referenced_project_0_included_because_1_specified_1411"), S("Output from referenced project '{0}' included because '{1}' specified")};
        static DiagnosticMessageStore Output_from_referenced_project_0_included_because_module_is_specified_as_none = {1412, DiagnosticCategory::Message, S("Output_from_referenced_project_0_included_because_module_is_specified_as_none_1412"), S("Output from referenced project '{0}' included because '--module' is specified as 'none'")};
        static DiagnosticMessageStore File_is_output_from_referenced_project_specified_here = {1413, DiagnosticCategory::Message, S("File_is_output_from_referenced_project_specified_here_1413"), S("File is output from referenced project specified here.")};
        static DiagnosticMessageStore Source_from_referenced_project_0_included_because_1_specified = {1414, DiagnosticCategory::Message, S("Source_from_referenced_project_0_included_because_1_specified_1414"), S("Source from referenced project '{0}' included because '{1}' specified")};
        static DiagnosticMessageStore Source_from_referenced_project_0_included_because_module_is_specified_as_none = {1415, DiagnosticCategory::Message, S("Source_from_referenced_project_0_included_because_module_is_specified_as_none_1415"), S("Source from referenced project '{0}' included because '--module' is specified as 'none'")};
        static DiagnosticMessageStore File_is_source_from_referenced_project_specified_here = {1416, DiagnosticCategory::Message, S("File_is_source_from_referenced_project_specified_here_1416"), S("File is source from referenced project specified here.")};
        static DiagnosticMessageStore Entry_point_of_type_library_0_specified_in_compilerOptions = {1417, DiagnosticCategory::Message, S("Entry_point_of_type_library_0_specified_in_compilerOptions_1417"), S("Entry point of type library '{0}' specified in compilerOptions")};
        static DiagnosticMessageStore Entry_point_of_type_library_0_specified_in_compilerOptions_with_packageId_1 = {1418, DiagnosticCategory::Message, S("Entry_point_of_type_library_0_specified_in_compilerOptions_with_packageId_1_1418"), S("Entry point of type library '{0}' specified in compilerOptions with packageId '{1}'")};
        static DiagnosticMessageStore File_is_entry_point_of_type_library_specified_here = {1419, DiagnosticCategory::Message, S("File_is_entry_point_of_type_library_specified_here_1419"), S("File is entry point of type library specified here.")};
        static DiagnosticMessageStore Entry_point_for_implicit_type_library_0 = {1420, DiagnosticCategory::Message, S("Entry_point_for_implicit_type_library_0_1420"), S("Entry point for implicit type library '{0}'")};
        static DiagnosticMessageStore Entry_point_for_implicit_type_library_0_with_packageId_1 = {1421, DiagnosticCategory::Message, S("Entry_point_for_implicit_type_library_0_with_packageId_1_1421"), S("Entry point for implicit type library '{0}' with packageId '{1}'")};
        static DiagnosticMessageStore Library_0_specified_in_compilerOptions = {1422, DiagnosticCategory::Message, S("Library_0_specified_in_compilerOptions_1422"), S("Library '{0}' specified in compilerOptions")};
        static DiagnosticMessageStore File_is_library_specified_here = {1423, DiagnosticCategory::Message, S("File_is_library_specified_here_1423"), S("File is library specified here.")};
        static DiagnosticMessageStore Default_library = {1424, DiagnosticCategory::Message, S("Default_library_1424"), S("Default library")};
        static DiagnosticMessageStore Default_library_for_target_0 = {1425, DiagnosticCategory::Message, S("Default_library_for_target_0_1425"), S("Default library for target '{0}'")};
        static DiagnosticMessageStore File_is_default_library_for_target_specified_here = {1426, DiagnosticCategory::Message, S("File_is_default_library_for_target_specified_here_1426"), S("File is default library for target specified here.")};
        static DiagnosticMessageStore Root_file_specified_for_compilation = {1427, DiagnosticCategory::Message, S("Root_file_specified_for_compilation_1427"), S("Root file specified for compilation")};
        static DiagnosticMessageStore File_is_output_of_project_reference_source_0 = {1428, DiagnosticCategory::Message, S("File_is_output_of_project_reference_source_0_1428"), S("File is output of project reference source '{0}'")};
        static DiagnosticMessageStore File_redirects_to_file_0 = {1429, DiagnosticCategory::Message, S("File_redirects_to_file_0_1429"), S("File redirects to file '{0}'")};
        static DiagnosticMessageStore The_file_is_in_the_program_because_Colon = {1430, DiagnosticCategory::Message, S("The_file_is_in_the_program_because_Colon_1430"), S("The file is in the program because:")};
        static DiagnosticMessageStore for_await_loops_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module = {1431, DiagnosticCategory::Error, S("for_await_loops_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_1431"), S("'for await' loops are only allowed at the top level of a file when that file is a module, but this file has no imports or exports. Consider adding an empty 'export {}' to make this file a module.")};
        static DiagnosticMessageStore Top_level_for_await_loops_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_node16_or_nodenext_and_the_target_option_is_set_to_es2017_or_higher = {1432, DiagnosticCategory::Error, S("Top_level_for_await_loops_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_nod_1432"), S("Top-level 'for await' loops are only allowed when the 'module' option is set to 'es2022', 'esnext', 'system', 'node16', or 'nodenext', and the 'target' option is set to 'es2017' or higher.")};
        static DiagnosticMessageStore Neither_decorators_nor_modifiers_may_be_applied_to_this_parameters = {1433, DiagnosticCategory::Error, S("Neither_decorators_nor_modifiers_may_be_applied_to_this_parameters_1433"), S("Neither decorators nor modifiers may be applied to 'this' parameters.")};
        static DiagnosticMessageStore Unexpected_keyword_or_identifier = {1434, DiagnosticCategory::Error, S("Unexpected_keyword_or_identifier_1434"), S("Unexpected keyword or identifier.")};
        static DiagnosticMessageStore Unknown_keyword_or_identifier_Did_you_mean_0 = {1435, DiagnosticCategory::Error, S("Unknown_keyword_or_identifier_Did_you_mean_0_1435"), S("Unknown keyword or identifier. Did you mean '{0}'?")};
        static DiagnosticMessageStore Decorators_must_precede_the_name_and_all_keywords_of_property_declarations = {1436, DiagnosticCategory::Error, S("Decorators_must_precede_the_name_and_all_keywords_of_property_declarations_1436"), S("Decorators must precede the name and all keywords of property declarations.")};
        static DiagnosticMessageStore Namespace_must_be_given_a_name = {1437, DiagnosticCategory::Error, S("Namespace_must_be_given_a_name_1437"), S("Namespace must be given a name.")};
        static DiagnosticMessageStore Interface_must_be_given_a_name = {1438, DiagnosticCategory::Error, S("Interface_must_be_given_a_name_1438"), S("Interface must be given a name.")};
        static DiagnosticMessageStore Type_alias_must_be_given_a_name = {1439, DiagnosticCategory::Error, S("Type_alias_must_be_given_a_name_1439"), S("Type alias must be given a name.")};
        static DiagnosticMessageStore Variable_declaration_not_allowed_at_this_location = {1440, DiagnosticCategory::Error, S("Variable_declaration_not_allowed_at_this_location_1440"), S("Variable declaration not allowed at this location.")};
        static DiagnosticMessageStore Cannot_start_a_function_call_in_a_type_annotation = {1441, DiagnosticCategory::Error, S("Cannot_start_a_function_call_in_a_type_annotation_1441"), S("Cannot start a function call in a type annotation.")};
        static DiagnosticMessageStore Expected_for_property_initializer = {1442, DiagnosticCategory::Error, S("Expected_for_property_initializer_1442"), S("Expected '=' for property initializer.")};
        static DiagnosticMessageStore Module_declaration_names_may_only_use_or_quoted_strings = {1443, DiagnosticCategory::Error, S("Module_declaration_names_may_only_use_or_quoted_strings_1443"), S("Module declaration names may only use ' or \" quoted strings.")};
        static DiagnosticMessageStore _0_is_a_type_and_must_be_imported_using_a_type_only_import_when_preserveValueImports_and_isolatedModules_are_both_enabled = {1444, DiagnosticCategory::Error, S("_0_is_a_type_and_must_be_imported_using_a_type_only_import_when_preserveValueImports_and_isolatedMod_1444"), S("'{0}' is a type and must be imported using a type-only import when 'preserveValueImports' and 'isolatedModules' are both enabled.")};
        static DiagnosticMessageStore _0_resolves_to_a_type_only_declaration_and_must_be_imported_using_a_type_only_import_when_preserveValueImports_and_isolatedModules_are_both_enabled = {1446, DiagnosticCategory::Error, S("_0_resolves_to_a_type_only_declaration_and_must_be_imported_using_a_type_only_import_when_preserveVa_1446"), S("'{0}' resolves to a type-only declaration and must be imported using a type-only import when 'preserveValueImports' and 'isolatedModules' are both enabled.")};
        static DiagnosticMessageStore _0_resolves_to_a_type_only_declaration_and_must_be_re_exported_using_a_type_only_re_export_when_1_is_enabled = {1448, DiagnosticCategory::Error, S("_0_resolves_to_a_type_only_declaration_and_must_be_re_exported_using_a_type_only_re_export_when_1_is_1448"), S("'{0}' resolves to a type-only declaration and must be re-exported using a type-only re-export when '{1}' is enabled.")};
        static DiagnosticMessageStore Preserve_unused_imported_values_in_the_JavaScript_output_that_would_otherwise_be_removed = {1449, DiagnosticCategory::Message, S("Preserve_unused_imported_values_in_the_JavaScript_output_that_would_otherwise_be_removed_1449"), S("Preserve unused imported values in the JavaScript output that would otherwise be removed.")};
        static DiagnosticMessageStore Dynamic_imports_can_only_accept_a_module_specifier_and_an_optional_set_of_attributes_as_arguments = {1450, DiagnosticCategory::Message, S("Dynamic_imports_can_only_accept_a_module_specifier_and_an_optional_set_of_attributes_as_arguments_1450"), S("Dynamic imports can only accept a module specifier and an optional set of attributes as arguments")};
        static DiagnosticMessageStore Private_identifiers_are_only_allowed_in_class_bodies_and_may_only_be_used_as_part_of_a_class_member_declaration_property_access_or_on_the_left_hand_side_of_an_in_expression = {1451, DiagnosticCategory::Error, S("Private_identifiers_are_only_allowed_in_class_bodies_and_may_only_be_used_as_part_of_a_class_member__1451"), S("Private identifiers are only allowed in class bodies and may only be used as part of a class member declaration, property access, or on the left-hand-side of an 'in' expression")};
        static DiagnosticMessageStore resolution_mode_should_be_either_require_or_import = {1453, DiagnosticCategory::Error, S("resolution_mode_should_be_either_require_or_import_1453"), S("`resolution-mode` should be either `require` or `import`.")};
        static DiagnosticMessageStore resolution_mode_can_only_be_set_for_type_only_imports = {1454, DiagnosticCategory::Error, S("resolution_mode_can_only_be_set_for_type_only_imports_1454"), S("`resolution-mode` can only be set for type-only imports.")};
        static DiagnosticMessageStore resolution_mode_is_the_only_valid_key_for_type_import_assertions = {1455, DiagnosticCategory::Error, S("resolution_mode_is_the_only_valid_key_for_type_import_assertions_1455"), S("`resolution-mode` is the only valid key for type import assertions.")};
        static DiagnosticMessageStore Type_import_assertions_should_have_exactly_one_key_resolution_mode_with_value_import_or_require = {1456, DiagnosticCategory::Error, S("Type_import_assertions_should_have_exactly_one_key_resolution_mode_with_value_import_or_require_1456"), S("Type import assertions should have exactly one key - `resolution-mode` - with value `import` or `require`.")};
        static DiagnosticMessageStore Matched_by_default_include_pattern_Asterisk_Asterisk_Slash_Asterisk = {1457, DiagnosticCategory::Message, S("Matched_by_default_include_pattern_Asterisk_Asterisk_Slash_Asterisk_1457"), S("Matched by default include pattern '**/*'")};
        static DiagnosticMessageStore File_is_ECMAScript_module_because_0_has_field_type_with_value_module = {1458, DiagnosticCategory::Message, S("File_is_ECMAScript_module_because_0_has_field_type_with_value_module_1458"), S("File is ECMAScript module because '{0}' has field \"type\" with value \"module\"")};
        static DiagnosticMessageStore File_is_CommonJS_module_because_0_has_field_type_whose_value_is_not_module = {1459, DiagnosticCategory::Message, S("File_is_CommonJS_module_because_0_has_field_type_whose_value_is_not_module_1459"), S("File is CommonJS module because '{0}' has field \"type\" whose value is not \"module\"")};
        static DiagnosticMessageStore File_is_CommonJS_module_because_0_does_not_have_field_type = {1460, DiagnosticCategory::Message, S("File_is_CommonJS_module_because_0_does_not_have_field_type_1460"), S("File is CommonJS module because '{0}' does not have field \"type\"")};
        static DiagnosticMessageStore File_is_CommonJS_module_because_package_json_was_not_found = {1461, DiagnosticCategory::Message, S("File_is_CommonJS_module_because_package_json_was_not_found_1461"), S("File is CommonJS module because 'package.json' was not found")};
        static DiagnosticMessageStore resolution_mode_is_the_only_valid_key_for_type_import_attributes = {1463, DiagnosticCategory::Error, S("resolution_mode_is_the_only_valid_key_for_type_import_attributes_1463"), S("'resolution-mode' is the only valid key for type import attributes.")};
        static DiagnosticMessageStore Type_import_attributes_should_have_exactly_one_key_resolution_mode_with_value_import_or_require = {1464, DiagnosticCategory::Error, S("Type_import_attributes_should_have_exactly_one_key_resolution_mode_with_value_import_or_require_1464"), S("Type import attributes should have exactly one key - 'resolution-mode' - with value 'import' or 'require'.")};
        static DiagnosticMessageStore The_import_meta_meta_property_is_not_allowed_in_files_which_will_build_into_CommonJS_output = {1470, DiagnosticCategory::Error, S("The_import_meta_meta_property_is_not_allowed_in_files_which_will_build_into_CommonJS_output_1470"), S("The 'import.meta' meta-property is not allowed in files which will build into CommonJS output.")};
        static DiagnosticMessageStore Module_0_cannot_be_imported_using_this_construct_The_specifier_only_resolves_to_an_ES_module_which_cannot_be_imported_with_require_Use_an_ECMAScript_import_instead = {1471, DiagnosticCategory::Error, S("Module_0_cannot_be_imported_using_this_construct_The_specifier_only_resolves_to_an_ES_module_which_c_1471"), S("Module '{0}' cannot be imported using this construct. The specifier only resolves to an ES module, which cannot be imported with 'require'. Use an ECMAScript import instead.")};
        static DiagnosticMessageStore catch_or_finally_expected = {1472, DiagnosticCategory::Error, S("catch_or_finally_expected_1472"), S("'catch' or 'finally' expected.")};
        static DiagnosticMessageStore An_import_declaration_can_only_be_used_at_the_top_level_of_a_module = {1473, DiagnosticCategory::Error, S("An_import_declaration_can_only_be_used_at_the_top_level_of_a_module_1473"), S("An import declaration can only be used at the top level of a module.")};
        static DiagnosticMessageStore An_export_declaration_can_only_be_used_at_the_top_level_of_a_module = {1474, DiagnosticCategory::Error, S("An_export_declaration_can_only_be_used_at_the_top_level_of_a_module_1474"), S("An export declaration can only be used at the top level of a module.")};
        static DiagnosticMessageStore Control_what_method_is_used_to_detect_module_format_JS_files = {1475, DiagnosticCategory::Message, S("Control_what_method_is_used_to_detect_module_format_JS_files_1475"), S("Control what method is used to detect module-format JS files.")};
        static DiagnosticMessageStore auto_Colon_Treat_files_with_imports_exports_import_meta_jsx_with_jsx_Colon_react_jsx_or_esm_format_with_module_Colon_node16_as_modules = {1476, DiagnosticCategory::Message, S("auto_Colon_Treat_files_with_imports_exports_import_meta_jsx_with_jsx_Colon_react_jsx_or_esm_format_w_1476"), S("\"auto\": Treat files with imports, exports, import.meta, jsx (with jsx: react-jsx), or esm format (with module: node16+) as modules.")};
        static DiagnosticMessageStore An_instantiation_expression_cannot_be_followed_by_a_property_access = {1477, DiagnosticCategory::Error, S("An_instantiation_expression_cannot_be_followed_by_a_property_access_1477"), S("An instantiation expression cannot be followed by a property access.")};
        static DiagnosticMessageStore Identifier_or_string_literal_expected = {1478, DiagnosticCategory::Error, S("Identifier_or_string_literal_expected_1478"), S("Identifier or string literal expected.")};
        static DiagnosticMessageStore The_current_file_is_a_CommonJS_module_whose_imports_will_produce_require_calls_however_the_referenced_file_is_an_ECMAScript_module_and_cannot_be_imported_with_require_Consider_writing_a_dynamic_import_0_call_instead = {1479, DiagnosticCategory::Error, S("The_current_file_is_a_CommonJS_module_whose_imports_will_produce_require_calls_however_the_reference_1479"), S("The current file is a CommonJS module whose imports will produce 'require' calls; however, the referenced file is an ECMAScript module and cannot be imported with 'require'. Consider writing a dynamic 'import(\"{0}\")' call instead.")};
        static DiagnosticMessageStore To_convert_this_file_to_an_ECMAScript_module_change_its_file_extension_to_0_or_create_a_local_package_json_file_with_type_Colon_module = {1480, DiagnosticCategory::Message, S("To_convert_this_file_to_an_ECMAScript_module_change_its_file_extension_to_0_or_create_a_local_packag_1480"), S("To convert this file to an ECMAScript module, change its file extension to '{0}' or create a local package.json file with `{ \"type\": \"module\" }`.")};
        static DiagnosticMessageStore To_convert_this_file_to_an_ECMAScript_module_change_its_file_extension_to_0_or_add_the_field_type_Colon_module_to_1 = {1481, DiagnosticCategory::Message, S("To_convert_this_file_to_an_ECMAScript_module_change_its_file_extension_to_0_or_add_the_field_type_Co_1481"), S("To convert this file to an ECMAScript module, change its file extension to '{0}', or add the field `\"type\": \"module\"` to '{1}'.")};
        static DiagnosticMessageStore To_convert_this_file_to_an_ECMAScript_module_add_the_field_type_Colon_module_to_0 = {1482, DiagnosticCategory::Message, S("To_convert_this_file_to_an_ECMAScript_module_add_the_field_type_Colon_module_to_0_1482"), S("To convert this file to an ECMAScript module, add the field `\"type\": \"module\"` to '{0}'.")};
        static DiagnosticMessageStore To_convert_this_file_to_an_ECMAScript_module_create_a_local_package_json_file_with_type_Colon_module = {1483, DiagnosticCategory::Message, S("To_convert_this_file_to_an_ECMAScript_module_create_a_local_package_json_file_with_type_Colon_module_1483"), S("To convert this file to an ECMAScript module, create a local package.json file with `{ \"type\": \"module\" }`.")};
        static DiagnosticMessageStore _0_is_a_type_and_must_be_imported_using_a_type_only_import_when_verbatimModuleSyntax_is_enabled = {1484, DiagnosticCategory::Error, S("_0_is_a_type_and_must_be_imported_using_a_type_only_import_when_verbatimModuleSyntax_is_enabled_1484"), S("'{0}' is a type and must be imported using a type-only import when 'verbatimModuleSyntax' is enabled.")};
        static DiagnosticMessageStore _0_resolves_to_a_type_only_declaration_and_must_be_imported_using_a_type_only_import_when_verbatimModuleSyntax_is_enabled = {1485, DiagnosticCategory::Error, S("_0_resolves_to_a_type_only_declaration_and_must_be_imported_using_a_type_only_import_when_verbatimMo_1485"), S("'{0}' resolves to a type-only declaration and must be imported using a type-only import when 'verbatimModuleSyntax' is enabled.")};
        static DiagnosticMessageStore Decorator_used_before_export_here = {1486, DiagnosticCategory::Error, S("Decorator_used_before_export_here_1486"), S("Decorator used before 'export' here.")};
        static DiagnosticMessageStore Octal_escape_sequences_are_not_allowed_Use_the_syntax_0 = {1487, DiagnosticCategory::Error, S("Octal_escape_sequences_are_not_allowed_Use_the_syntax_0_1487"), S("Octal escape sequences are not allowed. Use the syntax '{0}'.")};
        static DiagnosticMessageStore Escape_sequence_0_is_not_allowed = {1488, DiagnosticCategory::Error, S("Escape_sequence_0_is_not_allowed_1488"), S("Escape sequence '{0}' is not allowed.")};
        static DiagnosticMessageStore Decimals_with_leading_zeros_are_not_allowed = {1489, DiagnosticCategory::Error, S("Decimals_with_leading_zeros_are_not_allowed_1489"), S("Decimals with leading zeros are not allowed.")};
        static DiagnosticMessageStore File_appears_to_be_binary = {1490, DiagnosticCategory::Error, S("File_appears_to_be_binary_1490"), S("File appears to be binary.")};
        static DiagnosticMessageStore _0_modifier_cannot_appear_on_a_using_declaration = {1491, DiagnosticCategory::Error, S("_0_modifier_cannot_appear_on_a_using_declaration_1491"), S("'{0}' modifier cannot appear on a 'using' declaration.")};
        static DiagnosticMessageStore _0_declarations_may_not_have_binding_patterns = {1492, DiagnosticCategory::Error, S("_0_declarations_may_not_have_binding_patterns_1492"), S("'{0}' declarations may not have binding patterns.")};
        static DiagnosticMessageStore The_left_hand_side_of_a_for_in_statement_cannot_be_a_using_declaration = {1493, DiagnosticCategory::Error, S("The_left_hand_side_of_a_for_in_statement_cannot_be_a_using_declaration_1493"), S("The left-hand side of a 'for...in' statement cannot be a 'using' declaration.")};
        static DiagnosticMessageStore The_left_hand_side_of_a_for_in_statement_cannot_be_an_await_using_declaration = {1494, DiagnosticCategory::Error, S("The_left_hand_side_of_a_for_in_statement_cannot_be_an_await_using_declaration_1494"), S("The left-hand side of a 'for...in' statement cannot be an 'await using' declaration.")};
        static DiagnosticMessageStore _0_modifier_cannot_appear_on_an_await_using_declaration = {1495, DiagnosticCategory::Error, S("_0_modifier_cannot_appear_on_an_await_using_declaration_1495"), S("'{0}' modifier cannot appear on an 'await using' declaration.")};
        static DiagnosticMessageStore Identifier_string_literal_or_number_literal_expected = {1496, DiagnosticCategory::Error, S("Identifier_string_literal_or_number_literal_expected_1496"), S("Identifier, string literal, or number literal expected.")};
        static DiagnosticMessageStore The_types_of_0_are_incompatible_between_these_types = {2200, DiagnosticCategory::Error, S("The_types_of_0_are_incompatible_between_these_types_2200"), S("The types of '{0}' are incompatible between these types.")};
        static DiagnosticMessageStore The_types_returned_by_0_are_incompatible_between_these_types = {2201, DiagnosticCategory::Error, S("The_types_returned_by_0_are_incompatible_between_these_types_2201"), S("The types returned by '{0}' are incompatible between these types.")};
        static DiagnosticMessageStore Call_signature_return_types_0_and_1_are_incompatible = {2202, DiagnosticCategory::Error, S("Call_signature_return_types_0_and_1_are_incompatible_2202"), S("Call signature return types '{0}' and '{1}' are incompatible.")};
        static DiagnosticMessageStore Construct_signature_return_types_0_and_1_are_incompatible = {2203, DiagnosticCategory::Error, S("Construct_signature_return_types_0_and_1_are_incompatible_2203"), S("Construct signature return types '{0}' and '{1}' are incompatible.")};
        static DiagnosticMessageStore Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1 = {2204, DiagnosticCategory::Error, S("Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1_2204"), S("Call signatures with no arguments have incompatible return types '{0}' and '{1}'.")};
        static DiagnosticMessageStore Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1 = {2205, DiagnosticCategory::Error, S("Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1_2205"), S("Construct signatures with no arguments have incompatible return types '{0}' and '{1}'.")};
        static DiagnosticMessageStore The_type_modifier_cannot_be_used_on_a_named_import_when_import_type_is_used_on_its_import_statement = {2206, DiagnosticCategory::Error, S("The_type_modifier_cannot_be_used_on_a_named_import_when_import_type_is_used_on_its_import_statement_2206"), S("The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.")};
        static DiagnosticMessageStore The_type_modifier_cannot_be_used_on_a_named_export_when_export_type_is_used_on_its_export_statement = {2207, DiagnosticCategory::Error, S("The_type_modifier_cannot_be_used_on_a_named_export_when_export_type_is_used_on_its_export_statement_2207"), S("The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.")};
        static DiagnosticMessageStore This_type_parameter_might_need_an_extends_0_constraint = {2208, DiagnosticCategory::Error, S("This_type_parameter_might_need_an_extends_0_constraint_2208"), S("This type parameter might need an `extends {0}` constraint.")};
        static DiagnosticMessageStore The_project_root_is_ambiguous_but_is_required_to_resolve_export_map_entry_0_in_file_1_Supply_the_rootDir_compiler_option_to_disambiguate = {2209, DiagnosticCategory::Error, S("The_project_root_is_ambiguous_but_is_required_to_resolve_export_map_entry_0_in_file_1_Supply_the_roo_2209"), S("The project root is ambiguous, but is required to resolve export map entry '{0}' in file '{1}'. Supply the `rootDir` compiler option to disambiguate.")};
        static DiagnosticMessageStore The_project_root_is_ambiguous_but_is_required_to_resolve_import_map_entry_0_in_file_1_Supply_the_rootDir_compiler_option_to_disambiguate = {2210, DiagnosticCategory::Error, S("The_project_root_is_ambiguous_but_is_required_to_resolve_import_map_entry_0_in_file_1_Supply_the_roo_2210"), S("The project root is ambiguous, but is required to resolve import map entry '{0}' in file '{1}'. Supply the `rootDir` compiler option to disambiguate.")};
        static DiagnosticMessageStore Add_extends_constraint = {2211, DiagnosticCategory::Message, S("Add_extends_constraint_2211"), S("Add `extends` constraint.")};
        static DiagnosticMessageStore Add_extends_constraint_to_all_type_parameters = {2212, DiagnosticCategory::Message, S("Add_extends_constraint_to_all_type_parameters_2212"), S("Add `extends` constraint to all type parameters")};
        static DiagnosticMessageStore Duplicate_identifier_0 = {2300, DiagnosticCategory::Error, S("Duplicate_identifier_0_2300"), S("Duplicate identifier '{0}'.")};
        static DiagnosticMessageStore Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor = {2301, DiagnosticCategory::Error, S("Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor_2301"), S("Initializer of instance member variable '{0}' cannot reference identifier '{1}' declared in the constructor.")};
        static DiagnosticMessageStore Static_members_cannot_reference_class_type_parameters = {2302, DiagnosticCategory::Error, S("Static_members_cannot_reference_class_type_parameters_2302"), S("Static members cannot reference class type parameters.")};
        static DiagnosticMessageStore Circular_definition_of_import_alias_0 = {2303, DiagnosticCategory::Error, S("Circular_definition_of_import_alias_0_2303"), S("Circular definition of import alias '{0}'.")};
        static DiagnosticMessageStore Cannot_find_name_0 = {2304, DiagnosticCategory::Error, S("Cannot_find_name_0_2304"), S("Cannot find name '{0}'.")};
        static DiagnosticMessageStore Module_0_has_no_exported_member_1 = {2305, DiagnosticCategory::Error, S("Module_0_has_no_exported_member_1_2305"), S("Module '{0}' has no exported member '{1}'.")};
        static DiagnosticMessageStore File_0_is_not_a_module = {2306, DiagnosticCategory::Error, S("File_0_is_not_a_module_2306"), S("File '{0}' is not a module.")};
        static DiagnosticMessageStore Cannot_find_module_0_or_its_corresponding_type_declarations = {2307, DiagnosticCategory::Error, S("Cannot_find_module_0_or_its_corresponding_type_declarations_2307"), S("Cannot find module '{0}' or its corresponding type declarations.")};
        static DiagnosticMessageStore Module_0_has_already_exported_a_member_named_1_Consider_explicitly_re_exporting_to_resolve_the_ambiguity = {2308, DiagnosticCategory::Error, S("Module_0_has_already_exported_a_member_named_1_Consider_explicitly_re_exporting_to_resolve_the_ambig_2308"), S("Module {0} has already exported a member named '{1}'. Consider explicitly re-exporting to resolve the ambiguity.")};
        static DiagnosticMessageStore An_export_assignment_cannot_be_used_in_a_module_with_other_exported_elements = {2309, DiagnosticCategory::Error, S("An_export_assignment_cannot_be_used_in_a_module_with_other_exported_elements_2309"), S("An export assignment cannot be used in a module with other exported elements.")};
        static DiagnosticMessageStore Type_0_recursively_references_itself_as_a_base_type = {2310, DiagnosticCategory::Error, S("Type_0_recursively_references_itself_as_a_base_type_2310"), S("Type '{0}' recursively references itself as a base type.")};
        static DiagnosticMessageStore Cannot_find_name_0_Did_you_mean_to_write_this_in_an_async_function = {2311, DiagnosticCategory::Error, S("Cannot_find_name_0_Did_you_mean_to_write_this_in_an_async_function_2311"), S("Cannot find name '{0}'. Did you mean to write this in an async function?")};
        static DiagnosticMessageStore An_interface_can_only_extend_an_object_type_or_intersection_of_object_types_with_statically_known_members = {2312, DiagnosticCategory::Error, S("An_interface_can_only_extend_an_object_type_or_intersection_of_object_types_with_statically_known_me_2312"), S("An interface can only extend an object type or intersection of object types with statically known members.")};
        static DiagnosticMessageStore Type_parameter_0_has_a_circular_constraint = {2313, DiagnosticCategory::Error, S("Type_parameter_0_has_a_circular_constraint_2313"), S("Type parameter '{0}' has a circular constraint.")};
        static DiagnosticMessageStore Generic_type_0_requires_1_type_argument_s = {2314, DiagnosticCategory::Error, S("Generic_type_0_requires_1_type_argument_s_2314"), S("Generic type '{0}' requires {1} type argument(s).")};
        static DiagnosticMessageStore Type_0_is_not_generic = {2315, DiagnosticCategory::Error, S("Type_0_is_not_generic_2315"), S("Type '{0}' is not generic.")};
        static DiagnosticMessageStore Global_type_0_must_be_a_class_or_interface_type = {2316, DiagnosticCategory::Error, S("Global_type_0_must_be_a_class_or_interface_type_2316"), S("Global type '{0}' must be a class or interface type.")};
        static DiagnosticMessageStore Global_type_0_must_have_1_type_parameter_s = {2317, DiagnosticCategory::Error, S("Global_type_0_must_have_1_type_parameter_s_2317"), S("Global type '{0}' must have {1} type parameter(s).")};
        static DiagnosticMessageStore Cannot_find_global_type_0 = {2318, DiagnosticCategory::Error, S("Cannot_find_global_type_0_2318"), S("Cannot find global type '{0}'.")};
        static DiagnosticMessageStore Named_property_0_of_types_1_and_2_are_not_identical = {2319, DiagnosticCategory::Error, S("Named_property_0_of_types_1_and_2_are_not_identical_2319"), S("Named property '{0}' of types '{1}' and '{2}' are not identical.")};
        static DiagnosticMessageStore Interface_0_cannot_simultaneously_extend_types_1_and_2 = {2320, DiagnosticCategory::Error, S("Interface_0_cannot_simultaneously_extend_types_1_and_2_2320"), S("Interface '{0}' cannot simultaneously extend types '{1}' and '{2}'.")};
        static DiagnosticMessageStore Excessive_stack_depth_comparing_types_0_and_1 = {2321, DiagnosticCategory::Error, S("Excessive_stack_depth_comparing_types_0_and_1_2321"), S("Excessive stack depth comparing types '{0}' and '{1}'.")};
        static DiagnosticMessageStore Type_0_is_not_assignable_to_type_1 = {2322, DiagnosticCategory::Error, S("Type_0_is_not_assignable_to_type_1_2322"), S("Type '{0}' is not assignable to type '{1}'.")};
        static DiagnosticMessageStore Cannot_redeclare_exported_variable_0 = {2323, DiagnosticCategory::Error, S("Cannot_redeclare_exported_variable_0_2323"), S("Cannot redeclare exported variable '{0}'.")};
        static DiagnosticMessageStore Property_0_is_missing_in_type_1 = {2324, DiagnosticCategory::Error, S("Property_0_is_missing_in_type_1_2324"), S("Property '{0}' is missing in type '{1}'.")};
        static DiagnosticMessageStore Property_0_is_private_in_type_1_but_not_in_type_2 = {2325, DiagnosticCategory::Error, S("Property_0_is_private_in_type_1_but_not_in_type_2_2325"), S("Property '{0}' is private in type '{1}' but not in type '{2}'.")};
        static DiagnosticMessageStore Types_of_property_0_are_incompatible = {2326, DiagnosticCategory::Error, S("Types_of_property_0_are_incompatible_2326"), S("Types of property '{0}' are incompatible.")};
        static DiagnosticMessageStore Property_0_is_optional_in_type_1_but_required_in_type_2 = {2327, DiagnosticCategory::Error, S("Property_0_is_optional_in_type_1_but_required_in_type_2_2327"), S("Property '{0}' is optional in type '{1}' but required in type '{2}'.")};
        static DiagnosticMessageStore Types_of_parameters_0_and_1_are_incompatible = {2328, DiagnosticCategory::Error, S("Types_of_parameters_0_and_1_are_incompatible_2328"), S("Types of parameters '{0}' and '{1}' are incompatible.")};
        static DiagnosticMessageStore Index_signature_for_type_0_is_missing_in_type_1 = {2329, DiagnosticCategory::Error, S("Index_signature_for_type_0_is_missing_in_type_1_2329"), S("Index signature for type '{0}' is missing in type '{1}'.")};
        static DiagnosticMessageStore _0_and_1_index_signatures_are_incompatible = {2330, DiagnosticCategory::Error, S("_0_and_1_index_signatures_are_incompatible_2330"), S("'{0}' and '{1}' index signatures are incompatible.")};
        static DiagnosticMessageStore this_cannot_be_referenced_in_a_module_or_namespace_body = {2331, DiagnosticCategory::Error, S("this_cannot_be_referenced_in_a_module_or_namespace_body_2331"), S("'this' cannot be referenced in a module or namespace body.")};
        static DiagnosticMessageStore this_cannot_be_referenced_in_current_location = {2332, DiagnosticCategory::Error, S("this_cannot_be_referenced_in_current_location_2332"), S("'this' cannot be referenced in current location.")};
        static DiagnosticMessageStore this_cannot_be_referenced_in_constructor_arguments = {2333, DiagnosticCategory::Error, S("this_cannot_be_referenced_in_constructor_arguments_2333"), S("'this' cannot be referenced in constructor arguments.")};
        static DiagnosticMessageStore this_cannot_be_referenced_in_a_static_property_initializer = {2334, DiagnosticCategory::Error, S("this_cannot_be_referenced_in_a_static_property_initializer_2334"), S("'this' cannot be referenced in a static property initializer.")};
        static DiagnosticMessageStore super_can_only_be_referenced_in_a_derived_class = {2335, DiagnosticCategory::Error, S("super_can_only_be_referenced_in_a_derived_class_2335"), S("'super' can only be referenced in a derived class.")};
        static DiagnosticMessageStore super_cannot_be_referenced_in_constructor_arguments = {2336, DiagnosticCategory::Error, S("super_cannot_be_referenced_in_constructor_arguments_2336"), S("'super' cannot be referenced in constructor arguments.")};
        static DiagnosticMessageStore Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors = {2337, DiagnosticCategory::Error, S("Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors_2337"), S("Super calls are not permitted outside constructors or in nested functions inside constructors.")};
        static DiagnosticMessageStore super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_derived_class = {2338, DiagnosticCategory::Error, S("super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_der_2338"), S("'super' property access is permitted only in a constructor, member function, or member accessor of a derived class.")};
        static DiagnosticMessageStore Property_0_does_not_exist_on_type_1 = {2339, DiagnosticCategory::Error, S("Property_0_does_not_exist_on_type_1_2339"), S("Property '{0}' does not exist on type '{1}'.")};
        static DiagnosticMessageStore Only_public_and_protected_methods_of_the_base_class_are_accessible_via_the_super_keyword = {2340, DiagnosticCategory::Error, S("Only_public_and_protected_methods_of_the_base_class_are_accessible_via_the_super_keyword_2340"), S("Only public and protected methods of the base class are accessible via the 'super' keyword.")};
        static DiagnosticMessageStore Property_0_is_private_and_only_accessible_within_class_1 = {2341, DiagnosticCategory::Error, S("Property_0_is_private_and_only_accessible_within_class_1_2341"), S("Property '{0}' is private and only accessible within class '{1}'.")};
        static DiagnosticMessageStore This_syntax_requires_an_imported_helper_named_1_which_does_not_exist_in_0_Consider_upgrading_your_version_of_0 = {2343, DiagnosticCategory::Error, S("This_syntax_requires_an_imported_helper_named_1_which_does_not_exist_in_0_Consider_upgrading_your_ve_2343"), S("This syntax requires an imported helper named '{1}' which does not exist in '{0}'. Consider upgrading your version of '{0}'.")};
        static DiagnosticMessageStore Type_0_does_not_satisfy_the_constraint_1 = {2344, DiagnosticCategory::Error, S("Type_0_does_not_satisfy_the_constraint_1_2344"), S("Type '{0}' does not satisfy the constraint '{1}'.")};
        static DiagnosticMessageStore Argument_of_type_0_is_not_assignable_to_parameter_of_type_1 = {2345, DiagnosticCategory::Error, S("Argument_of_type_0_is_not_assignable_to_parameter_of_type_1_2345"), S("Argument of type '{0}' is not assignable to parameter of type '{1}'.")};
        static DiagnosticMessageStore Untyped_function_calls_may_not_accept_type_arguments = {2347, DiagnosticCategory::Error, S("Untyped_function_calls_may_not_accept_type_arguments_2347"), S("Untyped function calls may not accept type arguments.")};
        static DiagnosticMessageStore Value_of_type_0_is_not_callable_Did_you_mean_to_include_new = {2348, DiagnosticCategory::Error, S("Value_of_type_0_is_not_callable_Did_you_mean_to_include_new_2348"), S("Value of type '{0}' is not callable. Did you mean to include 'new'?")};
        static DiagnosticMessageStore This_expression_is_not_callable = {2349, DiagnosticCategory::Error, S("This_expression_is_not_callable_2349"), S("This expression is not callable.")};
        static DiagnosticMessageStore Only_a_void_function_can_be_called_with_the_new_keyword = {2350, DiagnosticCategory::Error, S("Only_a_void_function_can_be_called_with_the_new_keyword_2350"), S("Only a void function can be called with the 'new' keyword.")};
        static DiagnosticMessageStore This_expression_is_not_constructable = {2351, DiagnosticCategory::Error, S("This_expression_is_not_constructable_2351"), S("This expression is not constructable.")};
        static DiagnosticMessageStore Conversion_of_type_0_to_type_1_may_be_a_mistake_because_neither_type_sufficiently_overlaps_with_the_other_If_this_was_intentional_convert_the_expression_to_unknown_first = {2352, DiagnosticCategory::Error, S("Conversion_of_type_0_to_type_1_may_be_a_mistake_because_neither_type_sufficiently_overlaps_with_the__2352"), S("Conversion of type '{0}' to type '{1}' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.")};
        static DiagnosticMessageStore Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1 = {2353, DiagnosticCategory::Error, S("Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1_2353"), S("Object literal may only specify known properties, and '{0}' does not exist in type '{1}'.")};
        static DiagnosticMessageStore This_syntax_requires_an_imported_helper_but_module_0_cannot_be_found = {2354, DiagnosticCategory::Error, S("This_syntax_requires_an_imported_helper_but_module_0_cannot_be_found_2354"), S("This syntax requires an imported helper but module '{0}' cannot be found.")};
        static DiagnosticMessageStore A_function_whose_declared_type_is_neither_undefined_void_nor_any_must_return_a_value = {2355, DiagnosticCategory::Error, S("A_function_whose_declared_type_is_neither_undefined_void_nor_any_must_return_a_value_2355"), S("A function whose declared type is neither 'undefined', 'void', nor 'any' must return a value.")};
        static DiagnosticMessageStore An_arithmetic_operand_must_be_of_type_any_number_bigint_or_an_enum_type = {2356, DiagnosticCategory::Error, S("An_arithmetic_operand_must_be_of_type_any_number_bigint_or_an_enum_type_2356"), S("An arithmetic operand must be of type 'any', 'number', 'bigint' or an enum type.")};
        static DiagnosticMessageStore The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access = {2357, DiagnosticCategory::Error, S("The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access_2357"), S("The operand of an increment or decrement operator must be a variable or a property access.")};
        static DiagnosticMessageStore The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter = {2358, DiagnosticCategory::Error, S("The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_paramete_2358"), S("The left-hand side of an 'instanceof' expression must be of type 'any', an object type or a type parameter.")};
        static DiagnosticMessageStore The_right_hand_side_of_an_instanceof_expression_must_be_either_of_type_any_a_class_function_or_other_type_assignable_to_the_Function_interface_type_or_an_object_type_with_a_Symbol_hasInstance_method = {2359, DiagnosticCategory::Error, S("The_right_hand_side_of_an_instanceof_expression_must_be_either_of_type_any_a_class_function_or_other_2359"), S("The right-hand side of an 'instanceof' expression must be either of type 'any', a class, function, or other type assignable to the 'Function' interface type, or an object type with a 'Symbol.hasInstance' method.")};
        static DiagnosticMessageStore The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type = {2362, DiagnosticCategory::Error, S("The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type_2362"), S("The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.")};
        static DiagnosticMessageStore The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type = {2363, DiagnosticCategory::Error, S("The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type_2363"), S("The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.")};
        static DiagnosticMessageStore The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access = {2364, DiagnosticCategory::Error, S("The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access_2364"), S("The left-hand side of an assignment expression must be a variable or a property access.")};
        static DiagnosticMessageStore Operator_0_cannot_be_applied_to_types_1_and_2 = {2365, DiagnosticCategory::Error, S("Operator_0_cannot_be_applied_to_types_1_and_2_2365"), S("Operator '{0}' cannot be applied to types '{1}' and '{2}'.")};
        static DiagnosticMessageStore Function_lacks_ending_return_statement_and_return_type_does_not_include_undefined = {2366, DiagnosticCategory::Error, S("Function_lacks_ending_return_statement_and_return_type_does_not_include_undefined_2366"), S("Function lacks ending return statement and return type does not include 'undefined'.")};
        static DiagnosticMessageStore This_comparison_appears_to_be_unintentional_because_the_types_0_and_1_have_no_overlap = {2367, DiagnosticCategory::Error, S("This_comparison_appears_to_be_unintentional_because_the_types_0_and_1_have_no_overlap_2367"), S("This comparison appears to be unintentional because the types '{0}' and '{1}' have no overlap.")};
        static DiagnosticMessageStore Type_parameter_name_cannot_be_0 = {2368, DiagnosticCategory::Error, S("Type_parameter_name_cannot_be_0_2368"), S("Type parameter name cannot be '{0}'.")};
        static DiagnosticMessageStore A_parameter_property_is_only_allowed_in_a_constructor_implementation = {2369, DiagnosticCategory::Error, S("A_parameter_property_is_only_allowed_in_a_constructor_implementation_2369"), S("A parameter property is only allowed in a constructor implementation.")};
        static DiagnosticMessageStore A_rest_parameter_must_be_of_an_array_type = {2370, DiagnosticCategory::Error, S("A_rest_parameter_must_be_of_an_array_type_2370"), S("A rest parameter must be of an array type.")};
        static DiagnosticMessageStore A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation = {2371, DiagnosticCategory::Error, S("A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation_2371"), S("A parameter initializer is only allowed in a function or constructor implementation.")};
        static DiagnosticMessageStore Parameter_0_cannot_reference_itself = {2372, DiagnosticCategory::Error, S("Parameter_0_cannot_reference_itself_2372"), S("Parameter '{0}' cannot reference itself.")};
        static DiagnosticMessageStore Parameter_0_cannot_reference_identifier_1_declared_after_it = {2373, DiagnosticCategory::Error, S("Parameter_0_cannot_reference_identifier_1_declared_after_it_2373"), S("Parameter '{0}' cannot reference identifier '{1}' declared after it.")};
        static DiagnosticMessageStore Duplicate_index_signature_for_type_0 = {2374, DiagnosticCategory::Error, S("Duplicate_index_signature_for_type_0_2374"), S("Duplicate index signature for type '{0}'.")};
        static DiagnosticMessageStore Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_types_of_the_target_s_properties = {2375, DiagnosticCategory::Error, S("Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefi_2375"), S("Type '{0}' is not assignable to type '{1}' with 'exactOptionalPropertyTypes: true'. Consider adding 'undefined' to the types of the target's properties.")};
        static DiagnosticMessageStore A_super_call_must_be_the_first_statement_in_the_constructor_to_refer_to_super_or_this_when_a_derived_class_contains_initialized_properties_parameter_properties_or_private_identifiers = {2376, DiagnosticCategory::Error, S("A_super_call_must_be_the_first_statement_in_the_constructor_to_refer_to_super_or_this_when_a_derived_2376"), S("A 'super' call must be the first statement in the constructor to refer to 'super' or 'this' when a derived class contains initialized properties, parameter properties, or private identifiers.")};
        static DiagnosticMessageStore Constructors_for_derived_classes_must_contain_a_super_call = {2377, DiagnosticCategory::Error, S("Constructors_for_derived_classes_must_contain_a_super_call_2377"), S("Constructors for derived classes must contain a 'super' call.")};
        static DiagnosticMessageStore A_get_accessor_must_return_a_value = {2378, DiagnosticCategory::Error, S("A_get_accessor_must_return_a_value_2378"), S("A 'get' accessor must return a value.")};
        static DiagnosticMessageStore Argument_of_type_0_is_not_assignable_to_parameter_of_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_types_of_the_target_s_properties = {2379, DiagnosticCategory::Error, S("Argument_of_type_0_is_not_assignable_to_parameter_of_type_1_with_exactOptionalPropertyTypes_Colon_tr_2379"), S("Argument of type '{0}' is not assignable to parameter of type '{1}' with 'exactOptionalPropertyTypes: true'. Consider adding 'undefined' to the types of the target's properties.")};
        static DiagnosticMessageStore Overload_signatures_must_all_be_exported_or_non_exported = {2383, DiagnosticCategory::Error, S("Overload_signatures_must_all_be_exported_or_non_exported_2383"), S("Overload signatures must all be exported or non-exported.")};
        static DiagnosticMessageStore Overload_signatures_must_all_be_ambient_or_non_ambient = {2384, DiagnosticCategory::Error, S("Overload_signatures_must_all_be_ambient_or_non_ambient_2384"), S("Overload signatures must all be ambient or non-ambient.")};
        static DiagnosticMessageStore Overload_signatures_must_all_be_public_private_or_protected = {2385, DiagnosticCategory::Error, S("Overload_signatures_must_all_be_public_private_or_protected_2385"), S("Overload signatures must all be public, private or protected.")};
        static DiagnosticMessageStore Overload_signatures_must_all_be_optional_or_required = {2386, DiagnosticCategory::Error, S("Overload_signatures_must_all_be_optional_or_required_2386"), S("Overload signatures must all be optional or required.")};
        static DiagnosticMessageStore Function_overload_must_be_static = {2387, DiagnosticCategory::Error, S("Function_overload_must_be_static_2387"), S("Function overload must be static.")};
        static DiagnosticMessageStore Function_overload_must_not_be_static = {2388, DiagnosticCategory::Error, S("Function_overload_must_not_be_static_2388"), S("Function overload must not be static.")};
        static DiagnosticMessageStore Function_implementation_name_must_be_0 = {2389, DiagnosticCategory::Error, S("Function_implementation_name_must_be_0_2389"), S("Function implementation name must be '{0}'.")};
        static DiagnosticMessageStore Constructor_implementation_is_missing = {2390, DiagnosticCategory::Error, S("Constructor_implementation_is_missing_2390"), S("Constructor implementation is missing.")};
        static DiagnosticMessageStore Function_implementation_is_missing_or_not_immediately_following_the_declaration = {2391, DiagnosticCategory::Error, S("Function_implementation_is_missing_or_not_immediately_following_the_declaration_2391"), S("Function implementation is missing or not immediately following the declaration.")};
        static DiagnosticMessageStore Multiple_constructor_implementations_are_not_allowed = {2392, DiagnosticCategory::Error, S("Multiple_constructor_implementations_are_not_allowed_2392"), S("Multiple constructor implementations are not allowed.")};
        static DiagnosticMessageStore Duplicate_function_implementation = {2393, DiagnosticCategory::Error, S("Duplicate_function_implementation_2393"), S("Duplicate function implementation.")};
        static DiagnosticMessageStore This_overload_signature_is_not_compatible_with_its_implementation_signature = {2394, DiagnosticCategory::Error, S("This_overload_signature_is_not_compatible_with_its_implementation_signature_2394"), S("This overload signature is not compatible with its implementation signature.")};
        static DiagnosticMessageStore Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local = {2395, DiagnosticCategory::Error, S("Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local_2395"), S("Individual declarations in merged declaration '{0}' must be all exported or all local.")};
        static DiagnosticMessageStore Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters = {2396, DiagnosticCategory::Error, S("Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters_2396"), S("Duplicate identifier 'arguments'. Compiler uses 'arguments' to initialize rest parameters.")};
        static DiagnosticMessageStore Declaration_name_conflicts_with_built_in_global_identifier_0 = {2397, DiagnosticCategory::Error, S("Declaration_name_conflicts_with_built_in_global_identifier_0_2397"), S("Declaration name conflicts with built-in global identifier '{0}'.")};
        static DiagnosticMessageStore constructor_cannot_be_used_as_a_parameter_property_name = {2398, DiagnosticCategory::Error, S("constructor_cannot_be_used_as_a_parameter_property_name_2398"), S("'constructor' cannot be used as a parameter property name.")};
        static DiagnosticMessageStore Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference = {2399, DiagnosticCategory::Error, S("Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference_2399"), S("Duplicate identifier '_this'. Compiler uses variable declaration '_this' to capture 'this' reference.")};
        static DiagnosticMessageStore Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference = {2400, DiagnosticCategory::Error, S("Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference_2400"), S("Expression resolves to variable declaration '_this' that compiler uses to capture 'this' reference.")};
        static DiagnosticMessageStore A_super_call_must_be_a_root_level_statement_within_a_constructor_of_a_derived_class_that_contains_initialized_properties_parameter_properties_or_private_identifiers = {2401, DiagnosticCategory::Error, S("A_super_call_must_be_a_root_level_statement_within_a_constructor_of_a_derived_class_that_contains_in_2401"), S("A 'super' call must be a root-level statement within a constructor of a derived class that contains initialized properties, parameter properties, or private identifiers.")};
        static DiagnosticMessageStore Expression_resolves_to_super_that_compiler_uses_to_capture_base_class_reference = {2402, DiagnosticCategory::Error, S("Expression_resolves_to_super_that_compiler_uses_to_capture_base_class_reference_2402"), S("Expression resolves to '_super' that compiler uses to capture base class reference.")};
        static DiagnosticMessageStore Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2 = {2403, DiagnosticCategory::Error, S("Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_t_2403"), S("Subsequent variable declarations must have the same type.  Variable '{0}' must be of type '{1}', but here has type '{2}'.")};
        static DiagnosticMessageStore The_left_hand_side_of_a_for_in_statement_cannot_use_a_type_annotation = {2404, DiagnosticCategory::Error, S("The_left_hand_side_of_a_for_in_statement_cannot_use_a_type_annotation_2404"), S("The left-hand side of a 'for...in' statement cannot use a type annotation.")};
        static DiagnosticMessageStore The_left_hand_side_of_a_for_in_statement_must_be_of_type_string_or_any = {2405, DiagnosticCategory::Error, S("The_left_hand_side_of_a_for_in_statement_must_be_of_type_string_or_any_2405"), S("The left-hand side of a 'for...in' statement must be of type 'string' or 'any'.")};
        static DiagnosticMessageStore The_left_hand_side_of_a_for_in_statement_must_be_a_variable_or_a_property_access = {2406, DiagnosticCategory::Error, S("The_left_hand_side_of_a_for_in_statement_must_be_a_variable_or_a_property_access_2406"), S("The left-hand side of a 'for...in' statement must be a variable or a property access.")};
        static DiagnosticMessageStore The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter_but_here_has_type_0 = {2407, DiagnosticCategory::Error, S("The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter_but_2407"), S("The right-hand side of a 'for...in' statement must be of type 'any', an object type or a type parameter, but here has type '{0}'.")};
        static DiagnosticMessageStore Setters_cannot_return_a_value = {2408, DiagnosticCategory::Error, S("Setters_cannot_return_a_value_2408"), S("Setters cannot return a value.")};
        static DiagnosticMessageStore Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class = {2409, DiagnosticCategory::Error, S("Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class_2409"), S("Return type of constructor signature must be assignable to the instance type of the class.")};
        static DiagnosticMessageStore The_with_statement_is_not_supported_All_symbols_in_a_with_block_will_have_type_any = {2410, DiagnosticCategory::Error, S("The_with_statement_is_not_supported_All_symbols_in_a_with_block_will_have_type_any_2410"), S("The 'with' statement is not supported. All symbols in a 'with' block will have type 'any'.")};
        static DiagnosticMessageStore Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_type_of_the_target = {2412, DiagnosticCategory::Error, S("Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefi_2412"), S("Type '{0}' is not assignable to type '{1}' with 'exactOptionalPropertyTypes: true'. Consider adding 'undefined' to the type of the target.")};
        static DiagnosticMessageStore Property_0_of_type_1_is_not_assignable_to_2_index_type_3 = {2411, DiagnosticCategory::Error, S("Property_0_of_type_1_is_not_assignable_to_2_index_type_3_2411"), S("Property '{0}' of type '{1}' is not assignable to '{2}' index type '{3}'.")};
        static DiagnosticMessageStore _0_index_type_1_is_not_assignable_to_2_index_type_3 = {2413, DiagnosticCategory::Error, S("_0_index_type_1_is_not_assignable_to_2_index_type_3_2413"), S("'{0}' index type '{1}' is not assignable to '{2}' index type '{3}'.")};
        static DiagnosticMessageStore Class_name_cannot_be_0 = {2414, DiagnosticCategory::Error, S("Class_name_cannot_be_0_2414"), S("Class name cannot be '{0}'.")};
        static DiagnosticMessageStore Class_0_incorrectly_extends_base_class_1 = {2415, DiagnosticCategory::Error, S("Class_0_incorrectly_extends_base_class_1_2415"), S("Class '{0}' incorrectly extends base class '{1}'.")};
        static DiagnosticMessageStore Property_0_in_type_1_is_not_assignable_to_the_same_property_in_base_type_2 = {2416, DiagnosticCategory::Error, S("Property_0_in_type_1_is_not_assignable_to_the_same_property_in_base_type_2_2416"), S("Property '{0}' in type '{1}' is not assignable to the same property in base type '{2}'.")};
        static DiagnosticMessageStore Class_static_side_0_incorrectly_extends_base_class_static_side_1 = {2417, DiagnosticCategory::Error, S("Class_static_side_0_incorrectly_extends_base_class_static_side_1_2417"), S("Class static side '{0}' incorrectly extends base class static side '{1}'.")};
        static DiagnosticMessageStore Type_of_computed_property_s_value_is_0_which_is_not_assignable_to_type_1 = {2418, DiagnosticCategory::Error, S("Type_of_computed_property_s_value_is_0_which_is_not_assignable_to_type_1_2418"), S("Type of computed property's value is '{0}', which is not assignable to type '{1}'.")};
        static DiagnosticMessageStore Types_of_construct_signatures_are_incompatible = {2419, DiagnosticCategory::Error, S("Types_of_construct_signatures_are_incompatible_2419"), S("Types of construct signatures are incompatible.")};
        static DiagnosticMessageStore Class_0_incorrectly_implements_interface_1 = {2420, DiagnosticCategory::Error, S("Class_0_incorrectly_implements_interface_1_2420"), S("Class '{0}' incorrectly implements interface '{1}'.")};
        static DiagnosticMessageStore A_class_can_only_implement_an_object_type_or_intersection_of_object_types_with_statically_known_members = {2422, DiagnosticCategory::Error, S("A_class_can_only_implement_an_object_type_or_intersection_of_object_types_with_statically_known_memb_2422"), S("A class can only implement an object type or intersection of object types with statically known members.")};
        static DiagnosticMessageStore Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor = {2423, DiagnosticCategory::Error, S("Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_access_2423"), S("Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member accessor.")};
        static DiagnosticMessageStore Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function = {2425, DiagnosticCategory::Error, S("Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_functi_2425"), S("Class '{0}' defines instance member property '{1}', but extended class '{2}' defines it as instance member function.")};
        static DiagnosticMessageStore Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function = {2426, DiagnosticCategory::Error, S("Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_functi_2426"), S("Class '{0}' defines instance member accessor '{1}', but extended class '{2}' defines it as instance member function.")};
        static DiagnosticMessageStore Interface_name_cannot_be_0 = {2427, DiagnosticCategory::Error, S("Interface_name_cannot_be_0_2427"), S("Interface name cannot be '{0}'.")};
        static DiagnosticMessageStore All_declarations_of_0_must_have_identical_type_parameters = {2428, DiagnosticCategory::Error, S("All_declarations_of_0_must_have_identical_type_parameters_2428"), S("All declarations of '{0}' must have identical type parameters.")};
        static DiagnosticMessageStore Interface_0_incorrectly_extends_interface_1 = {2430, DiagnosticCategory::Error, S("Interface_0_incorrectly_extends_interface_1_2430"), S("Interface '{0}' incorrectly extends interface '{1}'.")};
        static DiagnosticMessageStore Enum_name_cannot_be_0 = {2431, DiagnosticCategory::Error, S("Enum_name_cannot_be_0_2431"), S("Enum name cannot be '{0}'.")};
        static DiagnosticMessageStore In_an_enum_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_its_first_enum_element = {2432, DiagnosticCategory::Error, S("In_an_enum_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_its_first_enu_2432"), S("In an enum with multiple declarations, only one declaration can omit an initializer for its first enum element.")};
        static DiagnosticMessageStore A_namespace_declaration_cannot_be_in_a_different_file_from_a_class_or_function_with_which_it_is_merged = {2433, DiagnosticCategory::Error, S("A_namespace_declaration_cannot_be_in_a_different_file_from_a_class_or_function_with_which_it_is_merg_2433"), S("A namespace declaration cannot be in a different file from a class or function with which it is merged.")};
        static DiagnosticMessageStore A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged = {2434, DiagnosticCategory::Error, S("A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged_2434"), S("A namespace declaration cannot be located prior to a class or function with which it is merged.")};
        static DiagnosticMessageStore Ambient_modules_cannot_be_nested_in_other_modules_or_namespaces = {2435, DiagnosticCategory::Error, S("Ambient_modules_cannot_be_nested_in_other_modules_or_namespaces_2435"), S("Ambient modules cannot be nested in other modules or namespaces.")};
        static DiagnosticMessageStore Ambient_module_declaration_cannot_specify_relative_module_name = {2436, DiagnosticCategory::Error, S("Ambient_module_declaration_cannot_specify_relative_module_name_2436"), S("Ambient module declaration cannot specify relative module name.")};
        static DiagnosticMessageStore Module_0_is_hidden_by_a_local_declaration_with_the_same_name = {2437, DiagnosticCategory::Error, S("Module_0_is_hidden_by_a_local_declaration_with_the_same_name_2437"), S("Module '{0}' is hidden by a local declaration with the same name.")};
        static DiagnosticMessageStore Import_name_cannot_be_0 = {2438, DiagnosticCategory::Error, S("Import_name_cannot_be_0_2438"), S("Import name cannot be '{0}'.")};
        static DiagnosticMessageStore Import_or_export_declaration_in_an_ambient_module_declaration_cannot_reference_module_through_relative_module_name = {2439, DiagnosticCategory::Error, S("Import_or_export_declaration_in_an_ambient_module_declaration_cannot_reference_module_through_relati_2439"), S("Import or export declaration in an ambient module declaration cannot reference module through relative module name.")};
        static DiagnosticMessageStore Import_declaration_conflicts_with_local_declaration_of_0 = {2440, DiagnosticCategory::Error, S("Import_declaration_conflicts_with_local_declaration_of_0_2440"), S("Import declaration conflicts with local declaration of '{0}'.")};
        static DiagnosticMessageStore Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module = {2441, DiagnosticCategory::Error, S("Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module_2441"), S("Duplicate identifier '{0}'. Compiler reserves name '{1}' in top level scope of a module.")};
        static DiagnosticMessageStore Types_have_separate_declarations_of_a_private_property_0 = {2442, DiagnosticCategory::Error, S("Types_have_separate_declarations_of_a_private_property_0_2442"), S("Types have separate declarations of a private property '{0}'.")};
        static DiagnosticMessageStore Property_0_is_protected_but_type_1_is_not_a_class_derived_from_2 = {2443, DiagnosticCategory::Error, S("Property_0_is_protected_but_type_1_is_not_a_class_derived_from_2_2443"), S("Property '{0}' is protected but type '{1}' is not a class derived from '{2}'.")};
        static DiagnosticMessageStore Property_0_is_protected_in_type_1_but_public_in_type_2 = {2444, DiagnosticCategory::Error, S("Property_0_is_protected_in_type_1_but_public_in_type_2_2444"), S("Property '{0}' is protected in type '{1}' but public in type '{2}'.")};
        static DiagnosticMessageStore Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses = {2445, DiagnosticCategory::Error, S("Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses_2445"), S("Property '{0}' is protected and only accessible within class '{1}' and its subclasses.")};
        static DiagnosticMessageStore Property_0_is_protected_and_only_accessible_through_an_instance_of_class_1_This_is_an_instance_of_class_2 = {2446, DiagnosticCategory::Error, S("Property_0_is_protected_and_only_accessible_through_an_instance_of_class_1_This_is_an_instance_of_cl_2446"), S("Property '{0}' is protected and only accessible through an instance of class '{1}'. This is an instance of class '{2}'.")};
        static DiagnosticMessageStore The_0_operator_is_not_allowed_for_boolean_types_Consider_using_1_instead = {2447, DiagnosticCategory::Error, S("The_0_operator_is_not_allowed_for_boolean_types_Consider_using_1_instead_2447"), S("The '{0}' operator is not allowed for boolean types. Consider using '{1}' instead.")};
        static DiagnosticMessageStore Block_scoped_variable_0_used_before_its_declaration = {2448, DiagnosticCategory::Error, S("Block_scoped_variable_0_used_before_its_declaration_2448"), S("Block-scoped variable '{0}' used before its declaration.")};
        static DiagnosticMessageStore Class_0_used_before_its_declaration = {2449, DiagnosticCategory::Error, S("Class_0_used_before_its_declaration_2449"), S("Class '{0}' used before its declaration.")};
        static DiagnosticMessageStore Enum_0_used_before_its_declaration = {2450, DiagnosticCategory::Error, S("Enum_0_used_before_its_declaration_2450"), S("Enum '{0}' used before its declaration.")};
        static DiagnosticMessageStore Cannot_redeclare_block_scoped_variable_0 = {2451, DiagnosticCategory::Error, S("Cannot_redeclare_block_scoped_variable_0_2451"), S("Cannot redeclare block-scoped variable '{0}'.")};
        static DiagnosticMessageStore An_enum_member_cannot_have_a_numeric_name = {2452, DiagnosticCategory::Error, S("An_enum_member_cannot_have_a_numeric_name_2452"), S("An enum member cannot have a numeric name.")};
        static DiagnosticMessageStore Variable_0_is_used_before_being_assigned = {2454, DiagnosticCategory::Error, S("Variable_0_is_used_before_being_assigned_2454"), S("Variable '{0}' is used before being assigned.")};
        static DiagnosticMessageStore Type_alias_0_circularly_references_itself = {2456, DiagnosticCategory::Error, S("Type_alias_0_circularly_references_itself_2456"), S("Type alias '{0}' circularly references itself.")};
        static DiagnosticMessageStore Type_alias_name_cannot_be_0 = {2457, DiagnosticCategory::Error, S("Type_alias_name_cannot_be_0_2457"), S("Type alias name cannot be '{0}'.")};
        static DiagnosticMessageStore An_AMD_module_cannot_have_multiple_name_assignments = {2458, DiagnosticCategory::Error, S("An_AMD_module_cannot_have_multiple_name_assignments_2458"), S("An AMD module cannot have multiple name assignments.")};
        static DiagnosticMessageStore Module_0_declares_1_locally_but_it_is_not_exported = {2459, DiagnosticCategory::Error, S("Module_0_declares_1_locally_but_it_is_not_exported_2459"), S("Module '{0}' declares '{1}' locally, but it is not exported.")};
        static DiagnosticMessageStore Module_0_declares_1_locally_but_it_is_exported_as_2 = {2460, DiagnosticCategory::Error, S("Module_0_declares_1_locally_but_it_is_exported_as_2_2460"), S("Module '{0}' declares '{1}' locally, but it is exported as '{2}'.")};
        static DiagnosticMessageStore Type_0_is_not_an_array_type = {2461, DiagnosticCategory::Error, S("Type_0_is_not_an_array_type_2461"), S("Type '{0}' is not an array type.")};
        static DiagnosticMessageStore A_rest_element_must_be_last_in_a_destructuring_pattern = {2462, DiagnosticCategory::Error, S("A_rest_element_must_be_last_in_a_destructuring_pattern_2462"), S("A rest element must be last in a destructuring pattern.")};
        static DiagnosticMessageStore A_binding_pattern_parameter_cannot_be_optional_in_an_implementation_signature = {2463, DiagnosticCategory::Error, S("A_binding_pattern_parameter_cannot_be_optional_in_an_implementation_signature_2463"), S("A binding pattern parameter cannot be optional in an implementation signature.")};
        static DiagnosticMessageStore A_computed_property_name_must_be_of_type_string_number_symbol_or_any = {2464, DiagnosticCategory::Error, S("A_computed_property_name_must_be_of_type_string_number_symbol_or_any_2464"), S("A computed property name must be of type 'string', 'number', 'symbol', or 'any'.")};
        static DiagnosticMessageStore this_cannot_be_referenced_in_a_computed_property_name = {2465, DiagnosticCategory::Error, S("this_cannot_be_referenced_in_a_computed_property_name_2465"), S("'this' cannot be referenced in a computed property name.")};
        static DiagnosticMessageStore super_cannot_be_referenced_in_a_computed_property_name = {2466, DiagnosticCategory::Error, S("super_cannot_be_referenced_in_a_computed_property_name_2466"), S("'super' cannot be referenced in a computed property name.")};
        static DiagnosticMessageStore A_computed_property_name_cannot_reference_a_type_parameter_from_its_containing_type = {2467, DiagnosticCategory::Error, S("A_computed_property_name_cannot_reference_a_type_parameter_from_its_containing_type_2467"), S("A computed property name cannot reference a type parameter from its containing type.")};
        static DiagnosticMessageStore Cannot_find_global_value_0 = {2468, DiagnosticCategory::Error, S("Cannot_find_global_value_0_2468"), S("Cannot find global value '{0}'.")};
        static DiagnosticMessageStore The_0_operator_cannot_be_applied_to_type_symbol = {2469, DiagnosticCategory::Error, S("The_0_operator_cannot_be_applied_to_type_symbol_2469"), S("The '{0}' operator cannot be applied to type 'symbol'.")};
        static DiagnosticMessageStore Spread_operator_in_new_expressions_is_only_available_when_targeting_ECMAScript_5_and_higher = {2472, DiagnosticCategory::Error, S("Spread_operator_in_new_expressions_is_only_available_when_targeting_ECMAScript_5_and_higher_2472"), S("Spread operator in 'new' expressions is only available when targeting ECMAScript 5 and higher.")};
        static DiagnosticMessageStore Enum_declarations_must_all_be_const_or_non_const = {2473, DiagnosticCategory::Error, S("Enum_declarations_must_all_be_const_or_non_const_2473"), S("Enum declarations must all be const or non-const.")};
        static DiagnosticMessageStore const_enum_member_initializers_must_be_constant_expressions = {2474, DiagnosticCategory::Error, S("const_enum_member_initializers_must_be_constant_expressions_2474"), S("const enum member initializers must be constant expressions.")};
        static DiagnosticMessageStore const_enums_can_only_be_used_in_property_or_index_access_expressions_or_the_right_hand_side_of_an_import_declaration_or_export_assignment_or_type_query = {2475, DiagnosticCategory::Error, S("const_enums_can_only_be_used_in_property_or_index_access_expressions_or_the_right_hand_side_of_an_im_2475"), S("'const' enums can only be used in property or index access expressions or the right hand side of an import declaration or export assignment or type query.")};
        static DiagnosticMessageStore A_const_enum_member_can_only_be_accessed_using_a_string_literal = {2476, DiagnosticCategory::Error, S("A_const_enum_member_can_only_be_accessed_using_a_string_literal_2476"), S("A const enum member can only be accessed using a string literal.")};
        static DiagnosticMessageStore const_enum_member_initializer_was_evaluated_to_a_non_finite_value = {2477, DiagnosticCategory::Error, S("const_enum_member_initializer_was_evaluated_to_a_non_finite_value_2477"), S("'const' enum member initializer was evaluated to a non-finite value.")};
        static DiagnosticMessageStore const_enum_member_initializer_was_evaluated_to_disallowed_value_NaN = {2478, DiagnosticCategory::Error, S("const_enum_member_initializer_was_evaluated_to_disallowed_value_NaN_2478"), S("'const' enum member initializer was evaluated to disallowed value 'NaN'.")};
        static DiagnosticMessageStore let_is_not_allowed_to_be_used_as_a_name_in_let_or_const_declarations = {2480, DiagnosticCategory::Error, S("let_is_not_allowed_to_be_used_as_a_name_in_let_or_const_declarations_2480"), S("'let' is not allowed to be used as a name in 'let' or 'const' declarations.")};
        static DiagnosticMessageStore Cannot_initialize_outer_scoped_variable_0_in_the_same_scope_as_block_scoped_declaration_1 = {2481, DiagnosticCategory::Error, S("Cannot_initialize_outer_scoped_variable_0_in_the_same_scope_as_block_scoped_declaration_1_2481"), S("Cannot initialize outer scoped variable '{0}' in the same scope as block scoped declaration '{1}'.")};
        static DiagnosticMessageStore The_left_hand_side_of_a_for_of_statement_cannot_use_a_type_annotation = {2483, DiagnosticCategory::Error, S("The_left_hand_side_of_a_for_of_statement_cannot_use_a_type_annotation_2483"), S("The left-hand side of a 'for...of' statement cannot use a type annotation.")};
        static DiagnosticMessageStore Export_declaration_conflicts_with_exported_declaration_of_0 = {2484, DiagnosticCategory::Error, S("Export_declaration_conflicts_with_exported_declaration_of_0_2484"), S("Export declaration conflicts with exported declaration of '{0}'.")};
        static DiagnosticMessageStore The_left_hand_side_of_a_for_of_statement_must_be_a_variable_or_a_property_access = {2487, DiagnosticCategory::Error, S("The_left_hand_side_of_a_for_of_statement_must_be_a_variable_or_a_property_access_2487"), S("The left-hand side of a 'for...of' statement must be a variable or a property access.")};
        static DiagnosticMessageStore Type_0_must_have_a_Symbol_iterator_method_that_returns_an_iterator = {2488, DiagnosticCategory::Error, S("Type_0_must_have_a_Symbol_iterator_method_that_returns_an_iterator_2488"), S("Type '{0}' must have a '[Symbol.iterator]()' method that returns an iterator.")};
        static DiagnosticMessageStore An_iterator_must_have_a_next_method = {2489, DiagnosticCategory::Error, S("An_iterator_must_have_a_next_method_2489"), S("An iterator must have a 'next()' method.")};
        static DiagnosticMessageStore The_type_returned_by_the_0_method_of_an_iterator_must_have_a_value_property = {2490, DiagnosticCategory::Error, S("The_type_returned_by_the_0_method_of_an_iterator_must_have_a_value_property_2490"), S("The type returned by the '{0}()' method of an iterator must have a 'value' property.")};
        static DiagnosticMessageStore The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern = {2491, DiagnosticCategory::Error, S("The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern_2491"), S("The left-hand side of a 'for...in' statement cannot be a destructuring pattern.")};
        static DiagnosticMessageStore Cannot_redeclare_identifier_0_in_catch_clause = {2492, DiagnosticCategory::Error, S("Cannot_redeclare_identifier_0_in_catch_clause_2492"), S("Cannot redeclare identifier '{0}' in catch clause.")};
        static DiagnosticMessageStore Tuple_type_0_of_length_1_has_no_element_at_index_2 = {2493, DiagnosticCategory::Error, S("Tuple_type_0_of_length_1_has_no_element_at_index_2_2493"), S("Tuple type '{0}' of length '{1}' has no element at index '{2}'.")};
        static DiagnosticMessageStore Using_a_string_in_a_for_of_statement_is_only_supported_in_ECMAScript_5_and_higher = {2494, DiagnosticCategory::Error, S("Using_a_string_in_a_for_of_statement_is_only_supported_in_ECMAScript_5_and_higher_2494"), S("Using a string in a 'for...of' statement is only supported in ECMAScript 5 and higher.")};
        static DiagnosticMessageStore Type_0_is_not_an_array_type_or_a_string_type = {2495, DiagnosticCategory::Error, S("Type_0_is_not_an_array_type_or_a_string_type_2495"), S("Type '{0}' is not an array type or a string type.")};
        static DiagnosticMessageStore The_arguments_object_cannot_be_referenced_in_an_arrow_function_in_ES3_and_ES5_Consider_using_a_standard_function_expression = {2496, DiagnosticCategory::Error, S("The_arguments_object_cannot_be_referenced_in_an_arrow_function_in_ES3_and_ES5_Consider_using_a_stand_2496"), S("The 'arguments' object cannot be referenced in an arrow function in ES3 and ES5. Consider using a standard function expression.")};
        static DiagnosticMessageStore This_module_can_only_be_referenced_with_ECMAScript_imports_Slashexports_by_turning_on_the_0_flag_and_referencing_its_default_export = {2497, DiagnosticCategory::Error, S("This_module_can_only_be_referenced_with_ECMAScript_imports_Slashexports_by_turning_on_the_0_flag_and_2497"), S("This module can only be referenced with ECMAScript imports/exports by turning on the '{0}' flag and referencing its default export.")};
        static DiagnosticMessageStore Module_0_uses_export_and_cannot_be_used_with_export_Asterisk = {2498, DiagnosticCategory::Error, S("Module_0_uses_export_and_cannot_be_used_with_export_Asterisk_2498"), S("Module '{0}' uses 'export =' and cannot be used with 'export *'.")};
        static DiagnosticMessageStore An_interface_can_only_extend_an_identifier_Slashqualified_name_with_optional_type_arguments = {2499, DiagnosticCategory::Error, S("An_interface_can_only_extend_an_identifier_Slashqualified_name_with_optional_type_arguments_2499"), S("An interface can only extend an identifier/qualified-name with optional type arguments.")};
        static DiagnosticMessageStore A_class_can_only_implement_an_identifier_Slashqualified_name_with_optional_type_arguments = {2500, DiagnosticCategory::Error, S("A_class_can_only_implement_an_identifier_Slashqualified_name_with_optional_type_arguments_2500"), S("A class can only implement an identifier/qualified-name with optional type arguments.")};
        static DiagnosticMessageStore A_rest_element_cannot_contain_a_binding_pattern = {2501, DiagnosticCategory::Error, S("A_rest_element_cannot_contain_a_binding_pattern_2501"), S("A rest element cannot contain a binding pattern.")};
        static DiagnosticMessageStore _0_is_referenced_directly_or_indirectly_in_its_own_type_annotation = {2502, DiagnosticCategory::Error, S("_0_is_referenced_directly_or_indirectly_in_its_own_type_annotation_2502"), S("'{0}' is referenced directly or indirectly in its own type annotation.")};
        static DiagnosticMessageStore Cannot_find_namespace_0 = {2503, DiagnosticCategory::Error, S("Cannot_find_namespace_0_2503"), S("Cannot find namespace '{0}'.")};
        static DiagnosticMessageStore Type_0_must_have_a_Symbol_asyncIterator_method_that_returns_an_async_iterator = {2504, DiagnosticCategory::Error, S("Type_0_must_have_a_Symbol_asyncIterator_method_that_returns_an_async_iterator_2504"), S("Type '{0}' must have a '[Symbol.asyncIterator]()' method that returns an async iterator.")};
        static DiagnosticMessageStore A_generator_cannot_have_a_void_type_annotation = {2505, DiagnosticCategory::Error, S("A_generator_cannot_have_a_void_type_annotation_2505"), S("A generator cannot have a 'void' type annotation.")};
        static DiagnosticMessageStore _0_is_referenced_directly_or_indirectly_in_its_own_base_expression = {2506, DiagnosticCategory::Error, S("_0_is_referenced_directly_or_indirectly_in_its_own_base_expression_2506"), S("'{0}' is referenced directly or indirectly in its own base expression.")};
        static DiagnosticMessageStore Type_0_is_not_a_constructor_function_type = {2507, DiagnosticCategory::Error, S("Type_0_is_not_a_constructor_function_type_2507"), S("Type '{0}' is not a constructor function type.")};
        static DiagnosticMessageStore No_base_constructor_has_the_specified_number_of_type_arguments = {2508, DiagnosticCategory::Error, S("No_base_constructor_has_the_specified_number_of_type_arguments_2508"), S("No base constructor has the specified number of type arguments.")};
        static DiagnosticMessageStore Base_constructor_return_type_0_is_not_an_object_type_or_intersection_of_object_types_with_statically_known_members = {2509, DiagnosticCategory::Error, S("Base_constructor_return_type_0_is_not_an_object_type_or_intersection_of_object_types_with_statically_2509"), S("Base constructor return type '{0}' is not an object type or intersection of object types with statically known members.")};
        static DiagnosticMessageStore Base_constructors_must_all_have_the_same_return_type = {2510, DiagnosticCategory::Error, S("Base_constructors_must_all_have_the_same_return_type_2510"), S("Base constructors must all have the same return type.")};
        static DiagnosticMessageStore Cannot_create_an_instance_of_an_abstract_class = {2511, DiagnosticCategory::Error, S("Cannot_create_an_instance_of_an_abstract_class_2511"), S("Cannot create an instance of an abstract class.")};
        static DiagnosticMessageStore Overload_signatures_must_all_be_abstract_or_non_abstract = {2512, DiagnosticCategory::Error, S("Overload_signatures_must_all_be_abstract_or_non_abstract_2512"), S("Overload signatures must all be abstract or non-abstract.")};
        static DiagnosticMessageStore Abstract_method_0_in_class_1_cannot_be_accessed_via_super_expression = {2513, DiagnosticCategory::Error, S("Abstract_method_0_in_class_1_cannot_be_accessed_via_super_expression_2513"), S("Abstract method '{0}' in class '{1}' cannot be accessed via super expression.")};
        static DiagnosticMessageStore A_tuple_type_cannot_be_indexed_with_a_negative_value = {2514, DiagnosticCategory::Error, S("A_tuple_type_cannot_be_indexed_with_a_negative_value_2514"), S("A tuple type cannot be indexed with a negative value.")};
        static DiagnosticMessageStore Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_class_2 = {2515, DiagnosticCategory::Error, S("Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_class_2_2515"), S("Non-abstract class '{0}' does not implement inherited abstract member '{1}' from class '{2}'.")};
        static DiagnosticMessageStore All_declarations_of_an_abstract_method_must_be_consecutive = {2516, DiagnosticCategory::Error, S("All_declarations_of_an_abstract_method_must_be_consecutive_2516"), S("All declarations of an abstract method must be consecutive.")};
        static DiagnosticMessageStore Cannot_assign_an_abstract_constructor_type_to_a_non_abstract_constructor_type = {2517, DiagnosticCategory::Error, S("Cannot_assign_an_abstract_constructor_type_to_a_non_abstract_constructor_type_2517"), S("Cannot assign an abstract constructor type to a non-abstract constructor type.")};
        static DiagnosticMessageStore A_this_based_type_guard_is_not_compatible_with_a_parameter_based_type_guard = {2518, DiagnosticCategory::Error, S("A_this_based_type_guard_is_not_compatible_with_a_parameter_based_type_guard_2518"), S("A 'this'-based type guard is not compatible with a parameter-based type guard.")};
        static DiagnosticMessageStore An_async_iterator_must_have_a_next_method = {2519, DiagnosticCategory::Error, S("An_async_iterator_must_have_a_next_method_2519"), S("An async iterator must have a 'next()' method.")};
        static DiagnosticMessageStore Duplicate_identifier_0_Compiler_uses_declaration_1_to_support_async_functions = {2520, DiagnosticCategory::Error, S("Duplicate_identifier_0_Compiler_uses_declaration_1_to_support_async_functions_2520"), S("Duplicate identifier '{0}'. Compiler uses declaration '{1}' to support async functions.")};
        static DiagnosticMessageStore The_arguments_object_cannot_be_referenced_in_an_async_function_or_method_in_ES3_and_ES5_Consider_using_a_standard_function_or_method = {2522, DiagnosticCategory::Error, S("The_arguments_object_cannot_be_referenced_in_an_async_function_or_method_in_ES3_and_ES5_Consider_usi_2522"), S("The 'arguments' object cannot be referenced in an async function or method in ES3 and ES5. Consider using a standard function or method.")};
        static DiagnosticMessageStore yield_expressions_cannot_be_used_in_a_parameter_initializer = {2523, DiagnosticCategory::Error, S("yield_expressions_cannot_be_used_in_a_parameter_initializer_2523"), S("'yield' expressions cannot be used in a parameter initializer.")};
        static DiagnosticMessageStore await_expressions_cannot_be_used_in_a_parameter_initializer = {2524, DiagnosticCategory::Error, S("await_expressions_cannot_be_used_in_a_parameter_initializer_2524"), S("'await' expressions cannot be used in a parameter initializer.")};
        static DiagnosticMessageStore Initializer_provides_no_value_for_this_binding_element_and_the_binding_element_has_no_default_value = {2525, DiagnosticCategory::Error, S("Initializer_provides_no_value_for_this_binding_element_and_the_binding_element_has_no_default_value_2525"), S("Initializer provides no value for this binding element and the binding element has no default value.")};
        static DiagnosticMessageStore A_this_type_is_available_only_in_a_non_static_member_of_a_class_or_interface = {2526, DiagnosticCategory::Error, S("A_this_type_is_available_only_in_a_non_static_member_of_a_class_or_interface_2526"), S("A 'this' type is available only in a non-static member of a class or interface.")};
        static DiagnosticMessageStore The_inferred_type_of_0_references_an_inaccessible_1_type_A_type_annotation_is_necessary = {2527, DiagnosticCategory::Error, S("The_inferred_type_of_0_references_an_inaccessible_1_type_A_type_annotation_is_necessary_2527"), S("The inferred type of '{0}' references an inaccessible '{1}' type. A type annotation is necessary.")};
        static DiagnosticMessageStore A_module_cannot_have_multiple_default_exports = {2528, DiagnosticCategory::Error, S("A_module_cannot_have_multiple_default_exports_2528"), S("A module cannot have multiple default exports.")};
        static DiagnosticMessageStore Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module_containing_async_functions = {2529, DiagnosticCategory::Error, S("Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module_containing_async_func_2529"), S("Duplicate identifier '{0}'. Compiler reserves name '{1}' in top level scope of a module containing async functions.")};
        static DiagnosticMessageStore Property_0_is_incompatible_with_index_signature = {2530, DiagnosticCategory::Error, S("Property_0_is_incompatible_with_index_signature_2530"), S("Property '{0}' is incompatible with index signature.")};
        static DiagnosticMessageStore Object_is_possibly_null = {2531, DiagnosticCategory::Error, S("Object_is_possibly_null_2531"), S("Object is possibly 'null'.")};
        static DiagnosticMessageStore Object_is_possibly_undefined = {2532, DiagnosticCategory::Error, S("Object_is_possibly_undefined_2532"), S("Object is possibly 'undefined'.")};
        static DiagnosticMessageStore Object_is_possibly_null_or_undefined = {2533, DiagnosticCategory::Error, S("Object_is_possibly_null_or_undefined_2533"), S("Object is possibly 'null' or 'undefined'.")};
        static DiagnosticMessageStore A_function_returning_never_cannot_have_a_reachable_end_point = {2534, DiagnosticCategory::Error, S("A_function_returning_never_cannot_have_a_reachable_end_point_2534"), S("A function returning 'never' cannot have a reachable end point.")};
        static DiagnosticMessageStore Type_0_cannot_be_used_to_index_type_1 = {2536, DiagnosticCategory::Error, S("Type_0_cannot_be_used_to_index_type_1_2536"), S("Type '{0}' cannot be used to index type '{1}'.")};
        static DiagnosticMessageStore Type_0_has_no_matching_index_signature_for_type_1 = {2537, DiagnosticCategory::Error, S("Type_0_has_no_matching_index_signature_for_type_1_2537"), S("Type '{0}' has no matching index signature for type '{1}'.")};
        static DiagnosticMessageStore Type_0_cannot_be_used_as_an_index_type = {2538, DiagnosticCategory::Error, S("Type_0_cannot_be_used_as_an_index_type_2538"), S("Type '{0}' cannot be used as an index type.")};
        static DiagnosticMessageStore Cannot_assign_to_0_because_it_is_not_a_variable = {2539, DiagnosticCategory::Error, S("Cannot_assign_to_0_because_it_is_not_a_variable_2539"), S("Cannot assign to '{0}' because it is not a variable.")};
        static DiagnosticMessageStore Cannot_assign_to_0_because_it_is_a_read_only_property = {2540, DiagnosticCategory::Error, S("Cannot_assign_to_0_because_it_is_a_read_only_property_2540"), S("Cannot assign to '{0}' because it is a read-only property.")};
        static DiagnosticMessageStore Index_signature_in_type_0_only_permits_reading = {2542, DiagnosticCategory::Error, S("Index_signature_in_type_0_only_permits_reading_2542"), S("Index signature in type '{0}' only permits reading.")};
        static DiagnosticMessageStore Duplicate_identifier_newTarget_Compiler_uses_variable_declaration_newTarget_to_capture_new_target_meta_property_reference = {2543, DiagnosticCategory::Error, S("Duplicate_identifier_newTarget_Compiler_uses_variable_declaration_newTarget_to_capture_new_target_me_2543"), S("Duplicate identifier '_newTarget'. Compiler uses variable declaration '_newTarget' to capture 'new.target' meta-property reference.")};
        static DiagnosticMessageStore Expression_resolves_to_variable_declaration_newTarget_that_compiler_uses_to_capture_new_target_meta_property_reference = {2544, DiagnosticCategory::Error, S("Expression_resolves_to_variable_declaration_newTarget_that_compiler_uses_to_capture_new_target_meta__2544"), S("Expression resolves to variable declaration '_newTarget' that compiler uses to capture 'new.target' meta-property reference.")};
        static DiagnosticMessageStore A_mixin_class_must_have_a_constructor_with_a_single_rest_parameter_of_type_any = {2545, DiagnosticCategory::Error, S("A_mixin_class_must_have_a_constructor_with_a_single_rest_parameter_of_type_any_2545"), S("A mixin class must have a constructor with a single rest parameter of type 'any[]'.")};
        static DiagnosticMessageStore The_type_returned_by_the_0_method_of_an_async_iterator_must_be_a_promise_for_a_type_with_a_value_property = {2547, DiagnosticCategory::Error, S("The_type_returned_by_the_0_method_of_an_async_iterator_must_be_a_promise_for_a_type_with_a_value_pro_2547"), S("The type returned by the '{0}()' method of an async iterator must be a promise for a type with a 'value' property.")};
        static DiagnosticMessageStore Type_0_is_not_an_array_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator = {2548, DiagnosticCategory::Error, S("Type_0_is_not_an_array_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator_2548"), S("Type '{0}' is not an array type or does not have a '[Symbol.iterator]()' method that returns an iterator.")};
        static DiagnosticMessageStore Type_0_is_not_an_array_type_or_a_string_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator = {2549, DiagnosticCategory::Error, S("Type_0_is_not_an_array_type_or_a_string_type_or_does_not_have_a_Symbol_iterator_method_that_returns__2549"), S("Type '{0}' is not an array type or a string type or does not have a '[Symbol.iterator]()' method that returns an iterator.")};
        static DiagnosticMessageStore Property_0_does_not_exist_on_type_1_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_2_or_later = {2550, DiagnosticCategory::Error, S("Property_0_does_not_exist_on_type_1_Do_you_need_to_change_your_target_library_Try_changing_the_lib_c_2550"), S("Property '{0}' does not exist on type '{1}'. Do you need to change your target library? Try changing the 'lib' compiler option to '{2}' or later.")};
        static DiagnosticMessageStore Property_0_does_not_exist_on_type_1_Did_you_mean_2 = {2551, DiagnosticCategory::Error, S("Property_0_does_not_exist_on_type_1_Did_you_mean_2_2551"), S("Property '{0}' does not exist on type '{1}'. Did you mean '{2}'?")};
        static DiagnosticMessageStore Cannot_find_name_0_Did_you_mean_1 = {2552, DiagnosticCategory::Error, S("Cannot_find_name_0_Did_you_mean_1_2552"), S("Cannot find name '{0}'. Did you mean '{1}'?")};
        static DiagnosticMessageStore Computed_values_are_not_permitted_in_an_enum_with_string_valued_members = {2553, DiagnosticCategory::Error, S("Computed_values_are_not_permitted_in_an_enum_with_string_valued_members_2553"), S("Computed values are not permitted in an enum with string valued members.")};
        static DiagnosticMessageStore Expected_0_arguments_but_got_1 = {2554, DiagnosticCategory::Error, S("Expected_0_arguments_but_got_1_2554"), S("Expected {0} arguments, but got {1}.")};
        static DiagnosticMessageStore Expected_at_least_0_arguments_but_got_1 = {2555, DiagnosticCategory::Error, S("Expected_at_least_0_arguments_but_got_1_2555"), S("Expected at least {0} arguments, but got {1}.")};
        static DiagnosticMessageStore A_spread_argument_must_either_have_a_tuple_type_or_be_passed_to_a_rest_parameter = {2556, DiagnosticCategory::Error, S("A_spread_argument_must_either_have_a_tuple_type_or_be_passed_to_a_rest_parameter_2556"), S("A spread argument must either have a tuple type or be passed to a rest parameter.")};
        static DiagnosticMessageStore Expected_0_type_arguments_but_got_1 = {2558, DiagnosticCategory::Error, S("Expected_0_type_arguments_but_got_1_2558"), S("Expected {0} type arguments, but got {1}.")};
        static DiagnosticMessageStore Type_0_has_no_properties_in_common_with_type_1 = {2559, DiagnosticCategory::Error, S("Type_0_has_no_properties_in_common_with_type_1_2559"), S("Type '{0}' has no properties in common with type '{1}'.")};
        static DiagnosticMessageStore Value_of_type_0_has_no_properties_in_common_with_type_1_Did_you_mean_to_call_it = {2560, DiagnosticCategory::Error, S("Value_of_type_0_has_no_properties_in_common_with_type_1_Did_you_mean_to_call_it_2560"), S("Value of type '{0}' has no properties in common with type '{1}'. Did you mean to call it?")};
        static DiagnosticMessageStore Object_literal_may_only_specify_known_properties_but_0_does_not_exist_in_type_1_Did_you_mean_to_write_2 = {2561, DiagnosticCategory::Error, S("Object_literal_may_only_specify_known_properties_but_0_does_not_exist_in_type_1_Did_you_mean_to_writ_2561"), S("Object literal may only specify known properties, but '{0}' does not exist in type '{1}'. Did you mean to write '{2}'?")};
        static DiagnosticMessageStore Base_class_expressions_cannot_reference_class_type_parameters = {2562, DiagnosticCategory::Error, S("Base_class_expressions_cannot_reference_class_type_parameters_2562"), S("Base class expressions cannot reference class type parameters.")};
        static DiagnosticMessageStore The_containing_function_or_module_body_is_too_large_for_control_flow_analysis = {2563, DiagnosticCategory::Error, S("The_containing_function_or_module_body_is_too_large_for_control_flow_analysis_2563"), S("The containing function or module body is too large for control flow analysis.")};
        static DiagnosticMessageStore Property_0_has_no_initializer_and_is_not_definitely_assigned_in_the_constructor = {2564, DiagnosticCategory::Error, S("Property_0_has_no_initializer_and_is_not_definitely_assigned_in_the_constructor_2564"), S("Property '{0}' has no initializer and is not definitely assigned in the constructor.")};
        static DiagnosticMessageStore Property_0_is_used_before_being_assigned = {2565, DiagnosticCategory::Error, S("Property_0_is_used_before_being_assigned_2565"), S("Property '{0}' is used before being assigned.")};
        static DiagnosticMessageStore A_rest_element_cannot_have_a_property_name = {2566, DiagnosticCategory::Error, S("A_rest_element_cannot_have_a_property_name_2566"), S("A rest element cannot have a property name.")};
        static DiagnosticMessageStore Enum_declarations_can_only_merge_with_namespace_or_other_enum_declarations = {2567, DiagnosticCategory::Error, S("Enum_declarations_can_only_merge_with_namespace_or_other_enum_declarations_2567"), S("Enum declarations can only merge with namespace or other enum declarations.")};
        static DiagnosticMessageStore Property_0_may_not_exist_on_type_1_Did_you_mean_2 = {2568, DiagnosticCategory::Error, S("Property_0_may_not_exist_on_type_1_Did_you_mean_2_2568"), S("Property '{0}' may not exist on type '{1}'. Did you mean '{2}'?")};
        static DiagnosticMessageStore Could_not_find_name_0_Did_you_mean_1 = {2570, DiagnosticCategory::Error, S("Could_not_find_name_0_Did_you_mean_1_2570"), S("Could not find name '{0}'. Did you mean '{1}'?")};
        static DiagnosticMessageStore Object_is_of_type_unknown = {2571, DiagnosticCategory::Error, S("Object_is_of_type_unknown_2571"), S("Object is of type 'unknown'.")};
        static DiagnosticMessageStore A_rest_element_type_must_be_an_array_type = {2574, DiagnosticCategory::Error, S("A_rest_element_type_must_be_an_array_type_2574"), S("A rest element type must be an array type.")};
        static DiagnosticMessageStore No_overload_expects_0_arguments_but_overloads_do_exist_that_expect_either_1_or_2_arguments = {2575, DiagnosticCategory::Error, S("No_overload_expects_0_arguments_but_overloads_do_exist_that_expect_either_1_or_2_arguments_2575"), S("No overload expects {0} arguments, but overloads do exist that expect either {1} or {2} arguments.")};
        static DiagnosticMessageStore Property_0_does_not_exist_on_type_1_Did_you_mean_to_access_the_static_member_2_instead = {2576, DiagnosticCategory::Error, S("Property_0_does_not_exist_on_type_1_Did_you_mean_to_access_the_static_member_2_instead_2576"), S("Property '{0}' does not exist on type '{1}'. Did you mean to access the static member '{2}' instead?")};
        static DiagnosticMessageStore Return_type_annotation_circularly_references_itself = {2577, DiagnosticCategory::Error, S("Return_type_annotation_circularly_references_itself_2577"), S("Return type annotation circularly references itself.")};
        static DiagnosticMessageStore Unused_ts_expect_error_directive = {2578, DiagnosticCategory::Error, S("Unused_ts_expect_error_directive_2578"), S("Unused '@ts-expect-error' directive.")};
        static DiagnosticMessageStore Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_Slashnode = {2580, DiagnosticCategory::Error, S("Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_Slashno_2580"), S("Cannot find name '{0}'. Do you need to install type definitions for node? Try `npm i --save-dev @types/node`.")};
        static DiagnosticMessageStore Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_Slashjquery = {2581, DiagnosticCategory::Error, S("Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_Slash_2581"), S("Cannot find name '{0}'. Do you need to install type definitions for jQuery? Try `npm i --save-dev @types/jquery`.")};
        static DiagnosticMessageStore Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_types_Slashjest_or_npm_i_save_dev_types_Slashmocha = {2582, DiagnosticCategory::Error, S("Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_type_2582"), S("Cannot find name '{0}'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha`.")};
        static DiagnosticMessageStore Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_1_or_later = {2583, DiagnosticCategory::Error, S("Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_2583"), S("Cannot find name '{0}'. Do you need to change your target library? Try changing the 'lib' compiler option to '{1}' or later.")};
        static DiagnosticMessageStore Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_include_dom = {2584, DiagnosticCategory::Error, S("Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_2584"), S("Cannot find name '{0}'. Do you need to change your target library? Try changing the 'lib' compiler option to include 'dom'.")};
        static DiagnosticMessageStore _0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_es2015_or_later = {2585, DiagnosticCategory::Error, S("_0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Do_you_need_to_change_your_target_library_2585"), S("'{0}' only refers to a type, but is being used as a value here. Do you need to change your target library? Try changing the 'lib' compiler option to es2015 or later.")};
        static DiagnosticMessageStore Cannot_assign_to_0_because_it_is_a_constant = {2588, DiagnosticCategory::Error, S("Cannot_assign_to_0_because_it_is_a_constant_2588"), S("Cannot assign to '{0}' because it is a constant.")};
        static DiagnosticMessageStore Type_instantiation_is_excessively_deep_and_possibly_infinite = {2589, DiagnosticCategory::Error, S("Type_instantiation_is_excessively_deep_and_possibly_infinite_2589"), S("Type instantiation is excessively deep and possibly infinite.")};
        static DiagnosticMessageStore Expression_produces_a_union_type_that_is_too_complex_to_represent = {2590, DiagnosticCategory::Error, S("Expression_produces_a_union_type_that_is_too_complex_to_represent_2590"), S("Expression produces a union type that is too complex to represent.")};
        static DiagnosticMessageStore Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_Slashnode_and_then_add_node_to_the_types_field_in_your_tsconfig = {2591, DiagnosticCategory::Error, S("Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_Slashno_2591"), S("Cannot find name '{0}'. Do you need to install type definitions for node? Try `npm i --save-dev @types/node` and then add 'node' to the types field in your tsconfig.")};
        static DiagnosticMessageStore Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_Slashjquery_and_then_add_jquery_to_the_types_field_in_your_tsconfig = {2592, DiagnosticCategory::Error, S("Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_Slash_2592"), S("Cannot find name '{0}'. Do you need to install type definitions for jQuery? Try `npm i --save-dev @types/jquery` and then add 'jquery' to the types field in your tsconfig.")};
        static DiagnosticMessageStore Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_types_Slashjest_or_npm_i_save_dev_types_Slashmocha_and_then_add_jest_or_mocha_to_the_types_field_in_your_tsconfig = {2593, DiagnosticCategory::Error, S("Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_type_2593"), S("Cannot find name '{0}'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig.")};
        static DiagnosticMessageStore This_module_is_declared_with_export_and_can_only_be_used_with_a_default_import_when_using_the_0_flag = {2594, DiagnosticCategory::Error, S("This_module_is_declared_with_export_and_can_only_be_used_with_a_default_import_when_using_the_0_flag_2594"), S("This module is declared with 'export =', and can only be used with a default import when using the '{0}' flag.")};
        static DiagnosticMessageStore _0_can_only_be_imported_by_using_a_default_import = {2595, DiagnosticCategory::Error, S("_0_can_only_be_imported_by_using_a_default_import_2595"), S("'{0}' can only be imported by using a default import.")};
        static DiagnosticMessageStore _0_can_only_be_imported_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import = {2596, DiagnosticCategory::Error, S("_0_can_only_be_imported_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import_2596"), S("'{0}' can only be imported by turning on the 'esModuleInterop' flag and using a default import.")};
        static DiagnosticMessageStore _0_can_only_be_imported_by_using_a_require_call_or_by_using_a_default_import = {2597, DiagnosticCategory::Error, S("_0_can_only_be_imported_by_using_a_require_call_or_by_using_a_default_import_2597"), S("'{0}' can only be imported by using a 'require' call or by using a default import.")};
        static DiagnosticMessageStore _0_can_only_be_imported_by_using_a_require_call_or_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import = {2598, DiagnosticCategory::Error, S("_0_can_only_be_imported_by_using_a_require_call_or_by_turning_on_the_esModuleInterop_flag_and_using__2598"), S("'{0}' can only be imported by using a 'require' call or by turning on the 'esModuleInterop' flag and using a default import.")};
        static DiagnosticMessageStore JSX_element_implicitly_has_type_any_because_the_global_type_JSX_Element_does_not_exist = {2602, DiagnosticCategory::Error, S("JSX_element_implicitly_has_type_any_because_the_global_type_JSX_Element_does_not_exist_2602"), S("JSX element implicitly has type 'any' because the global type 'JSX.Element' does not exist.")};
        static DiagnosticMessageStore Property_0_in_type_1_is_not_assignable_to_type_2 = {2603, DiagnosticCategory::Error, S("Property_0_in_type_1_is_not_assignable_to_type_2_2603"), S("Property '{0}' in type '{1}' is not assignable to type '{2}'.")};
        static DiagnosticMessageStore JSX_element_type_0_does_not_have_any_construct_or_call_signatures = {2604, DiagnosticCategory::Error, S("JSX_element_type_0_does_not_have_any_construct_or_call_signatures_2604"), S("JSX element type '{0}' does not have any construct or call signatures.")};
        static DiagnosticMessageStore Property_0_of_JSX_spread_attribute_is_not_assignable_to_target_property = {2606, DiagnosticCategory::Error, S("Property_0_of_JSX_spread_attribute_is_not_assignable_to_target_property_2606"), S("Property '{0}' of JSX spread attribute is not assignable to target property.")};
        static DiagnosticMessageStore JSX_element_class_does_not_support_attributes_because_it_does_not_have_a_0_property = {2607, DiagnosticCategory::Error, S("JSX_element_class_does_not_support_attributes_because_it_does_not_have_a_0_property_2607"), S("JSX element class does not support attributes because it does not have a '{0}' property.")};
        static DiagnosticMessageStore The_global_type_JSX_0_may_not_have_more_than_one_property = {2608, DiagnosticCategory::Error, S("The_global_type_JSX_0_may_not_have_more_than_one_property_2608"), S("The global type 'JSX.{0}' may not have more than one property.")};
        static DiagnosticMessageStore JSX_spread_child_must_be_an_array_type = {2609, DiagnosticCategory::Error, S("JSX_spread_child_must_be_an_array_type_2609"), S("JSX spread child must be an array type.")};
        static DiagnosticMessageStore _0_is_defined_as_an_accessor_in_class_1_but_is_overridden_here_in_2_as_an_instance_property = {2610, DiagnosticCategory::Error, S("_0_is_defined_as_an_accessor_in_class_1_but_is_overridden_here_in_2_as_an_instance_property_2610"), S("'{0}' is defined as an accessor in class '{1}', but is overridden here in '{2}' as an instance property.")};
        static DiagnosticMessageStore _0_is_defined_as_a_property_in_class_1_but_is_overridden_here_in_2_as_an_accessor = {2611, DiagnosticCategory::Error, S("_0_is_defined_as_a_property_in_class_1_but_is_overridden_here_in_2_as_an_accessor_2611"), S("'{0}' is defined as a property in class '{1}', but is overridden here in '{2}' as an accessor.")};
        static DiagnosticMessageStore Property_0_will_overwrite_the_base_property_in_1_If_this_is_intentional_add_an_initializer_Otherwise_add_a_declare_modifier_or_remove_the_redundant_declaration = {2612, DiagnosticCategory::Error, S("Property_0_will_overwrite_the_base_property_in_1_If_this_is_intentional_add_an_initializer_Otherwise_2612"), S("Property '{0}' will overwrite the base property in '{1}'. If this is intentional, add an initializer. Otherwise, add a 'declare' modifier or remove the redundant declaration.")};
        static DiagnosticMessageStore Module_0_has_no_default_export_Did_you_mean_to_use_import_1_from_0_instead = {2613, DiagnosticCategory::Error, S("Module_0_has_no_default_export_Did_you_mean_to_use_import_1_from_0_instead_2613"), S("Module '{0}' has no default export. Did you mean to use 'import { {1} } from {0}' instead?")};
        static DiagnosticMessageStore Module_0_has_no_exported_member_1_Did_you_mean_to_use_import_1_from_0_instead = {2614, DiagnosticCategory::Error, S("Module_0_has_no_exported_member_1_Did_you_mean_to_use_import_1_from_0_instead_2614"), S("Module '{0}' has no exported member '{1}'. Did you mean to use 'import {1} from {0}' instead?")};
        static DiagnosticMessageStore Type_of_property_0_circularly_references_itself_in_mapped_type_1 = {2615, DiagnosticCategory::Error, S("Type_of_property_0_circularly_references_itself_in_mapped_type_1_2615"), S("Type of property '{0}' circularly references itself in mapped type '{1}'.")};
        static DiagnosticMessageStore _0_can_only_be_imported_by_using_import_1_require_2_or_a_default_import = {2616, DiagnosticCategory::Error, S("_0_can_only_be_imported_by_using_import_1_require_2_or_a_default_import_2616"), S("'{0}' can only be imported by using 'import {1} = require({2})' or a default import.")};
        static DiagnosticMessageStore _0_can_only_be_imported_by_using_import_1_require_2_or_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import = {2617, DiagnosticCategory::Error, S("_0_can_only_be_imported_by_using_import_1_require_2_or_by_turning_on_the_esModuleInterop_flag_and_us_2617"), S("'{0}' can only be imported by using 'import {1} = require({2})' or by turning on the 'esModuleInterop' flag and using a default import.")};
        static DiagnosticMessageStore Source_has_0_element_s_but_target_requires_1 = {2618, DiagnosticCategory::Error, S("Source_has_0_element_s_but_target_requires_1_2618"), S("Source has {0} element(s) but target requires {1}.")};
        static DiagnosticMessageStore Source_has_0_element_s_but_target_allows_only_1 = {2619, DiagnosticCategory::Error, S("Source_has_0_element_s_but_target_allows_only_1_2619"), S("Source has {0} element(s) but target allows only {1}.")};
        static DiagnosticMessageStore Target_requires_0_element_s_but_source_may_have_fewer = {2620, DiagnosticCategory::Error, S("Target_requires_0_element_s_but_source_may_have_fewer_2620"), S("Target requires {0} element(s) but source may have fewer.")};
        static DiagnosticMessageStore Target_allows_only_0_element_s_but_source_may_have_more = {2621, DiagnosticCategory::Error, S("Target_allows_only_0_element_s_but_source_may_have_more_2621"), S("Target allows only {0} element(s) but source may have more.")};
        static DiagnosticMessageStore Source_provides_no_match_for_required_element_at_position_0_in_target = {2623, DiagnosticCategory::Error, S("Source_provides_no_match_for_required_element_at_position_0_in_target_2623"), S("Source provides no match for required element at position {0} in target.")};
        static DiagnosticMessageStore Source_provides_no_match_for_variadic_element_at_position_0_in_target = {2624, DiagnosticCategory::Error, S("Source_provides_no_match_for_variadic_element_at_position_0_in_target_2624"), S("Source provides no match for variadic element at position {0} in target.")};
        static DiagnosticMessageStore Variadic_element_at_position_0_in_source_does_not_match_element_at_position_1_in_target = {2625, DiagnosticCategory::Error, S("Variadic_element_at_position_0_in_source_does_not_match_element_at_position_1_in_target_2625"), S("Variadic element at position {0} in source does not match element at position {1} in target.")};
        static DiagnosticMessageStore Type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target = {2626, DiagnosticCategory::Error, S("Type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target_2626"), S("Type at position {0} in source is not compatible with type at position {1} in target.")};
        static DiagnosticMessageStore Type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target = {2627, DiagnosticCategory::Error, S("Type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target_2627"), S("Type at positions {0} through {1} in source is not compatible with type at position {2} in target.")};
        static DiagnosticMessageStore Cannot_assign_to_0_because_it_is_an_enum = {2628, DiagnosticCategory::Error, S("Cannot_assign_to_0_because_it_is_an_enum_2628"), S("Cannot assign to '{0}' because it is an enum.")};
        static DiagnosticMessageStore Cannot_assign_to_0_because_it_is_a_class = {2629, DiagnosticCategory::Error, S("Cannot_assign_to_0_because_it_is_a_class_2629"), S("Cannot assign to '{0}' because it is a class.")};
        static DiagnosticMessageStore Cannot_assign_to_0_because_it_is_a_function = {2630, DiagnosticCategory::Error, S("Cannot_assign_to_0_because_it_is_a_function_2630"), S("Cannot assign to '{0}' because it is a function.")};
        static DiagnosticMessageStore Cannot_assign_to_0_because_it_is_a_namespace = {2631, DiagnosticCategory::Error, S("Cannot_assign_to_0_because_it_is_a_namespace_2631"), S("Cannot assign to '{0}' because it is a namespace.")};
        static DiagnosticMessageStore Cannot_assign_to_0_because_it_is_an_import = {2632, DiagnosticCategory::Error, S("Cannot_assign_to_0_because_it_is_an_import_2632"), S("Cannot assign to '{0}' because it is an import.")};
        static DiagnosticMessageStore JSX_property_access_expressions_cannot_include_JSX_namespace_names = {2633, DiagnosticCategory::Error, S("JSX_property_access_expressions_cannot_include_JSX_namespace_names_2633"), S("JSX property access expressions cannot include JSX namespace names")};
        static DiagnosticMessageStore _0_index_signatures_are_incompatible = {2634, DiagnosticCategory::Error, S("_0_index_signatures_are_incompatible_2634"), S("'{0}' index signatures are incompatible.")};
        static DiagnosticMessageStore Type_0_has_no_signatures_for_which_the_type_argument_list_is_applicable = {2635, DiagnosticCategory::Error, S("Type_0_has_no_signatures_for_which_the_type_argument_list_is_applicable_2635"), S("Type '{0}' has no signatures for which the type argument list is applicable.")};
        static DiagnosticMessageStore Type_0_is_not_assignable_to_type_1_as_implied_by_variance_annotation = {2636, DiagnosticCategory::Error, S("Type_0_is_not_assignable_to_type_1_as_implied_by_variance_annotation_2636"), S("Type '{0}' is not assignable to type '{1}' as implied by variance annotation.")};
        static DiagnosticMessageStore Variance_annotations_are_only_supported_in_type_aliases_for_object_function_constructor_and_mapped_types = {2637, DiagnosticCategory::Error, S("Variance_annotations_are_only_supported_in_type_aliases_for_object_function_constructor_and_mapped_t_2637"), S("Variance annotations are only supported in type aliases for object, function, constructor, and mapped types.")};
        static DiagnosticMessageStore Type_0_may_represent_a_primitive_value_which_is_not_permitted_as_the_right_operand_of_the_in_operator = {2638, DiagnosticCategory::Error, S("Type_0_may_represent_a_primitive_value_which_is_not_permitted_as_the_right_operand_of_the_in_operato_2638"), S("Type '{0}' may represent a primitive value, which is not permitted as the right operand of the 'in' operator.")};
        static DiagnosticMessageStore React_components_cannot_include_JSX_namespace_names = {2639, DiagnosticCategory::Error, S("React_components_cannot_include_JSX_namespace_names_2639"), S("React components cannot include JSX namespace names")};
        static DiagnosticMessageStore Cannot_augment_module_0_with_value_exports_because_it_resolves_to_a_non_module_entity = {2649, DiagnosticCategory::Error, S("Cannot_augment_module_0_with_value_exports_because_it_resolves_to_a_non_module_entity_2649"), S("Cannot augment module '{0}' with value exports because it resolves to a non-module entity.")};
        static DiagnosticMessageStore A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums = {2651, DiagnosticCategory::Error, S("A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_memb_2651"), S("A member initializer in a enum declaration cannot reference members declared after it, including members defined in other enums.")};
        static DiagnosticMessageStore Merged_declaration_0_cannot_include_a_default_export_declaration_Consider_adding_a_separate_export_default_0_declaration_instead = {2652, DiagnosticCategory::Error, S("Merged_declaration_0_cannot_include_a_default_export_declaration_Consider_adding_a_separate_export_d_2652"), S("Merged declaration '{0}' cannot include a default export declaration. Consider adding a separate 'export default {0}' declaration instead.")};
        static DiagnosticMessageStore Non_abstract_class_expression_does_not_implement_inherited_abstract_member_0_from_class_1 = {2653, DiagnosticCategory::Error, S("Non_abstract_class_expression_does_not_implement_inherited_abstract_member_0_from_class_1_2653"), S("Non-abstract class expression does not implement inherited abstract member '{0}' from class '{1}'.")};
        static DiagnosticMessageStore JSX_expressions_must_have_one_parent_element = {2657, DiagnosticCategory::Error, S("JSX_expressions_must_have_one_parent_element_2657"), S("JSX expressions must have one parent element.")};
        static DiagnosticMessageStore Type_0_provides_no_match_for_the_signature_1 = {2658, DiagnosticCategory::Error, S("Type_0_provides_no_match_for_the_signature_1_2658"), S("Type '{0}' provides no match for the signature '{1}'.")};
        static DiagnosticMessageStore super_is_only_allowed_in_members_of_object_literal_expressions_when_option_target_is_ES2015_or_higher = {2659, DiagnosticCategory::Error, S("super_is_only_allowed_in_members_of_object_literal_expressions_when_option_target_is_ES2015_or_highe_2659"), S("'super' is only allowed in members of object literal expressions when option 'target' is 'ES2015' or higher.")};
        static DiagnosticMessageStore super_can_only_be_referenced_in_members_of_derived_classes_or_object_literal_expressions = {2660, DiagnosticCategory::Error, S("super_can_only_be_referenced_in_members_of_derived_classes_or_object_literal_expressions_2660"), S("'super' can only be referenced in members of derived classes or object literal expressions.")};
        static DiagnosticMessageStore Cannot_export_0_Only_local_declarations_can_be_exported_from_a_module = {2661, DiagnosticCategory::Error, S("Cannot_export_0_Only_local_declarations_can_be_exported_from_a_module_2661"), S("Cannot export '{0}'. Only local declarations can be exported from a module.")};
        static DiagnosticMessageStore Cannot_find_name_0_Did_you_mean_the_static_member_1_0 = {2662, DiagnosticCategory::Error, S("Cannot_find_name_0_Did_you_mean_the_static_member_1_0_2662"), S("Cannot find name '{0}'. Did you mean the static member '{1}.{0}'?")};
        static DiagnosticMessageStore Cannot_find_name_0_Did_you_mean_the_instance_member_this_0 = {2663, DiagnosticCategory::Error, S("Cannot_find_name_0_Did_you_mean_the_instance_member_this_0_2663"), S("Cannot find name '{0}'. Did you mean the instance member 'this.{0}'?")};
        static DiagnosticMessageStore Invalid_module_name_in_augmentation_module_0_cannot_be_found = {2664, DiagnosticCategory::Error, S("Invalid_module_name_in_augmentation_module_0_cannot_be_found_2664"), S("Invalid module name in augmentation, module '{0}' cannot be found.")};
        static DiagnosticMessageStore Invalid_module_name_in_augmentation_Module_0_resolves_to_an_untyped_module_at_1_which_cannot_be_augmented = {2665, DiagnosticCategory::Error, S("Invalid_module_name_in_augmentation_Module_0_resolves_to_an_untyped_module_at_1_which_cannot_be_augm_2665"), S("Invalid module name in augmentation. Module '{0}' resolves to an untyped module at '{1}', which cannot be augmented.")};
        static DiagnosticMessageStore Exports_and_export_assignments_are_not_permitted_in_module_augmentations = {2666, DiagnosticCategory::Error, S("Exports_and_export_assignments_are_not_permitted_in_module_augmentations_2666"), S("Exports and export assignments are not permitted in module augmentations.")};
        static DiagnosticMessageStore Imports_are_not_permitted_in_module_augmentations_Consider_moving_them_to_the_enclosing_external_module = {2667, DiagnosticCategory::Error, S("Imports_are_not_permitted_in_module_augmentations_Consider_moving_them_to_the_enclosing_external_mod_2667"), S("Imports are not permitted in module augmentations. Consider moving them to the enclosing external module.")};
        static DiagnosticMessageStore export_modifier_cannot_be_applied_to_ambient_modules_and_module_augmentations_since_they_are_always_visible = {2668, DiagnosticCategory::Error, S("export_modifier_cannot_be_applied_to_ambient_modules_and_module_augmentations_since_they_are_always__2668"), S("'export' modifier cannot be applied to ambient modules and module augmentations since they are always visible.")};
        static DiagnosticMessageStore Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_declarations = {2669, DiagnosticCategory::Error, S("Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_2669"), S("Augmentations for the global scope can only be directly nested in external modules or ambient module declarations.")};
        static DiagnosticMessageStore Augmentations_for_the_global_scope_should_have_declare_modifier_unless_they_appear_in_already_ambient_context = {2670, DiagnosticCategory::Error, S("Augmentations_for_the_global_scope_should_have_declare_modifier_unless_they_appear_in_already_ambien_2670"), S("Augmentations for the global scope should have 'declare' modifier unless they appear in already ambient context.")};
        static DiagnosticMessageStore Cannot_augment_module_0_because_it_resolves_to_a_non_module_entity = {2671, DiagnosticCategory::Error, S("Cannot_augment_module_0_because_it_resolves_to_a_non_module_entity_2671"), S("Cannot augment module '{0}' because it resolves to a non-module entity.")};
        static DiagnosticMessageStore Cannot_assign_a_0_constructor_type_to_a_1_constructor_type = {2672, DiagnosticCategory::Error, S("Cannot_assign_a_0_constructor_type_to_a_1_constructor_type_2672"), S("Cannot assign a '{0}' constructor type to a '{1}' constructor type.")};
        static DiagnosticMessageStore Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration = {2673, DiagnosticCategory::Error, S("Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration_2673"), S("Constructor of class '{0}' is private and only accessible within the class declaration.")};
        static DiagnosticMessageStore Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration = {2674, DiagnosticCategory::Error, S("Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration_2674"), S("Constructor of class '{0}' is protected and only accessible within the class declaration.")};
        static DiagnosticMessageStore Cannot_extend_a_class_0_Class_constructor_is_marked_as_private = {2675, DiagnosticCategory::Error, S("Cannot_extend_a_class_0_Class_constructor_is_marked_as_private_2675"), S("Cannot extend a class '{0}'. Class constructor is marked as private.")};
        static DiagnosticMessageStore Accessors_must_both_be_abstract_or_non_abstract = {2676, DiagnosticCategory::Error, S("Accessors_must_both_be_abstract_or_non_abstract_2676"), S("Accessors must both be abstract or non-abstract.")};
        static DiagnosticMessageStore A_type_predicate_s_type_must_be_assignable_to_its_parameter_s_type = {2677, DiagnosticCategory::Error, S("A_type_predicate_s_type_must_be_assignable_to_its_parameter_s_type_2677"), S("A type predicate's type must be assignable to its parameter's type.")};
        static DiagnosticMessageStore Type_0_is_not_comparable_to_type_1 = {2678, DiagnosticCategory::Error, S("Type_0_is_not_comparable_to_type_1_2678"), S("Type '{0}' is not comparable to type '{1}'.")};
        static DiagnosticMessageStore A_function_that_is_called_with_the_new_keyword_cannot_have_a_this_type_that_is_void = {2679, DiagnosticCategory::Error, S("A_function_that_is_called_with_the_new_keyword_cannot_have_a_this_type_that_is_void_2679"), S("A function that is called with the 'new' keyword cannot have a 'this' type that is 'void'.")};
        static DiagnosticMessageStore A_0_parameter_must_be_the_first_parameter = {2680, DiagnosticCategory::Error, S("A_0_parameter_must_be_the_first_parameter_2680"), S("A '{0}' parameter must be the first parameter.")};
        static DiagnosticMessageStore A_constructor_cannot_have_a_this_parameter = {2681, DiagnosticCategory::Error, S("A_constructor_cannot_have_a_this_parameter_2681"), S("A constructor cannot have a 'this' parameter.")};
        static DiagnosticMessageStore this_implicitly_has_type_any_because_it_does_not_have_a_type_annotation = {2683, DiagnosticCategory::Error, S("this_implicitly_has_type_any_because_it_does_not_have_a_type_annotation_2683"), S("'this' implicitly has type 'any' because it does not have a type annotation.")};
        static DiagnosticMessageStore The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1 = {2684, DiagnosticCategory::Error, S("The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1_2684"), S("The 'this' context of type '{0}' is not assignable to method's 'this' of type '{1}'.")};
        static DiagnosticMessageStore The_this_types_of_each_signature_are_incompatible = {2685, DiagnosticCategory::Error, S("The_this_types_of_each_signature_are_incompatible_2685"), S("The 'this' types of each signature are incompatible.")};
        static DiagnosticMessageStore _0_refers_to_a_UMD_global_but_the_current_file_is_a_module_Consider_adding_an_import_instead = {2686, DiagnosticCategory::Error, S("_0_refers_to_a_UMD_global_but_the_current_file_is_a_module_Consider_adding_an_import_instead_2686"), S("'{0}' refers to a UMD global, but the current file is a module. Consider adding an import instead.")};
        static DiagnosticMessageStore All_declarations_of_0_must_have_identical_modifiers = {2687, DiagnosticCategory::Error, S("All_declarations_of_0_must_have_identical_modifiers_2687"), S("All declarations of '{0}' must have identical modifiers.")};
        static DiagnosticMessageStore Cannot_find_type_definition_file_for_0 = {2688, DiagnosticCategory::Error, S("Cannot_find_type_definition_file_for_0_2688"), S("Cannot find type definition file for '{0}'.")};
        static DiagnosticMessageStore Cannot_extend_an_interface_0_Did_you_mean_implements = {2689, DiagnosticCategory::Error, S("Cannot_extend_an_interface_0_Did_you_mean_implements_2689"), S("Cannot extend an interface '{0}'. Did you mean 'implements'?")};
        static DiagnosticMessageStore _0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Did_you_mean_to_use_1_in_0 = {2690, DiagnosticCategory::Error, S("_0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Did_you_mean_to_use_1_in_0_2690"), S("'{0}' only refers to a type, but is being used as a value here. Did you mean to use '{1} in {0}'?")};
        static DiagnosticMessageStore _0_is_a_primitive_but_1_is_a_wrapper_object_Prefer_using_0_when_possible = {2692, DiagnosticCategory::Error, S("_0_is_a_primitive_but_1_is_a_wrapper_object_Prefer_using_0_when_possible_2692"), S("'{0}' is a primitive, but '{1}' is a wrapper object. Prefer using '{0}' when possible.")};
        static DiagnosticMessageStore _0_only_refers_to_a_type_but_is_being_used_as_a_value_here = {2693, DiagnosticCategory::Error, S("_0_only_refers_to_a_type_but_is_being_used_as_a_value_here_2693"), S("'{0}' only refers to a type, but is being used as a value here.")};
        static DiagnosticMessageStore Namespace_0_has_no_exported_member_1 = {2694, DiagnosticCategory::Error, S("Namespace_0_has_no_exported_member_1_2694"), S("Namespace '{0}' has no exported member '{1}'.")};
        static DiagnosticMessageStore Left_side_of_comma_operator_is_unused_and_has_no_side_effects = {2695, DiagnosticCategory::Error, S("Left_side_of_comma_operator_is_unused_and_has_no_side_effects_2695"), S("Left side of comma operator is unused and has no side effects.")};
        static DiagnosticMessageStore The_Object_type_is_assignable_to_very_few_other_types_Did_you_mean_to_use_the_any_type_instead = {2696, DiagnosticCategory::Error, S("The_Object_type_is_assignable_to_very_few_other_types_Did_you_mean_to_use_the_any_type_instead_2696"), S("The 'Object' type is assignable to very few other types. Did you mean to use the 'any' type instead?")};
        static DiagnosticMessageStore An_async_function_or_method_must_return_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES2015_in_your_lib_option = {2697, DiagnosticCategory::Error, S("An_async_function_or_method_must_return_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_in_2697"), S("An async function or method must return a 'Promise'. Make sure you have a declaration for 'Promise' or include 'ES2015' in your '--lib' option.")};
        static DiagnosticMessageStore Spread_types_may_only_be_created_from_object_types = {2698, DiagnosticCategory::Error, S("Spread_types_may_only_be_created_from_object_types_2698"), S("Spread types may only be created from object types.")};
        static DiagnosticMessageStore Static_property_0_conflicts_with_built_in_property_Function_0_of_constructor_function_1 = {2699, DiagnosticCategory::Error, S("Static_property_0_conflicts_with_built_in_property_Function_0_of_constructor_function_1_2699"), S("Static property '{0}' conflicts with built-in property 'Function.{0}' of constructor function '{1}'.")};
        static DiagnosticMessageStore Rest_types_may_only_be_created_from_object_types = {2700, DiagnosticCategory::Error, S("Rest_types_may_only_be_created_from_object_types_2700"), S("Rest types may only be created from object types.")};
        static DiagnosticMessageStore The_target_of_an_object_rest_assignment_must_be_a_variable_or_a_property_access = {2701, DiagnosticCategory::Error, S("The_target_of_an_object_rest_assignment_must_be_a_variable_or_a_property_access_2701"), S("The target of an object rest assignment must be a variable or a property access.")};
        static DiagnosticMessageStore _0_only_refers_to_a_type_but_is_being_used_as_a_namespace_here = {2702, DiagnosticCategory::Error, S("_0_only_refers_to_a_type_but_is_being_used_as_a_namespace_here_2702"), S("'{0}' only refers to a type, but is being used as a namespace here.")};
        static DiagnosticMessageStore The_operand_of_a_delete_operator_must_be_a_property_reference = {2703, DiagnosticCategory::Error, S("The_operand_of_a_delete_operator_must_be_a_property_reference_2703"), S("The operand of a 'delete' operator must be a property reference.")};
        static DiagnosticMessageStore The_operand_of_a_delete_operator_cannot_be_a_read_only_property = {2704, DiagnosticCategory::Error, S("The_operand_of_a_delete_operator_cannot_be_a_read_only_property_2704"), S("The operand of a 'delete' operator cannot be a read-only property.")};
        static DiagnosticMessageStore An_async_function_or_method_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option = {2705, DiagnosticCategory::Error, S("An_async_function_or_method_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_de_2705"), S("An async function or method in ES5/ES3 requires the 'Promise' constructor.  Make sure you have a declaration for the 'Promise' constructor or include 'ES2015' in your '--lib' option.")};
        static DiagnosticMessageStore Required_type_parameters_may_not_follow_optional_type_parameters = {2706, DiagnosticCategory::Error, S("Required_type_parameters_may_not_follow_optional_type_parameters_2706"), S("Required type parameters may not follow optional type parameters.")};
        static DiagnosticMessageStore Generic_type_0_requires_between_1_and_2_type_arguments = {2707, DiagnosticCategory::Error, S("Generic_type_0_requires_between_1_and_2_type_arguments_2707"), S("Generic type '{0}' requires between {1} and {2} type arguments.")};
        static DiagnosticMessageStore Cannot_use_namespace_0_as_a_value = {2708, DiagnosticCategory::Error, S("Cannot_use_namespace_0_as_a_value_2708"), S("Cannot use namespace '{0}' as a value.")};
        static DiagnosticMessageStore Cannot_use_namespace_0_as_a_type = {2709, DiagnosticCategory::Error, S("Cannot_use_namespace_0_as_a_type_2709"), S("Cannot use namespace '{0}' as a type.")};
        static DiagnosticMessageStore _0_are_specified_twice_The_attribute_named_0_will_be_overwritten = {2710, DiagnosticCategory::Error, S("_0_are_specified_twice_The_attribute_named_0_will_be_overwritten_2710"), S("'{0}' are specified twice. The attribute named '{0}' will be overwritten.")};
        static DiagnosticMessageStore A_dynamic_import_call_returns_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES2015_in_your_lib_option = {2711, DiagnosticCategory::Error, S("A_dynamic_import_call_returns_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES20_2711"), S("A dynamic import call returns a 'Promise'. Make sure you have a declaration for 'Promise' or include 'ES2015' in your '--lib' option.")};
        static DiagnosticMessageStore A_dynamic_import_call_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option = {2712, DiagnosticCategory::Error, S("A_dynamic_import_call_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_declarat_2712"), S("A dynamic import call in ES5/ES3 requires the 'Promise' constructor.  Make sure you have a declaration for the 'Promise' constructor or include 'ES2015' in your '--lib' option.")};
        static DiagnosticMessageStore Cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_Did_you_mean_to_retrieve_the_type_of_the_property_1_in_0_with_0_1 = {2713, DiagnosticCategory::Error, S("Cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_Did_you_mean_to_retrieve_the_type_of_the_p_2713"), S("Cannot access '{0}.{1}' because '{0}' is a type, but not a namespace. Did you mean to retrieve the type of the property '{1}' in '{0}' with '{0}[\"{1}\"]'?")};
        static DiagnosticMessageStore The_expression_of_an_export_assignment_must_be_an_identifier_or_qualified_name_in_an_ambient_context = {2714, DiagnosticCategory::Error, S("The_expression_of_an_export_assignment_must_be_an_identifier_or_qualified_name_in_an_ambient_context_2714"), S("The expression of an export assignment must be an identifier or qualified name in an ambient context.")};
        static DiagnosticMessageStore Abstract_property_0_in_class_1_cannot_be_accessed_in_the_constructor = {2715, DiagnosticCategory::Error, S("Abstract_property_0_in_class_1_cannot_be_accessed_in_the_constructor_2715"), S("Abstract property '{0}' in class '{1}' cannot be accessed in the constructor.")};
        static DiagnosticMessageStore Type_parameter_0_has_a_circular_default = {2716, DiagnosticCategory::Error, S("Type_parameter_0_has_a_circular_default_2716"), S("Type parameter '{0}' has a circular default.")};
        static DiagnosticMessageStore Subsequent_property_declarations_must_have_the_same_type_Property_0_must_be_of_type_1_but_here_has_type_2 = {2717, DiagnosticCategory::Error, S("Subsequent_property_declarations_must_have_the_same_type_Property_0_must_be_of_type_1_but_here_has_t_2717"), S("Subsequent property declarations must have the same type.  Property '{0}' must be of type '{1}', but here has type '{2}'.")};
        static DiagnosticMessageStore Duplicate_property_0 = {2718, DiagnosticCategory::Error, S("Duplicate_property_0_2718"), S("Duplicate property '{0}'.")};
        static DiagnosticMessageStore Type_0_is_not_assignable_to_type_1_Two_different_types_with_this_name_exist_but_they_are_unrelated = {2719, DiagnosticCategory::Error, S("Type_0_is_not_assignable_to_type_1_Two_different_types_with_this_name_exist_but_they_are_unrelated_2719"), S("Type '{0}' is not assignable to type '{1}'. Two different types with this name exist, but they are unrelated.")};
        static DiagnosticMessageStore Class_0_incorrectly_implements_class_1_Did_you_mean_to_extend_1_and_inherit_its_members_as_a_subclass = {2720, DiagnosticCategory::Error, S("Class_0_incorrectly_implements_class_1_Did_you_mean_to_extend_1_and_inherit_its_members_as_a_subclas_2720"), S("Class '{0}' incorrectly implements class '{1}'. Did you mean to extend '{1}' and inherit its members as a subclass?")};
        static DiagnosticMessageStore Cannot_invoke_an_object_which_is_possibly_null = {2721, DiagnosticCategory::Error, S("Cannot_invoke_an_object_which_is_possibly_null_2721"), S("Cannot invoke an object which is possibly 'null'.")};
        static DiagnosticMessageStore Cannot_invoke_an_object_which_is_possibly_undefined = {2722, DiagnosticCategory::Error, S("Cannot_invoke_an_object_which_is_possibly_undefined_2722"), S("Cannot invoke an object which is possibly 'undefined'.")};
        static DiagnosticMessageStore Cannot_invoke_an_object_which_is_possibly_null_or_undefined = {2723, DiagnosticCategory::Error, S("Cannot_invoke_an_object_which_is_possibly_null_or_undefined_2723"), S("Cannot invoke an object which is possibly 'null' or 'undefined'.")};
        static DiagnosticMessageStore _0_has_no_exported_member_named_1_Did_you_mean_2 = {2724, DiagnosticCategory::Error, S("_0_has_no_exported_member_named_1_Did_you_mean_2_2724"), S("'{0}' has no exported member named '{1}'. Did you mean '{2}'?")};
        static DiagnosticMessageStore Class_name_cannot_be_Object_when_targeting_ES5_with_module_0 = {2725, DiagnosticCategory::Error, S("Class_name_cannot_be_Object_when_targeting_ES5_with_module_0_2725"), S("Class name cannot be 'Object' when targeting ES5 with module {0}.")};
        static DiagnosticMessageStore Cannot_find_lib_definition_for_0 = {2726, DiagnosticCategory::Error, S("Cannot_find_lib_definition_for_0_2726"), S("Cannot find lib definition for '{0}'.")};
        static DiagnosticMessageStore Cannot_find_lib_definition_for_0_Did_you_mean_1 = {2727, DiagnosticCategory::Error, S("Cannot_find_lib_definition_for_0_Did_you_mean_1_2727"), S("Cannot find lib definition for '{0}'. Did you mean '{1}'?")};
        static DiagnosticMessageStore _0_is_declared_here = {2728, DiagnosticCategory::Message, S("_0_is_declared_here_2728"), S("'{0}' is declared here.")};
        static DiagnosticMessageStore Property_0_is_used_before_its_initialization = {2729, DiagnosticCategory::Error, S("Property_0_is_used_before_its_initialization_2729"), S("Property '{0}' is used before its initialization.")};
        static DiagnosticMessageStore An_arrow_function_cannot_have_a_this_parameter = {2730, DiagnosticCategory::Error, S("An_arrow_function_cannot_have_a_this_parameter_2730"), S("An arrow function cannot have a 'this' parameter.")};
        static DiagnosticMessageStore Implicit_conversion_of_a_symbol_to_a_string_will_fail_at_runtime_Consider_wrapping_this_expression_in_String = {2731, DiagnosticCategory::Error, S("Implicit_conversion_of_a_symbol_to_a_string_will_fail_at_runtime_Consider_wrapping_this_expression_i_2731"), S("Implicit conversion of a 'symbol' to a 'string' will fail at runtime. Consider wrapping this expression in 'String(...)'.")};
        static DiagnosticMessageStore Cannot_find_module_0_Consider_using_resolveJsonModule_to_import_module_with_json_extension = {2732, DiagnosticCategory::Error, S("Cannot_find_module_0_Consider_using_resolveJsonModule_to_import_module_with_json_extension_2732"), S("Cannot find module '{0}'. Consider using '--resolveJsonModule' to import module with '.json' extension.")};
        static DiagnosticMessageStore Property_0_was_also_declared_here = {2733, DiagnosticCategory::Error, S("Property_0_was_also_declared_here_2733"), S("Property '{0}' was also declared here.")};
        static DiagnosticMessageStore Are_you_missing_a_semicolon = {2734, DiagnosticCategory::Error, S("Are_you_missing_a_semicolon_2734"), S("Are you missing a semicolon?")};
        static DiagnosticMessageStore Did_you_mean_for_0_to_be_constrained_to_type_new_args_Colon_any_1 = {2735, DiagnosticCategory::Error, S("Did_you_mean_for_0_to_be_constrained_to_type_new_args_Colon_any_1_2735"), S("Did you mean for '{0}' to be constrained to type 'new (...args: any[]) => {1}'?")};
        static DiagnosticMessageStore Operator_0_cannot_be_applied_to_type_1 = {2736, DiagnosticCategory::Error, S("Operator_0_cannot_be_applied_to_type_1_2736"), S("Operator '{0}' cannot be applied to type '{1}'.")};
        static DiagnosticMessageStore BigInt_literals_are_not_available_when_targeting_lower_than_ES2020 = {2737, DiagnosticCategory::Error, S("BigInt_literals_are_not_available_when_targeting_lower_than_ES2020_2737"), S("BigInt literals are not available when targeting lower than ES2020.")};
        static DiagnosticMessageStore An_outer_value_of_this_is_shadowed_by_this_container = {2738, DiagnosticCategory::Message, S("An_outer_value_of_this_is_shadowed_by_this_container_2738"), S("An outer value of 'this' is shadowed by this container.")};
        static DiagnosticMessageStore Type_0_is_missing_the_following_properties_from_type_1_Colon_2 = {2739, DiagnosticCategory::Error, S("Type_0_is_missing_the_following_properties_from_type_1_Colon_2_2739"), S("Type '{0}' is missing the following properties from type '{1}': {2}")};
        static DiagnosticMessageStore Type_0_is_missing_the_following_properties_from_type_1_Colon_2_and_3_more = {2740, DiagnosticCategory::Error, S("Type_0_is_missing_the_following_properties_from_type_1_Colon_2_and_3_more_2740"), S("Type '{0}' is missing the following properties from type '{1}': {2}, and {3} more.")};
        static DiagnosticMessageStore Property_0_is_missing_in_type_1_but_required_in_type_2 = {2741, DiagnosticCategory::Error, S("Property_0_is_missing_in_type_1_but_required_in_type_2_2741"), S("Property '{0}' is missing in type '{1}' but required in type '{2}'.")};
        static DiagnosticMessageStore The_inferred_type_of_0_cannot_be_named_without_a_reference_to_1_This_is_likely_not_portable_A_type_annotation_is_necessary = {2742, DiagnosticCategory::Error, S("The_inferred_type_of_0_cannot_be_named_without_a_reference_to_1_This_is_likely_not_portable_A_type_a_2742"), S("The inferred type of '{0}' cannot be named without a reference to '{1}'. This is likely not portable. A type annotation is necessary.")};
        static DiagnosticMessageStore No_overload_expects_0_type_arguments_but_overloads_do_exist_that_expect_either_1_or_2_type_arguments = {2743, DiagnosticCategory::Error, S("No_overload_expects_0_type_arguments_but_overloads_do_exist_that_expect_either_1_or_2_type_arguments_2743"), S("No overload expects {0} type arguments, but overloads do exist that expect either {1} or {2} type arguments.")};
        static DiagnosticMessageStore Type_parameter_defaults_can_only_reference_previously_declared_type_parameters = {2744, DiagnosticCategory::Error, S("Type_parameter_defaults_can_only_reference_previously_declared_type_parameters_2744"), S("Type parameter defaults can only reference previously declared type parameters.")};
        static DiagnosticMessageStore This_JSX_tag_s_0_prop_expects_type_1_which_requires_multiple_children_but_only_a_single_child_was_provided = {2745, DiagnosticCategory::Error, S("This_JSX_tag_s_0_prop_expects_type_1_which_requires_multiple_children_but_only_a_single_child_was_pr_2745"), S("This JSX tag's '{0}' prop expects type '{1}' which requires multiple children, but only a single child was provided.")};
        static DiagnosticMessageStore This_JSX_tag_s_0_prop_expects_a_single_child_of_type_1_but_multiple_children_were_provided = {2746, DiagnosticCategory::Error, S("This_JSX_tag_s_0_prop_expects_a_single_child_of_type_1_but_multiple_children_were_provided_2746"), S("This JSX tag's '{0}' prop expects a single child of type '{1}', but multiple children were provided.")};
        static DiagnosticMessageStore _0_components_don_t_accept_text_as_child_elements_Text_in_JSX_has_the_type_string_but_the_expected_type_of_1_is_2 = {2747, DiagnosticCategory::Error, S("_0_components_don_t_accept_text_as_child_elements_Text_in_JSX_has_the_type_string_but_the_expected_t_2747"), S("'{0}' components don't accept text as child elements. Text in JSX has the type 'string', but the expected type of '{1}' is '{2}'.")};
        static DiagnosticMessageStore Cannot_access_ambient_const_enums_when_0_is_enabled = {2748, DiagnosticCategory::Error, S("Cannot_access_ambient_const_enums_when_0_is_enabled_2748"), S("Cannot access ambient const enums when '{0}' is enabled.")};
        static DiagnosticMessageStore _0_refers_to_a_value_but_is_being_used_as_a_type_here_Did_you_mean_typeof_0 = {2749, DiagnosticCategory::Error, S("_0_refers_to_a_value_but_is_being_used_as_a_type_here_Did_you_mean_typeof_0_2749"), S("'{0}' refers to a value, but is being used as a type here. Did you mean 'typeof {0}'?")};
        static DiagnosticMessageStore The_implementation_signature_is_declared_here = {2750, DiagnosticCategory::Error, S("The_implementation_signature_is_declared_here_2750"), S("The implementation signature is declared here.")};
        static DiagnosticMessageStore Circularity_originates_in_type_at_this_location = {2751, DiagnosticCategory::Error, S("Circularity_originates_in_type_at_this_location_2751"), S("Circularity originates in type at this location.")};
        static DiagnosticMessageStore The_first_export_default_is_here = {2752, DiagnosticCategory::Error, S("The_first_export_default_is_here_2752"), S("The first export default is here.")};
        static DiagnosticMessageStore Another_export_default_is_here = {2753, DiagnosticCategory::Error, S("Another_export_default_is_here_2753"), S("Another export default is here.")};
        static DiagnosticMessageStore super_may_not_use_type_arguments = {2754, DiagnosticCategory::Error, S("super_may_not_use_type_arguments_2754"), S("'super' may not use type arguments.")};
        static DiagnosticMessageStore No_constituent_of_type_0_is_callable = {2755, DiagnosticCategory::Error, S("No_constituent_of_type_0_is_callable_2755"), S("No constituent of type '{0}' is callable.")};
        static DiagnosticMessageStore Not_all_constituents_of_type_0_are_callable = {2756, DiagnosticCategory::Error, S("Not_all_constituents_of_type_0_are_callable_2756"), S("Not all constituents of type '{0}' are callable.")};
        static DiagnosticMessageStore Type_0_has_no_call_signatures = {2757, DiagnosticCategory::Error, S("Type_0_has_no_call_signatures_2757"), S("Type '{0}' has no call signatures.")};
        static DiagnosticMessageStore Each_member_of_the_union_type_0_has_signatures_but_none_of_those_signatures_are_compatible_with_each_other = {2758, DiagnosticCategory::Error, S("Each_member_of_the_union_type_0_has_signatures_but_none_of_those_signatures_are_compatible_with_each_2758"), S("Each member of the union type '{0}' has signatures, but none of those signatures are compatible with each other.")};
        static DiagnosticMessageStore No_constituent_of_type_0_is_constructable = {2759, DiagnosticCategory::Error, S("No_constituent_of_type_0_is_constructable_2759"), S("No constituent of type '{0}' is constructable.")};
        static DiagnosticMessageStore Not_all_constituents_of_type_0_are_constructable = {2760, DiagnosticCategory::Error, S("Not_all_constituents_of_type_0_are_constructable_2760"), S("Not all constituents of type '{0}' are constructable.")};
        static DiagnosticMessageStore Type_0_has_no_construct_signatures = {2761, DiagnosticCategory::Error, S("Type_0_has_no_construct_signatures_2761"), S("Type '{0}' has no construct signatures.")};
        static DiagnosticMessageStore Each_member_of_the_union_type_0_has_construct_signatures_but_none_of_those_signatures_are_compatible_with_each_other = {2762, DiagnosticCategory::Error, S("Each_member_of_the_union_type_0_has_construct_signatures_but_none_of_those_signatures_are_compatible_2762"), S("Each member of the union type '{0}' has construct signatures, but none of those signatures are compatible with each other.")};
        static DiagnosticMessageStore Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_for_of_will_always_send_0 = {2763, DiagnosticCategory::Error, S("Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_for_of_will_always_s_2763"), S("Cannot iterate value because the 'next' method of its iterator expects type '{1}', but for-of will always send '{0}'.")};
        static DiagnosticMessageStore Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_spread_will_always_send_0 = {2764, DiagnosticCategory::Error, S("Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_spread_will_al_2764"), S("Cannot iterate value because the 'next' method of its iterator expects type '{1}', but array spread will always send '{0}'.")};
        static DiagnosticMessageStore Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_destructuring_will_always_send_0 = {2765, DiagnosticCategory::Error, S("Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_destructuring__2765"), S("Cannot iterate value because the 'next' method of its iterator expects type '{1}', but array destructuring will always send '{0}'.")};
        static DiagnosticMessageStore Cannot_delegate_iteration_to_value_because_the_next_method_of_its_iterator_expects_type_1_but_the_containing_generator_will_always_send_0 = {2766, DiagnosticCategory::Error, S("Cannot_delegate_iteration_to_value_because_the_next_method_of_its_iterator_expects_type_1_but_the_co_2766"), S("Cannot delegate iteration to value because the 'next' method of its iterator expects type '{1}', but the containing generator will always send '{0}'.")};
        static DiagnosticMessageStore The_0_property_of_an_iterator_must_be_a_method = {2767, DiagnosticCategory::Error, S("The_0_property_of_an_iterator_must_be_a_method_2767"), S("The '{0}' property of an iterator must be a method.")};
        static DiagnosticMessageStore The_0_property_of_an_async_iterator_must_be_a_method = {2768, DiagnosticCategory::Error, S("The_0_property_of_an_async_iterator_must_be_a_method_2768"), S("The '{0}' property of an async iterator must be a method.")};
        static DiagnosticMessageStore No_overload_matches_this_call = {2769, DiagnosticCategory::Error, S("No_overload_matches_this_call_2769"), S("No overload matches this call.")};
        static DiagnosticMessageStore The_last_overload_gave_the_following_error = {2770, DiagnosticCategory::Error, S("The_last_overload_gave_the_following_error_2770"), S("The last overload gave the following error.")};
        static DiagnosticMessageStore The_last_overload_is_declared_here = {2771, DiagnosticCategory::Error, S("The_last_overload_is_declared_here_2771"), S("The last overload is declared here.")};
        static DiagnosticMessageStore Overload_0_of_1_2_gave_the_following_error = {2772, DiagnosticCategory::Error, S("Overload_0_of_1_2_gave_the_following_error_2772"), S("Overload {0} of {1}, '{2}', gave the following error.")};
        static DiagnosticMessageStore Did_you_forget_to_use_await = {2773, DiagnosticCategory::Error, S("Did_you_forget_to_use_await_2773"), S("Did you forget to use 'await'?")};
        static DiagnosticMessageStore This_condition_will_always_return_true_since_this_function_is_always_defined_Did_you_mean_to_call_it_instead = {2774, DiagnosticCategory::Error, S("This_condition_will_always_return_true_since_this_function_is_always_defined_Did_you_mean_to_call_it_2774"), S("This condition will always return true since this function is always defined. Did you mean to call it instead?")};
        static DiagnosticMessageStore Assertions_require_every_name_in_the_call_target_to_be_declared_with_an_explicit_type_annotation = {2775, DiagnosticCategory::Error, S("Assertions_require_every_name_in_the_call_target_to_be_declared_with_an_explicit_type_annotation_2775"), S("Assertions require every name in the call target to be declared with an explicit type annotation.")};
        static DiagnosticMessageStore Assertions_require_the_call_target_to_be_an_identifier_or_qualified_name = {2776, DiagnosticCategory::Error, S("Assertions_require_the_call_target_to_be_an_identifier_or_qualified_name_2776"), S("Assertions require the call target to be an identifier or qualified name.")};
        static DiagnosticMessageStore The_operand_of_an_increment_or_decrement_operator_may_not_be_an_optional_property_access = {2777, DiagnosticCategory::Error, S("The_operand_of_an_increment_or_decrement_operator_may_not_be_an_optional_property_access_2777"), S("The operand of an increment or decrement operator may not be an optional property access.")};
        static DiagnosticMessageStore The_target_of_an_object_rest_assignment_may_not_be_an_optional_property_access = {2778, DiagnosticCategory::Error, S("The_target_of_an_object_rest_assignment_may_not_be_an_optional_property_access_2778"), S("The target of an object rest assignment may not be an optional property access.")};
        static DiagnosticMessageStore The_left_hand_side_of_an_assignment_expression_may_not_be_an_optional_property_access = {2779, DiagnosticCategory::Error, S("The_left_hand_side_of_an_assignment_expression_may_not_be_an_optional_property_access_2779"), S("The left-hand side of an assignment expression may not be an optional property access.")};
        static DiagnosticMessageStore The_left_hand_side_of_a_for_in_statement_may_not_be_an_optional_property_access = {2780, DiagnosticCategory::Error, S("The_left_hand_side_of_a_for_in_statement_may_not_be_an_optional_property_access_2780"), S("The left-hand side of a 'for...in' statement may not be an optional property access.")};
        static DiagnosticMessageStore The_left_hand_side_of_a_for_of_statement_may_not_be_an_optional_property_access = {2781, DiagnosticCategory::Error, S("The_left_hand_side_of_a_for_of_statement_may_not_be_an_optional_property_access_2781"), S("The left-hand side of a 'for...of' statement may not be an optional property access.")};
        static DiagnosticMessageStore _0_needs_an_explicit_type_annotation = {2782, DiagnosticCategory::Message, S("_0_needs_an_explicit_type_annotation_2782"), S("'{0}' needs an explicit type annotation.")};
        static DiagnosticMessageStore _0_is_specified_more_than_once_so_this_usage_will_be_overwritten = {2783, DiagnosticCategory::Error, S("_0_is_specified_more_than_once_so_this_usage_will_be_overwritten_2783"), S("'{0}' is specified more than once, so this usage will be overwritten.")};
        static DiagnosticMessageStore get_and_set_accessors_cannot_declare_this_parameters = {2784, DiagnosticCategory::Error, S("get_and_set_accessors_cannot_declare_this_parameters_2784"), S("'get' and 'set' accessors cannot declare 'this' parameters.")};
        static DiagnosticMessageStore This_spread_always_overwrites_this_property = {2785, DiagnosticCategory::Error, S("This_spread_always_overwrites_this_property_2785"), S("This spread always overwrites this property.")};
        static DiagnosticMessageStore _0_cannot_be_used_as_a_JSX_component = {2786, DiagnosticCategory::Error, S("_0_cannot_be_used_as_a_JSX_component_2786"), S("'{0}' cannot be used as a JSX component.")};
        static DiagnosticMessageStore Its_return_type_0_is_not_a_valid_JSX_element = {2787, DiagnosticCategory::Error, S("Its_return_type_0_is_not_a_valid_JSX_element_2787"), S("Its return type '{0}' is not a valid JSX element.")};
        static DiagnosticMessageStore Its_instance_type_0_is_not_a_valid_JSX_element = {2788, DiagnosticCategory::Error, S("Its_instance_type_0_is_not_a_valid_JSX_element_2788"), S("Its instance type '{0}' is not a valid JSX element.")};
        static DiagnosticMessageStore Its_element_type_0_is_not_a_valid_JSX_element = {2789, DiagnosticCategory::Error, S("Its_element_type_0_is_not_a_valid_JSX_element_2789"), S("Its element type '{0}' is not a valid JSX element.")};
        static DiagnosticMessageStore The_operand_of_a_delete_operator_must_be_optional = {2790, DiagnosticCategory::Error, S("The_operand_of_a_delete_operator_must_be_optional_2790"), S("The operand of a 'delete' operator must be optional.")};
        static DiagnosticMessageStore Exponentiation_cannot_be_performed_on_bigint_values_unless_the_target_option_is_set_to_es2016_or_later = {2791, DiagnosticCategory::Error, S("Exponentiation_cannot_be_performed_on_bigint_values_unless_the_target_option_is_set_to_es2016_or_lat_2791"), S("Exponentiation cannot be performed on 'bigint' values unless the 'target' option is set to 'es2016' or later.")};
        static DiagnosticMessageStore Cannot_find_module_0_Did_you_mean_to_set_the_moduleResolution_option_to_nodenext_or_to_add_aliases_to_the_paths_option = {2792, DiagnosticCategory::Error, S("Cannot_find_module_0_Did_you_mean_to_set_the_moduleResolution_option_to_nodenext_or_to_add_aliases_t_2792"), S("Cannot find module '{0}'. Did you mean to set the 'moduleResolution' option to 'nodenext', or to add aliases to the 'paths' option?")};
        static DiagnosticMessageStore The_call_would_have_succeeded_against_this_implementation_but_implementation_signatures_of_overloads_are_not_externally_visible = {2793, DiagnosticCategory::Error, S("The_call_would_have_succeeded_against_this_implementation_but_implementation_signatures_of_overloads_2793"), S("The call would have succeeded against this implementation, but implementation signatures of overloads are not externally visible.")};
        static DiagnosticMessageStore Expected_0_arguments_but_got_1_Did_you_forget_to_include_void_in_your_type_argument_to_Promise = {2794, DiagnosticCategory::Error, S("Expected_0_arguments_but_got_1_Did_you_forget_to_include_void_in_your_type_argument_to_Promise_2794"), S("Expected {0} arguments, but got {1}. Did you forget to include 'void' in your type argument to 'Promise'?")};
        static DiagnosticMessageStore The_intrinsic_keyword_can_only_be_used_to_declare_compiler_provided_intrinsic_types = {2795, DiagnosticCategory::Error, S("The_intrinsic_keyword_can_only_be_used_to_declare_compiler_provided_intrinsic_types_2795"), S("The 'intrinsic' keyword can only be used to declare compiler provided intrinsic types.")};
        static DiagnosticMessageStore It_is_likely_that_you_are_missing_a_comma_to_separate_these_two_template_expressions_They_form_a_tagged_template_expression_which_cannot_be_invoked = {2796, DiagnosticCategory::Error, S("It_is_likely_that_you_are_missing_a_comma_to_separate_these_two_template_expressions_They_form_a_tag_2796"), S("It is likely that you are missing a comma to separate these two template expressions. They form a tagged template expression which cannot be invoked.")};
        static DiagnosticMessageStore A_mixin_class_that_extends_from_a_type_variable_containing_an_abstract_construct_signature_must_also_be_declared_abstract = {2797, DiagnosticCategory::Error, S("A_mixin_class_that_extends_from_a_type_variable_containing_an_abstract_construct_signature_must_also_2797"), S("A mixin class that extends from a type variable containing an abstract construct signature must also be declared 'abstract'.")};
        static DiagnosticMessageStore The_declaration_was_marked_as_deprecated_here = {2798, DiagnosticCategory::Error, S("The_declaration_was_marked_as_deprecated_here_2798"), S("The declaration was marked as deprecated here.")};
        static DiagnosticMessageStore Type_produces_a_tuple_type_that_is_too_large_to_represent = {2799, DiagnosticCategory::Error, S("Type_produces_a_tuple_type_that_is_too_large_to_represent_2799"), S("Type produces a tuple type that is too large to represent.")};
        static DiagnosticMessageStore Expression_produces_a_tuple_type_that_is_too_large_to_represent = {2800, DiagnosticCategory::Error, S("Expression_produces_a_tuple_type_that_is_too_large_to_represent_2800"), S("Expression produces a tuple type that is too large to represent.")};
        static DiagnosticMessageStore This_condition_will_always_return_true_since_this_0_is_always_defined = {2801, DiagnosticCategory::Error, S("This_condition_will_always_return_true_since_this_0_is_always_defined_2801"), S("This condition will always return true since this '{0}' is always defined.")};
        static DiagnosticMessageStore Type_0_can_only_be_iterated_through_when_using_the_downlevelIteration_flag_or_with_a_target_of_es2015_or_higher = {2802, DiagnosticCategory::Error, S("Type_0_can_only_be_iterated_through_when_using_the_downlevelIteration_flag_or_with_a_target_of_es201_2802"), S("Type '{0}' can only be iterated through when using the '--downlevelIteration' flag or with a '--target' of 'es2015' or higher.")};
        static DiagnosticMessageStore Cannot_assign_to_private_method_0_Private_methods_are_not_writable = {2803, DiagnosticCategory::Error, S("Cannot_assign_to_private_method_0_Private_methods_are_not_writable_2803"), S("Cannot assign to private method '{0}'. Private methods are not writable.")};
        static DiagnosticMessageStore Duplicate_identifier_0_Static_and_instance_elements_cannot_share_the_same_private_name = {2804, DiagnosticCategory::Error, S("Duplicate_identifier_0_Static_and_instance_elements_cannot_share_the_same_private_name_2804"), S("Duplicate identifier '{0}'. Static and instance elements cannot share the same private name.")};
        static DiagnosticMessageStore Private_accessor_was_defined_without_a_getter = {2806, DiagnosticCategory::Error, S("Private_accessor_was_defined_without_a_getter_2806"), S("Private accessor was defined without a getter.")};
        static DiagnosticMessageStore This_syntax_requires_an_imported_helper_named_1_with_2_parameters_which_is_not_compatible_with_the_one_in_0_Consider_upgrading_your_version_of_0 = {2807, DiagnosticCategory::Error, S("This_syntax_requires_an_imported_helper_named_1_with_2_parameters_which_is_not_compatible_with_the_o_2807"), S("This syntax requires an imported helper named '{1}' with {2} parameters, which is not compatible with the one in '{0}'. Consider upgrading your version of '{0}'.")};
        static DiagnosticMessageStore A_get_accessor_must_be_at_least_as_accessible_as_the_setter = {2808, DiagnosticCategory::Error, S("A_get_accessor_must_be_at_least_as_accessible_as_the_setter_2808"), S("A get accessor must be at least as accessible as the setter")};
        static DiagnosticMessageStore Declaration_or_statement_expected_This_follows_a_block_of_statements_so_if_you_intended_to_write_a_destructuring_assignment_you_might_need_to_wrap_the_whole_assignment_in_parentheses = {2809, DiagnosticCategory::Error, S("Declaration_or_statement_expected_This_follows_a_block_of_statements_so_if_you_intended_to_write_a_d_2809"), S("Declaration or statement expected. This '=' follows a block of statements, so if you intended to write a destructuring assignment, you might need to wrap the whole assignment in parentheses.")};
        static DiagnosticMessageStore Expected_1_argument_but_got_0_new_Promise_needs_a_JSDoc_hint_to_produce_a_resolve_that_can_be_called_without_arguments = {2810, DiagnosticCategory::Error, S("Expected_1_argument_but_got_0_new_Promise_needs_a_JSDoc_hint_to_produce_a_resolve_that_can_be_called_2810"), S("Expected 1 argument, but got 0. 'new Promise()' needs a JSDoc hint to produce a 'resolve' that can be called without arguments.")};
        static DiagnosticMessageStore Initializer_for_property_0 = {2811, DiagnosticCategory::Error, S("Initializer_for_property_0_2811"), S("Initializer for property '{0}'")};
        static DiagnosticMessageStore Property_0_does_not_exist_on_type_1_Try_changing_the_lib_compiler_option_to_include_dom = {2812, DiagnosticCategory::Error, S("Property_0_does_not_exist_on_type_1_Try_changing_the_lib_compiler_option_to_include_dom_2812"), S("Property '{0}' does not exist on type '{1}'. Try changing the 'lib' compiler option to include 'dom'.")};
        static DiagnosticMessageStore Class_declaration_cannot_implement_overload_list_for_0 = {2813, DiagnosticCategory::Error, S("Class_declaration_cannot_implement_overload_list_for_0_2813"), S("Class declaration cannot implement overload list for '{0}'.")};
        static DiagnosticMessageStore Function_with_bodies_can_only_merge_with_classes_that_are_ambient = {2814, DiagnosticCategory::Error, S("Function_with_bodies_can_only_merge_with_classes_that_are_ambient_2814"), S("Function with bodies can only merge with classes that are ambient.")};
        static DiagnosticMessageStore arguments_cannot_be_referenced_in_property_initializers = {2815, DiagnosticCategory::Error, S("arguments_cannot_be_referenced_in_property_initializers_2815"), S("'arguments' cannot be referenced in property initializers.")};
        static DiagnosticMessageStore Cannot_use_this_in_a_static_property_initializer_of_a_decorated_class = {2816, DiagnosticCategory::Error, S("Cannot_use_this_in_a_static_property_initializer_of_a_decorated_class_2816"), S("Cannot use 'this' in a static property initializer of a decorated class.")};
        static DiagnosticMessageStore Property_0_has_no_initializer_and_is_not_definitely_assigned_in_a_class_static_block = {2817, DiagnosticCategory::Error, S("Property_0_has_no_initializer_and_is_not_definitely_assigned_in_a_class_static_block_2817"), S("Property '{0}' has no initializer and is not definitely assigned in a class static block.")};
        static DiagnosticMessageStore Duplicate_identifier_0_Compiler_reserves_name_1_when_emitting_super_references_in_static_initializers = {2818, DiagnosticCategory::Error, S("Duplicate_identifier_0_Compiler_reserves_name_1_when_emitting_super_references_in_static_initializer_2818"), S("Duplicate identifier '{0}'. Compiler reserves name '{1}' when emitting 'super' references in static initializers.")};
        static DiagnosticMessageStore Namespace_name_cannot_be_0 = {2819, DiagnosticCategory::Error, S("Namespace_name_cannot_be_0_2819"), S("Namespace name cannot be '{0}'.")};
        static DiagnosticMessageStore Type_0_is_not_assignable_to_type_1_Did_you_mean_2 = {2820, DiagnosticCategory::Error, S("Type_0_is_not_assignable_to_type_1_Did_you_mean_2_2820"), S("Type '{0}' is not assignable to type '{1}'. Did you mean '{2}'?")};
        static DiagnosticMessageStore Import_assertions_are_only_supported_when_the_module_option_is_set_to_esnext_or_nodenext = {2821, DiagnosticCategory::Error, S("Import_assertions_are_only_supported_when_the_module_option_is_set_to_esnext_or_nodenext_2821"), S("Import assertions are only supported when the '--module' option is set to 'esnext' or 'nodenext'.")};
        static DiagnosticMessageStore Import_assertions_cannot_be_used_with_type_only_imports_or_exports = {2822, DiagnosticCategory::Error, S("Import_assertions_cannot_be_used_with_type_only_imports_or_exports_2822"), S("Import assertions cannot be used with type-only imports or exports.")};
        static DiagnosticMessageStore Import_attributes_are_only_supported_when_the_module_option_is_set_to_esnext_or_nodenext = {2823, DiagnosticCategory::Error, S("Import_attributes_are_only_supported_when_the_module_option_is_set_to_esnext_or_nodenext_2823"), S("Import attributes are only supported when the '--module' option is set to 'esnext' or 'nodenext'.")};
        static DiagnosticMessageStore Cannot_find_namespace_0_Did_you_mean_1 = {2833, DiagnosticCategory::Error, S("Cannot_find_namespace_0_Did_you_mean_1_2833"), S("Cannot find namespace '{0}'. Did you mean '{1}'?")};
        static DiagnosticMessageStore Relative_import_paths_need_explicit_file_extensions_in_ECMAScript_imports_when_moduleResolution_is_node16_or_nodenext_Consider_adding_an_extension_to_the_import_path = {2834, DiagnosticCategory::Error, S("Relative_import_paths_need_explicit_file_extensions_in_ECMAScript_imports_when_moduleResolution_is_n_2834"), S("Relative import paths need explicit file extensions in ECMAScript imports when '--moduleResolution' is 'node16' or 'nodenext'. Consider adding an extension to the import path.")};
        static DiagnosticMessageStore Relative_import_paths_need_explicit_file_extensions_in_ECMAScript_imports_when_moduleResolution_is_node16_or_nodenext_Did_you_mean_0 = {2835, DiagnosticCategory::Error, S("Relative_import_paths_need_explicit_file_extensions_in_ECMAScript_imports_when_moduleResolution_is_n_2835"), S("Relative import paths need explicit file extensions in ECMAScript imports when '--moduleResolution' is 'node16' or 'nodenext'. Did you mean '{0}'?")};
        static DiagnosticMessageStore Import_assertions_are_not_allowed_on_statements_that_compile_to_CommonJS_require_calls = {2836, DiagnosticCategory::Error, S("Import_assertions_are_not_allowed_on_statements_that_compile_to_CommonJS_require_calls_2836"), S("Import assertions are not allowed on statements that compile to CommonJS 'require' calls.")};
        static DiagnosticMessageStore Import_assertion_values_must_be_string_literal_expressions = {2837, DiagnosticCategory::Error, S("Import_assertion_values_must_be_string_literal_expressions_2837"), S("Import assertion values must be string literal expressions.")};
        static DiagnosticMessageStore All_declarations_of_0_must_have_identical_constraints = {2838, DiagnosticCategory::Error, S("All_declarations_of_0_must_have_identical_constraints_2838"), S("All declarations of '{0}' must have identical constraints.")};
        static DiagnosticMessageStore This_condition_will_always_return_0_since_JavaScript_compares_objects_by_reference_not_value = {2839, DiagnosticCategory::Error, S("This_condition_will_always_return_0_since_JavaScript_compares_objects_by_reference_not_value_2839"), S("This condition will always return '{0}' since JavaScript compares objects by reference, not value.")};
        static DiagnosticMessageStore An_interface_cannot_extend_a_primitive_type_like_0_an_interface_can_only_extend_named_types_and_classes = {2840, DiagnosticCategory::Error, S("An_interface_cannot_extend_a_primitive_type_like_0_an_interface_can_only_extend_named_types_and_clas_2840"), S("An interface cannot extend a primitive type like '{0}'; an interface can only extend named types and classes")};
        static DiagnosticMessageStore _0_is_an_unused_renaming_of_1_Did_you_intend_to_use_it_as_a_type_annotation = {2842, DiagnosticCategory::Error, S("_0_is_an_unused_renaming_of_1_Did_you_intend_to_use_it_as_a_type_annotation_2842"), S("'{0}' is an unused renaming of '{1}'. Did you intend to use it as a type annotation?")};
        static DiagnosticMessageStore We_can_only_write_a_type_for_0_by_adding_a_type_for_the_entire_parameter_here = {2843, DiagnosticCategory::Error, S("We_can_only_write_a_type_for_0_by_adding_a_type_for_the_entire_parameter_here_2843"), S("We can only write a type for '{0}' by adding a type for the entire parameter here.")};
        static DiagnosticMessageStore Type_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor = {2844, DiagnosticCategory::Error, S("Type_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor_2844"), S("Type of instance member variable '{0}' cannot reference identifier '{1}' declared in the constructor.")};
        static DiagnosticMessageStore This_condition_will_always_return_0 = {2845, DiagnosticCategory::Error, S("This_condition_will_always_return_0_2845"), S("This condition will always return '{0}'.")};
        static DiagnosticMessageStore A_declaration_file_cannot_be_imported_without_import_type_Did_you_mean_to_import_an_implementation_file_0_instead = {2846, DiagnosticCategory::Error, S("A_declaration_file_cannot_be_imported_without_import_type_Did_you_mean_to_import_an_implementation_f_2846"), S("A declaration file cannot be imported without 'import type'. Did you mean to import an implementation file '{0}' instead?")};
        static DiagnosticMessageStore The_right_hand_side_of_an_instanceof_expression_must_not_be_an_instantiation_expression = {2848, DiagnosticCategory::Error, S("The_right_hand_side_of_an_instanceof_expression_must_not_be_an_instantiation_expression_2848"), S("The right-hand side of an 'instanceof' expression must not be an instantiation expression.")};
        static DiagnosticMessageStore Target_signature_provides_too_few_arguments_Expected_0_or_more_but_got_1 = {2849, DiagnosticCategory::Error, S("Target_signature_provides_too_few_arguments_Expected_0_or_more_but_got_1_2849"), S("Target signature provides too few arguments. Expected {0} or more, but got {1}.")};
        static DiagnosticMessageStore The_initializer_of_a_using_declaration_must_be_either_an_object_with_a_Symbol_dispose_method_or_be_null_or_undefined = {2850, DiagnosticCategory::Error, S("The_initializer_of_a_using_declaration_must_be_either_an_object_with_a_Symbol_dispose_method_or_be_n_2850"), S("The initializer of a 'using' declaration must be either an object with a '[Symbol.dispose]()' method, or be 'null' or 'undefined'.")};
        static DiagnosticMessageStore The_initializer_of_an_await_using_declaration_must_be_either_an_object_with_a_Symbol_asyncDispose_or_Symbol_dispose_method_or_be_null_or_undefined = {2851, DiagnosticCategory::Error, S("The_initializer_of_an_await_using_declaration_must_be_either_an_object_with_a_Symbol_asyncDispose_or_2851"), S("The initializer of an 'await using' declaration must be either an object with a '[Symbol.asyncDispose]()' or '[Symbol.dispose]()' method, or be 'null' or 'undefined'.")};
        static DiagnosticMessageStore await_using_statements_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules = {2852, DiagnosticCategory::Error, S("await_using_statements_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules_2852"), S("'await using' statements are only allowed within async functions and at the top levels of modules.")};
        static DiagnosticMessageStore await_using_statements_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module = {2853, DiagnosticCategory::Error, S("await_using_statements_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_th_2853"), S("'await using' statements are only allowed at the top level of a file when that file is a module, but this file has no imports or exports. Consider adding an empty 'export {}' to make this file a module.")};
        static DiagnosticMessageStore Top_level_await_using_statements_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_node16_or_nodenext_and_the_target_option_is_set_to_es2017_or_higher = {2854, DiagnosticCategory::Error, S("Top_level_await_using_statements_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_sys_2854"), S("Top-level 'await using' statements are only allowed when the 'module' option is set to 'es2022', 'esnext', 'system', 'node16', or 'nodenext', and the 'target' option is set to 'es2017' or higher.")};
        static DiagnosticMessageStore Class_field_0_defined_by_the_parent_class_is_not_accessible_in_the_child_class_via_super = {2855, DiagnosticCategory::Error, S("Class_field_0_defined_by_the_parent_class_is_not_accessible_in_the_child_class_via_super_2855"), S("Class field '{0}' defined by the parent class is not accessible in the child class via super.")};
        static DiagnosticMessageStore Import_attributes_are_not_allowed_on_statements_that_compile_to_CommonJS_require_calls = {2856, DiagnosticCategory::Error, S("Import_attributes_are_not_allowed_on_statements_that_compile_to_CommonJS_require_calls_2856"), S("Import attributes are not allowed on statements that compile to CommonJS 'require' calls.")};
        static DiagnosticMessageStore Import_attributes_cannot_be_used_with_type_only_imports_or_exports = {2857, DiagnosticCategory::Error, S("Import_attributes_cannot_be_used_with_type_only_imports_or_exports_2857"), S("Import attributes cannot be used with type-only imports or exports.")};
        static DiagnosticMessageStore Import_attribute_values_must_be_string_literal_expressions = {2858, DiagnosticCategory::Error, S("Import_attribute_values_must_be_string_literal_expressions_2858"), S("Import attribute values must be string literal expressions.")};
        static DiagnosticMessageStore Excessive_complexity_comparing_types_0_and_1 = {2859, DiagnosticCategory::Error, S("Excessive_complexity_comparing_types_0_and_1_2859"), S("Excessive complexity comparing types '{0}' and '{1}'.")};
        static DiagnosticMessageStore The_left_hand_side_of_an_instanceof_expression_must_be_assignable_to_the_first_argument_of_the_right_hand_side_s_Symbol_hasInstance_method = {2860, DiagnosticCategory::Error, S("The_left_hand_side_of_an_instanceof_expression_must_be_assignable_to_the_first_argument_of_the_right_2860"), S("The left-hand side of an 'instanceof' expression must be assignable to the first argument of the right-hand side's '[Symbol.hasInstance]' method.")};
        static DiagnosticMessageStore An_object_s_Symbol_hasInstance_method_must_return_a_boolean_value_for_it_to_be_used_on_the_right_hand_side_of_an_instanceof_expression = {2861, DiagnosticCategory::Error, S("An_object_s_Symbol_hasInstance_method_must_return_a_boolean_value_for_it_to_be_used_on_the_right_han_2861"), S("An object's '[Symbol.hasInstance]' method must return a boolean value for it to be used on the right-hand side of an 'instanceof' expression.")};
        static DiagnosticMessageStore Import_declaration_0_is_using_private_name_1 = {4000, DiagnosticCategory::Error, S("Import_declaration_0_is_using_private_name_1_4000"), S("Import declaration '{0}' is using private name '{1}'.")};
        static DiagnosticMessageStore Type_parameter_0_of_exported_class_has_or_is_using_private_name_1 = {4002, DiagnosticCategory::Error, S("Type_parameter_0_of_exported_class_has_or_is_using_private_name_1_4002"), S("Type parameter '{0}' of exported class has or is using private name '{1}'.")};
        static DiagnosticMessageStore Type_parameter_0_of_exported_interface_has_or_is_using_private_name_1 = {4004, DiagnosticCategory::Error, S("Type_parameter_0_of_exported_interface_has_or_is_using_private_name_1_4004"), S("Type parameter '{0}' of exported interface has or is using private name '{1}'.")};
        static DiagnosticMessageStore Type_parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1 = {4006, DiagnosticCategory::Error, S("Type_parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1_4006"), S("Type parameter '{0}' of constructor signature from exported interface has or is using private name '{1}'.")};
        static DiagnosticMessageStore Type_parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1 = {4008, DiagnosticCategory::Error, S("Type_parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1_4008"), S("Type parameter '{0}' of call signature from exported interface has or is using private name '{1}'.")};
        static DiagnosticMessageStore Type_parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1 = {4010, DiagnosticCategory::Error, S("Type_parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1_4010"), S("Type parameter '{0}' of public static method from exported class has or is using private name '{1}'.")};
        static DiagnosticMessageStore Type_parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1 = {4012, DiagnosticCategory::Error, S("Type_parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1_4012"), S("Type parameter '{0}' of public method from exported class has or is using private name '{1}'.")};
        static DiagnosticMessageStore Type_parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1 = {4014, DiagnosticCategory::Error, S("Type_parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1_4014"), S("Type parameter '{0}' of method from exported interface has or is using private name '{1}'.")};
        static DiagnosticMessageStore Type_parameter_0_of_exported_function_has_or_is_using_private_name_1 = {4016, DiagnosticCategory::Error, S("Type_parameter_0_of_exported_function_has_or_is_using_private_name_1_4016"), S("Type parameter '{0}' of exported function has or is using private name '{1}'.")};
        static DiagnosticMessageStore Implements_clause_of_exported_class_0_has_or_is_using_private_name_1 = {4019, DiagnosticCategory::Error, S("Implements_clause_of_exported_class_0_has_or_is_using_private_name_1_4019"), S("Implements clause of exported class '{0}' has or is using private name '{1}'.")};
        static DiagnosticMessageStore extends_clause_of_exported_class_0_has_or_is_using_private_name_1 = {4020, DiagnosticCategory::Error, S("extends_clause_of_exported_class_0_has_or_is_using_private_name_1_4020"), S("'extends' clause of exported class '{0}' has or is using private name '{1}'.")};
        static DiagnosticMessageStore extends_clause_of_exported_class_has_or_is_using_private_name_0 = {4021, DiagnosticCategory::Error, S("extends_clause_of_exported_class_has_or_is_using_private_name_0_4021"), S("'extends' clause of exported class has or is using private name '{0}'.")};
        static DiagnosticMessageStore extends_clause_of_exported_interface_0_has_or_is_using_private_name_1 = {4022, DiagnosticCategory::Error, S("extends_clause_of_exported_interface_0_has_or_is_using_private_name_1_4022"), S("'extends' clause of exported interface '{0}' has or is using private name '{1}'.")};
        static DiagnosticMessageStore Exported_variable_0_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named = {4023, DiagnosticCategory::Error, S("Exported_variable_0_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named_4023"), S("Exported variable '{0}' has or is using name '{1}' from external module {2} but cannot be named.")};
        static DiagnosticMessageStore Exported_variable_0_has_or_is_using_name_1_from_private_module_2 = {4024, DiagnosticCategory::Error, S("Exported_variable_0_has_or_is_using_name_1_from_private_module_2_4024"), S("Exported variable '{0}' has or is using name '{1}' from private module '{2}'.")};
        static DiagnosticMessageStore Exported_variable_0_has_or_is_using_private_name_1 = {4025, DiagnosticCategory::Error, S("Exported_variable_0_has_or_is_using_private_name_1_4025"), S("Exported variable '{0}' has or is using private name '{1}'.")};
        static DiagnosticMessageStore Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named = {4026, DiagnosticCategory::Error, S("Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot__4026"), S("Public static property '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named.")};
        static DiagnosticMessageStore Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2 = {4027, DiagnosticCategory::Error, S("Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2_4027"), S("Public static property '{0}' of exported class has or is using name '{1}' from private module '{2}'.")};
        static DiagnosticMessageStore Public_static_property_0_of_exported_class_has_or_is_using_private_name_1 = {4028, DiagnosticCategory::Error, S("Public_static_property_0_of_exported_class_has_or_is_using_private_name_1_4028"), S("Public static property '{0}' of exported class has or is using private name '{1}'.")};
        static DiagnosticMessageStore Public_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named = {4029, DiagnosticCategory::Error, S("Public_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_name_4029"), S("Public property '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named.")};
        static DiagnosticMessageStore Public_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2 = {4030, DiagnosticCategory::Error, S("Public_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2_4030"), S("Public property '{0}' of exported class has or is using name '{1}' from private module '{2}'.")};
        static DiagnosticMessageStore Public_property_0_of_exported_class_has_or_is_using_private_name_1 = {4031, DiagnosticCategory::Error, S("Public_property_0_of_exported_class_has_or_is_using_private_name_1_4031"), S("Public property '{0}' of exported class has or is using private name '{1}'.")};
        static DiagnosticMessageStore Property_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2 = {4032, DiagnosticCategory::Error, S("Property_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2_4032"), S("Property '{0}' of exported interface has or is using name '{1}' from private module '{2}'.")};
        static DiagnosticMessageStore Property_0_of_exported_interface_has_or_is_using_private_name_1 = {4033, DiagnosticCategory::Error, S("Property_0_of_exported_interface_has_or_is_using_private_name_1_4033"), S("Property '{0}' of exported interface has or is using private name '{1}'.")};
        static DiagnosticMessageStore Parameter_type_of_public_static_setter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2 = {4034, DiagnosticCategory::Error, S("Parameter_type_of_public_static_setter_0_from_exported_class_has_or_is_using_name_1_from_private_mod_4034"), S("Parameter type of public static setter '{0}' from exported class has or is using name '{1}' from private module '{2}'.")};
        static DiagnosticMessageStore Parameter_type_of_public_static_setter_0_from_exported_class_has_or_is_using_private_name_1 = {4035, DiagnosticCategory::Error, S("Parameter_type_of_public_static_setter_0_from_exported_class_has_or_is_using_private_name_1_4035"), S("Parameter type of public static setter '{0}' from exported class has or is using private name '{1}'.")};
        static DiagnosticMessageStore Parameter_type_of_public_setter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2 = {4036, DiagnosticCategory::Error, S("Parameter_type_of_public_setter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2_4036"), S("Parameter type of public setter '{0}' from exported class has or is using name '{1}' from private module '{2}'.")};
        static DiagnosticMessageStore Parameter_type_of_public_setter_0_from_exported_class_has_or_is_using_private_name_1 = {4037, DiagnosticCategory::Error, S("Parameter_type_of_public_setter_0_from_exported_class_has_or_is_using_private_name_1_4037"), S("Parameter type of public setter '{0}' from exported class has or is using private name '{1}'.")};
        static DiagnosticMessageStore Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named = {4038, DiagnosticCategory::Error, S("Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_name_1_from_external_modul_4038"), S("Return type of public static getter '{0}' from exported class has or is using name '{1}' from external module {2} but cannot be named.")};
        static DiagnosticMessageStore Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2 = {4039, DiagnosticCategory::Error, S("Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_name_1_from_private_module_4039"), S("Return type of public static getter '{0}' from exported class has or is using name '{1}' from private module '{2}'.")};
        static DiagnosticMessageStore Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_private_name_1 = {4040, DiagnosticCategory::Error, S("Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_private_name_1_4040"), S("Return type of public static getter '{0}' from exported class has or is using private name '{1}'.")};
        static DiagnosticMessageStore Return_type_of_public_getter_0_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named = {4041, DiagnosticCategory::Error, S("Return_type_of_public_getter_0_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_4041"), S("Return type of public getter '{0}' from exported class has or is using name '{1}' from external module {2} but cannot be named.")};
        static DiagnosticMessageStore Return_type_of_public_getter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2 = {4042, DiagnosticCategory::Error, S("Return_type_of_public_getter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2_4042"), S("Return type of public getter '{0}' from exported class has or is using name '{1}' from private module '{2}'.")};
        static DiagnosticMessageStore Return_type_of_public_getter_0_from_exported_class_has_or_is_using_private_name_1 = {4043, DiagnosticCategory::Error, S("Return_type_of_public_getter_0_from_exported_class_has_or_is_using_private_name_1_4043"), S("Return type of public getter '{0}' from exported class has or is using private name '{1}'.")};
        static DiagnosticMessageStore Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1 = {4044, DiagnosticCategory::Error, S("Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_name_0_from_private_mod_4044"), S("Return type of constructor signature from exported interface has or is using name '{0}' from private module '{1}'.")};
        static DiagnosticMessageStore Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_0 = {4045, DiagnosticCategory::Error, S("Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_0_4045"), S("Return type of constructor signature from exported interface has or is using private name '{0}'.")};
        static DiagnosticMessageStore Return_type_of_call_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1 = {4046, DiagnosticCategory::Error, S("Return_type_of_call_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1_4046"), S("Return type of call signature from exported interface has or is using name '{0}' from private module '{1}'.")};
        static DiagnosticMessageStore Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_name_0 = {4047, DiagnosticCategory::Error, S("Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_name_0_4047"), S("Return type of call signature from exported interface has or is using private name '{0}'.")};
        static DiagnosticMessageStore Return_type_of_index_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1 = {4048, DiagnosticCategory::Error, S("Return_type_of_index_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1_4048"), S("Return type of index signature from exported interface has or is using name '{0}' from private module '{1}'.")};
        static DiagnosticMessageStore Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_name_0 = {4049, DiagnosticCategory::Error, S("Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_name_0_4049"), S("Return type of index signature from exported interface has or is using private name '{0}'.")};
        static DiagnosticMessageStore Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named = {4050, DiagnosticCategory::Error, S("Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_external_module__4050"), S("Return type of public static method from exported class has or is using name '{0}' from external module {1} but cannot be named.")};
        static DiagnosticMessageStore Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_private_module_1 = {4051, DiagnosticCategory::Error, S("Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_private_module_1_4051"), S("Return type of public static method from exported class has or is using name '{0}' from private module '{1}'.")};
        static DiagnosticMessageStore Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_name_0 = {4052, DiagnosticCategory::Error, S("Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_name_0_4052"), S("Return type of public static method from exported class has or is using private name '{0}'.")};
        static DiagnosticMessageStore Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named = {4053, DiagnosticCategory::Error, S("Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_c_4053"), S("Return type of public method from exported class has or is using name '{0}' from external module {1} but cannot be named.")};
        static DiagnosticMessageStore Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_private_module_1 = {4054, DiagnosticCategory::Error, S("Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_private_module_1_4054"), S("Return type of public method from exported class has or is using name '{0}' from private module '{1}'.")};
        static DiagnosticMessageStore Return_type_of_public_method_from_exported_class_has_or_is_using_private_name_0 = {4055, DiagnosticCategory::Error, S("Return_type_of_public_method_from_exported_class_has_or_is_using_private_name_0_4055"), S("Return type of public method from exported class has or is using private name '{0}'.")};
        static DiagnosticMessageStore Return_type_of_method_from_exported_interface_has_or_is_using_name_0_from_private_module_1 = {4056, DiagnosticCategory::Error, S("Return_type_of_method_from_exported_interface_has_or_is_using_name_0_from_private_module_1_4056"), S("Return type of method from exported interface has or is using name '{0}' from private module '{1}'.")};
        static DiagnosticMessageStore Return_type_of_method_from_exported_interface_has_or_is_using_private_name_0 = {4057, DiagnosticCategory::Error, S("Return_type_of_method_from_exported_interface_has_or_is_using_private_name_0_4057"), S("Return type of method from exported interface has or is using private name '{0}'.")};
        static DiagnosticMessageStore Return_type_of_exported_function_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named = {4058, DiagnosticCategory::Error, S("Return_type_of_exported_function_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named_4058"), S("Return type of exported function has or is using name '{0}' from external module {1} but cannot be named.")};
        static DiagnosticMessageStore Return_type_of_exported_function_has_or_is_using_name_0_from_private_module_1 = {4059, DiagnosticCategory::Error, S("Return_type_of_exported_function_has_or_is_using_name_0_from_private_module_1_4059"), S("Return type of exported function has or is using name '{0}' from private module '{1}'.")};
        static DiagnosticMessageStore Return_type_of_exported_function_has_or_is_using_private_name_0 = {4060, DiagnosticCategory::Error, S("Return_type_of_exported_function_has_or_is_using_private_name_0_4060"), S("Return type of exported function has or is using private name '{0}'.")};
        static DiagnosticMessageStore Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named = {4061, DiagnosticCategory::Error, S("Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_can_4061"), S("Parameter '{0}' of constructor from exported class has or is using name '{1}' from external module {2} but cannot be named.")};
        static DiagnosticMessageStore Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_private_module_2 = {4062, DiagnosticCategory::Error, S("Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_private_module_2_4062"), S("Parameter '{0}' of constructor from exported class has or is using name '{1}' from private module '{2}'.")};
        static DiagnosticMessageStore Parameter_0_of_constructor_from_exported_class_has_or_is_using_private_name_1 = {4063, DiagnosticCategory::Error, S("Parameter_0_of_constructor_from_exported_class_has_or_is_using_private_name_1_4063"), S("Parameter '{0}' of constructor from exported class has or is using private name '{1}'.")};
        static DiagnosticMessageStore Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2 = {4064, DiagnosticCategory::Error, S("Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_name_1_from_private_mod_4064"), S("Parameter '{0}' of constructor signature from exported interface has or is using name '{1}' from private module '{2}'.")};
        static DiagnosticMessageStore Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1 = {4065, DiagnosticCategory::Error, S("Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1_4065"), S("Parameter '{0}' of constructor signature from exported interface has or is using private name '{1}'.")};
        static DiagnosticMessageStore Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2 = {4066, DiagnosticCategory::Error, S("Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2_4066"), S("Parameter '{0}' of call signature from exported interface has or is using name '{1}' from private module '{2}'.")};
        static DiagnosticMessageStore Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1 = {4067, DiagnosticCategory::Error, S("Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1_4067"), S("Parameter '{0}' of call signature from exported interface has or is using private name '{1}'.")};
        static DiagnosticMessageStore Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named = {4068, DiagnosticCategory::Error, S("Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_external_module__4068"), S("Parameter '{0}' of public static method from exported class has or is using name '{1}' from external module {2} but cannot be named.")};
        static DiagnosticMessageStore Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_private_module_2 = {4069, DiagnosticCategory::Error, S("Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_private_module_2_4069"), S("Parameter '{0}' of public static method from exported class has or is using name '{1}' from private module '{2}'.")};
        static DiagnosticMessageStore Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1 = {4070, DiagnosticCategory::Error, S("Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1_4070"), S("Parameter '{0}' of public static method from exported class has or is using private name '{1}'.")};
        static DiagnosticMessageStore Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named = {4071, DiagnosticCategory::Error, S("Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_c_4071"), S("Parameter '{0}' of public method from exported class has or is using name '{1}' from external module {2} but cannot be named.")};
        static DiagnosticMessageStore Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_private_module_2 = {4072, DiagnosticCategory::Error, S("Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_private_module_2_4072"), S("Parameter '{0}' of public method from exported class has or is using name '{1}' from private module '{2}'.")};
        static DiagnosticMessageStore Parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1 = {4073, DiagnosticCategory::Error, S("Parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1_4073"), S("Parameter '{0}' of public method from exported class has or is using private name '{1}'.")};
        static DiagnosticMessageStore Parameter_0_of_method_from_exported_interface_has_or_is_using_name_1_from_private_module_2 = {4074, DiagnosticCategory::Error, S("Parameter_0_of_method_from_exported_interface_has_or_is_using_name_1_from_private_module_2_4074"), S("Parameter '{0}' of method from exported interface has or is using name '{1}' from private module '{2}'.")};
        static DiagnosticMessageStore Parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1 = {4075, DiagnosticCategory::Error, S("Parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1_4075"), S("Parameter '{0}' of method from exported interface has or is using private name '{1}'.")};
        static DiagnosticMessageStore Parameter_0_of_exported_function_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named = {4076, DiagnosticCategory::Error, S("Parameter_0_of_exported_function_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named_4076"), S("Parameter '{0}' of exported function has or is using name '{1}' from external module {2} but cannot be named.")};
        static DiagnosticMessageStore Parameter_0_of_exported_function_has_or_is_using_name_1_from_private_module_2 = {4077, DiagnosticCategory::Error, S("Parameter_0_of_exported_function_has_or_is_using_name_1_from_private_module_2_4077"), S("Parameter '{0}' of exported function has or is using name '{1}' from private module '{2}'.")};
        static DiagnosticMessageStore Parameter_0_of_exported_function_has_or_is_using_private_name_1 = {4078, DiagnosticCategory::Error, S("Parameter_0_of_exported_function_has_or_is_using_private_name_1_4078"), S("Parameter '{0}' of exported function has or is using private name '{1}'.")};
        static DiagnosticMessageStore Exported_type_alias_0_has_or_is_using_private_name_1 = {4081, DiagnosticCategory::Error, S("Exported_type_alias_0_has_or_is_using_private_name_1_4081"), S("Exported type alias '{0}' has or is using private name '{1}'.")};
        static DiagnosticMessageStore Default_export_of_the_module_has_or_is_using_private_name_0 = {4082, DiagnosticCategory::Error, S("Default_export_of_the_module_has_or_is_using_private_name_0_4082"), S("Default export of the module has or is using private name '{0}'.")};
        static DiagnosticMessageStore Type_parameter_0_of_exported_type_alias_has_or_is_using_private_name_1 = {4083, DiagnosticCategory::Error, S("Type_parameter_0_of_exported_type_alias_has_or_is_using_private_name_1_4083"), S("Type parameter '{0}' of exported type alias has or is using private name '{1}'.")};
        static DiagnosticMessageStore Exported_type_alias_0_has_or_is_using_private_name_1_from_module_2 = {4084, DiagnosticCategory::Error, S("Exported_type_alias_0_has_or_is_using_private_name_1_from_module_2_4084"), S("Exported type alias '{0}' has or is using private name '{1}' from module {2}.")};
        static DiagnosticMessageStore Extends_clause_for_inferred_type_0_has_or_is_using_private_name_1 = {4085, DiagnosticCategory::Error, S("Extends_clause_for_inferred_type_0_has_or_is_using_private_name_1_4085"), S("Extends clause for inferred type '{0}' has or is using private name '{1}'.")};
        static DiagnosticMessageStore Conflicting_definitions_for_0_found_at_1_and_2_Consider_installing_a_specific_version_of_this_library_to_resolve_the_conflict = {4090, DiagnosticCategory::Error, S("Conflicting_definitions_for_0_found_at_1_and_2_Consider_installing_a_specific_version_of_this_librar_4090"), S("Conflicting definitions for '{0}' found at '{1}' and '{2}'. Consider installing a specific version of this library to resolve the conflict.")};
        static DiagnosticMessageStore Parameter_0_of_index_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2 = {4091, DiagnosticCategory::Error, S("Parameter_0_of_index_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2_4091"), S("Parameter '{0}' of index signature from exported interface has or is using name '{1}' from private module '{2}'.")};
        static DiagnosticMessageStore Parameter_0_of_index_signature_from_exported_interface_has_or_is_using_private_name_1 = {4092, DiagnosticCategory::Error, S("Parameter_0_of_index_signature_from_exported_interface_has_or_is_using_private_name_1_4092"), S("Parameter '{0}' of index signature from exported interface has or is using private name '{1}'.")};
        static DiagnosticMessageStore Property_0_of_exported_class_expression_may_not_be_private_or_protected = {4094, DiagnosticCategory::Error, S("Property_0_of_exported_class_expression_may_not_be_private_or_protected_4094"), S("Property '{0}' of exported class expression may not be private or protected.")};
        static DiagnosticMessageStore Public_static_method_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named = {4095, DiagnosticCategory::Error, S("Public_static_method_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_4095"), S("Public static method '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named.")};
        static DiagnosticMessageStore Public_static_method_0_of_exported_class_has_or_is_using_name_1_from_private_module_2 = {4096, DiagnosticCategory::Error, S("Public_static_method_0_of_exported_class_has_or_is_using_name_1_from_private_module_2_4096"), S("Public static method '{0}' of exported class has or is using name '{1}' from private module '{2}'.")};
        static DiagnosticMessageStore Public_static_method_0_of_exported_class_has_or_is_using_private_name_1 = {4097, DiagnosticCategory::Error, S("Public_static_method_0_of_exported_class_has_or_is_using_private_name_1_4097"), S("Public static method '{0}' of exported class has or is using private name '{1}'.")};
        static DiagnosticMessageStore Public_method_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named = {4098, DiagnosticCategory::Error, S("Public_method_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named_4098"), S("Public method '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named.")};
        static DiagnosticMessageStore Public_method_0_of_exported_class_has_or_is_using_name_1_from_private_module_2 = {4099, DiagnosticCategory::Error, S("Public_method_0_of_exported_class_has_or_is_using_name_1_from_private_module_2_4099"), S("Public method '{0}' of exported class has or is using name '{1}' from private module '{2}'.")};
        static DiagnosticMessageStore Public_method_0_of_exported_class_has_or_is_using_private_name_1 = {4100, DiagnosticCategory::Error, S("Public_method_0_of_exported_class_has_or_is_using_private_name_1_4100"), S("Public method '{0}' of exported class has or is using private name '{1}'.")};
        static DiagnosticMessageStore Method_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2 = {4101, DiagnosticCategory::Error, S("Method_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2_4101"), S("Method '{0}' of exported interface has or is using name '{1}' from private module '{2}'.")};
        static DiagnosticMessageStore Method_0_of_exported_interface_has_or_is_using_private_name_1 = {4102, DiagnosticCategory::Error, S("Method_0_of_exported_interface_has_or_is_using_private_name_1_4102"), S("Method '{0}' of exported interface has or is using private name '{1}'.")};
        static DiagnosticMessageStore Type_parameter_0_of_exported_mapped_object_type_is_using_private_name_1 = {4103, DiagnosticCategory::Error, S("Type_parameter_0_of_exported_mapped_object_type_is_using_private_name_1_4103"), S("Type parameter '{0}' of exported mapped object type is using private name '{1}'.")};
        static DiagnosticMessageStore The_type_0_is_readonly_and_cannot_be_assigned_to_the_mutable_type_1 = {4104, DiagnosticCategory::Error, S("The_type_0_is_readonly_and_cannot_be_assigned_to_the_mutable_type_1_4104"), S("The type '{0}' is 'readonly' and cannot be assigned to the mutable type '{1}'.")};
        static DiagnosticMessageStore Private_or_protected_member_0_cannot_be_accessed_on_a_type_parameter = {4105, DiagnosticCategory::Error, S("Private_or_protected_member_0_cannot_be_accessed_on_a_type_parameter_4105"), S("Private or protected member '{0}' cannot be accessed on a type parameter.")};
        static DiagnosticMessageStore Parameter_0_of_accessor_has_or_is_using_private_name_1 = {4106, DiagnosticCategory::Error, S("Parameter_0_of_accessor_has_or_is_using_private_name_1_4106"), S("Parameter '{0}' of accessor has or is using private name '{1}'.")};
        static DiagnosticMessageStore Parameter_0_of_accessor_has_or_is_using_name_1_from_private_module_2 = {4107, DiagnosticCategory::Error, S("Parameter_0_of_accessor_has_or_is_using_name_1_from_private_module_2_4107"), S("Parameter '{0}' of accessor has or is using name '{1}' from private module '{2}'.")};
        static DiagnosticMessageStore Parameter_0_of_accessor_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named = {4108, DiagnosticCategory::Error, S("Parameter_0_of_accessor_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named_4108"), S("Parameter '{0}' of accessor has or is using name '{1}' from external module '{2}' but cannot be named.")};
        static DiagnosticMessageStore Type_arguments_for_0_circularly_reference_themselves = {4109, DiagnosticCategory::Error, S("Type_arguments_for_0_circularly_reference_themselves_4109"), S("Type arguments for '{0}' circularly reference themselves.")};
        static DiagnosticMessageStore Tuple_type_arguments_circularly_reference_themselves = {4110, DiagnosticCategory::Error, S("Tuple_type_arguments_circularly_reference_themselves_4110"), S("Tuple type arguments circularly reference themselves.")};
        static DiagnosticMessageStore Property_0_comes_from_an_index_signature_so_it_must_be_accessed_with_0 = {4111, DiagnosticCategory::Error, S("Property_0_comes_from_an_index_signature_so_it_must_be_accessed_with_0_4111"), S("Property '{0}' comes from an index signature, so it must be accessed with ['{0}'].")};
        static DiagnosticMessageStore This_member_cannot_have_an_override_modifier_because_its_containing_class_0_does_not_extend_another_class = {4112, DiagnosticCategory::Error, S("This_member_cannot_have_an_override_modifier_because_its_containing_class_0_does_not_extend_another__4112"), S("This member cannot have an 'override' modifier because its containing class '{0}' does not extend another class.")};
        static DiagnosticMessageStore This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0 = {4113, DiagnosticCategory::Error, S("This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0_4113"), S("This member cannot have an 'override' modifier because it is not declared in the base class '{0}'.")};
        static DiagnosticMessageStore This_member_must_have_an_override_modifier_because_it_overrides_a_member_in_the_base_class_0 = {4114, DiagnosticCategory::Error, S("This_member_must_have_an_override_modifier_because_it_overrides_a_member_in_the_base_class_0_4114"), S("This member must have an 'override' modifier because it overrides a member in the base class '{0}'.")};
        static DiagnosticMessageStore This_parameter_property_must_have_an_override_modifier_because_it_overrides_a_member_in_base_class_0 = {4115, DiagnosticCategory::Error, S("This_parameter_property_must_have_an_override_modifier_because_it_overrides_a_member_in_base_class_0_4115"), S("This parameter property must have an 'override' modifier because it overrides a member in base class '{0}'.")};
        static DiagnosticMessageStore This_member_must_have_an_override_modifier_because_it_overrides_an_abstract_method_that_is_declared_in_the_base_class_0 = {4116, DiagnosticCategory::Error, S("This_member_must_have_an_override_modifier_because_it_overrides_an_abstract_method_that_is_declared__4116"), S("This member must have an 'override' modifier because it overrides an abstract method that is declared in the base class '{0}'.")};
        static DiagnosticMessageStore This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0_Did_you_mean_1 = {4117, DiagnosticCategory::Error, S("This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0_Did_you__4117"), S("This member cannot have an 'override' modifier because it is not declared in the base class '{0}'. Did you mean '{1}'?")};
        static DiagnosticMessageStore The_type_of_this_node_cannot_be_serialized_because_its_property_0_cannot_be_serialized = {4118, DiagnosticCategory::Error, S("The_type_of_this_node_cannot_be_serialized_because_its_property_0_cannot_be_serialized_4118"), S("The type of this node cannot be serialized because its property '{0}' cannot be serialized.")};
        static DiagnosticMessageStore This_member_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_class_0 = {4119, DiagnosticCategory::Error, S("This_member_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_4119"), S("This member must have a JSDoc comment with an '@override' tag because it overrides a member in the base class '{0}'.")};
        static DiagnosticMessageStore This_parameter_property_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_class_0 = {4120, DiagnosticCategory::Error, S("This_parameter_property_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_4120"), S("This parameter property must have a JSDoc comment with an '@override' tag because it overrides a member in the base class '{0}'.")};
        static DiagnosticMessageStore This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_its_containing_class_0_does_not_extend_another_class = {4121, DiagnosticCategory::Error, S("This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_its_containing_class_0_does_not_4121"), S("This member cannot have a JSDoc comment with an '@override' tag because its containing class '{0}' does not extend another class.")};
        static DiagnosticMessageStore This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base_class_0 = {4122, DiagnosticCategory::Error, S("This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base__4122"), S("This member cannot have a JSDoc comment with an '@override' tag because it is not declared in the base class '{0}'.")};
        static DiagnosticMessageStore This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base_class_0_Did_you_mean_1 = {4123, DiagnosticCategory::Error, S("This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base__4123"), S("This member cannot have a JSDoc comment with an 'override' tag because it is not declared in the base class '{0}'. Did you mean '{1}'?")};
        static DiagnosticMessageStore Compiler_option_0_of_value_1_is_unstable_Use_nightly_TypeScript_to_silence_this_error_Try_updating_with_npm_install_D_typescript_next = {4124, DiagnosticCategory::Error, S("Compiler_option_0_of_value_1_is_unstable_Use_nightly_TypeScript_to_silence_this_error_Try_updating_w_4124"), S("Compiler option '{0}' of value '{1}' is unstable. Use nightly TypeScript to silence this error. Try updating with 'npm install -D typescript@next'.")};
        static DiagnosticMessageStore The_current_host_does_not_support_the_0_option = {5001, DiagnosticCategory::Error, S("The_current_host_does_not_support_the_0_option_5001"), S("The current host does not support the '{0}' option.")};
        static DiagnosticMessageStore Cannot_find_the_common_subdirectory_path_for_the_input_files = {5009, DiagnosticCategory::Error, S("Cannot_find_the_common_subdirectory_path_for_the_input_files_5009"), S("Cannot find the common subdirectory path for the input files.")};
        static DiagnosticMessageStore File_specification_cannot_end_in_a_recursive_directory_wildcard_Asterisk_Asterisk_Colon_0 = {5010, DiagnosticCategory::Error, S("File_specification_cannot_end_in_a_recursive_directory_wildcard_Asterisk_Asterisk_Colon_0_5010"), S("File specification cannot end in a recursive directory wildcard ('**'): '{0}'.")};
        static DiagnosticMessageStore Cannot_read_file_0_Colon_1 = {5012, DiagnosticCategory::Error, S("Cannot_read_file_0_Colon_1_5012"), S("Cannot read file '{0}': {1}.")};
        static DiagnosticMessageStore Failed_to_parse_file_0_Colon_1 = {5014, DiagnosticCategory::Error, S("Failed_to_parse_file_0_Colon_1_5014"), S("Failed to parse file '{0}': {1}.")};
        static DiagnosticMessageStore Unknown_compiler_option_0 = {5023, DiagnosticCategory::Error, S("Unknown_compiler_option_0_5023"), S("Unknown compiler option '{0}'.")};
        static DiagnosticMessageStore Compiler_option_0_requires_a_value_of_type_1 = {5024, DiagnosticCategory::Error, S("Compiler_option_0_requires_a_value_of_type_1_5024"), S("Compiler option '{0}' requires a value of type {1}.")};
        static DiagnosticMessageStore Unknown_compiler_option_0_Did_you_mean_1 = {5025, DiagnosticCategory::Error, S("Unknown_compiler_option_0_Did_you_mean_1_5025"), S("Unknown compiler option '{0}'. Did you mean '{1}'?")};
        static DiagnosticMessageStore Could_not_write_file_0_Colon_1 = {5033, DiagnosticCategory::Error, S("Could_not_write_file_0_Colon_1_5033"), S("Could not write file '{0}': {1}.")};
        static DiagnosticMessageStore Option_project_cannot_be_mixed_with_source_files_on_a_command_line = {5042, DiagnosticCategory::Error, S("Option_project_cannot_be_mixed_with_source_files_on_a_command_line_5042"), S("Option 'project' cannot be mixed with source files on a command line.")};
        static DiagnosticMessageStore Option_isolatedModules_can_only_be_used_when_either_option_module_is_provided_or_option_target_is_ES2015_or_higher = {5047, DiagnosticCategory::Error, S("Option_isolatedModules_can_only_be_used_when_either_option_module_is_provided_or_option_target_is_ES_5047"), S("Option 'isolatedModules' can only be used when either option '--module' is provided or option 'target' is 'ES2015' or higher.")};
        static DiagnosticMessageStore Option_0_cannot_be_specified_when_option_target_is_ES3 = {5048, DiagnosticCategory::Error, S("Option_0_cannot_be_specified_when_option_target_is_ES3_5048"), S("Option '{0}' cannot be specified when option 'target' is 'ES3'.")};
        static DiagnosticMessageStore Option_0_can_only_be_used_when_either_option_inlineSourceMap_or_option_sourceMap_is_provided = {5051, DiagnosticCategory::Error, S("Option_0_can_only_be_used_when_either_option_inlineSourceMap_or_option_sourceMap_is_provided_5051"), S("Option '{0} can only be used when either option '--inlineSourceMap' or option '--sourceMap' is provided.")};
        static DiagnosticMessageStore Option_0_cannot_be_specified_without_specifying_option_1 = {5052, DiagnosticCategory::Error, S("Option_0_cannot_be_specified_without_specifying_option_1_5052"), S("Option '{0}' cannot be specified without specifying option '{1}'.")};
        static DiagnosticMessageStore Option_0_cannot_be_specified_with_option_1 = {5053, DiagnosticCategory::Error, S("Option_0_cannot_be_specified_with_option_1_5053"), S("Option '{0}' cannot be specified with option '{1}'.")};
        static DiagnosticMessageStore A_tsconfig_json_file_is_already_defined_at_Colon_0 = {5054, DiagnosticCategory::Error, S("A_tsconfig_json_file_is_already_defined_at_Colon_0_5054"), S("A 'tsconfig.json' file is already defined at: '{0}'.")};
        static DiagnosticMessageStore Cannot_write_file_0_because_it_would_overwrite_input_file = {5055, DiagnosticCategory::Error, S("Cannot_write_file_0_because_it_would_overwrite_input_file_5055"), S("Cannot write file '{0}' because it would overwrite input file.")};
        static DiagnosticMessageStore Cannot_write_file_0_because_it_would_be_overwritten_by_multiple_input_files = {5056, DiagnosticCategory::Error, S("Cannot_write_file_0_because_it_would_be_overwritten_by_multiple_input_files_5056"), S("Cannot write file '{0}' because it would be overwritten by multiple input files.")};
        static DiagnosticMessageStore Cannot_find_a_tsconfig_json_file_at_the_specified_directory_Colon_0 = {5057, DiagnosticCategory::Error, S("Cannot_find_a_tsconfig_json_file_at_the_specified_directory_Colon_0_5057"), S("Cannot find a tsconfig.json file at the specified directory: '{0}'.")};
        static DiagnosticMessageStore The_specified_path_does_not_exist_Colon_0 = {5058, DiagnosticCategory::Error, S("The_specified_path_does_not_exist_Colon_0_5058"), S("The specified path does not exist: '{0}'.")};
        static DiagnosticMessageStore Invalid_value_for_reactNamespace_0_is_not_a_valid_identifier = {5059, DiagnosticCategory::Error, S("Invalid_value_for_reactNamespace_0_is_not_a_valid_identifier_5059"), S("Invalid value for '--reactNamespace'. '{0}' is not a valid identifier.")};
        static DiagnosticMessageStore Pattern_0_can_have_at_most_one_Asterisk_character = {5061, DiagnosticCategory::Error, S("Pattern_0_can_have_at_most_one_Asterisk_character_5061"), S("Pattern '{0}' can have at most one '*' character.")};
        static DiagnosticMessageStore Substitution_0_in_pattern_1_can_have_at_most_one_Asterisk_character = {5062, DiagnosticCategory::Error, S("Substitution_0_in_pattern_1_can_have_at_most_one_Asterisk_character_5062"), S("Substitution '{0}' in pattern '{1}' can have at most one '*' character.")};
        static DiagnosticMessageStore Substitutions_for_pattern_0_should_be_an_array = {5063, DiagnosticCategory::Error, S("Substitutions_for_pattern_0_should_be_an_array_5063"), S("Substitutions for pattern '{0}' should be an array.")};
        static DiagnosticMessageStore Substitution_0_for_pattern_1_has_incorrect_type_expected_string_got_2 = {5064, DiagnosticCategory::Error, S("Substitution_0_for_pattern_1_has_incorrect_type_expected_string_got_2_5064"), S("Substitution '{0}' for pattern '{1}' has incorrect type, expected 'string', got '{2}'.")};
        static DiagnosticMessageStore File_specification_cannot_contain_a_parent_directory_that_appears_after_a_recursive_directory_wildcard_Asterisk_Asterisk_Colon_0 = {5065, DiagnosticCategory::Error, S("File_specification_cannot_contain_a_parent_directory_that_appears_after_a_recursive_directory_wildca_5065"), S("File specification cannot contain a parent directory ('..') that appears after a recursive directory wildcard ('**'): '{0}'.")};
        static DiagnosticMessageStore Substitutions_for_pattern_0_shouldn_t_be_an_empty_array = {5066, DiagnosticCategory::Error, S("Substitutions_for_pattern_0_shouldn_t_be_an_empty_array_5066"), S("Substitutions for pattern '{0}' shouldn't be an empty array.")};
        static DiagnosticMessageStore Invalid_value_for_jsxFactory_0_is_not_a_valid_identifier_or_qualified_name = {5067, DiagnosticCategory::Error, S("Invalid_value_for_jsxFactory_0_is_not_a_valid_identifier_or_qualified_name_5067"), S("Invalid value for 'jsxFactory'. '{0}' is not a valid identifier or qualified-name.")};
        static DiagnosticMessageStore Adding_a_tsconfig_json_file_will_help_organize_projects_that_contain_both_TypeScript_and_JavaScript_files_Learn_more_at_https_Colon_Slash_Slashaka_ms_Slashtsconfig = {5068, DiagnosticCategory::Error, S("Adding_a_tsconfig_json_file_will_help_organize_projects_that_contain_both_TypeScript_and_JavaScript__5068"), S("Adding a tsconfig.json file will help organize projects that contain both TypeScript and JavaScript files. Learn more at https://aka.ms/tsconfig.")};
        static DiagnosticMessageStore Option_0_cannot_be_specified_without_specifying_option_1_or_option_2 = {5069, DiagnosticCategory::Error, S("Option_0_cannot_be_specified_without_specifying_option_1_or_option_2_5069"), S("Option '{0}' cannot be specified without specifying option '{1}' or option '{2}'.")};
        static DiagnosticMessageStore Option_resolveJsonModule_cannot_be_specified_when_moduleResolution_is_set_to_classic = {5070, DiagnosticCategory::Error, S("Option_resolveJsonModule_cannot_be_specified_when_moduleResolution_is_set_to_classic_5070"), S("Option '--resolveJsonModule' cannot be specified when 'moduleResolution' is set to 'classic'.")};
        static DiagnosticMessageStore Option_resolveJsonModule_can_only_be_specified_when_module_code_generation_is_commonjs_amd_es2015_or_esNext = {5071, DiagnosticCategory::Error, S("Option_resolveJsonModule_can_only_be_specified_when_module_code_generation_is_commonjs_amd_es2015_or_5071"), S("Option '--resolveJsonModule' can only be specified when module code generation is 'commonjs', 'amd', 'es2015' or 'esNext'.")};
        static DiagnosticMessageStore Unknown_build_option_0 = {5072, DiagnosticCategory::Error, S("Unknown_build_option_0_5072"), S("Unknown build option '{0}'.")};
        static DiagnosticMessageStore Build_option_0_requires_a_value_of_type_1 = {5073, DiagnosticCategory::Error, S("Build_option_0_requires_a_value_of_type_1_5073"), S("Build option '{0}' requires a value of type {1}.")};
        static DiagnosticMessageStore Option_incremental_can_only_be_specified_using_tsconfig_emitting_to_single_file_or_when_option_tsBuildInfoFile_is_specified = {5074, DiagnosticCategory::Error, S("Option_incremental_can_only_be_specified_using_tsconfig_emitting_to_single_file_or_when_option_tsBui_5074"), S("Option '--incremental' can only be specified using tsconfig, emitting to single file or when option '--tsBuildInfoFile' is specified.")};
        static DiagnosticMessageStore _0_is_assignable_to_the_constraint_of_type_1_but_1_could_be_instantiated_with_a_different_subtype_of_constraint_2 = {5075, DiagnosticCategory::Error, S("_0_is_assignable_to_the_constraint_of_type_1_but_1_could_be_instantiated_with_a_different_subtype_of_5075"), S("'{0}' is assignable to the constraint of type '{1}', but '{1}' could be instantiated with a different subtype of constraint '{2}'.")};
        static DiagnosticMessageStore _0_and_1_operations_cannot_be_mixed_without_parentheses = {5076, DiagnosticCategory::Error, S("_0_and_1_operations_cannot_be_mixed_without_parentheses_5076"), S("'{0}' and '{1}' operations cannot be mixed without parentheses.")};
        static DiagnosticMessageStore Unknown_build_option_0_Did_you_mean_1 = {5077, DiagnosticCategory::Error, S("Unknown_build_option_0_Did_you_mean_1_5077"), S("Unknown build option '{0}'. Did you mean '{1}'?")};
        static DiagnosticMessageStore Unknown_watch_option_0 = {5078, DiagnosticCategory::Error, S("Unknown_watch_option_0_5078"), S("Unknown watch option '{0}'.")};
        static DiagnosticMessageStore Unknown_watch_option_0_Did_you_mean_1 = {5079, DiagnosticCategory::Error, S("Unknown_watch_option_0_Did_you_mean_1_5079"), S("Unknown watch option '{0}'. Did you mean '{1}'?")};
        static DiagnosticMessageStore Watch_option_0_requires_a_value_of_type_1 = {5080, DiagnosticCategory::Error, S("Watch_option_0_requires_a_value_of_type_1_5080"), S("Watch option '{0}' requires a value of type {1}.")};
        static DiagnosticMessageStore Cannot_find_a_tsconfig_json_file_at_the_current_directory_Colon_0 = {5081, DiagnosticCategory::Error, S("Cannot_find_a_tsconfig_json_file_at_the_current_directory_Colon_0_5081"), S("Cannot find a tsconfig.json file at the current directory: {0}.")};
        static DiagnosticMessageStore _0_could_be_instantiated_with_an_arbitrary_type_which_could_be_unrelated_to_1 = {5082, DiagnosticCategory::Error, S("_0_could_be_instantiated_with_an_arbitrary_type_which_could_be_unrelated_to_1_5082"), S("'{0}' could be instantiated with an arbitrary type which could be unrelated to '{1}'.")};
        static DiagnosticMessageStore Cannot_read_file_0 = {5083, DiagnosticCategory::Error, S("Cannot_read_file_0_5083"), S("Cannot read file '{0}'.")};
        static DiagnosticMessageStore A_tuple_member_cannot_be_both_optional_and_rest = {5085, DiagnosticCategory::Error, S("A_tuple_member_cannot_be_both_optional_and_rest_5085"), S("A tuple member cannot be both optional and rest.")};
        static DiagnosticMessageStore A_labeled_tuple_element_is_declared_as_optional_with_a_question_mark_after_the_name_and_before_the_colon_rather_than_after_the_type = {5086, DiagnosticCategory::Error, S("A_labeled_tuple_element_is_declared_as_optional_with_a_question_mark_after_the_name_and_before_the_c_5086"), S("A labeled tuple element is declared as optional with a question mark after the name and before the colon, rather than after the type.")};
        static DiagnosticMessageStore A_labeled_tuple_element_is_declared_as_rest_with_a_before_the_name_rather_than_before_the_type = {5087, DiagnosticCategory::Error, S("A_labeled_tuple_element_is_declared_as_rest_with_a_before_the_name_rather_than_before_the_type_5087"), S("A labeled tuple element is declared as rest with a '...' before the name, rather than before the type.")};
        static DiagnosticMessageStore The_inferred_type_of_0_references_a_type_with_a_cyclic_structure_which_cannot_be_trivially_serialized_A_type_annotation_is_necessary = {5088, DiagnosticCategory::Error, S("The_inferred_type_of_0_references_a_type_with_a_cyclic_structure_which_cannot_be_trivially_serialize_5088"), S("The inferred type of '{0}' references a type with a cyclic structure which cannot be trivially serialized. A type annotation is necessary.")};
        static DiagnosticMessageStore Option_0_cannot_be_specified_when_option_jsx_is_1 = {5089, DiagnosticCategory::Error, S("Option_0_cannot_be_specified_when_option_jsx_is_1_5089"), S("Option '{0}' cannot be specified when option 'jsx' is '{1}'.")};
        static DiagnosticMessageStore Non_relative_paths_are_not_allowed_when_baseUrl_is_not_set_Did_you_forget_a_leading_Slash = {5090, DiagnosticCategory::Error, S("Non_relative_paths_are_not_allowed_when_baseUrl_is_not_set_Did_you_forget_a_leading_Slash_5090"), S("Non-relative paths are not allowed when 'baseUrl' is not set. Did you forget a leading './'?")};
        static DiagnosticMessageStore Option_preserveConstEnums_cannot_be_disabled_when_0_is_enabled = {5091, DiagnosticCategory::Error, S("Option_preserveConstEnums_cannot_be_disabled_when_0_is_enabled_5091"), S("Option 'preserveConstEnums' cannot be disabled when '{0}' is enabled.")};
        static DiagnosticMessageStore The_root_value_of_a_0_file_must_be_an_object = {5092, DiagnosticCategory::Error, S("The_root_value_of_a_0_file_must_be_an_object_5092"), S("The root value of a '{0}' file must be an object.")};
        static DiagnosticMessageStore Compiler_option_0_may_only_be_used_with_build = {5093, DiagnosticCategory::Error, S("Compiler_option_0_may_only_be_used_with_build_5093"), S("Compiler option '--{0}' may only be used with '--build'.")};
        static DiagnosticMessageStore Compiler_option_0_may_not_be_used_with_build = {5094, DiagnosticCategory::Error, S("Compiler_option_0_may_not_be_used_with_build_5094"), S("Compiler option '--{0}' may not be used with '--build'.")};
        static DiagnosticMessageStore Option_0_can_only_be_used_when_module_is_set_to_es2015_or_later = {5095, DiagnosticCategory::Error, S("Option_0_can_only_be_used_when_module_is_set_to_es2015_or_later_5095"), S("Option '{0}' can only be used when 'module' is set to 'es2015' or later.")};
        static DiagnosticMessageStore Option_allowImportingTsExtensions_can_only_be_used_when_either_noEmit_or_emitDeclarationOnly_is_set = {5096, DiagnosticCategory::Error, S("Option_allowImportingTsExtensions_can_only_be_used_when_either_noEmit_or_emitDeclarationOnly_is_set_5096"), S("Option 'allowImportingTsExtensions' can only be used when either 'noEmit' or 'emitDeclarationOnly' is set.")};
        static DiagnosticMessageStore An_import_path_can_only_end_with_a_0_extension_when_allowImportingTsExtensions_is_enabled = {5097, DiagnosticCategory::Error, S("An_import_path_can_only_end_with_a_0_extension_when_allowImportingTsExtensions_is_enabled_5097"), S("An import path can only end with a '{0}' extension when 'allowImportingTsExtensions' is enabled.")};
        static DiagnosticMessageStore Option_0_can_only_be_used_when_moduleResolution_is_set_to_node16_nodenext_or_bundler = {5098, DiagnosticCategory::Error, S("Option_0_can_only_be_used_when_moduleResolution_is_set_to_node16_nodenext_or_bundler_5098"), S("Option '{0}' can only be used when 'moduleResolution' is set to 'node16', 'nodenext', or 'bundler'.")};
        static DiagnosticMessageStore Option_0_is_deprecated_and_will_stop_functioning_in_TypeScript_1_Specify_compilerOption_ignoreDeprecations_Colon_2_to_silence_this_error = {5101, DiagnosticCategory::Error, S("Option_0_is_deprecated_and_will_stop_functioning_in_TypeScript_1_Specify_compilerOption_ignoreDeprec_5101"), S("Option '{0}' is deprecated and will stop functioning in TypeScript {1}. Specify compilerOption '\"ignoreDeprecations\": \"{2}\"' to silence this error.")};
        static DiagnosticMessageStore Option_0_has_been_removed_Please_remove_it_from_your_configuration = {5102, DiagnosticCategory::Error, S("Option_0_has_been_removed_Please_remove_it_from_your_configuration_5102"), S("Option '{0}' has been removed. Please remove it from your configuration.")};
        static DiagnosticMessageStore Invalid_value_for_ignoreDeprecations = {5103, DiagnosticCategory::Error, S("Invalid_value_for_ignoreDeprecations_5103"), S("Invalid value for '--ignoreDeprecations'.")};
        static DiagnosticMessageStore Option_0_is_redundant_and_cannot_be_specified_with_option_1 = {5104, DiagnosticCategory::Error, S("Option_0_is_redundant_and_cannot_be_specified_with_option_1_5104"), S("Option '{0}' is redundant and cannot be specified with option '{1}'.")};
        static DiagnosticMessageStore Option_verbatimModuleSyntax_cannot_be_used_when_module_is_set_to_UMD_AMD_or_System = {5105, DiagnosticCategory::Error, S("Option_verbatimModuleSyntax_cannot_be_used_when_module_is_set_to_UMD_AMD_or_System_5105"), S("Option 'verbatimModuleSyntax' cannot be used when 'module' is set to 'UMD', 'AMD', or 'System'.")};
        static DiagnosticMessageStore Use_0_instead = {5106, DiagnosticCategory::Message, S("Use_0_instead_5106"), S("Use '{0}' instead.")};
        static DiagnosticMessageStore Option_0_1_is_deprecated_and_will_stop_functioning_in_TypeScript_2_Specify_compilerOption_ignoreDeprecations_Colon_3_to_silence_this_error = {5107, DiagnosticCategory::Error, S("Option_0_1_is_deprecated_and_will_stop_functioning_in_TypeScript_2_Specify_compilerOption_ignoreDepr_5107"), S("Option '{0}={1}' is deprecated and will stop functioning in TypeScript {2}. Specify compilerOption '\"ignoreDeprecations\": \"{3}\"' to silence this error.")};
        static DiagnosticMessageStore Option_0_1_has_been_removed_Please_remove_it_from_your_configuration = {5108, DiagnosticCategory::Error, S("Option_0_1_has_been_removed_Please_remove_it_from_your_configuration_5108"), S("Option '{0}={1}' has been removed. Please remove it from your configuration.")};
        static DiagnosticMessageStore Option_moduleResolution_must_be_set_to_0_or_left_unspecified_when_option_module_is_set_to_1 = {5109, DiagnosticCategory::Error, S("Option_moduleResolution_must_be_set_to_0_or_left_unspecified_when_option_module_is_set_to_1_5109"), S("Option 'moduleResolution' must be set to '{0}' (or left unspecified) when option 'module' is set to '{1}'.")};
        static DiagnosticMessageStore Option_module_must_be_set_to_0_when_option_moduleResolution_is_set_to_1 = {5110, DiagnosticCategory::Error, S("Option_module_must_be_set_to_0_when_option_moduleResolution_is_set_to_1_5110"), S("Option 'module' must be set to '{0}' when option 'moduleResolution' is set to '{1}'.")};
        static DiagnosticMessageStore Generates_a_sourcemap_for_each_corresponding_d_ts_file = {6000, DiagnosticCategory::Message, S("Generates_a_sourcemap_for_each_corresponding_d_ts_file_6000"), S("Generates a sourcemap for each corresponding '.d.ts' file.")};
        static DiagnosticMessageStore Concatenate_and_emit_output_to_single_file = {6001, DiagnosticCategory::Message, S("Concatenate_and_emit_output_to_single_file_6001"), S("Concatenate and emit output to single file.")};
        static DiagnosticMessageStore Generates_corresponding_d_ts_file = {6002, DiagnosticCategory::Message, S("Generates_corresponding_d_ts_file_6002"), S("Generates corresponding '.d.ts' file.")};
        static DiagnosticMessageStore Specify_the_location_where_debugger_should_locate_TypeScript_files_instead_of_source_locations = {6004, DiagnosticCategory::Message, S("Specify_the_location_where_debugger_should_locate_TypeScript_files_instead_of_source_locations_6004"), S("Specify the location where debugger should locate TypeScript files instead of source locations.")};
        static DiagnosticMessageStore Watch_input_files = {6005, DiagnosticCategory::Message, S("Watch_input_files_6005"), S("Watch input files.")};
        static DiagnosticMessageStore Redirect_output_structure_to_the_directory = {6006, DiagnosticCategory::Message, S("Redirect_output_structure_to_the_directory_6006"), S("Redirect output structure to the directory.")};
        static DiagnosticMessageStore Do_not_erase_const_enum_declarations_in_generated_code = {6007, DiagnosticCategory::Message, S("Do_not_erase_const_enum_declarations_in_generated_code_6007"), S("Do not erase const enum declarations in generated code.")};
        static DiagnosticMessageStore Do_not_emit_outputs_if_any_errors_were_reported = {6008, DiagnosticCategory::Message, S("Do_not_emit_outputs_if_any_errors_were_reported_6008"), S("Do not emit outputs if any errors were reported.")};
        static DiagnosticMessageStore Do_not_emit_comments_to_output = {6009, DiagnosticCategory::Message, S("Do_not_emit_comments_to_output_6009"), S("Do not emit comments to output.")};
        static DiagnosticMessageStore Do_not_emit_outputs = {6010, DiagnosticCategory::Message, S("Do_not_emit_outputs_6010"), S("Do not emit outputs.")};
        static DiagnosticMessageStore Allow_default_imports_from_modules_with_no_default_export_This_does_not_affect_code_emit_just_typechecking = {6011, DiagnosticCategory::Message, S("Allow_default_imports_from_modules_with_no_default_export_This_does_not_affect_code_emit_just_typech_6011"), S("Allow default imports from modules with no default export. This does not affect code emit, just typechecking.")};
        static DiagnosticMessageStore Skip_type_checking_of_declaration_files = {6012, DiagnosticCategory::Message, S("Skip_type_checking_of_declaration_files_6012"), S("Skip type checking of declaration files.")};
        static DiagnosticMessageStore Do_not_resolve_the_real_path_of_symlinks = {6013, DiagnosticCategory::Message, S("Do_not_resolve_the_real_path_of_symlinks_6013"), S("Do not resolve the real path of symlinks.")};
        static DiagnosticMessageStore Only_emit_d_ts_declaration_files = {6014, DiagnosticCategory::Message, S("Only_emit_d_ts_declaration_files_6014"), S("Only emit '.d.ts' declaration files.")};
        static DiagnosticMessageStore Specify_ECMAScript_target_version = {6015, DiagnosticCategory::Message, S("Specify_ECMAScript_target_version_6015"), S("Specify ECMAScript target version.")};
        static DiagnosticMessageStore Specify_module_code_generation = {6016, DiagnosticCategory::Message, S("Specify_module_code_generation_6016"), S("Specify module code generation.")};
        static DiagnosticMessageStore Print_this_message = {6017, DiagnosticCategory::Message, S("Print_this_message_6017"), S("Print this message.")};
        static DiagnosticMessageStore Print_the_compiler_s_version = {6019, DiagnosticCategory::Message, S("Print_the_compiler_s_version_6019"), S("Print the compiler's version.")};
        static DiagnosticMessageStore Compile_the_project_given_the_path_to_its_configuration_file_or_to_a_folder_with_a_tsconfig_json = {6020, DiagnosticCategory::Message, S("Compile_the_project_given_the_path_to_its_configuration_file_or_to_a_folder_with_a_tsconfig_json_6020"), S("Compile the project given the path to its configuration file, or to a folder with a 'tsconfig.json'.")};
        static DiagnosticMessageStore Syntax_Colon_0 = {6023, DiagnosticCategory::Message, S("Syntax_Colon_0_6023"), S("Syntax: {0}")};
        static DiagnosticMessageStore options = {6024, DiagnosticCategory::Message, S("options_6024"), S("options")};
        static DiagnosticMessageStore file = {6025, DiagnosticCategory::Message, S("file_6025"), S("file")};
        static DiagnosticMessageStore Examples_Colon_0 = {6026, DiagnosticCategory::Message, S("Examples_Colon_0_6026"), S("Examples: {0}")};
        static DiagnosticMessageStore Options_Colon = {6027, DiagnosticCategory::Message, S("Options_Colon_6027"), S("Options:")};
        static DiagnosticMessageStore Version_0 = {6029, DiagnosticCategory::Message, S("Version_0_6029"), S("Version {0}")};
        static DiagnosticMessageStore Insert_command_line_options_and_files_from_a_file = {6030, DiagnosticCategory::Message, S("Insert_command_line_options_and_files_from_a_file_6030"), S("Insert command line options and files from a file.")};
        static DiagnosticMessageStore Starting_compilation_in_watch_mode = {6031, DiagnosticCategory::Message, S("Starting_compilation_in_watch_mode_6031"), S("Starting compilation in watch mode...")};
        static DiagnosticMessageStore File_change_detected_Starting_incremental_compilation = {6032, DiagnosticCategory::Message, S("File_change_detected_Starting_incremental_compilation_6032"), S("File change detected. Starting incremental compilation...")};
        static DiagnosticMessageStore KIND = {6034, DiagnosticCategory::Message, S("KIND_6034"), S("KIND")};
        static DiagnosticMessageStore FILE = {6035, DiagnosticCategory::Message, S("FILE_6035"), S("FILE")};
        static DiagnosticMessageStore VERSION = {6036, DiagnosticCategory::Message, S("VERSION_6036"), S("VERSION")};
        static DiagnosticMessageStore LOCATION = {6037, DiagnosticCategory::Message, S("LOCATION_6037"), S("LOCATION")};
        static DiagnosticMessageStore DIRECTORY = {6038, DiagnosticCategory::Message, S("DIRECTORY_6038"), S("DIRECTORY")};
        static DiagnosticMessageStore STRATEGY = {6039, DiagnosticCategory::Message, S("STRATEGY_6039"), S("STRATEGY")};
        static DiagnosticMessageStore FILE_OR_DIRECTORY = {6040, DiagnosticCategory::Message, S("FILE_OR_DIRECTORY_6040"), S("FILE OR DIRECTORY")};
        static DiagnosticMessageStore Errors_Files = {6041, DiagnosticCategory::Message, S("Errors_Files_6041"), S("Errors  Files")};
        static DiagnosticMessageStore Generates_corresponding_map_file = {6043, DiagnosticCategory::Message, S("Generates_corresponding_map_file_6043"), S("Generates corresponding '.map' file.")};
        static DiagnosticMessageStore Compiler_option_0_expects_an_argument = {6044, DiagnosticCategory::Error, S("Compiler_option_0_expects_an_argument_6044"), S("Compiler option '{0}' expects an argument.")};
        static DiagnosticMessageStore Unterminated_quoted_string_in_response_file_0 = {6045, DiagnosticCategory::Error, S("Unterminated_quoted_string_in_response_file_0_6045"), S("Unterminated quoted string in response file '{0}'.")};
        static DiagnosticMessageStore Argument_for_0_option_must_be_Colon_1 = {6046, DiagnosticCategory::Error, S("Argument_for_0_option_must_be_Colon_1_6046"), S("Argument for '{0}' option must be: {1}.")};
        static DiagnosticMessageStore Locale_must_be_of_the_form_language_or_language_territory_For_example_0_or_1 = {6048, DiagnosticCategory::Error, S("Locale_must_be_of_the_form_language_or_language_territory_For_example_0_or_1_6048"), S("Locale must be of the form <language> or <language>-<territory>. For example '{0}' or '{1}'.")};
        static DiagnosticMessageStore Unable_to_open_file_0 = {6050, DiagnosticCategory::Error, S("Unable_to_open_file_0_6050"), S("Unable to open file '{0}'.")};
        static DiagnosticMessageStore Corrupted_locale_file_0 = {6051, DiagnosticCategory::Error, S("Corrupted_locale_file_0_6051"), S("Corrupted locale file {0}.")};
        static DiagnosticMessageStore Raise_error_on_expressions_and_declarations_with_an_implied_any_type = {6052, DiagnosticCategory::Message, S("Raise_error_on_expressions_and_declarations_with_an_implied_any_type_6052"), S("Raise error on expressions and declarations with an implied 'any' type.")};
        static DiagnosticMessageStore File_0_not_found = {6053, DiagnosticCategory::Error, S("File_0_not_found_6053"), S("File '{0}' not found.")};
        static DiagnosticMessageStore File_0_has_an_unsupported_extension_The_only_supported_extensions_are_1 = {6054, DiagnosticCategory::Error, S("File_0_has_an_unsupported_extension_The_only_supported_extensions_are_1_6054"), S("File '{0}' has an unsupported extension. The only supported extensions are {1}.")};
        static DiagnosticMessageStore Suppress_noImplicitAny_errors_for_indexing_objects_lacking_index_signatures = {6055, DiagnosticCategory::Message, S("Suppress_noImplicitAny_errors_for_indexing_objects_lacking_index_signatures_6055"), S("Suppress noImplicitAny errors for indexing objects lacking index signatures.")};
        static DiagnosticMessageStore Do_not_emit_declarations_for_code_that_has_an_internal_annotation = {6056, DiagnosticCategory::Message, S("Do_not_emit_declarations_for_code_that_has_an_internal_annotation_6056"), S("Do not emit declarations for code that has an '@internal' annotation.")};
        static DiagnosticMessageStore Specify_the_root_directory_of_input_files_Use_to_control_the_output_directory_structure_with_outDir = {6058, DiagnosticCategory::Message, S("Specify_the_root_directory_of_input_files_Use_to_control_the_output_directory_structure_with_outDir_6058"), S("Specify the root directory of input files. Use to control the output directory structure with --outDir.")};
        static DiagnosticMessageStore File_0_is_not_under_rootDir_1_rootDir_is_expected_to_contain_all_source_files = {6059, DiagnosticCategory::Error, S("File_0_is_not_under_rootDir_1_rootDir_is_expected_to_contain_all_source_files_6059"), S("File '{0}' is not under 'rootDir' '{1}'. 'rootDir' is expected to contain all source files.")};
        static DiagnosticMessageStore Specify_the_end_of_line_sequence_to_be_used_when_emitting_files_Colon_CRLF_dos_or_LF_unix = {6060, DiagnosticCategory::Message, S("Specify_the_end_of_line_sequence_to_be_used_when_emitting_files_Colon_CRLF_dos_or_LF_unix_6060"), S("Specify the end of line sequence to be used when emitting files: 'CRLF' (dos) or 'LF' (unix).")};
        static DiagnosticMessageStore NEWLINE = {6061, DiagnosticCategory::Message, S("NEWLINE_6061"), S("NEWLINE")};
        static DiagnosticMessageStore Option_0_can_only_be_specified_in_tsconfig_json_file_or_set_to_null_on_command_line = {6064, DiagnosticCategory::Error, S("Option_0_can_only_be_specified_in_tsconfig_json_file_or_set_to_null_on_command_line_6064"), S("Option '{0}' can only be specified in 'tsconfig.json' file or set to 'null' on command line.")};
        static DiagnosticMessageStore Enables_experimental_support_for_ES7_decorators = {6065, DiagnosticCategory::Message, S("Enables_experimental_support_for_ES7_decorators_6065"), S("Enables experimental support for ES7 decorators.")};
        static DiagnosticMessageStore Enables_experimental_support_for_emitting_type_metadata_for_decorators = {6066, DiagnosticCategory::Message, S("Enables_experimental_support_for_emitting_type_metadata_for_decorators_6066"), S("Enables experimental support for emitting type metadata for decorators.")};
        static DiagnosticMessageStore Initializes_a_TypeScript_project_and_creates_a_tsconfig_json_file = {6070, DiagnosticCategory::Message, S("Initializes_a_TypeScript_project_and_creates_a_tsconfig_json_file_6070"), S("Initializes a TypeScript project and creates a tsconfig.json file.")};
        static DiagnosticMessageStore Successfully_created_a_tsconfig_json_file = {6071, DiagnosticCategory::Message, S("Successfully_created_a_tsconfig_json_file_6071"), S("Successfully created a tsconfig.json file.")};
        static DiagnosticMessageStore Suppress_excess_property_checks_for_object_literals = {6072, DiagnosticCategory::Message, S("Suppress_excess_property_checks_for_object_literals_6072"), S("Suppress excess property checks for object literals.")};
        static DiagnosticMessageStore Stylize_errors_and_messages_using_color_and_context_experimental = {6073, DiagnosticCategory::Message, S("Stylize_errors_and_messages_using_color_and_context_experimental_6073"), S("Stylize errors and messages using color and context (experimental).")};
        static DiagnosticMessageStore Do_not_report_errors_on_unused_labels = {6074, DiagnosticCategory::Message, S("Do_not_report_errors_on_unused_labels_6074"), S("Do not report errors on unused labels.")};
        static DiagnosticMessageStore Report_error_when_not_all_code_paths_in_function_return_a_value = {6075, DiagnosticCategory::Message, S("Report_error_when_not_all_code_paths_in_function_return_a_value_6075"), S("Report error when not all code paths in function return a value.")};
        static DiagnosticMessageStore Report_errors_for_fallthrough_cases_in_switch_statement = {6076, DiagnosticCategory::Message, S("Report_errors_for_fallthrough_cases_in_switch_statement_6076"), S("Report errors for fallthrough cases in switch statement.")};
        static DiagnosticMessageStore Do_not_report_errors_on_unreachable_code = {6077, DiagnosticCategory::Message, S("Do_not_report_errors_on_unreachable_code_6077"), S("Do not report errors on unreachable code.")};
        static DiagnosticMessageStore Disallow_inconsistently_cased_references_to_the_same_file = {6078, DiagnosticCategory::Message, S("Disallow_inconsistently_cased_references_to_the_same_file_6078"), S("Disallow inconsistently-cased references to the same file.")};
        static DiagnosticMessageStore Specify_library_files_to_be_included_in_the_compilation = {6079, DiagnosticCategory::Message, S("Specify_library_files_to_be_included_in_the_compilation_6079"), S("Specify library files to be included in the compilation.")};
        static DiagnosticMessageStore Specify_JSX_code_generation = {6080, DiagnosticCategory::Message, S("Specify_JSX_code_generation_6080"), S("Specify JSX code generation.")};
        static DiagnosticMessageStore File_0_has_an_unsupported_extension_so_skipping_it = {6081, DiagnosticCategory::Message, S("File_0_has_an_unsupported_extension_so_skipping_it_6081"), S("File '{0}' has an unsupported extension, so skipping it.")};
        static DiagnosticMessageStore Only_amd_and_system_modules_are_supported_alongside_0 = {6082, DiagnosticCategory::Error, S("Only_amd_and_system_modules_are_supported_alongside_0_6082"), S("Only 'amd' and 'system' modules are supported alongside --{0}.")};
        static DiagnosticMessageStore Base_directory_to_resolve_non_absolute_module_names = {6083, DiagnosticCategory::Message, S("Base_directory_to_resolve_non_absolute_module_names_6083"), S("Base directory to resolve non-absolute module names.")};
        static DiagnosticMessageStore Deprecated_Use_jsxFactory_instead_Specify_the_object_invoked_for_createElement_when_targeting_react_JSX_emit = {6084, DiagnosticCategory::Message, S("Deprecated_Use_jsxFactory_instead_Specify_the_object_invoked_for_createElement_when_targeting_react__6084"), S("[Deprecated] Use '--jsxFactory' instead. Specify the object invoked for createElement when targeting 'react' JSX emit")};
        static DiagnosticMessageStore Enable_tracing_of_the_name_resolution_process = {6085, DiagnosticCategory::Message, S("Enable_tracing_of_the_name_resolution_process_6085"), S("Enable tracing of the name resolution process.")};
        static DiagnosticMessageStore Resolving_module_0_from_1 = {6086, DiagnosticCategory::Message, S("Resolving_module_0_from_1_6086"), S("======== Resolving module '{0}' from '{1}'. ========")};
        static DiagnosticMessageStore Explicitly_specified_module_resolution_kind_Colon_0 = {6087, DiagnosticCategory::Message, S("Explicitly_specified_module_resolution_kind_Colon_0_6087"), S("Explicitly specified module resolution kind: '{0}'.")};
        static DiagnosticMessageStore Module_resolution_kind_is_not_specified_using_0 = {6088, DiagnosticCategory::Message, S("Module_resolution_kind_is_not_specified_using_0_6088"), S("Module resolution kind is not specified, using '{0}'.")};
        static DiagnosticMessageStore Module_name_0_was_successfully_resolved_to_1 = {6089, DiagnosticCategory::Message, S("Module_name_0_was_successfully_resolved_to_1_6089"), S("======== Module name '{0}' was successfully resolved to '{1}'. ========")};
        static DiagnosticMessageStore Module_name_0_was_not_resolved = {6090, DiagnosticCategory::Message, S("Module_name_0_was_not_resolved_6090"), S("======== Module name '{0}' was not resolved. ========")};
        static DiagnosticMessageStore paths_option_is_specified_looking_for_a_pattern_to_match_module_name_0 = {6091, DiagnosticCategory::Message, S("paths_option_is_specified_looking_for_a_pattern_to_match_module_name_0_6091"), S("'paths' option is specified, looking for a pattern to match module name '{0}'.")};
        static DiagnosticMessageStore Module_name_0_matched_pattern_1 = {6092, DiagnosticCategory::Message, S("Module_name_0_matched_pattern_1_6092"), S("Module name '{0}', matched pattern '{1}'.")};
        static DiagnosticMessageStore Trying_substitution_0_candidate_module_location_Colon_1 = {6093, DiagnosticCategory::Message, S("Trying_substitution_0_candidate_module_location_Colon_1_6093"), S("Trying substitution '{0}', candidate module location: '{1}'.")};
        static DiagnosticMessageStore Resolving_module_name_0_relative_to_base_url_1_2 = {6094, DiagnosticCategory::Message, S("Resolving_module_name_0_relative_to_base_url_1_2_6094"), S("Resolving module name '{0}' relative to base url '{1}' - '{2}'.")};
        static DiagnosticMessageStore Loading_module_as_file_Slash_folder_candidate_module_location_0_target_file_types_Colon_1 = {6095, DiagnosticCategory::Message, S("Loading_module_as_file_Slash_folder_candidate_module_location_0_target_file_types_Colon_1_6095"), S("Loading module as file / folder, candidate module location '{0}', target file types: {1}.")};
        static DiagnosticMessageStore File_0_does_not_exist = {6096, DiagnosticCategory::Message, S("File_0_does_not_exist_6096"), S("File '{0}' does not exist.")};
        static DiagnosticMessageStore File_0_exists_use_it_as_a_name_resolution_result = {6097, DiagnosticCategory::Message, S("File_0_exists_use_it_as_a_name_resolution_result_6097"), S("File '{0}' exists - use it as a name resolution result.")};
        static DiagnosticMessageStore Loading_module_0_from_node_modules_folder_target_file_types_Colon_1 = {6098, DiagnosticCategory::Message, S("Loading_module_0_from_node_modules_folder_target_file_types_Colon_1_6098"), S("Loading module '{0}' from 'node_modules' folder, target file types: {1}.")};
        static DiagnosticMessageStore Found_package_json_at_0 = {6099, DiagnosticCategory::Message, S("Found_package_json_at_0_6099"), S("Found 'package.json' at '{0}'.")};
        static DiagnosticMessageStore package_json_does_not_have_a_0_field = {6100, DiagnosticCategory::Message, S("package_json_does_not_have_a_0_field_6100"), S("'package.json' does not have a '{0}' field.")};
        static DiagnosticMessageStore package_json_has_0_field_1_that_references_2 = {6101, DiagnosticCategory::Message, S("package_json_has_0_field_1_that_references_2_6101"), S("'package.json' has '{0}' field '{1}' that references '{2}'.")};
        static DiagnosticMessageStore Allow_javascript_files_to_be_compiled = {6102, DiagnosticCategory::Message, S("Allow_javascript_files_to_be_compiled_6102"), S("Allow javascript files to be compiled.")};
        static DiagnosticMessageStore Checking_if_0_is_the_longest_matching_prefix_for_1_2 = {6104, DiagnosticCategory::Message, S("Checking_if_0_is_the_longest_matching_prefix_for_1_2_6104"), S("Checking if '{0}' is the longest matching prefix for '{1}' - '{2}'.")};
        static DiagnosticMessageStore Expected_type_of_0_field_in_package_json_to_be_1_got_2 = {6105, DiagnosticCategory::Message, S("Expected_type_of_0_field_in_package_json_to_be_1_got_2_6105"), S("Expected type of '{0}' field in 'package.json' to be '{1}', got '{2}'.")};
        static DiagnosticMessageStore baseUrl_option_is_set_to_0_using_this_value_to_resolve_non_relative_module_name_1 = {6106, DiagnosticCategory::Message, S("baseUrl_option_is_set_to_0_using_this_value_to_resolve_non_relative_module_name_1_6106"), S("'baseUrl' option is set to '{0}', using this value to resolve non-relative module name '{1}'.")};
        static DiagnosticMessageStore rootDirs_option_is_set_using_it_to_resolve_relative_module_name_0 = {6107, DiagnosticCategory::Message, S("rootDirs_option_is_set_using_it_to_resolve_relative_module_name_0_6107"), S("'rootDirs' option is set, using it to resolve relative module name '{0}'.")};
        static DiagnosticMessageStore Longest_matching_prefix_for_0_is_1 = {6108, DiagnosticCategory::Message, S("Longest_matching_prefix_for_0_is_1_6108"), S("Longest matching prefix for '{0}' is '{1}'.")};
        static DiagnosticMessageStore Loading_0_from_the_root_dir_1_candidate_location_2 = {6109, DiagnosticCategory::Message, S("Loading_0_from_the_root_dir_1_candidate_location_2_6109"), S("Loading '{0}' from the root dir '{1}', candidate location '{2}'.")};
        static DiagnosticMessageStore Trying_other_entries_in_rootDirs = {6110, DiagnosticCategory::Message, S("Trying_other_entries_in_rootDirs_6110"), S("Trying other entries in 'rootDirs'.")};
        static DiagnosticMessageStore Module_resolution_using_rootDirs_has_failed = {6111, DiagnosticCategory::Message, S("Module_resolution_using_rootDirs_has_failed_6111"), S("Module resolution using 'rootDirs' has failed.")};
        static DiagnosticMessageStore Do_not_emit_use_strict_directives_in_module_output = {6112, DiagnosticCategory::Message, S("Do_not_emit_use_strict_directives_in_module_output_6112"), S("Do not emit 'use strict' directives in module output.")};
        static DiagnosticMessageStore Enable_strict_null_checks = {6113, DiagnosticCategory::Message, S("Enable_strict_null_checks_6113"), S("Enable strict null checks.")};
        static DiagnosticMessageStore Unknown_option_excludes_Did_you_mean_exclude = {6114, DiagnosticCategory::Error, S("Unknown_option_excludes_Did_you_mean_exclude_6114"), S("Unknown option 'excludes'. Did you mean 'exclude'?")};
        static DiagnosticMessageStore Raise_error_on_this_expressions_with_an_implied_any_type = {6115, DiagnosticCategory::Message, S("Raise_error_on_this_expressions_with_an_implied_any_type_6115"), S("Raise error on 'this' expressions with an implied 'any' type.")};
        static DiagnosticMessageStore Resolving_type_reference_directive_0_containing_file_1_root_directory_2 = {6116, DiagnosticCategory::Message, S("Resolving_type_reference_directive_0_containing_file_1_root_directory_2_6116"), S("======== Resolving type reference directive '{0}', containing file '{1}', root directory '{2}'. ========")};
        static DiagnosticMessageStore Type_reference_directive_0_was_successfully_resolved_to_1_primary_Colon_2 = {6119, DiagnosticCategory::Message, S("Type_reference_directive_0_was_successfully_resolved_to_1_primary_Colon_2_6119"), S("======== Type reference directive '{0}' was successfully resolved to '{1}', primary: {2}. ========")};
        static DiagnosticMessageStore Type_reference_directive_0_was_not_resolved = {6120, DiagnosticCategory::Message, S("Type_reference_directive_0_was_not_resolved_6120"), S("======== Type reference directive '{0}' was not resolved. ========")};
        static DiagnosticMessageStore Resolving_with_primary_search_path_0 = {6121, DiagnosticCategory::Message, S("Resolving_with_primary_search_path_0_6121"), S("Resolving with primary search path '{0}'.")};
        static DiagnosticMessageStore Root_directory_cannot_be_determined_skipping_primary_search_paths = {6122, DiagnosticCategory::Message, S("Root_directory_cannot_be_determined_skipping_primary_search_paths_6122"), S("Root directory cannot be determined, skipping primary search paths.")};
        static DiagnosticMessageStore Resolving_type_reference_directive_0_containing_file_1_root_directory_not_set = {6123, DiagnosticCategory::Message, S("Resolving_type_reference_directive_0_containing_file_1_root_directory_not_set_6123"), S("======== Resolving type reference directive '{0}', containing file '{1}', root directory not set. ========")};
        static DiagnosticMessageStore Type_declaration_files_to_be_included_in_compilation = {6124, DiagnosticCategory::Message, S("Type_declaration_files_to_be_included_in_compilation_6124"), S("Type declaration files to be included in compilation.")};
        static DiagnosticMessageStore Looking_up_in_node_modules_folder_initial_location_0 = {6125, DiagnosticCategory::Message, S("Looking_up_in_node_modules_folder_initial_location_0_6125"), S("Looking up in 'node_modules' folder, initial location '{0}'.")};
        static DiagnosticMessageStore Containing_file_is_not_specified_and_root_directory_cannot_be_determined_skipping_lookup_in_node_modules_folder = {6126, DiagnosticCategory::Message, S("Containing_file_is_not_specified_and_root_directory_cannot_be_determined_skipping_lookup_in_node_mod_6126"), S("Containing file is not specified and root directory cannot be determined, skipping lookup in 'node_modules' folder.")};
        static DiagnosticMessageStore Resolving_type_reference_directive_0_containing_file_not_set_root_directory_1 = {6127, DiagnosticCategory::Message, S("Resolving_type_reference_directive_0_containing_file_not_set_root_directory_1_6127"), S("======== Resolving type reference directive '{0}', containing file not set, root directory '{1}'. ========")};
        static DiagnosticMessageStore Resolving_type_reference_directive_0_containing_file_not_set_root_directory_not_set = {6128, DiagnosticCategory::Message, S("Resolving_type_reference_directive_0_containing_file_not_set_root_directory_not_set_6128"), S("======== Resolving type reference directive '{0}', containing file not set, root directory not set. ========")};
        static DiagnosticMessageStore Resolving_real_path_for_0_result_1 = {6130, DiagnosticCategory::Message, S("Resolving_real_path_for_0_result_1_6130"), S("Resolving real path for '{0}', result '{1}'.")};
        static DiagnosticMessageStore Cannot_compile_modules_using_option_0_unless_the_module_flag_is_amd_or_system = {6131, DiagnosticCategory::Error, S("Cannot_compile_modules_using_option_0_unless_the_module_flag_is_amd_or_system_6131"), S("Cannot compile modules using option '{0}' unless the '--module' flag is 'amd' or 'system'.")};
        static DiagnosticMessageStore File_name_0_has_a_1_extension_stripping_it = {6132, DiagnosticCategory::Message, S("File_name_0_has_a_1_extension_stripping_it_6132"), S("File name '{0}' has a '{1}' extension - stripping it.")};
        static DiagnosticMessageStore _0_is_declared_but_its_value_is_never_read = {6133, DiagnosticCategory::Error, S("_0_is_declared_but_its_value_is_never_read_6133"), S("'{0}' is declared but its value is never read.")};
        static DiagnosticMessageStore Report_errors_on_unused_locals = {6134, DiagnosticCategory::Message, S("Report_errors_on_unused_locals_6134"), S("Report errors on unused locals.")};
        static DiagnosticMessageStore Report_errors_on_unused_parameters = {6135, DiagnosticCategory::Message, S("Report_errors_on_unused_parameters_6135"), S("Report errors on unused parameters.")};
        static DiagnosticMessageStore The_maximum_dependency_depth_to_search_under_node_modules_and_load_JavaScript_files = {6136, DiagnosticCategory::Message, S("The_maximum_dependency_depth_to_search_under_node_modules_and_load_JavaScript_files_6136"), S("The maximum dependency depth to search under node_modules and load JavaScript files.")};
        static DiagnosticMessageStore Cannot_import_type_declaration_files_Consider_importing_0_instead_of_1 = {6137, DiagnosticCategory::Error, S("Cannot_import_type_declaration_files_Consider_importing_0_instead_of_1_6137"), S("Cannot import type declaration files. Consider importing '{0}' instead of '{1}'.")};
        static DiagnosticMessageStore Property_0_is_declared_but_its_value_is_never_read = {6138, DiagnosticCategory::Error, S("Property_0_is_declared_but_its_value_is_never_read_6138"), S("Property '{0}' is declared but its value is never read.")};
        static DiagnosticMessageStore Import_emit_helpers_from_tslib = {6139, DiagnosticCategory::Message, S("Import_emit_helpers_from_tslib_6139"), S("Import emit helpers from 'tslib'.")};
        static DiagnosticMessageStore Auto_discovery_for_typings_is_enabled_in_project_0_Running_extra_resolution_pass_for_module_1_using_cache_location_2 = {6140, DiagnosticCategory::Error, S("Auto_discovery_for_typings_is_enabled_in_project_0_Running_extra_resolution_pass_for_module_1_using__6140"), S("Auto discovery for typings is enabled in project '{0}'. Running extra resolution pass for module '{1}' using cache location '{2}'.")};
        static DiagnosticMessageStore Parse_in_strict_mode_and_emit_use_strict_for_each_source_file = {6141, DiagnosticCategory::Message, S("Parse_in_strict_mode_and_emit_use_strict_for_each_source_file_6141"), S("Parse in strict mode and emit \"use strict\" for each source file.")};
        static DiagnosticMessageStore Module_0_was_resolved_to_1_but_jsx_is_not_set = {6142, DiagnosticCategory::Error, S("Module_0_was_resolved_to_1_but_jsx_is_not_set_6142"), S("Module '{0}' was resolved to '{1}', but '--jsx' is not set.")};
        static DiagnosticMessageStore Module_0_was_resolved_as_locally_declared_ambient_module_in_file_1 = {6144, DiagnosticCategory::Message, S("Module_0_was_resolved_as_locally_declared_ambient_module_in_file_1_6144"), S("Module '{0}' was resolved as locally declared ambient module in file '{1}'.")};
        static DiagnosticMessageStore Module_0_was_resolved_as_ambient_module_declared_in_1_since_this_file_was_not_modified = {6145, DiagnosticCategory::Message, S("Module_0_was_resolved_as_ambient_module_declared_in_1_since_this_file_was_not_modified_6145"), S("Module '{0}' was resolved as ambient module declared in '{1}' since this file was not modified.")};
        static DiagnosticMessageStore Specify_the_JSX_factory_function_to_use_when_targeting_react_JSX_emit_e_g_React_createElement_or_h = {6146, DiagnosticCategory::Message, S("Specify_the_JSX_factory_function_to_use_when_targeting_react_JSX_emit_e_g_React_createElement_or_h_6146"), S("Specify the JSX factory function to use when targeting 'react' JSX emit, e.g. 'React.createElement' or 'h'.")};
        static DiagnosticMessageStore Resolution_for_module_0_was_found_in_cache_from_location_1 = {6147, DiagnosticCategory::Message, S("Resolution_for_module_0_was_found_in_cache_from_location_1_6147"), S("Resolution for module '{0}' was found in cache from location '{1}'.")};
        static DiagnosticMessageStore Directory_0_does_not_exist_skipping_all_lookups_in_it = {6148, DiagnosticCategory::Message, S("Directory_0_does_not_exist_skipping_all_lookups_in_it_6148"), S("Directory '{0}' does not exist, skipping all lookups in it.")};
        static DiagnosticMessageStore Show_diagnostic_information = {6149, DiagnosticCategory::Message, S("Show_diagnostic_information_6149"), S("Show diagnostic information.")};
        static DiagnosticMessageStore Show_verbose_diagnostic_information = {6150, DiagnosticCategory::Message, S("Show_verbose_diagnostic_information_6150"), S("Show verbose diagnostic information.")};
        static DiagnosticMessageStore Emit_a_single_file_with_source_maps_instead_of_having_a_separate_file = {6151, DiagnosticCategory::Message, S("Emit_a_single_file_with_source_maps_instead_of_having_a_separate_file_6151"), S("Emit a single file with source maps instead of having a separate file.")};
        static DiagnosticMessageStore Emit_the_source_alongside_the_sourcemaps_within_a_single_file_requires_inlineSourceMap_or_sourceMap_to_be_set = {6152, DiagnosticCategory::Message, S("Emit_the_source_alongside_the_sourcemaps_within_a_single_file_requires_inlineSourceMap_or_sourceMap__6152"), S("Emit the source alongside the sourcemaps within a single file; requires '--inlineSourceMap' or '--sourceMap' to be set.")};
        static DiagnosticMessageStore Transpile_each_file_as_a_separate_module_similar_to_ts_transpileModule = {6153, DiagnosticCategory::Message, S("Transpile_each_file_as_a_separate_module_similar_to_ts_transpileModule_6153"), S("Transpile each file as a separate module (similar to 'ts.transpileModule').")};
        static DiagnosticMessageStore Print_names_of_generated_files_part_of_the_compilation = {6154, DiagnosticCategory::Message, S("Print_names_of_generated_files_part_of_the_compilation_6154"), S("Print names of generated files part of the compilation.")};
        static DiagnosticMessageStore Print_names_of_files_part_of_the_compilation = {6155, DiagnosticCategory::Message, S("Print_names_of_files_part_of_the_compilation_6155"), S("Print names of files part of the compilation.")};
        static DiagnosticMessageStore The_locale_used_when_displaying_messages_to_the_user_e_g_en_us = {6156, DiagnosticCategory::Message, S("The_locale_used_when_displaying_messages_to_the_user_e_g_en_us_6156"), S("The locale used when displaying messages to the user (e.g. 'en-us')")};
        static DiagnosticMessageStore Do_not_generate_custom_helper_functions_like_extends_in_compiled_output = {6157, DiagnosticCategory::Message, S("Do_not_generate_custom_helper_functions_like_extends_in_compiled_output_6157"), S("Do not generate custom helper functions like '__extends' in compiled output.")};
        static DiagnosticMessageStore Do_not_include_the_default_library_file_lib_d_ts = {6158, DiagnosticCategory::Message, S("Do_not_include_the_default_library_file_lib_d_ts_6158"), S("Do not include the default library file (lib.d.ts).")};
        static DiagnosticMessageStore Do_not_add_triple_slash_references_or_imported_modules_to_the_list_of_compiled_files = {6159, DiagnosticCategory::Message, S("Do_not_add_triple_slash_references_or_imported_modules_to_the_list_of_compiled_files_6159"), S("Do not add triple-slash references or imported modules to the list of compiled files.")};
        static DiagnosticMessageStore Deprecated_Use_skipLibCheck_instead_Skip_type_checking_of_default_library_declaration_files = {6160, DiagnosticCategory::Message, S("Deprecated_Use_skipLibCheck_instead_Skip_type_checking_of_default_library_declaration_files_6160"), S("[Deprecated] Use '--skipLibCheck' instead. Skip type checking of default library declaration files.")};
        static DiagnosticMessageStore List_of_folders_to_include_type_definitions_from = {6161, DiagnosticCategory::Message, S("List_of_folders_to_include_type_definitions_from_6161"), S("List of folders to include type definitions from.")};
        static DiagnosticMessageStore Disable_size_limitations_on_JavaScript_projects = {6162, DiagnosticCategory::Message, S("Disable_size_limitations_on_JavaScript_projects_6162"), S("Disable size limitations on JavaScript projects.")};
        static DiagnosticMessageStore The_character_set_of_the_input_files = {6163, DiagnosticCategory::Message, S("The_character_set_of_the_input_files_6163"), S("The character set of the input files.")};
        static DiagnosticMessageStore Skipping_module_0_that_looks_like_an_absolute_URI_target_file_types_Colon_1 = {6164, DiagnosticCategory::Message, S("Skipping_module_0_that_looks_like_an_absolute_URI_target_file_types_Colon_1_6164"), S("Skipping module '{0}' that looks like an absolute URI, target file types: {1}.")};
        static DiagnosticMessageStore Do_not_truncate_error_messages = {6165, DiagnosticCategory::Message, S("Do_not_truncate_error_messages_6165"), S("Do not truncate error messages.")};
        static DiagnosticMessageStore Output_directory_for_generated_declaration_files = {6166, DiagnosticCategory::Message, S("Output_directory_for_generated_declaration_files_6166"), S("Output directory for generated declaration files.")};
        static DiagnosticMessageStore A_series_of_entries_which_re_map_imports_to_lookup_locations_relative_to_the_baseUrl = {6167, DiagnosticCategory::Message, S("A_series_of_entries_which_re_map_imports_to_lookup_locations_relative_to_the_baseUrl_6167"), S("A series of entries which re-map imports to lookup locations relative to the 'baseUrl'.")};
        static DiagnosticMessageStore List_of_root_folders_whose_combined_content_represents_the_structure_of_the_project_at_runtime = {6168, DiagnosticCategory::Message, S("List_of_root_folders_whose_combined_content_represents_the_structure_of_the_project_at_runtime_6168"), S("List of root folders whose combined content represents the structure of the project at runtime.")};
        static DiagnosticMessageStore Show_all_compiler_options = {6169, DiagnosticCategory::Message, S("Show_all_compiler_options_6169"), S("Show all compiler options.")};
        static DiagnosticMessageStore Deprecated_Use_outFile_instead_Concatenate_and_emit_output_to_single_file = {6170, DiagnosticCategory::Message, S("Deprecated_Use_outFile_instead_Concatenate_and_emit_output_to_single_file_6170"), S("[Deprecated] Use '--outFile' instead. Concatenate and emit output to single file")};
        static DiagnosticMessageStore Command_line_Options = {6171, DiagnosticCategory::Message, S("Command_line_Options_6171"), S("Command-line Options")};
        static DiagnosticMessageStore Provide_full_support_for_iterables_in_for_of_spread_and_destructuring_when_targeting_ES5_or_ES3 = {6179, DiagnosticCategory::Message, S("Provide_full_support_for_iterables_in_for_of_spread_and_destructuring_when_targeting_ES5_or_ES3_6179"), S("Provide full support for iterables in 'for-of', spread, and destructuring when targeting 'ES5' or 'ES3'.")};
        static DiagnosticMessageStore Enable_all_strict_type_checking_options = {6180, DiagnosticCategory::Message, S("Enable_all_strict_type_checking_options_6180"), S("Enable all strict type-checking options.")};
        static DiagnosticMessageStore Scoped_package_detected_looking_in_0 = {6182, DiagnosticCategory::Message, S("Scoped_package_detected_looking_in_0_6182"), S("Scoped package detected, looking in '{0}'")};
        static DiagnosticMessageStore Reusing_resolution_of_module_0_from_1_of_old_program_it_was_successfully_resolved_to_2 = {6183, DiagnosticCategory::Message, S("Reusing_resolution_of_module_0_from_1_of_old_program_it_was_successfully_resolved_to_2_6183"), S("Reusing resolution of module '{0}' from '{1}' of old program, it was successfully resolved to '{2}'.")};
        static DiagnosticMessageStore Reusing_resolution_of_module_0_from_1_of_old_program_it_was_successfully_resolved_to_2_with_Package_ID_3 = {6184, DiagnosticCategory::Message, S("Reusing_resolution_of_module_0_from_1_of_old_program_it_was_successfully_resolved_to_2_with_Package__6184"), S("Reusing resolution of module '{0}' from '{1}' of old program, it was successfully resolved to '{2}' with Package ID '{3}'.")};
        static DiagnosticMessageStore Enable_strict_checking_of_function_types = {6186, DiagnosticCategory::Message, S("Enable_strict_checking_of_function_types_6186"), S("Enable strict checking of function types.")};
        static DiagnosticMessageStore Enable_strict_checking_of_property_initialization_in_classes = {6187, DiagnosticCategory::Message, S("Enable_strict_checking_of_property_initialization_in_classes_6187"), S("Enable strict checking of property initialization in classes.")};
        static DiagnosticMessageStore Numeric_separators_are_not_allowed_here = {6188, DiagnosticCategory::Error, S("Numeric_separators_are_not_allowed_here_6188"), S("Numeric separators are not allowed here.")};
        static DiagnosticMessageStore Multiple_consecutive_numeric_separators_are_not_permitted = {6189, DiagnosticCategory::Error, S("Multiple_consecutive_numeric_separators_are_not_permitted_6189"), S("Multiple consecutive numeric separators are not permitted.")};
        static DiagnosticMessageStore Whether_to_keep_outdated_console_output_in_watch_mode_instead_of_clearing_the_screen = {6191, DiagnosticCategory::Message, S("Whether_to_keep_outdated_console_output_in_watch_mode_instead_of_clearing_the_screen_6191"), S("Whether to keep outdated console output in watch mode instead of clearing the screen.")};
        static DiagnosticMessageStore All_imports_in_import_declaration_are_unused = {6192, DiagnosticCategory::Error, S("All_imports_in_import_declaration_are_unused_6192"), S("All imports in import declaration are unused.")};
        static DiagnosticMessageStore Found_1_error_Watching_for_file_changes = {6193, DiagnosticCategory::Message, S("Found_1_error_Watching_for_file_changes_6193"), S("Found 1 error. Watching for file changes.")};
        static DiagnosticMessageStore Found_0_errors_Watching_for_file_changes = {6194, DiagnosticCategory::Message, S("Found_0_errors_Watching_for_file_changes_6194"), S("Found {0} errors. Watching for file changes.")};
        static DiagnosticMessageStore Resolve_keyof_to_string_valued_property_names_only_no_numbers_or_symbols = {6195, DiagnosticCategory::Message, S("Resolve_keyof_to_string_valued_property_names_only_no_numbers_or_symbols_6195"), S("Resolve 'keyof' to string valued property names only (no numbers or symbols).")};
        static DiagnosticMessageStore _0_is_declared_but_never_used = {6196, DiagnosticCategory::Error, S("_0_is_declared_but_never_used_6196"), S("'{0}' is declared but never used.")};
        static DiagnosticMessageStore Include_modules_imported_with_json_extension = {6197, DiagnosticCategory::Message, S("Include_modules_imported_with_json_extension_6197"), S("Include modules imported with '.json' extension")};
        static DiagnosticMessageStore All_destructured_elements_are_unused = {6198, DiagnosticCategory::Error, S("All_destructured_elements_are_unused_6198"), S("All destructured elements are unused.")};
        static DiagnosticMessageStore All_variables_are_unused = {6199, DiagnosticCategory::Error, S("All_variables_are_unused_6199"), S("All variables are unused.")};
        static DiagnosticMessageStore Definitions_of_the_following_identifiers_conflict_with_those_in_another_file_Colon_0 = {6200, DiagnosticCategory::Error, S("Definitions_of_the_following_identifiers_conflict_with_those_in_another_file_Colon_0_6200"), S("Definitions of the following identifiers conflict with those in another file: {0}")};
        static DiagnosticMessageStore Conflicts_are_in_this_file = {6201, DiagnosticCategory::Message, S("Conflicts_are_in_this_file_6201"), S("Conflicts are in this file.")};
        static DiagnosticMessageStore Project_references_may_not_form_a_circular_graph_Cycle_detected_Colon_0 = {6202, DiagnosticCategory::Error, S("Project_references_may_not_form_a_circular_graph_Cycle_detected_Colon_0_6202"), S("Project references may not form a circular graph. Cycle detected: {0}")};
        static DiagnosticMessageStore _0_was_also_declared_here = {6203, DiagnosticCategory::Message, S("_0_was_also_declared_here_6203"), S("'{0}' was also declared here.")};
        static DiagnosticMessageStore and_here = {6204, DiagnosticCategory::Message, S("and_here_6204"), S("and here.")};
        static DiagnosticMessageStore All_type_parameters_are_unused = {6205, DiagnosticCategory::Error, S("All_type_parameters_are_unused_6205"), S("All type parameters are unused.")};
        static DiagnosticMessageStore package_json_has_a_typesVersions_field_with_version_specific_path_mappings = {6206, DiagnosticCategory::Message, S("package_json_has_a_typesVersions_field_with_version_specific_path_mappings_6206"), S("'package.json' has a 'typesVersions' field with version-specific path mappings.")};
        static DiagnosticMessageStore package_json_does_not_have_a_typesVersions_entry_that_matches_version_0 = {6207, DiagnosticCategory::Message, S("package_json_does_not_have_a_typesVersions_entry_that_matches_version_0_6207"), S("'package.json' does not have a 'typesVersions' entry that matches version '{0}'.")};
        static DiagnosticMessageStore package_json_has_a_typesVersions_entry_0_that_matches_compiler_version_1_looking_for_a_pattern_to_match_module_name_2 = {6208, DiagnosticCategory::Message, S("package_json_has_a_typesVersions_entry_0_that_matches_compiler_version_1_looking_for_a_pattern_to_ma_6208"), S("'package.json' has a 'typesVersions' entry '{0}' that matches compiler version '{1}', looking for a pattern to match module name '{2}'.")};
        static DiagnosticMessageStore package_json_has_a_typesVersions_entry_0_that_is_not_a_valid_semver_range = {6209, DiagnosticCategory::Message, S("package_json_has_a_typesVersions_entry_0_that_is_not_a_valid_semver_range_6209"), S("'package.json' has a 'typesVersions' entry '{0}' that is not a valid semver range.")};
        static DiagnosticMessageStore An_argument_for_0_was_not_provided = {6210, DiagnosticCategory::Message, S("An_argument_for_0_was_not_provided_6210"), S("An argument for '{0}' was not provided.")};
        static DiagnosticMessageStore An_argument_matching_this_binding_pattern_was_not_provided = {6211, DiagnosticCategory::Message, S("An_argument_matching_this_binding_pattern_was_not_provided_6211"), S("An argument matching this binding pattern was not provided.")};
        static DiagnosticMessageStore Did_you_mean_to_call_this_expression = {6212, DiagnosticCategory::Message, S("Did_you_mean_to_call_this_expression_6212"), S("Did you mean to call this expression?")};
        static DiagnosticMessageStore Did_you_mean_to_use_new_with_this_expression = {6213, DiagnosticCategory::Message, S("Did_you_mean_to_use_new_with_this_expression_6213"), S("Did you mean to use 'new' with this expression?")};
        static DiagnosticMessageStore Enable_strict_bind_call_and_apply_methods_on_functions = {6214, DiagnosticCategory::Message, S("Enable_strict_bind_call_and_apply_methods_on_functions_6214"), S("Enable strict 'bind', 'call', and 'apply' methods on functions.")};
        static DiagnosticMessageStore Using_compiler_options_of_project_reference_redirect_0 = {6215, DiagnosticCategory::Message, S("Using_compiler_options_of_project_reference_redirect_0_6215"), S("Using compiler options of project reference redirect '{0}'.")};
        static DiagnosticMessageStore Found_1_error = {6216, DiagnosticCategory::Message, S("Found_1_error_6216"), S("Found 1 error.")};
        static DiagnosticMessageStore Found_0_errors = {6217, DiagnosticCategory::Message, S("Found_0_errors_6217"), S("Found {0} errors.")};
        static DiagnosticMessageStore Module_name_0_was_successfully_resolved_to_1_with_Package_ID_2 = {6218, DiagnosticCategory::Message, S("Module_name_0_was_successfully_resolved_to_1_with_Package_ID_2_6218"), S("======== Module name '{0}' was successfully resolved to '{1}' with Package ID '{2}'. ========")};
        static DiagnosticMessageStore Type_reference_directive_0_was_successfully_resolved_to_1_with_Package_ID_2_primary_Colon_3 = {6219, DiagnosticCategory::Message, S("Type_reference_directive_0_was_successfully_resolved_to_1_with_Package_ID_2_primary_Colon_3_6219"), S("======== Type reference directive '{0}' was successfully resolved to '{1}' with Package ID '{2}', primary: {3}. ========")};
        static DiagnosticMessageStore package_json_had_a_falsy_0_field = {6220, DiagnosticCategory::Message, S("package_json_had_a_falsy_0_field_6220"), S("'package.json' had a falsy '{0}' field.")};
        static DiagnosticMessageStore Disable_use_of_source_files_instead_of_declaration_files_from_referenced_projects = {6221, DiagnosticCategory::Message, S("Disable_use_of_source_files_instead_of_declaration_files_from_referenced_projects_6221"), S("Disable use of source files instead of declaration files from referenced projects.")};
        static DiagnosticMessageStore Emit_class_fields_with_Define_instead_of_Set = {6222, DiagnosticCategory::Message, S("Emit_class_fields_with_Define_instead_of_Set_6222"), S("Emit class fields with Define instead of Set.")};
        static DiagnosticMessageStore Generates_a_CPU_profile = {6223, DiagnosticCategory::Message, S("Generates_a_CPU_profile_6223"), S("Generates a CPU profile.")};
        static DiagnosticMessageStore Disable_solution_searching_for_this_project = {6224, DiagnosticCategory::Message, S("Disable_solution_searching_for_this_project_6224"), S("Disable solution searching for this project.")};
        static DiagnosticMessageStore Specify_strategy_for_watching_file_Colon_FixedPollingInterval_default_PriorityPollingInterval_DynamicPriorityPolling_FixedChunkSizePolling_UseFsEvents_UseFsEventsOnParentDirectory = {6225, DiagnosticCategory::Message, S("Specify_strategy_for_watching_file_Colon_FixedPollingInterval_default_PriorityPollingInterval_Dynami_6225"), S("Specify strategy for watching file: 'FixedPollingInterval' (default), 'PriorityPollingInterval', 'DynamicPriorityPolling', 'FixedChunkSizePolling', 'UseFsEvents', 'UseFsEventsOnParentDirectory'.")};
        static DiagnosticMessageStore Specify_strategy_for_watching_directory_on_platforms_that_don_t_support_recursive_watching_natively_Colon_UseFsEvents_default_FixedPollingInterval_DynamicPriorityPolling_FixedChunkSizePolling = {6226, DiagnosticCategory::Message, S("Specify_strategy_for_watching_directory_on_platforms_that_don_t_support_recursive_watching_natively__6226"), S("Specify strategy for watching directory on platforms that don't support recursive watching natively: 'UseFsEvents' (default), 'FixedPollingInterval', 'DynamicPriorityPolling', 'FixedChunkSizePolling'.")};
        static DiagnosticMessageStore Specify_strategy_for_creating_a_polling_watch_when_it_fails_to_create_using_file_system_events_Colon_FixedInterval_default_PriorityInterval_DynamicPriority_FixedChunkSize = {6227, DiagnosticCategory::Message, S("Specify_strategy_for_creating_a_polling_watch_when_it_fails_to_create_using_file_system_events_Colon_6227"), S("Specify strategy for creating a polling watch when it fails to create using file system events: 'FixedInterval' (default), 'PriorityInterval', 'DynamicPriority', 'FixedChunkSize'.")};
        static DiagnosticMessageStore Tag_0_expects_at_least_1_arguments_but_the_JSX_factory_2_provides_at_most_3 = {6229, DiagnosticCategory::Error, S("Tag_0_expects_at_least_1_arguments_but_the_JSX_factory_2_provides_at_most_3_6229"), S("Tag '{0}' expects at least '{1}' arguments, but the JSX factory '{2}' provides at most '{3}'.")};
        static DiagnosticMessageStore Option_0_can_only_be_specified_in_tsconfig_json_file_or_set_to_false_or_null_on_command_line = {6230, DiagnosticCategory::Error, S("Option_0_can_only_be_specified_in_tsconfig_json_file_or_set_to_false_or_null_on_command_line_6230"), S("Option '{0}' can only be specified in 'tsconfig.json' file or set to 'false' or 'null' on command line.")};
        static DiagnosticMessageStore Could_not_resolve_the_path_0_with_the_extensions_Colon_1 = {6231, DiagnosticCategory::Error, S("Could_not_resolve_the_path_0_with_the_extensions_Colon_1_6231"), S("Could not resolve the path '{0}' with the extensions: {1}.")};
        static DiagnosticMessageStore Declaration_augments_declaration_in_another_file_This_cannot_be_serialized = {6232, DiagnosticCategory::Error, S("Declaration_augments_declaration_in_another_file_This_cannot_be_serialized_6232"), S("Declaration augments declaration in another file. This cannot be serialized.")};
        static DiagnosticMessageStore This_is_the_declaration_being_augmented_Consider_moving_the_augmenting_declaration_into_the_same_file = {6233, DiagnosticCategory::Error, S("This_is_the_declaration_being_augmented_Consider_moving_the_augmenting_declaration_into_the_same_fil_6233"), S("This is the declaration being augmented. Consider moving the augmenting declaration into the same file.")};
        static DiagnosticMessageStore This_expression_is_not_callable_because_it_is_a_get_accessor_Did_you_mean_to_use_it_without = {6234, DiagnosticCategory::Error, S("This_expression_is_not_callable_because_it_is_a_get_accessor_Did_you_mean_to_use_it_without_6234"), S("This expression is not callable because it is a 'get' accessor. Did you mean to use it without '()'?")};
        static DiagnosticMessageStore Disable_loading_referenced_projects = {6235, DiagnosticCategory::Message, S("Disable_loading_referenced_projects_6235"), S("Disable loading referenced projects.")};
        static DiagnosticMessageStore Arguments_for_the_rest_parameter_0_were_not_provided = {6236, DiagnosticCategory::Error, S("Arguments_for_the_rest_parameter_0_were_not_provided_6236"), S("Arguments for the rest parameter '{0}' were not provided.")};
        static DiagnosticMessageStore Generates_an_event_trace_and_a_list_of_types = {6237, DiagnosticCategory::Message, S("Generates_an_event_trace_and_a_list_of_types_6237"), S("Generates an event trace and a list of types.")};
        static DiagnosticMessageStore Specify_the_module_specifier_to_be_used_to_import_the_jsx_and_jsxs_factory_functions_from_eg_react = {6238, DiagnosticCategory::Error, S("Specify_the_module_specifier_to_be_used_to_import_the_jsx_and_jsxs_factory_functions_from_eg_react_6238"), S("Specify the module specifier to be used to import the 'jsx' and 'jsxs' factory functions from. eg, react")};
        static DiagnosticMessageStore File_0_exists_according_to_earlier_cached_lookups = {6239, DiagnosticCategory::Message, S("File_0_exists_according_to_earlier_cached_lookups_6239"), S("File '{0}' exists according to earlier cached lookups.")};
        static DiagnosticMessageStore File_0_does_not_exist_according_to_earlier_cached_lookups = {6240, DiagnosticCategory::Message, S("File_0_does_not_exist_according_to_earlier_cached_lookups_6240"), S("File '{0}' does not exist according to earlier cached lookups.")};
        static DiagnosticMessageStore Resolution_for_type_reference_directive_0_was_found_in_cache_from_location_1 = {6241, DiagnosticCategory::Message, S("Resolution_for_type_reference_directive_0_was_found_in_cache_from_location_1_6241"), S("Resolution for type reference directive '{0}' was found in cache from location '{1}'.")};
        static DiagnosticMessageStore Resolving_type_reference_directive_0_containing_file_1 = {6242, DiagnosticCategory::Message, S("Resolving_type_reference_directive_0_containing_file_1_6242"), S("======== Resolving type reference directive '{0}', containing file '{1}'. ========")};
        static DiagnosticMessageStore Interpret_optional_property_types_as_written_rather_than_adding_undefined = {6243, DiagnosticCategory::Message, S("Interpret_optional_property_types_as_written_rather_than_adding_undefined_6243"), S("Interpret optional property types as written, rather than adding 'undefined'.")};
        static DiagnosticMessageStore Modules = {6244, DiagnosticCategory::Message, S("Modules_6244"), S("Modules")};
        static DiagnosticMessageStore File_Management = {6245, DiagnosticCategory::Message, S("File_Management_6245"), S("File Management")};
        static DiagnosticMessageStore Emit = {6246, DiagnosticCategory::Message, S("Emit_6246"), S("Emit")};
        static DiagnosticMessageStore JavaScript_Support = {6247, DiagnosticCategory::Message, S("JavaScript_Support_6247"), S("JavaScript Support")};
        static DiagnosticMessageStore Type_Checking = {6248, DiagnosticCategory::Message, S("Type_Checking_6248"), S("Type Checking")};
        static DiagnosticMessageStore Editor_Support = {6249, DiagnosticCategory::Message, S("Editor_Support_6249"), S("Editor Support")};
        static DiagnosticMessageStore Watch_and_Build_Modes = {6250, DiagnosticCategory::Message, S("Watch_and_Build_Modes_6250"), S("Watch and Build Modes")};
        static DiagnosticMessageStore Compiler_Diagnostics = {6251, DiagnosticCategory::Message, S("Compiler_Diagnostics_6251"), S("Compiler Diagnostics")};
        static DiagnosticMessageStore Interop_Constraints = {6252, DiagnosticCategory::Message, S("Interop_Constraints_6252"), S("Interop Constraints")};
        static DiagnosticMessageStore Backwards_Compatibility = {6253, DiagnosticCategory::Message, S("Backwards_Compatibility_6253"), S("Backwards Compatibility")};
        static DiagnosticMessageStore Language_and_Environment = {6254, DiagnosticCategory::Message, S("Language_and_Environment_6254"), S("Language and Environment")};
        static DiagnosticMessageStore Projects = {6255, DiagnosticCategory::Message, S("Projects_6255"), S("Projects")};
        static DiagnosticMessageStore Output_Formatting = {6256, DiagnosticCategory::Message, S("Output_Formatting_6256"), S("Output Formatting")};
        static DiagnosticMessageStore Completeness = {6257, DiagnosticCategory::Message, S("Completeness_6257"), S("Completeness")};
        static DiagnosticMessageStore _0_should_be_set_inside_the_compilerOptions_object_of_the_config_json_file = {6258, DiagnosticCategory::Error, S("_0_should_be_set_inside_the_compilerOptions_object_of_the_config_json_file_6258"), S("'{0}' should be set inside the 'compilerOptions' object of the config json file")};
        static DiagnosticMessageStore Found_1_error_in_0 = {6259, DiagnosticCategory::Message, S("Found_1_error_in_0_6259"), S("Found 1 error in {0}")};
        static DiagnosticMessageStore Found_0_errors_in_the_same_file_starting_at_Colon_1 = {6260, DiagnosticCategory::Message, S("Found_0_errors_in_the_same_file_starting_at_Colon_1_6260"), S("Found {0} errors in the same file, starting at: {1}")};
        static DiagnosticMessageStore Found_0_errors_in_1_files = {6261, DiagnosticCategory::Message, S("Found_0_errors_in_1_files_6261"), S("Found {0} errors in {1} files.")};
        static DiagnosticMessageStore File_name_0_has_a_1_extension_looking_up_2_instead = {6262, DiagnosticCategory::Message, S("File_name_0_has_a_1_extension_looking_up_2_instead_6262"), S("File name '{0}' has a '{1}' extension - looking up '{2}' instead.")};
        static DiagnosticMessageStore Module_0_was_resolved_to_1_but_allowArbitraryExtensions_is_not_set = {6263, DiagnosticCategory::Error, S("Module_0_was_resolved_to_1_but_allowArbitraryExtensions_is_not_set_6263"), S("Module '{0}' was resolved to '{1}', but '--allowArbitraryExtensions' is not set.")};
        static DiagnosticMessageStore Enable_importing_files_with_any_extension_provided_a_declaration_file_is_present = {6264, DiagnosticCategory::Message, S("Enable_importing_files_with_any_extension_provided_a_declaration_file_is_present_6264"), S("Enable importing files with any extension, provided a declaration file is present.")};
        static DiagnosticMessageStore Resolving_type_reference_directive_for_program_that_specifies_custom_typeRoots_skipping_lookup_in_node_modules_folder = {6265, DiagnosticCategory::Message, S("Resolving_type_reference_directive_for_program_that_specifies_custom_typeRoots_skipping_lookup_in_no_6265"), S("Resolving type reference directive for program that specifies custom typeRoots, skipping lookup in 'node_modules' folder.")};
        static DiagnosticMessageStore Option_0_can_only_be_specified_on_command_line = {6266, DiagnosticCategory::Error, S("Option_0_can_only_be_specified_on_command_line_6266"), S("Option '{0}' can only be specified on command line.")};
        static DiagnosticMessageStore Directory_0_has_no_containing_package_json_scope_Imports_will_not_resolve = {6270, DiagnosticCategory::Message, S("Directory_0_has_no_containing_package_json_scope_Imports_will_not_resolve_6270"), S("Directory '{0}' has no containing package.json scope. Imports will not resolve.")};
        static DiagnosticMessageStore Import_specifier_0_does_not_exist_in_package_json_scope_at_path_1 = {6271, DiagnosticCategory::Message, S("Import_specifier_0_does_not_exist_in_package_json_scope_at_path_1_6271"), S("Import specifier '{0}' does not exist in package.json scope at path '{1}'.")};
        static DiagnosticMessageStore Invalid_import_specifier_0_has_no_possible_resolutions = {6272, DiagnosticCategory::Message, S("Invalid_import_specifier_0_has_no_possible_resolutions_6272"), S("Invalid import specifier '{0}' has no possible resolutions.")};
        static DiagnosticMessageStore package_json_scope_0_has_no_imports_defined = {6273, DiagnosticCategory::Message, S("package_json_scope_0_has_no_imports_defined_6273"), S("package.json scope '{0}' has no imports defined.")};
        static DiagnosticMessageStore package_json_scope_0_explicitly_maps_specifier_1_to_null = {6274, DiagnosticCategory::Message, S("package_json_scope_0_explicitly_maps_specifier_1_to_null_6274"), S("package.json scope '{0}' explicitly maps specifier '{1}' to null.")};
        static DiagnosticMessageStore package_json_scope_0_has_invalid_type_for_target_of_specifier_1 = {6275, DiagnosticCategory::Message, S("package_json_scope_0_has_invalid_type_for_target_of_specifier_1_6275"), S("package.json scope '{0}' has invalid type for target of specifier '{1}'")};
        static DiagnosticMessageStore Export_specifier_0_does_not_exist_in_package_json_scope_at_path_1 = {6276, DiagnosticCategory::Message, S("Export_specifier_0_does_not_exist_in_package_json_scope_at_path_1_6276"), S("Export specifier '{0}' does not exist in package.json scope at path '{1}'.")};
        static DiagnosticMessageStore Resolution_of_non_relative_name_failed_trying_with_modern_Node_resolution_features_disabled_to_see_if_npm_library_needs_configuration_update = {6277, DiagnosticCategory::Message, S("Resolution_of_non_relative_name_failed_trying_with_modern_Node_resolution_features_disabled_to_see_i_6277"), S("Resolution of non-relative name failed; trying with modern Node resolution features disabled to see if npm library needs configuration update.")};
        static DiagnosticMessageStore There_are_types_at_0_but_this_result_could_not_be_resolved_when_respecting_package_json_exports_The_1_library_may_need_to_update_its_package_json_or_typings = {6278, DiagnosticCategory::Message, S("There_are_types_at_0_but_this_result_could_not_be_resolved_when_respecting_package_json_exports_The__6278"), S("There are types at '{0}', but this result could not be resolved when respecting package.json \"exports\". The '{1}' library may need to update its package.json or typings.")};
        static DiagnosticMessageStore Enable_project_compilation = {6302, DiagnosticCategory::Message, S("Enable_project_compilation_6302"), S("Enable project compilation")};
        static DiagnosticMessageStore Composite_projects_may_not_disable_declaration_emit = {6304, DiagnosticCategory::Error, S("Composite_projects_may_not_disable_declaration_emit_6304"), S("Composite projects may not disable declaration emit.")};
        static DiagnosticMessageStore Output_file_0_has_not_been_built_from_source_file_1 = {6305, DiagnosticCategory::Error, S("Output_file_0_has_not_been_built_from_source_file_1_6305"), S("Output file '{0}' has not been built from source file '{1}'.")};
        static DiagnosticMessageStore Referenced_project_0_must_have_setting_composite_Colon_true = {6306, DiagnosticCategory::Error, S("Referenced_project_0_must_have_setting_composite_Colon_true_6306"), S("Referenced project '{0}' must have setting \"composite\": true.")};
        static DiagnosticMessageStore File_0_is_not_listed_within_the_file_list_of_project_1_Projects_must_list_all_files_or_use_an_include_pattern = {6307, DiagnosticCategory::Error, S("File_0_is_not_listed_within_the_file_list_of_project_1_Projects_must_list_all_files_or_use_an_includ_6307"), S("File '{0}' is not listed within the file list of project '{1}'. Projects must list all files or use an 'include' pattern.")};
        static DiagnosticMessageStore Cannot_prepend_project_0_because_it_does_not_have_outFile_set = {6308, DiagnosticCategory::Error, S("Cannot_prepend_project_0_because_it_does_not_have_outFile_set_6308"), S("Cannot prepend project '{0}' because it does not have 'outFile' set")};
        static DiagnosticMessageStore Output_file_0_from_project_1_does_not_exist = {6309, DiagnosticCategory::Error, S("Output_file_0_from_project_1_does_not_exist_6309"), S("Output file '{0}' from project '{1}' does not exist")};
        static DiagnosticMessageStore Referenced_project_0_may_not_disable_emit = {6310, DiagnosticCategory::Error, S("Referenced_project_0_may_not_disable_emit_6310"), S("Referenced project '{0}' may not disable emit.")};
        static DiagnosticMessageStore Project_0_is_out_of_date_because_output_1_is_older_than_input_2 = {6350, DiagnosticCategory::Message, S("Project_0_is_out_of_date_because_output_1_is_older_than_input_2_6350"), S("Project '{0}' is out of date because output '{1}' is older than input '{2}'")};
        static DiagnosticMessageStore Project_0_is_up_to_date_because_newest_input_1_is_older_than_output_2 = {6351, DiagnosticCategory::Message, S("Project_0_is_up_to_date_because_newest_input_1_is_older_than_output_2_6351"), S("Project '{0}' is up to date because newest input '{1}' is older than output '{2}'")};
        static DiagnosticMessageStore Project_0_is_out_of_date_because_output_file_1_does_not_exist = {6352, DiagnosticCategory::Message, S("Project_0_is_out_of_date_because_output_file_1_does_not_exist_6352"), S("Project '{0}' is out of date because output file '{1}' does not exist")};
        static DiagnosticMessageStore Project_0_is_out_of_date_because_its_dependency_1_is_out_of_date = {6353, DiagnosticCategory::Message, S("Project_0_is_out_of_date_because_its_dependency_1_is_out_of_date_6353"), S("Project '{0}' is out of date because its dependency '{1}' is out of date")};
        static DiagnosticMessageStore Project_0_is_up_to_date_with_d_ts_files_from_its_dependencies = {6354, DiagnosticCategory::Message, S("Project_0_is_up_to_date_with_d_ts_files_from_its_dependencies_6354"), S("Project '{0}' is up to date with .d.ts files from its dependencies")};
        static DiagnosticMessageStore Projects_in_this_build_Colon_0 = {6355, DiagnosticCategory::Message, S("Projects_in_this_build_Colon_0_6355"), S("Projects in this build: {0}")};
        static DiagnosticMessageStore A_non_dry_build_would_delete_the_following_files_Colon_0 = {6356, DiagnosticCategory::Message, S("A_non_dry_build_would_delete_the_following_files_Colon_0_6356"), S("A non-dry build would delete the following files: {0}")};
        static DiagnosticMessageStore A_non_dry_build_would_build_project_0 = {6357, DiagnosticCategory::Message, S("A_non_dry_build_would_build_project_0_6357"), S("A non-dry build would build project '{0}'")};
        static DiagnosticMessageStore Building_project_0 = {6358, DiagnosticCategory::Message, S("Building_project_0_6358"), S("Building project '{0}'...")};
        static DiagnosticMessageStore Updating_output_timestamps_of_project_0 = {6359, DiagnosticCategory::Message, S("Updating_output_timestamps_of_project_0_6359"), S("Updating output timestamps of project '{0}'...")};
        static DiagnosticMessageStore Project_0_is_up_to_date = {6361, DiagnosticCategory::Message, S("Project_0_is_up_to_date_6361"), S("Project '{0}' is up to date")};
        static DiagnosticMessageStore Skipping_build_of_project_0_because_its_dependency_1_has_errors = {6362, DiagnosticCategory::Message, S("Skipping_build_of_project_0_because_its_dependency_1_has_errors_6362"), S("Skipping build of project '{0}' because its dependency '{1}' has errors")};
        static DiagnosticMessageStore Project_0_can_t_be_built_because_its_dependency_1_has_errors = {6363, DiagnosticCategory::Message, S("Project_0_can_t_be_built_because_its_dependency_1_has_errors_6363"), S("Project '{0}' can't be built because its dependency '{1}' has errors")};
        static DiagnosticMessageStore Build_one_or_more_projects_and_their_dependencies_if_out_of_date = {6364, DiagnosticCategory::Message, S("Build_one_or_more_projects_and_their_dependencies_if_out_of_date_6364"), S("Build one or more projects and their dependencies, if out of date")};
        static DiagnosticMessageStore Delete_the_outputs_of_all_projects = {6365, DiagnosticCategory::Message, S("Delete_the_outputs_of_all_projects_6365"), S("Delete the outputs of all projects.")};
        static DiagnosticMessageStore Show_what_would_be_built_or_deleted_if_specified_with_clean = {6367, DiagnosticCategory::Message, S("Show_what_would_be_built_or_deleted_if_specified_with_clean_6367"), S("Show what would be built (or deleted, if specified with '--clean')")};
        static DiagnosticMessageStore Option_build_must_be_the_first_command_line_argument = {6369, DiagnosticCategory::Error, S("Option_build_must_be_the_first_command_line_argument_6369"), S("Option '--build' must be the first command line argument.")};
        static DiagnosticMessageStore Options_0_and_1_cannot_be_combined = {6370, DiagnosticCategory::Error, S("Options_0_and_1_cannot_be_combined_6370"), S("Options '{0}' and '{1}' cannot be combined.")};
        static DiagnosticMessageStore Updating_unchanged_output_timestamps_of_project_0 = {6371, DiagnosticCategory::Message, S("Updating_unchanged_output_timestamps_of_project_0_6371"), S("Updating unchanged output timestamps of project '{0}'...")};
        static DiagnosticMessageStore Project_0_is_out_of_date_because_output_of_its_dependency_1_has_changed = {6372, DiagnosticCategory::Message, S("Project_0_is_out_of_date_because_output_of_its_dependency_1_has_changed_6372"), S("Project '{0}' is out of date because output of its dependency '{1}' has changed")};
        static DiagnosticMessageStore Updating_output_of_project_0 = {6373, DiagnosticCategory::Message, S("Updating_output_of_project_0_6373"), S("Updating output of project '{0}'...")};
        static DiagnosticMessageStore A_non_dry_build_would_update_timestamps_for_output_of_project_0 = {6374, DiagnosticCategory::Message, S("A_non_dry_build_would_update_timestamps_for_output_of_project_0_6374"), S("A non-dry build would update timestamps for output of project '{0}'")};
        static DiagnosticMessageStore A_non_dry_build_would_update_output_of_project_0 = {6375, DiagnosticCategory::Message, S("A_non_dry_build_would_update_output_of_project_0_6375"), S("A non-dry build would update output of project '{0}'")};
        static DiagnosticMessageStore Cannot_update_output_of_project_0_because_there_was_error_reading_file_1 = {6376, DiagnosticCategory::Message, S("Cannot_update_output_of_project_0_because_there_was_error_reading_file_1_6376"), S("Cannot update output of project '{0}' because there was error reading file '{1}'")};
        static DiagnosticMessageStore Cannot_write_file_0_because_it_will_overwrite_tsbuildinfo_file_generated_by_referenced_project_1 = {6377, DiagnosticCategory::Error, S("Cannot_write_file_0_because_it_will_overwrite_tsbuildinfo_file_generated_by_referenced_project_1_6377"), S("Cannot write file '{0}' because it will overwrite '.tsbuildinfo' file generated by referenced project '{1}'")};
        static DiagnosticMessageStore Composite_projects_may_not_disable_incremental_compilation = {6379, DiagnosticCategory::Error, S("Composite_projects_may_not_disable_incremental_compilation_6379"), S("Composite projects may not disable incremental compilation.")};
        static DiagnosticMessageStore Specify_file_to_store_incremental_compilation_information = {6380, DiagnosticCategory::Message, S("Specify_file_to_store_incremental_compilation_information_6380"), S("Specify file to store incremental compilation information")};
        static DiagnosticMessageStore Project_0_is_out_of_date_because_output_for_it_was_generated_with_version_1_that_differs_with_current_version_2 = {6381, DiagnosticCategory::Message, S("Project_0_is_out_of_date_because_output_for_it_was_generated_with_version_1_that_differs_with_curren_6381"), S("Project '{0}' is out of date because output for it was generated with version '{1}' that differs with current version '{2}'")};
        static DiagnosticMessageStore Skipping_build_of_project_0_because_its_dependency_1_was_not_built = {6382, DiagnosticCategory::Message, S("Skipping_build_of_project_0_because_its_dependency_1_was_not_built_6382"), S("Skipping build of project '{0}' because its dependency '{1}' was not built")};
        static DiagnosticMessageStore Project_0_can_t_be_built_because_its_dependency_1_was_not_built = {6383, DiagnosticCategory::Message, S("Project_0_can_t_be_built_because_its_dependency_1_was_not_built_6383"), S("Project '{0}' can't be built because its dependency '{1}' was not built")};
        static DiagnosticMessageStore Have_recompiles_in_incremental_and_watch_assume_that_changes_within_a_file_will_only_affect_files_directly_depending_on_it = {6384, DiagnosticCategory::Message, S("Have_recompiles_in_incremental_and_watch_assume_that_changes_within_a_file_will_only_affect_files_di_6384"), S("Have recompiles in '--incremental' and '--watch' assume that changes within a file will only affect files directly depending on it.")};
        static DiagnosticMessageStore _0_is_deprecated = {6385, DiagnosticCategory::Suggestion, S("_0_is_deprecated_6385"), S("'{0}' is deprecated.")};
        static DiagnosticMessageStore Performance_timings_for_diagnostics_or_extendedDiagnostics_are_not_available_in_this_session_A_native_implementation_of_the_Web_Performance_API_could_not_be_found = {6386, DiagnosticCategory::Message, S("Performance_timings_for_diagnostics_or_extendedDiagnostics_are_not_available_in_this_session_A_nativ_6386"), S("Performance timings for '--diagnostics' or '--extendedDiagnostics' are not available in this session. A native implementation of the Web Performance API could not be found.")};
        static DiagnosticMessageStore The_signature_0_of_1_is_deprecated = {6387, DiagnosticCategory::Suggestion, S("The_signature_0_of_1_is_deprecated_6387"), S("The signature '{0}' of '{1}' is deprecated.")};
        static DiagnosticMessageStore Project_0_is_being_forcibly_rebuilt = {6388, DiagnosticCategory::Message, S("Project_0_is_being_forcibly_rebuilt_6388"), S("Project '{0}' is being forcibly rebuilt")};
        static DiagnosticMessageStore Reusing_resolution_of_module_0_from_1_of_old_program_it_was_not_resolved = {6389, DiagnosticCategory::Message, S("Reusing_resolution_of_module_0_from_1_of_old_program_it_was_not_resolved_6389"), S("Reusing resolution of module '{0}' from '{1}' of old program, it was not resolved.")};
        static DiagnosticMessageStore Reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_successfully_resolved_to_2 = {6390, DiagnosticCategory::Message, S("Reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_successfully_resolved__6390"), S("Reusing resolution of type reference directive '{0}' from '{1}' of old program, it was successfully resolved to '{2}'.")};
        static DiagnosticMessageStore Reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_successfully_resolved_to_2_with_Package_ID_3 = {6391, DiagnosticCategory::Message, S("Reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_successfully_resolved__6391"), S("Reusing resolution of type reference directive '{0}' from '{1}' of old program, it was successfully resolved to '{2}' with Package ID '{3}'.")};
        static DiagnosticMessageStore Reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_not_resolved = {6392, DiagnosticCategory::Message, S("Reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_not_resolved_6392"), S("Reusing resolution of type reference directive '{0}' from '{1}' of old program, it was not resolved.")};
        static DiagnosticMessageStore Reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_3 = {6393, DiagnosticCategory::Message, S("Reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_6393"), S("Reusing resolution of module '{0}' from '{1}' found in cache from location '{2}', it was successfully resolved to '{3}'.")};
        static DiagnosticMessageStore Reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_3_with_Package_ID_4 = {6394, DiagnosticCategory::Message, S("Reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_6394"), S("Reusing resolution of module '{0}' from '{1}' found in cache from location '{2}', it was successfully resolved to '{3}' with Package ID '{4}'.")};
        static DiagnosticMessageStore Reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_not_resolved = {6395, DiagnosticCategory::Message, S("Reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_not_resolved_6395"), S("Reusing resolution of module '{0}' from '{1}' found in cache from location '{2}', it was not resolved.")};
        static DiagnosticMessageStore Reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_3 = {6396, DiagnosticCategory::Message, S("Reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_succes_6396"), S("Reusing resolution of type reference directive '{0}' from '{1}' found in cache from location '{2}', it was successfully resolved to '{3}'.")};
        static DiagnosticMessageStore Reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_3_with_Package_ID_4 = {6397, DiagnosticCategory::Message, S("Reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_succes_6397"), S("Reusing resolution of type reference directive '{0}' from '{1}' found in cache from location '{2}', it was successfully resolved to '{3}' with Package ID '{4}'.")};
        static DiagnosticMessageStore Reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_not_resolved = {6398, DiagnosticCategory::Message, S("Reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_not_re_6398"), S("Reusing resolution of type reference directive '{0}' from '{1}' found in cache from location '{2}', it was not resolved.")};
        static DiagnosticMessageStore Project_0_is_out_of_date_because_buildinfo_file_1_indicates_that_some_of_the_changes_were_not_emitted = {6399, DiagnosticCategory::Message, S("Project_0_is_out_of_date_because_buildinfo_file_1_indicates_that_some_of_the_changes_were_not_emitte_6399"), S("Project '{0}' is out of date because buildinfo file '{1}' indicates that some of the changes were not emitted")};
        static DiagnosticMessageStore Project_0_is_up_to_date_but_needs_to_update_timestamps_of_output_files_that_are_older_than_input_files = {6400, DiagnosticCategory::Message, S("Project_0_is_up_to_date_but_needs_to_update_timestamps_of_output_files_that_are_older_than_input_fil_6400"), S("Project '{0}' is up to date but needs to update timestamps of output files that are older than input files")};
        static DiagnosticMessageStore Project_0_is_out_of_date_because_there_was_error_reading_file_1 = {6401, DiagnosticCategory::Message, S("Project_0_is_out_of_date_because_there_was_error_reading_file_1_6401"), S("Project '{0}' is out of date because there was error reading file '{1}'")};
        static DiagnosticMessageStore Resolving_in_0_mode_with_conditions_1 = {6402, DiagnosticCategory::Message, S("Resolving_in_0_mode_with_conditions_1_6402"), S("Resolving in {0} mode with conditions {1}.")};
        static DiagnosticMessageStore Matched_0_condition_1 = {6403, DiagnosticCategory::Message, S("Matched_0_condition_1_6403"), S("Matched '{0}' condition '{1}'.")};
        static DiagnosticMessageStore Using_0_subpath_1_with_target_2 = {6404, DiagnosticCategory::Message, S("Using_0_subpath_1_with_target_2_6404"), S("Using '{0}' subpath '{1}' with target '{2}'.")};
        static DiagnosticMessageStore Saw_non_matching_condition_0 = {6405, DiagnosticCategory::Message, S("Saw_non_matching_condition_0_6405"), S("Saw non-matching condition '{0}'.")};
        static DiagnosticMessageStore Project_0_is_out_of_date_because_buildinfo_file_1_indicates_there_is_change_in_compilerOptions = {6406, DiagnosticCategory::Message, S("Project_0_is_out_of_date_because_buildinfo_file_1_indicates_there_is_change_in_compilerOptions_6406"), S("Project '{0}' is out of date because buildinfo file '{1}' indicates there is change in compilerOptions")};
        static DiagnosticMessageStore Allow_imports_to_include_TypeScript_file_extensions_Requires_moduleResolution_bundler_and_either_noEmit_or_emitDeclarationOnly_to_be_set = {6407, DiagnosticCategory::Message, S("Allow_imports_to_include_TypeScript_file_extensions_Requires_moduleResolution_bundler_and_either_noE_6407"), S("Allow imports to include TypeScript file extensions. Requires '--moduleResolution bundler' and either '--noEmit' or '--emitDeclarationOnly' to be set.")};
        static DiagnosticMessageStore Use_the_package_json_exports_field_when_resolving_package_imports = {6408, DiagnosticCategory::Message, S("Use_the_package_json_exports_field_when_resolving_package_imports_6408"), S("Use the package.json 'exports' field when resolving package imports.")};
        static DiagnosticMessageStore Use_the_package_json_imports_field_when_resolving_imports = {6409, DiagnosticCategory::Message, S("Use_the_package_json_imports_field_when_resolving_imports_6409"), S("Use the package.json 'imports' field when resolving imports.")};
        static DiagnosticMessageStore Conditions_to_set_in_addition_to_the_resolver_specific_defaults_when_resolving_imports = {6410, DiagnosticCategory::Message, S("Conditions_to_set_in_addition_to_the_resolver_specific_defaults_when_resolving_imports_6410"), S("Conditions to set in addition to the resolver-specific defaults when resolving imports.")};
        static DiagnosticMessageStore true_when_moduleResolution_is_node16_nodenext_or_bundler_otherwise_false = {6411, DiagnosticCategory::Message, S("true_when_moduleResolution_is_node16_nodenext_or_bundler_otherwise_false_6411"), S("`true` when 'moduleResolution' is 'node16', 'nodenext', or 'bundler'; otherwise `false`.")};
        static DiagnosticMessageStore Project_0_is_out_of_date_because_buildinfo_file_1_indicates_that_file_2_was_root_file_of_compilation_but_not_any_more = {6412, DiagnosticCategory::Message, S("Project_0_is_out_of_date_because_buildinfo_file_1_indicates_that_file_2_was_root_file_of_compilation_6412"), S("Project '{0}' is out of date because buildinfo file '{1}' indicates that file '{2}' was root file of compilation but not any more.")};
        static DiagnosticMessageStore Entering_conditional_exports = {6413, DiagnosticCategory::Message, S("Entering_conditional_exports_6413"), S("Entering conditional exports.")};
        static DiagnosticMessageStore Resolved_under_condition_0 = {6414, DiagnosticCategory::Message, S("Resolved_under_condition_0_6414"), S("Resolved under condition '{0}'.")};
        static DiagnosticMessageStore Failed_to_resolve_under_condition_0 = {6415, DiagnosticCategory::Message, S("Failed_to_resolve_under_condition_0_6415"), S("Failed to resolve under condition '{0}'.")};
        static DiagnosticMessageStore Exiting_conditional_exports = {6416, DiagnosticCategory::Message, S("Exiting_conditional_exports_6416"), S("Exiting conditional exports.")};
        static DiagnosticMessageStore Searching_all_ancestor_node_modules_directories_for_preferred_extensions_Colon_0 = {6417, DiagnosticCategory::Message, S("Searching_all_ancestor_node_modules_directories_for_preferred_extensions_Colon_0_6417"), S("Searching all ancestor node_modules directories for preferred extensions: {0}.")};
        static DiagnosticMessageStore Searching_all_ancestor_node_modules_directories_for_fallback_extensions_Colon_0 = {6418, DiagnosticCategory::Message, S("Searching_all_ancestor_node_modules_directories_for_fallback_extensions_Colon_0_6418"), S("Searching all ancestor node_modules directories for fallback extensions: {0}.")};
        static DiagnosticMessageStore The_expected_type_comes_from_property_0_which_is_declared_here_on_type_1 = {6500, DiagnosticCategory::Message, S("The_expected_type_comes_from_property_0_which_is_declared_here_on_type_1_6500"), S("The expected type comes from property '{0}' which is declared here on type '{1}'")};
        static DiagnosticMessageStore The_expected_type_comes_from_this_index_signature = {6501, DiagnosticCategory::Message, S("The_expected_type_comes_from_this_index_signature_6501"), S("The expected type comes from this index signature.")};
        static DiagnosticMessageStore The_expected_type_comes_from_the_return_type_of_this_signature = {6502, DiagnosticCategory::Message, S("The_expected_type_comes_from_the_return_type_of_this_signature_6502"), S("The expected type comes from the return type of this signature.")};
        static DiagnosticMessageStore Print_names_of_files_that_are_part_of_the_compilation_and_then_stop_processing = {6503, DiagnosticCategory::Message, S("Print_names_of_files_that_are_part_of_the_compilation_and_then_stop_processing_6503"), S("Print names of files that are part of the compilation and then stop processing.")};
        static DiagnosticMessageStore File_0_is_a_JavaScript_file_Did_you_mean_to_enable_the_allowJs_option = {6504, DiagnosticCategory::Error, S("File_0_is_a_JavaScript_file_Did_you_mean_to_enable_the_allowJs_option_6504"), S("File '{0}' is a JavaScript file. Did you mean to enable the 'allowJs' option?")};
        static DiagnosticMessageStore Print_names_of_files_and_the_reason_they_are_part_of_the_compilation = {6505, DiagnosticCategory::Message, S("Print_names_of_files_and_the_reason_they_are_part_of_the_compilation_6505"), S("Print names of files and the reason they are part of the compilation.")};
        static DiagnosticMessageStore Consider_adding_a_declare_modifier_to_this_class = {6506, DiagnosticCategory::Message, S("Consider_adding_a_declare_modifier_to_this_class_6506"), S("Consider adding a 'declare' modifier to this class.")};
        static DiagnosticMessageStore Allow_JavaScript_files_to_be_a_part_of_your_program_Use_the_checkJS_option_to_get_errors_from_these_files = {6600, DiagnosticCategory::Message, S("Allow_JavaScript_files_to_be_a_part_of_your_program_Use_the_checkJS_option_to_get_errors_from_these__6600"), S("Allow JavaScript files to be a part of your program. Use the 'checkJS' option to get errors from these files.")};
        static DiagnosticMessageStore Allow_import_x_from_y_when_a_module_doesn_t_have_a_default_export = {6601, DiagnosticCategory::Message, S("Allow_import_x_from_y_when_a_module_doesn_t_have_a_default_export_6601"), S("Allow 'import x from y' when a module doesn't have a default export.")};
        static DiagnosticMessageStore Allow_accessing_UMD_globals_from_modules = {6602, DiagnosticCategory::Message, S("Allow_accessing_UMD_globals_from_modules_6602"), S("Allow accessing UMD globals from modules.")};
        static DiagnosticMessageStore Disable_error_reporting_for_unreachable_code = {6603, DiagnosticCategory::Message, S("Disable_error_reporting_for_unreachable_code_6603"), S("Disable error reporting for unreachable code.")};
        static DiagnosticMessageStore Disable_error_reporting_for_unused_labels = {6604, DiagnosticCategory::Message, S("Disable_error_reporting_for_unused_labels_6604"), S("Disable error reporting for unused labels.")};
        static DiagnosticMessageStore Ensure_use_strict_is_always_emitted = {6605, DiagnosticCategory::Message, S("Ensure_use_strict_is_always_emitted_6605"), S("Ensure 'use strict' is always emitted.")};
        static DiagnosticMessageStore Have_recompiles_in_projects_that_use_incremental_and_watch_mode_assume_that_changes_within_a_file_will_only_affect_files_directly_depending_on_it = {6606, DiagnosticCategory::Message, S("Have_recompiles_in_projects_that_use_incremental_and_watch_mode_assume_that_changes_within_a_file_wi_6606"), S("Have recompiles in projects that use 'incremental' and 'watch' mode assume that changes within a file will only affect files directly depending on it.")};
        static DiagnosticMessageStore Specify_the_base_directory_to_resolve_non_relative_module_names = {6607, DiagnosticCategory::Message, S("Specify_the_base_directory_to_resolve_non_relative_module_names_6607"), S("Specify the base directory to resolve non-relative module names.")};
        static DiagnosticMessageStore No_longer_supported_In_early_versions_manually_set_the_text_encoding_for_reading_files = {6608, DiagnosticCategory::Message, S("No_longer_supported_In_early_versions_manually_set_the_text_encoding_for_reading_files_6608"), S("No longer supported. In early versions, manually set the text encoding for reading files.")};
        static DiagnosticMessageStore Enable_error_reporting_in_type_checked_JavaScript_files = {6609, DiagnosticCategory::Message, S("Enable_error_reporting_in_type_checked_JavaScript_files_6609"), S("Enable error reporting in type-checked JavaScript files.")};
        static DiagnosticMessageStore Enable_constraints_that_allow_a_TypeScript_project_to_be_used_with_project_references = {6611, DiagnosticCategory::Message, S("Enable_constraints_that_allow_a_TypeScript_project_to_be_used_with_project_references_6611"), S("Enable constraints that allow a TypeScript project to be used with project references.")};
        static DiagnosticMessageStore Generate_d_ts_files_from_TypeScript_and_JavaScript_files_in_your_project = {6612, DiagnosticCategory::Message, S("Generate_d_ts_files_from_TypeScript_and_JavaScript_files_in_your_project_6612"), S("Generate .d.ts files from TypeScript and JavaScript files in your project.")};
        static DiagnosticMessageStore Specify_the_output_directory_for_generated_declaration_files = {6613, DiagnosticCategory::Message, S("Specify_the_output_directory_for_generated_declaration_files_6613"), S("Specify the output directory for generated declaration files.")};
        static DiagnosticMessageStore Create_sourcemaps_for_d_ts_files = {6614, DiagnosticCategory::Message, S("Create_sourcemaps_for_d_ts_files_6614"), S("Create sourcemaps for d.ts files.")};
        static DiagnosticMessageStore Output_compiler_performance_information_after_building = {6615, DiagnosticCategory::Message, S("Output_compiler_performance_information_after_building_6615"), S("Output compiler performance information after building.")};
        static DiagnosticMessageStore Disables_inference_for_type_acquisition_by_looking_at_filenames_in_a_project = {6616, DiagnosticCategory::Message, S("Disables_inference_for_type_acquisition_by_looking_at_filenames_in_a_project_6616"), S("Disables inference for type acquisition by looking at filenames in a project.")};
        static DiagnosticMessageStore Reduce_the_number_of_projects_loaded_automatically_by_TypeScript = {6617, DiagnosticCategory::Message, S("Reduce_the_number_of_projects_loaded_automatically_by_TypeScript_6617"), S("Reduce the number of projects loaded automatically by TypeScript.")};
        static DiagnosticMessageStore Remove_the_20mb_cap_on_total_source_code_size_for_JavaScript_files_in_the_TypeScript_language_server = {6618, DiagnosticCategory::Message, S("Remove_the_20mb_cap_on_total_source_code_size_for_JavaScript_files_in_the_TypeScript_language_server_6618"), S("Remove the 20mb cap on total source code size for JavaScript files in the TypeScript language server.")};
        static DiagnosticMessageStore Opt_a_project_out_of_multi_project_reference_checking_when_editing = {6619, DiagnosticCategory::Message, S("Opt_a_project_out_of_multi_project_reference_checking_when_editing_6619"), S("Opt a project out of multi-project reference checking when editing.")};
        static DiagnosticMessageStore Disable_preferring_source_files_instead_of_declaration_files_when_referencing_composite_projects = {6620, DiagnosticCategory::Message, S("Disable_preferring_source_files_instead_of_declaration_files_when_referencing_composite_projects_6620"), S("Disable preferring source files instead of declaration files when referencing composite projects.")};
        static DiagnosticMessageStore Emit_more_compliant_but_verbose_and_less_performant_JavaScript_for_iteration = {6621, DiagnosticCategory::Message, S("Emit_more_compliant_but_verbose_and_less_performant_JavaScript_for_iteration_6621"), S("Emit more compliant, but verbose and less performant JavaScript for iteration.")};
        static DiagnosticMessageStore Emit_a_UTF_8_Byte_Order_Mark_BOM_in_the_beginning_of_output_files = {6622, DiagnosticCategory::Message, S("Emit_a_UTF_8_Byte_Order_Mark_BOM_in_the_beginning_of_output_files_6622"), S("Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files.")};
        static DiagnosticMessageStore Only_output_d_ts_files_and_not_JavaScript_files = {6623, DiagnosticCategory::Message, S("Only_output_d_ts_files_and_not_JavaScript_files_6623"), S("Only output d.ts files and not JavaScript files.")};
        static DiagnosticMessageStore Emit_design_type_metadata_for_decorated_declarations_in_source_files = {6624, DiagnosticCategory::Message, S("Emit_design_type_metadata_for_decorated_declarations_in_source_files_6624"), S("Emit design-type metadata for decorated declarations in source files.")};
        static DiagnosticMessageStore Disable_the_type_acquisition_for_JavaScript_projects = {6625, DiagnosticCategory::Message, S("Disable_the_type_acquisition_for_JavaScript_projects_6625"), S("Disable the type acquisition for JavaScript projects")};
        static DiagnosticMessageStore Emit_additional_JavaScript_to_ease_support_for_importing_CommonJS_modules_This_enables_allowSyntheticDefaultImports_for_type_compatibility = {6626, DiagnosticCategory::Message, S("Emit_additional_JavaScript_to_ease_support_for_importing_CommonJS_modules_This_enables_allowSyntheti_6626"), S("Emit additional JavaScript to ease support for importing CommonJS modules. This enables 'allowSyntheticDefaultImports' for type compatibility.")};
        static DiagnosticMessageStore Filters_results_from_the_include_option = {6627, DiagnosticCategory::Message, S("Filters_results_from_the_include_option_6627"), S("Filters results from the `include` option.")};
        static DiagnosticMessageStore Remove_a_list_of_directories_from_the_watch_process = {6628, DiagnosticCategory::Message, S("Remove_a_list_of_directories_from_the_watch_process_6628"), S("Remove a list of directories from the watch process.")};
        static DiagnosticMessageStore Remove_a_list_of_files_from_the_watch_mode_s_processing = {6629, DiagnosticCategory::Message, S("Remove_a_list_of_files_from_the_watch_mode_s_processing_6629"), S("Remove a list of files from the watch mode's processing.")};
        static DiagnosticMessageStore Enable_experimental_support_for_legacy_experimental_decorators = {6630, DiagnosticCategory::Message, S("Enable_experimental_support_for_legacy_experimental_decorators_6630"), S("Enable experimental support for legacy experimental decorators.")};
        static DiagnosticMessageStore Print_files_read_during_the_compilation_including_why_it_was_included = {6631, DiagnosticCategory::Message, S("Print_files_read_during_the_compilation_including_why_it_was_included_6631"), S("Print files read during the compilation including why it was included.")};
        static DiagnosticMessageStore Output_more_detailed_compiler_performance_information_after_building = {6632, DiagnosticCategory::Message, S("Output_more_detailed_compiler_performance_information_after_building_6632"), S("Output more detailed compiler performance information after building.")};
        static DiagnosticMessageStore Specify_one_or_more_path_or_node_module_references_to_base_configuration_files_from_which_settings_are_inherited = {6633, DiagnosticCategory::Message, S("Specify_one_or_more_path_or_node_module_references_to_base_configuration_files_from_which_settings_a_6633"), S("Specify one or more path or node module references to base configuration files from which settings are inherited.")};
        static DiagnosticMessageStore Specify_what_approach_the_watcher_should_use_if_the_system_runs_out_of_native_file_watchers = {6634, DiagnosticCategory::Message, S("Specify_what_approach_the_watcher_should_use_if_the_system_runs_out_of_native_file_watchers_6634"), S("Specify what approach the watcher should use if the system runs out of native file watchers.")};
        static DiagnosticMessageStore Include_a_list_of_files_This_does_not_support_glob_patterns_as_opposed_to_include = {6635, DiagnosticCategory::Message, S("Include_a_list_of_files_This_does_not_support_glob_patterns_as_opposed_to_include_6635"), S("Include a list of files. This does not support glob patterns, as opposed to `include`.")};
        static DiagnosticMessageStore Build_all_projects_including_those_that_appear_to_be_up_to_date = {6636, DiagnosticCategory::Message, S("Build_all_projects_including_those_that_appear_to_be_up_to_date_6636"), S("Build all projects, including those that appear to be up to date.")};
        static DiagnosticMessageStore Ensure_that_casing_is_correct_in_imports = {6637, DiagnosticCategory::Message, S("Ensure_that_casing_is_correct_in_imports_6637"), S("Ensure that casing is correct in imports.")};
        static DiagnosticMessageStore Emit_a_v8_CPU_profile_of_the_compiler_run_for_debugging = {6638, DiagnosticCategory::Message, S("Emit_a_v8_CPU_profile_of_the_compiler_run_for_debugging_6638"), S("Emit a v8 CPU profile of the compiler run for debugging.")};
        static DiagnosticMessageStore Allow_importing_helper_functions_from_tslib_once_per_project_instead_of_including_them_per_file = {6639, DiagnosticCategory::Message, S("Allow_importing_helper_functions_from_tslib_once_per_project_instead_of_including_them_per_file_6639"), S("Allow importing helper functions from tslib once per project, instead of including them per-file.")};
        static DiagnosticMessageStore Specify_a_list_of_glob_patterns_that_match_files_to_be_included_in_compilation = {6641, DiagnosticCategory::Message, S("Specify_a_list_of_glob_patterns_that_match_files_to_be_included_in_compilation_6641"), S("Specify a list of glob patterns that match files to be included in compilation.")};
        static DiagnosticMessageStore Save_tsbuildinfo_files_to_allow_for_incremental_compilation_of_projects = {6642, DiagnosticCategory::Message, S("Save_tsbuildinfo_files_to_allow_for_incremental_compilation_of_projects_6642"), S("Save .tsbuildinfo files to allow for incremental compilation of projects.")};
        static DiagnosticMessageStore Include_sourcemap_files_inside_the_emitted_JavaScript = {6643, DiagnosticCategory::Message, S("Include_sourcemap_files_inside_the_emitted_JavaScript_6643"), S("Include sourcemap files inside the emitted JavaScript.")};
        static DiagnosticMessageStore Include_source_code_in_the_sourcemaps_inside_the_emitted_JavaScript = {6644, DiagnosticCategory::Message, S("Include_source_code_in_the_sourcemaps_inside_the_emitted_JavaScript_6644"), S("Include source code in the sourcemaps inside the emitted JavaScript.")};
        static DiagnosticMessageStore Ensure_that_each_file_can_be_safely_transpiled_without_relying_on_other_imports = {6645, DiagnosticCategory::Message, S("Ensure_that_each_file_can_be_safely_transpiled_without_relying_on_other_imports_6645"), S("Ensure that each file can be safely transpiled without relying on other imports.")};
        static DiagnosticMessageStore Specify_what_JSX_code_is_generated = {6646, DiagnosticCategory::Message, S("Specify_what_JSX_code_is_generated_6646"), S("Specify what JSX code is generated.")};
        static DiagnosticMessageStore Specify_the_JSX_factory_function_used_when_targeting_React_JSX_emit_e_g_React_createElement_or_h = {6647, DiagnosticCategory::Message, S("Specify_the_JSX_factory_function_used_when_targeting_React_JSX_emit_e_g_React_createElement_or_h_6647"), S("Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'.")};
        static DiagnosticMessageStore Specify_the_JSX_Fragment_reference_used_for_fragments_when_targeting_React_JSX_emit_e_g_React_Fragment_or_Fragment = {6648, DiagnosticCategory::Message, S("Specify_the_JSX_Fragment_reference_used_for_fragments_when_targeting_React_JSX_emit_e_g_React_Fragme_6648"), S("Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'.")};
        static DiagnosticMessageStore Specify_module_specifier_used_to_import_the_JSX_factory_functions_when_using_jsx_Colon_react_jsx_Asterisk = {6649, DiagnosticCategory::Message, S("Specify_module_specifier_used_to_import_the_JSX_factory_functions_when_using_jsx_Colon_react_jsx_Ast_6649"), S("Specify module specifier used to import the JSX factory functions when using 'jsx: react-jsx*'.")};
        static DiagnosticMessageStore Make_keyof_only_return_strings_instead_of_string_numbers_or_symbols_Legacy_option = {6650, DiagnosticCategory::Message, S("Make_keyof_only_return_strings_instead_of_string_numbers_or_symbols_Legacy_option_6650"), S("Make keyof only return strings instead of string, numbers or symbols. Legacy option.")};
        static DiagnosticMessageStore Specify_a_set_of_bundled_library_declaration_files_that_describe_the_target_runtime_environment = {6651, DiagnosticCategory::Message, S("Specify_a_set_of_bundled_library_declaration_files_that_describe_the_target_runtime_environment_6651"), S("Specify a set of bundled library declaration files that describe the target runtime environment.")};
        static DiagnosticMessageStore Print_the_names_of_emitted_files_after_a_compilation = {6652, DiagnosticCategory::Message, S("Print_the_names_of_emitted_files_after_a_compilation_6652"), S("Print the names of emitted files after a compilation.")};
        static DiagnosticMessageStore Print_all_of_the_files_read_during_the_compilation = {6653, DiagnosticCategory::Message, S("Print_all_of_the_files_read_during_the_compilation_6653"), S("Print all of the files read during the compilation.")};
        static DiagnosticMessageStore Set_the_language_of_the_messaging_from_TypeScript_This_does_not_affect_emit = {6654, DiagnosticCategory::Message, S("Set_the_language_of_the_messaging_from_TypeScript_This_does_not_affect_emit_6654"), S("Set the language of the messaging from TypeScript. This does not affect emit.")};
        static DiagnosticMessageStore Specify_the_location_where_debugger_should_locate_map_files_instead_of_generated_locations = {6655, DiagnosticCategory::Message, S("Specify_the_location_where_debugger_should_locate_map_files_instead_of_generated_locations_6655"), S("Specify the location where debugger should locate map files instead of generated locations.")};
        static DiagnosticMessageStore Specify_the_maximum_folder_depth_used_for_checking_JavaScript_files_from_node_modules_Only_applicable_with_allowJs = {6656, DiagnosticCategory::Message, S("Specify_the_maximum_folder_depth_used_for_checking_JavaScript_files_from_node_modules_Only_applicabl_6656"), S("Specify the maximum folder depth used for checking JavaScript files from 'node_modules'. Only applicable with 'allowJs'.")};
        static DiagnosticMessageStore Specify_what_module_code_is_generated = {6657, DiagnosticCategory::Message, S("Specify_what_module_code_is_generated_6657"), S("Specify what module code is generated.")};
        static DiagnosticMessageStore Specify_how_TypeScript_looks_up_a_file_from_a_given_module_specifier = {6658, DiagnosticCategory::Message, S("Specify_how_TypeScript_looks_up_a_file_from_a_given_module_specifier_6658"), S("Specify how TypeScript looks up a file from a given module specifier.")};
        static DiagnosticMessageStore Set_the_newline_character_for_emitting_files = {6659, DiagnosticCategory::Message, S("Set_the_newline_character_for_emitting_files_6659"), S("Set the newline character for emitting files.")};
        static DiagnosticMessageStore Disable_emitting_files_from_a_compilation = {6660, DiagnosticCategory::Message, S("Disable_emitting_files_from_a_compilation_6660"), S("Disable emitting files from a compilation.")};
        static DiagnosticMessageStore Disable_generating_custom_helper_functions_like_extends_in_compiled_output = {6661, DiagnosticCategory::Message, S("Disable_generating_custom_helper_functions_like_extends_in_compiled_output_6661"), S("Disable generating custom helper functions like '__extends' in compiled output.")};
        static DiagnosticMessageStore Disable_emitting_files_if_any_type_checking_errors_are_reported = {6662, DiagnosticCategory::Message, S("Disable_emitting_files_if_any_type_checking_errors_are_reported_6662"), S("Disable emitting files if any type checking errors are reported.")};
        static DiagnosticMessageStore Disable_truncating_types_in_error_messages = {6663, DiagnosticCategory::Message, S("Disable_truncating_types_in_error_messages_6663"), S("Disable truncating types in error messages.")};
        static DiagnosticMessageStore Enable_error_reporting_for_fallthrough_cases_in_switch_statements = {6664, DiagnosticCategory::Message, S("Enable_error_reporting_for_fallthrough_cases_in_switch_statements_6664"), S("Enable error reporting for fallthrough cases in switch statements.")};
        static DiagnosticMessageStore Enable_error_reporting_for_expressions_and_declarations_with_an_implied_any_type = {6665, DiagnosticCategory::Message, S("Enable_error_reporting_for_expressions_and_declarations_with_an_implied_any_type_6665"), S("Enable error reporting for expressions and declarations with an implied 'any' type.")};
        static DiagnosticMessageStore Ensure_overriding_members_in_derived_classes_are_marked_with_an_override_modifier = {6666, DiagnosticCategory::Message, S("Ensure_overriding_members_in_derived_classes_are_marked_with_an_override_modifier_6666"), S("Ensure overriding members in derived classes are marked with an override modifier.")};
        static DiagnosticMessageStore Enable_error_reporting_for_codepaths_that_do_not_explicitly_return_in_a_function = {6667, DiagnosticCategory::Message, S("Enable_error_reporting_for_codepaths_that_do_not_explicitly_return_in_a_function_6667"), S("Enable error reporting for codepaths that do not explicitly return in a function.")};
        static DiagnosticMessageStore Enable_error_reporting_when_this_is_given_the_type_any = {6668, DiagnosticCategory::Message, S("Enable_error_reporting_when_this_is_given_the_type_any_6668"), S("Enable error reporting when 'this' is given the type 'any'.")};
        static DiagnosticMessageStore Disable_adding_use_strict_directives_in_emitted_JavaScript_files = {6669, DiagnosticCategory::Message, S("Disable_adding_use_strict_directives_in_emitted_JavaScript_files_6669"), S("Disable adding 'use strict' directives in emitted JavaScript files.")};
        static DiagnosticMessageStore Disable_including_any_library_files_including_the_default_lib_d_ts = {6670, DiagnosticCategory::Message, S("Disable_including_any_library_files_including_the_default_lib_d_ts_6670"), S("Disable including any library files, including the default lib.d.ts.")};
        static DiagnosticMessageStore Enforces_using_indexed_accessors_for_keys_declared_using_an_indexed_type = {6671, DiagnosticCategory::Message, S("Enforces_using_indexed_accessors_for_keys_declared_using_an_indexed_type_6671"), S("Enforces using indexed accessors for keys declared using an indexed type.")};
        static DiagnosticMessageStore Disallow_import_s_require_s_or_reference_s_from_expanding_the_number_of_files_TypeScript_should_add_to_a_project = {6672, DiagnosticCategory::Message, S("Disallow_import_s_require_s_or_reference_s_from_expanding_the_number_of_files_TypeScript_should_add__6672"), S("Disallow 'import's, 'require's or '<reference>'s from expanding the number of files TypeScript should add to a project.")};
        static DiagnosticMessageStore Disable_strict_checking_of_generic_signatures_in_function_types = {6673, DiagnosticCategory::Message, S("Disable_strict_checking_of_generic_signatures_in_function_types_6673"), S("Disable strict checking of generic signatures in function types.")};
        static DiagnosticMessageStore Add_undefined_to_a_type_when_accessed_using_an_index = {6674, DiagnosticCategory::Message, S("Add_undefined_to_a_type_when_accessed_using_an_index_6674"), S("Add 'undefined' to a type when accessed using an index.")};
        static DiagnosticMessageStore Enable_error_reporting_when_local_variables_aren_t_read = {6675, DiagnosticCategory::Message, S("Enable_error_reporting_when_local_variables_aren_t_read_6675"), S("Enable error reporting when local variables aren't read.")};
        static DiagnosticMessageStore Raise_an_error_when_a_function_parameter_isn_t_read = {6676, DiagnosticCategory::Message, S("Raise_an_error_when_a_function_parameter_isn_t_read_6676"), S("Raise an error when a function parameter isn't read.")};
        static DiagnosticMessageStore Deprecated_setting_Use_outFile_instead = {6677, DiagnosticCategory::Message, S("Deprecated_setting_Use_outFile_instead_6677"), S("Deprecated setting. Use 'outFile' instead.")};
        static DiagnosticMessageStore Specify_an_output_folder_for_all_emitted_files = {6678, DiagnosticCategory::Message, S("Specify_an_output_folder_for_all_emitted_files_6678"), S("Specify an output folder for all emitted files.")};
        static DiagnosticMessageStore Specify_a_file_that_bundles_all_outputs_into_one_JavaScript_file_If_declaration_is_true_also_designates_a_file_that_bundles_all_d_ts_output = {6679, DiagnosticCategory::Message, S("Specify_a_file_that_bundles_all_outputs_into_one_JavaScript_file_If_declaration_is_true_also_designa_6679"), S("Specify a file that bundles all outputs into one JavaScript file. If 'declaration' is true, also designates a file that bundles all .d.ts output.")};
        static DiagnosticMessageStore Specify_a_set_of_entries_that_re_map_imports_to_additional_lookup_locations = {6680, DiagnosticCategory::Message, S("Specify_a_set_of_entries_that_re_map_imports_to_additional_lookup_locations_6680"), S("Specify a set of entries that re-map imports to additional lookup locations.")};
        static DiagnosticMessageStore Specify_a_list_of_language_service_plugins_to_include = {6681, DiagnosticCategory::Message, S("Specify_a_list_of_language_service_plugins_to_include_6681"), S("Specify a list of language service plugins to include.")};
        static DiagnosticMessageStore Disable_erasing_const_enum_declarations_in_generated_code = {6682, DiagnosticCategory::Message, S("Disable_erasing_const_enum_declarations_in_generated_code_6682"), S("Disable erasing 'const enum' declarations in generated code.")};
        static DiagnosticMessageStore Disable_resolving_symlinks_to_their_realpath_This_correlates_to_the_same_flag_in_node = {6683, DiagnosticCategory::Message, S("Disable_resolving_symlinks_to_their_realpath_This_correlates_to_the_same_flag_in_node_6683"), S("Disable resolving symlinks to their realpath. This correlates to the same flag in node.")};
        static DiagnosticMessageStore Disable_wiping_the_console_in_watch_mode = {6684, DiagnosticCategory::Message, S("Disable_wiping_the_console_in_watch_mode_6684"), S("Disable wiping the console in watch mode.")};
        static DiagnosticMessageStore Enable_color_and_formatting_in_TypeScript_s_output_to_make_compiler_errors_easier_to_read = {6685, DiagnosticCategory::Message, S("Enable_color_and_formatting_in_TypeScript_s_output_to_make_compiler_errors_easier_to_read_6685"), S("Enable color and formatting in TypeScript's output to make compiler errors easier to read.")};
        static DiagnosticMessageStore Specify_the_object_invoked_for_createElement_This_only_applies_when_targeting_react_JSX_emit = {6686, DiagnosticCategory::Message, S("Specify_the_object_invoked_for_createElement_This_only_applies_when_targeting_react_JSX_emit_6686"), S("Specify the object invoked for 'createElement'. This only applies when targeting 'react' JSX emit.")};
        static DiagnosticMessageStore Specify_an_array_of_objects_that_specify_paths_for_projects_Used_in_project_references = {6687, DiagnosticCategory::Message, S("Specify_an_array_of_objects_that_specify_paths_for_projects_Used_in_project_references_6687"), S("Specify an array of objects that specify paths for projects. Used in project references.")};
        static DiagnosticMessageStore Disable_emitting_comments = {6688, DiagnosticCategory::Message, S("Disable_emitting_comments_6688"), S("Disable emitting comments.")};
        static DiagnosticMessageStore Enable_importing_json_files = {6689, DiagnosticCategory::Message, S("Enable_importing_json_files_6689"), S("Enable importing .json files.")};
        static DiagnosticMessageStore Specify_the_root_folder_within_your_source_files = {6690, DiagnosticCategory::Message, S("Specify_the_root_folder_within_your_source_files_6690"), S("Specify the root folder within your source files.")};
        static DiagnosticMessageStore Allow_multiple_folders_to_be_treated_as_one_when_resolving_modules = {6691, DiagnosticCategory::Message, S("Allow_multiple_folders_to_be_treated_as_one_when_resolving_modules_6691"), S("Allow multiple folders to be treated as one when resolving modules.")};
        static DiagnosticMessageStore Skip_type_checking_d_ts_files_that_are_included_with_TypeScript = {6692, DiagnosticCategory::Message, S("Skip_type_checking_d_ts_files_that_are_included_with_TypeScript_6692"), S("Skip type checking .d.ts files that are included with TypeScript.")};
        static DiagnosticMessageStore Skip_type_checking_all_d_ts_files = {6693, DiagnosticCategory::Message, S("Skip_type_checking_all_d_ts_files_6693"), S("Skip type checking all .d.ts files.")};
        static DiagnosticMessageStore Create_source_map_files_for_emitted_JavaScript_files = {6694, DiagnosticCategory::Message, S("Create_source_map_files_for_emitted_JavaScript_files_6694"), S("Create source map files for emitted JavaScript files.")};
        static DiagnosticMessageStore Specify_the_root_path_for_debuggers_to_find_the_reference_source_code = {6695, DiagnosticCategory::Message, S("Specify_the_root_path_for_debuggers_to_find_the_reference_source_code_6695"), S("Specify the root path for debuggers to find the reference source code.")};
        static DiagnosticMessageStore Check_that_the_arguments_for_bind_call_and_apply_methods_match_the_original_function = {6697, DiagnosticCategory::Message, S("Check_that_the_arguments_for_bind_call_and_apply_methods_match_the_original_function_6697"), S("Check that the arguments for 'bind', 'call', and 'apply' methods match the original function.")};
        static DiagnosticMessageStore When_assigning_functions_check_to_ensure_parameters_and_the_return_values_are_subtype_compatible = {6698, DiagnosticCategory::Message, S("When_assigning_functions_check_to_ensure_parameters_and_the_return_values_are_subtype_compatible_6698"), S("When assigning functions, check to ensure parameters and the return values are subtype-compatible.")};
        static DiagnosticMessageStore When_type_checking_take_into_account_null_and_undefined = {6699, DiagnosticCategory::Message, S("When_type_checking_take_into_account_null_and_undefined_6699"), S("When type checking, take into account 'null' and 'undefined'.")};
        static DiagnosticMessageStore Check_for_class_properties_that_are_declared_but_not_set_in_the_constructor = {6700, DiagnosticCategory::Message, S("Check_for_class_properties_that_are_declared_but_not_set_in_the_constructor_6700"), S("Check for class properties that are declared but not set in the constructor.")};
        static DiagnosticMessageStore Disable_emitting_declarations_that_have_internal_in_their_JSDoc_comments = {6701, DiagnosticCategory::Message, S("Disable_emitting_declarations_that_have_internal_in_their_JSDoc_comments_6701"), S("Disable emitting declarations that have '@internal' in their JSDoc comments.")};
        static DiagnosticMessageStore Disable_reporting_of_excess_property_errors_during_the_creation_of_object_literals = {6702, DiagnosticCategory::Message, S("Disable_reporting_of_excess_property_errors_during_the_creation_of_object_literals_6702"), S("Disable reporting of excess property errors during the creation of object literals.")};
        static DiagnosticMessageStore Suppress_noImplicitAny_errors_when_indexing_objects_that_lack_index_signatures = {6703, DiagnosticCategory::Message, S("Suppress_noImplicitAny_errors_when_indexing_objects_that_lack_index_signatures_6703"), S("Suppress 'noImplicitAny' errors when indexing objects that lack index signatures.")};
        static DiagnosticMessageStore Synchronously_call_callbacks_and_update_the_state_of_directory_watchers_on_platforms_that_don_t_support_recursive_watching_natively = {6704, DiagnosticCategory::Message, S("Synchronously_call_callbacks_and_update_the_state_of_directory_watchers_on_platforms_that_don_t_supp_6704"), S("Synchronously call callbacks and update the state of directory watchers on platforms that don`t support recursive watching natively.")};
        static DiagnosticMessageStore Set_the_JavaScript_language_version_for_emitted_JavaScript_and_include_compatible_library_declarations = {6705, DiagnosticCategory::Message, S("Set_the_JavaScript_language_version_for_emitted_JavaScript_and_include_compatible_library_declaratio_6705"), S("Set the JavaScript language version for emitted JavaScript and include compatible library declarations.")};
        static DiagnosticMessageStore Log_paths_used_during_the_moduleResolution_process = {6706, DiagnosticCategory::Message, S("Log_paths_used_during_the_moduleResolution_process_6706"), S("Log paths used during the 'moduleResolution' process.")};
        static DiagnosticMessageStore Specify_the_path_to_tsbuildinfo_incremental_compilation_file = {6707, DiagnosticCategory::Message, S("Specify_the_path_to_tsbuildinfo_incremental_compilation_file_6707"), S("Specify the path to .tsbuildinfo incremental compilation file.")};
        static DiagnosticMessageStore Specify_options_for_automatic_acquisition_of_declaration_files = {6709, DiagnosticCategory::Message, S("Specify_options_for_automatic_acquisition_of_declaration_files_6709"), S("Specify options for automatic acquisition of declaration files.")};
        static DiagnosticMessageStore Specify_multiple_folders_that_act_like_Slashnode_modules_Slash_types = {6710, DiagnosticCategory::Message, S("Specify_multiple_folders_that_act_like_Slashnode_modules_Slash_types_6710"), S("Specify multiple folders that act like './node_modules/@types'.")};
        static DiagnosticMessageStore Specify_type_package_names_to_be_included_without_being_referenced_in_a_source_file = {6711, DiagnosticCategory::Message, S("Specify_type_package_names_to_be_included_without_being_referenced_in_a_source_file_6711"), S("Specify type package names to be included without being referenced in a source file.")};
        static DiagnosticMessageStore Emit_ECMAScript_standard_compliant_class_fields = {6712, DiagnosticCategory::Message, S("Emit_ECMAScript_standard_compliant_class_fields_6712"), S("Emit ECMAScript-standard-compliant class fields.")};
        static DiagnosticMessageStore Enable_verbose_logging = {6713, DiagnosticCategory::Message, S("Enable_verbose_logging_6713"), S("Enable verbose logging.")};
        static DiagnosticMessageStore Specify_how_directories_are_watched_on_systems_that_lack_recursive_file_watching_functionality = {6714, DiagnosticCategory::Message, S("Specify_how_directories_are_watched_on_systems_that_lack_recursive_file_watching_functionality_6714"), S("Specify how directories are watched on systems that lack recursive file-watching functionality.")};
        static DiagnosticMessageStore Specify_how_the_TypeScript_watch_mode_works = {6715, DiagnosticCategory::Message, S("Specify_how_the_TypeScript_watch_mode_works_6715"), S("Specify how the TypeScript watch mode works.")};
        static DiagnosticMessageStore Require_undeclared_properties_from_index_signatures_to_use_element_accesses = {6717, DiagnosticCategory::Message, S("Require_undeclared_properties_from_index_signatures_to_use_element_accesses_6717"), S("Require undeclared properties from index signatures to use element accesses.")};
        static DiagnosticMessageStore Specify_emit_Slashchecking_behavior_for_imports_that_are_only_used_for_types = {6718, DiagnosticCategory::Message, S("Specify_emit_Slashchecking_behavior_for_imports_that_are_only_used_for_types_6718"), S("Specify emit/checking behavior for imports that are only used for types.")};
        static DiagnosticMessageStore Default_catch_clause_variables_as_unknown_instead_of_any = {6803, DiagnosticCategory::Message, S("Default_catch_clause_variables_as_unknown_instead_of_any_6803"), S("Default catch clause variables as 'unknown' instead of 'any'.")};
        static DiagnosticMessageStore Do_not_transform_or_elide_any_imports_or_exports_not_marked_as_type_only_ensuring_they_are_written_in_the_output_file_s_format_based_on_the_module_setting = {6804, DiagnosticCategory::Message, S("Do_not_transform_or_elide_any_imports_or_exports_not_marked_as_type_only_ensuring_they_are_written_i_6804"), S("Do not transform or elide any imports or exports not marked as type-only, ensuring they are written in the output file's format based on the 'module' setting.")};
        static DiagnosticMessageStore one_of_Colon = {6900, DiagnosticCategory::Message, S("one_of_Colon_6900"), S("one of:")};
        static DiagnosticMessageStore one_or_more_Colon = {6901, DiagnosticCategory::Message, S("one_or_more_Colon_6901"), S("one or more:")};
        static DiagnosticMessageStore type_Colon = {6902, DiagnosticCategory::Message, S("type_Colon_6902"), S("type:")};
        static DiagnosticMessageStore default_Colon = {6903, DiagnosticCategory::Message, S("default_Colon_6903"), S("default:")};
        static DiagnosticMessageStore module_system_or_esModuleInterop = {6904, DiagnosticCategory::Message, S("module_system_or_esModuleInterop_6904"), S("module === \"system\" or esModuleInterop")};
        static DiagnosticMessageStore false_unless_strict_is_set = {6905, DiagnosticCategory::Message, S("false_unless_strict_is_set_6905"), S("`false`, unless `strict` is set")};
        static DiagnosticMessageStore false_unless_composite_is_set = {6906, DiagnosticCategory::Message, S("false_unless_composite_is_set_6906"), S("`false`, unless `composite` is set")};
        static DiagnosticMessageStore node_modules_bower_components_jspm_packages_plus_the_value_of_outDir_if_one_is_specified = {6907, DiagnosticCategory::Message, S("node_modules_bower_components_jspm_packages_plus_the_value_of_outDir_if_one_is_specified_6907"), S("`[\"node_modules\", \"bower_components\", \"jspm_packages\"]`, plus the value of `outDir` if one is specified.")};
        static DiagnosticMessageStore if_files_is_specified_otherwise_Asterisk_Asterisk_Slash_Asterisk = {6908, DiagnosticCategory::Message, S("if_files_is_specified_otherwise_Asterisk_Asterisk_Slash_Asterisk_6908"), S("`[]` if `files` is specified, otherwise `[\"**/*\"]`")};
        static DiagnosticMessageStore true_if_composite_false_otherwise = {6909, DiagnosticCategory::Message, S("true_if_composite_false_otherwise_6909"), S("`true` if `composite`, `false` otherwise")};
        static DiagnosticMessageStore module_AMD_or_UMD_or_System_or_ES6_then_Classic_Otherwise_Node = {69010, DiagnosticCategory::Message, S("module_AMD_or_UMD_or_System_or_ES6_then_Classic_Otherwise_Node_69010"), S("module === `AMD` or `UMD` or `System` or `ES6`, then `Classic`, Otherwise `Node`")};
        static DiagnosticMessageStore Computed_from_the_list_of_input_files = {6911, DiagnosticCategory::Message, S("Computed_from_the_list_of_input_files_6911"), S("Computed from the list of input files")};
        static DiagnosticMessageStore Platform_specific = {6912, DiagnosticCategory::Message, S("Platform_specific_6912"), S("Platform specific")};
        static DiagnosticMessageStore You_can_learn_about_all_of_the_compiler_options_at_0 = {6913, DiagnosticCategory::Message, S("You_can_learn_about_all_of_the_compiler_options_at_0_6913"), S("You can learn about all of the compiler options at {0}")};
        static DiagnosticMessageStore Including_watch_w_will_start_watching_the_current_project_for_the_file_changes_Once_set_you_can_config_watch_mode_with_Colon = {6914, DiagnosticCategory::Message, S("Including_watch_w_will_start_watching_the_current_project_for_the_file_changes_Once_set_you_can_conf_6914"), S("Including --watch, -w will start watching the current project for the file changes. Once set, you can config watch mode with:")};
        static DiagnosticMessageStore Using_build_b_will_make_tsc_behave_more_like_a_build_orchestrator_than_a_compiler_This_is_used_to_trigger_building_composite_projects_which_you_can_learn_more_about_at_0 = {6915, DiagnosticCategory::Message, S("Using_build_b_will_make_tsc_behave_more_like_a_build_orchestrator_than_a_compiler_This_is_used_to_tr_6915"), S("Using --build, -b will make tsc behave more like a build orchestrator than a compiler. This is used to trigger building composite projects which you can learn more about at {0}")};
        static DiagnosticMessageStore COMMON_COMMANDS = {6916, DiagnosticCategory::Message, S("COMMON_COMMANDS_6916"), S("COMMON COMMANDS")};
        static DiagnosticMessageStore ALL_COMPILER_OPTIONS = {6917, DiagnosticCategory::Message, S("ALL_COMPILER_OPTIONS_6917"), S("ALL COMPILER OPTIONS")};
        static DiagnosticMessageStore WATCH_OPTIONS = {6918, DiagnosticCategory::Message, S("WATCH_OPTIONS_6918"), S("WATCH OPTIONS")};
        static DiagnosticMessageStore BUILD_OPTIONS = {6919, DiagnosticCategory::Message, S("BUILD_OPTIONS_6919"), S("BUILD OPTIONS")};
        static DiagnosticMessageStore COMMON_COMPILER_OPTIONS = {6920, DiagnosticCategory::Message, S("COMMON_COMPILER_OPTIONS_6920"), S("COMMON COMPILER OPTIONS")};
        static DiagnosticMessageStore COMMAND_LINE_FLAGS = {6921, DiagnosticCategory::Message, S("COMMAND_LINE_FLAGS_6921"), S("COMMAND LINE FLAGS")};
        static DiagnosticMessageStore tsc_Colon_The_TypeScript_Compiler = {6922, DiagnosticCategory::Message, S("tsc_Colon_The_TypeScript_Compiler_6922"), S("tsc: The TypeScript Compiler")};
        static DiagnosticMessageStore Compiles_the_current_project_tsconfig_json_in_the_working_directory = {6923, DiagnosticCategory::Message, S("Compiles_the_current_project_tsconfig_json_in_the_working_directory_6923"), S("Compiles the current project (tsconfig.json in the working directory.)")};
        static DiagnosticMessageStore Ignoring_tsconfig_json_compiles_the_specified_files_with_default_compiler_options = {6924, DiagnosticCategory::Message, S("Ignoring_tsconfig_json_compiles_the_specified_files_with_default_compiler_options_6924"), S("Ignoring tsconfig.json, compiles the specified files with default compiler options.")};
        static DiagnosticMessageStore Build_a_composite_project_in_the_working_directory = {6925, DiagnosticCategory::Message, S("Build_a_composite_project_in_the_working_directory_6925"), S("Build a composite project in the working directory.")};
        static DiagnosticMessageStore Creates_a_tsconfig_json_with_the_recommended_settings_in_the_working_directory = {6926, DiagnosticCategory::Message, S("Creates_a_tsconfig_json_with_the_recommended_settings_in_the_working_directory_6926"), S("Creates a tsconfig.json with the recommended settings in the working directory.")};
        static DiagnosticMessageStore Compiles_the_TypeScript_project_located_at_the_specified_path = {6927, DiagnosticCategory::Message, S("Compiles_the_TypeScript_project_located_at_the_specified_path_6927"), S("Compiles the TypeScript project located at the specified path.")};
        static DiagnosticMessageStore An_expanded_version_of_this_information_showing_all_possible_compiler_options = {6928, DiagnosticCategory::Message, S("An_expanded_version_of_this_information_showing_all_possible_compiler_options_6928"), S("An expanded version of this information, showing all possible compiler options")};
        static DiagnosticMessageStore Compiles_the_current_project_with_additional_settings = {6929, DiagnosticCategory::Message, S("Compiles_the_current_project_with_additional_settings_6929"), S("Compiles the current project, with additional settings.")};
        static DiagnosticMessageStore true_for_ES2022_and_above_including_ESNext = {6930, DiagnosticCategory::Message, S("true_for_ES2022_and_above_including_ESNext_6930"), S("`true` for ES2022 and above, including ESNext.")};
        static DiagnosticMessageStore List_of_file_name_suffixes_to_search_when_resolving_a_module = {6931, DiagnosticCategory::Error, S("List_of_file_name_suffixes_to_search_when_resolving_a_module_6931"), S("List of file name suffixes to search when resolving a module.")};
        static DiagnosticMessageStore Variable_0_implicitly_has_an_1_type = {7005, DiagnosticCategory::Error, S("Variable_0_implicitly_has_an_1_type_7005"), S("Variable '{0}' implicitly has an '{1}' type.")};
        static DiagnosticMessageStore Parameter_0_implicitly_has_an_1_type = {7006, DiagnosticCategory::Error, S("Parameter_0_implicitly_has_an_1_type_7006"), S("Parameter '{0}' implicitly has an '{1}' type.")};
        static DiagnosticMessageStore Member_0_implicitly_has_an_1_type = {7008, DiagnosticCategory::Error, S("Member_0_implicitly_has_an_1_type_7008"), S("Member '{0}' implicitly has an '{1}' type.")};
        static DiagnosticMessageStore new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type = {7009, DiagnosticCategory::Error, S("new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type_7009"), S("'new' expression, whose target lacks a construct signature, implicitly has an 'any' type.")};
        static DiagnosticMessageStore _0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type = {7010, DiagnosticCategory::Error, S("_0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type_7010"), S("'{0}', which lacks return-type annotation, implicitly has an '{1}' return type.")};
        static DiagnosticMessageStore Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type = {7011, DiagnosticCategory::Error, S("Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type_7011"), S("Function expression, which lacks return-type annotation, implicitly has an '{0}' return type.")};
        static DiagnosticMessageStore This_overload_implicitly_returns_the_type_0_because_it_lacks_a_return_type_annotation = {7012, DiagnosticCategory::Error, S("This_overload_implicitly_returns_the_type_0_because_it_lacks_a_return_type_annotation_7012"), S("This overload implicitly returns the type '{0}' because it lacks a return type annotation.")};
        static DiagnosticMessageStore Construct_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type = {7013, DiagnosticCategory::Error, S("Construct_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type_7013"), S("Construct signature, which lacks return-type annotation, implicitly has an 'any' return type.")};
        static DiagnosticMessageStore Function_type_which_lacks_return_type_annotation_implicitly_has_an_0_return_type = {7014, DiagnosticCategory::Error, S("Function_type_which_lacks_return_type_annotation_implicitly_has_an_0_return_type_7014"), S("Function type, which lacks return-type annotation, implicitly has an '{0}' return type.")};
        static DiagnosticMessageStore Element_implicitly_has_an_any_type_because_index_expression_is_not_of_type_number = {7015, DiagnosticCategory::Error, S("Element_implicitly_has_an_any_type_because_index_expression_is_not_of_type_number_7015"), S("Element implicitly has an 'any' type because index expression is not of type 'number'.")};
        static DiagnosticMessageStore Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type = {7016, DiagnosticCategory::Error, S("Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type_7016"), S("Could not find a declaration file for module '{0}'. '{1}' implicitly has an 'any' type.")};
        static DiagnosticMessageStore Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature = {7017, DiagnosticCategory::Error, S("Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature_7017"), S("Element implicitly has an 'any' type because type '{0}' has no index signature.")};
        static DiagnosticMessageStore Object_literal_s_property_0_implicitly_has_an_1_type = {7018, DiagnosticCategory::Error, S("Object_literal_s_property_0_implicitly_has_an_1_type_7018"), S("Object literal's property '{0}' implicitly has an '{1}' type.")};
        static DiagnosticMessageStore Rest_parameter_0_implicitly_has_an_any_type = {7019, DiagnosticCategory::Error, S("Rest_parameter_0_implicitly_has_an_any_type_7019"), S("Rest parameter '{0}' implicitly has an 'any[]' type.")};
        static DiagnosticMessageStore Call_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type = {7020, DiagnosticCategory::Error, S("Call_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type_7020"), S("Call signature, which lacks return-type annotation, implicitly has an 'any' return type.")};
        static DiagnosticMessageStore _0_implicitly_has_type_any_because_it_does_not_have_a_type_annotation_and_is_referenced_directly_or_indirectly_in_its_own_initializer = {7022, DiagnosticCategory::Error, S("_0_implicitly_has_type_any_because_it_does_not_have_a_type_annotation_and_is_referenced_directly_or__7022"), S("'{0}' implicitly has type 'any' because it does not have a type annotation and is referenced directly or indirectly in its own initializer.")};
        static DiagnosticMessageStore _0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions = {7023, DiagnosticCategory::Error, S("_0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_reference_7023"), S("'{0}' implicitly has return type 'any' because it does not have a return type annotation and is referenced directly or indirectly in one of its return expressions.")};
        static DiagnosticMessageStore Function_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions = {7024, DiagnosticCategory::Error, S("Function_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_ref_7024"), S("Function implicitly has return type 'any' because it does not have a return type annotation and is referenced directly or indirectly in one of its return expressions.")};
        static DiagnosticMessageStore Generator_implicitly_has_yield_type_0_because_it_does_not_yield_any_values_Consider_supplying_a_return_type_annotation = {7025, DiagnosticCategory::Error, S("Generator_implicitly_has_yield_type_0_because_it_does_not_yield_any_values_Consider_supplying_a_retu_7025"), S("Generator implicitly has yield type '{0}' because it does not yield any values. Consider supplying a return type annotation.")};
        static DiagnosticMessageStore JSX_element_implicitly_has_type_any_because_no_interface_JSX_0_exists = {7026, DiagnosticCategory::Error, S("JSX_element_implicitly_has_type_any_because_no_interface_JSX_0_exists_7026"), S("JSX element implicitly has type 'any' because no interface 'JSX.{0}' exists.")};
        static DiagnosticMessageStore Unreachable_code_detected = {7027, DiagnosticCategory::Error, S("Unreachable_code_detected_7027"), S("Unreachable code detected.")};
        static DiagnosticMessageStore Unused_label = {7028, DiagnosticCategory::Error, S("Unused_label_7028"), S("Unused label.")};
        static DiagnosticMessageStore Fallthrough_case_in_switch = {7029, DiagnosticCategory::Error, S("Fallthrough_case_in_switch_7029"), S("Fallthrough case in switch.")};
        static DiagnosticMessageStore Not_all_code_paths_return_a_value = {7030, DiagnosticCategory::Error, S("Not_all_code_paths_return_a_value_7030"), S("Not all code paths return a value.")};
        static DiagnosticMessageStore Binding_element_0_implicitly_has_an_1_type = {7031, DiagnosticCategory::Error, S("Binding_element_0_implicitly_has_an_1_type_7031"), S("Binding element '{0}' implicitly has an '{1}' type.")};
        static DiagnosticMessageStore Property_0_implicitly_has_type_any_because_its_set_accessor_lacks_a_parameter_type_annotation = {7032, DiagnosticCategory::Error, S("Property_0_implicitly_has_type_any_because_its_set_accessor_lacks_a_parameter_type_annotation_7032"), S("Property '{0}' implicitly has type 'any', because its set accessor lacks a parameter type annotation.")};
        static DiagnosticMessageStore Property_0_implicitly_has_type_any_because_its_get_accessor_lacks_a_return_type_annotation = {7033, DiagnosticCategory::Error, S("Property_0_implicitly_has_type_any_because_its_get_accessor_lacks_a_return_type_annotation_7033"), S("Property '{0}' implicitly has type 'any', because its get accessor lacks a return type annotation.")};
        static DiagnosticMessageStore Variable_0_implicitly_has_type_1_in_some_locations_where_its_type_cannot_be_determined = {7034, DiagnosticCategory::Error, S("Variable_0_implicitly_has_type_1_in_some_locations_where_its_type_cannot_be_determined_7034"), S("Variable '{0}' implicitly has type '{1}' in some locations where its type cannot be determined.")};
        static DiagnosticMessageStore Try_npm_i_save_dev_types_Slash_1_if_it_exists_or_add_a_new_declaration_d_ts_file_containing_declare_module_0 = {7035, DiagnosticCategory::Error, S("Try_npm_i_save_dev_types_Slash_1_if_it_exists_or_add_a_new_declaration_d_ts_file_containing_declare__7035"), S("Try `npm i --save-dev @types/{1}` if it exists or add a new declaration (.d.ts) file containing `declare module '{0}';`")};
        static DiagnosticMessageStore Dynamic_import_s_specifier_must_be_of_type_string_but_here_has_type_0 = {7036, DiagnosticCategory::Error, S("Dynamic_import_s_specifier_must_be_of_type_string_but_here_has_type_0_7036"), S("Dynamic import's specifier must be of type 'string', but here has type '{0}'.")};
        static DiagnosticMessageStore Enables_emit_interoperability_between_CommonJS_and_ES_Modules_via_creation_of_namespace_objects_for_all_imports_Implies_allowSyntheticDefaultImports = {7037, DiagnosticCategory::Message, S("Enables_emit_interoperability_between_CommonJS_and_ES_Modules_via_creation_of_namespace_objects_for__7037"), S("Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'.")};
        static DiagnosticMessageStore Type_originates_at_this_import_A_namespace_style_import_cannot_be_called_or_constructed_and_will_cause_a_failure_at_runtime_Consider_using_a_default_import_or_import_require_here_instead = {7038, DiagnosticCategory::Message, S("Type_originates_at_this_import_A_namespace_style_import_cannot_be_called_or_constructed_and_will_cau_7038"), S("Type originates at this import. A namespace-style import cannot be called or constructed, and will cause a failure at runtime. Consider using a default import or import require here instead.")};
        static DiagnosticMessageStore Mapped_object_type_implicitly_has_an_any_template_type = {7039, DiagnosticCategory::Error, S("Mapped_object_type_implicitly_has_an_any_template_type_7039"), S("Mapped object type implicitly has an 'any' template type.")};
        static DiagnosticMessageStore If_the_0_package_actually_exposes_this_module_consider_sending_a_pull_request_to_amend_https_Colon_Slash_Slashgithub_com_SlashDefinitelyTyped_SlashDefinitelyTyped_Slashtree_Slashmaster_Slashtypes_Slash_1 = {7040, DiagnosticCategory::Error, S("If_the_0_package_actually_exposes_this_module_consider_sending_a_pull_request_to_amend_https_Colon_S_7040"), S("If the '{0}' package actually exposes this module, consider sending a pull request to amend 'https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/{1}'")};
        static DiagnosticMessageStore The_containing_arrow_function_captures_the_global_value_of_this = {7041, DiagnosticCategory::Error, S("The_containing_arrow_function_captures_the_global_value_of_this_7041"), S("The containing arrow function captures the global value of 'this'.")};
        static DiagnosticMessageStore Module_0_was_resolved_to_1_but_resolveJsonModule_is_not_used = {7042, DiagnosticCategory::Error, S("Module_0_was_resolved_to_1_but_resolveJsonModule_is_not_used_7042"), S("Module '{0}' was resolved to '{1}', but '--resolveJsonModule' is not used.")};
        static DiagnosticMessageStore Variable_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage = {7043, DiagnosticCategory::Suggestion, S("Variable_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage_7043"), S("Variable '{0}' implicitly has an '{1}' type, but a better type may be inferred from usage.")};
        static DiagnosticMessageStore Parameter_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage = {7044, DiagnosticCategory::Suggestion, S("Parameter_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage_7044"), S("Parameter '{0}' implicitly has an '{1}' type, but a better type may be inferred from usage.")};
        static DiagnosticMessageStore Member_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage = {7045, DiagnosticCategory::Suggestion, S("Member_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage_7045"), S("Member '{0}' implicitly has an '{1}' type, but a better type may be inferred from usage.")};
        static DiagnosticMessageStore Variable_0_implicitly_has_type_1_in_some_locations_but_a_better_type_may_be_inferred_from_usage = {7046, DiagnosticCategory::Suggestion, S("Variable_0_implicitly_has_type_1_in_some_locations_but_a_better_type_may_be_inferred_from_usage_7046"), S("Variable '{0}' implicitly has type '{1}' in some locations, but a better type may be inferred from usage.")};
        static DiagnosticMessageStore Rest_parameter_0_implicitly_has_an_any_type_but_a_better_type_may_be_inferred_from_usage = {7047, DiagnosticCategory::Suggestion, S("Rest_parameter_0_implicitly_has_an_any_type_but_a_better_type_may_be_inferred_from_usage_7047"), S("Rest parameter '{0}' implicitly has an 'any[]' type, but a better type may be inferred from usage.")};
        static DiagnosticMessageStore Property_0_implicitly_has_type_any_but_a_better_type_for_its_get_accessor_may_be_inferred_from_usage = {7048, DiagnosticCategory::Suggestion, S("Property_0_implicitly_has_type_any_but_a_better_type_for_its_get_accessor_may_be_inferred_from_usage_7048"), S("Property '{0}' implicitly has type 'any', but a better type for its get accessor may be inferred from usage.")};
        static DiagnosticMessageStore Property_0_implicitly_has_type_any_but_a_better_type_for_its_set_accessor_may_be_inferred_from_usage = {7049, DiagnosticCategory::Suggestion, S("Property_0_implicitly_has_type_any_but_a_better_type_for_its_set_accessor_may_be_inferred_from_usage_7049"), S("Property '{0}' implicitly has type 'any', but a better type for its set accessor may be inferred from usage.")};
        static DiagnosticMessageStore _0_implicitly_has_an_1_return_type_but_a_better_type_may_be_inferred_from_usage = {7050, DiagnosticCategory::Suggestion, S("_0_implicitly_has_an_1_return_type_but_a_better_type_may_be_inferred_from_usage_7050"), S("'{0}' implicitly has an '{1}' return type, but a better type may be inferred from usage.")};
        static DiagnosticMessageStore Parameter_has_a_name_but_no_type_Did_you_mean_0_Colon_1 = {7051, DiagnosticCategory::Error, S("Parameter_has_a_name_but_no_type_Did_you_mean_0_Colon_1_7051"), S("Parameter has a name but no type. Did you mean '{0}: {1}'?")};
        static DiagnosticMessageStore Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature_Did_you_mean_to_call_1 = {7052, DiagnosticCategory::Error, S("Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature_Did_you_mean_to_call_1_7052"), S("Element implicitly has an 'any' type because type '{0}' has no index signature. Did you mean to call '{1}'?")};
        static DiagnosticMessageStore Element_implicitly_has_an_any_type_because_expression_of_type_0_can_t_be_used_to_index_type_1 = {7053, DiagnosticCategory::Error, S("Element_implicitly_has_an_any_type_because_expression_of_type_0_can_t_be_used_to_index_type_1_7053"), S("Element implicitly has an 'any' type because expression of type '{0}' can't be used to index type '{1}'.")};
        static DiagnosticMessageStore No_index_signature_with_a_parameter_of_type_0_was_found_on_type_1 = {7054, DiagnosticCategory::Error, S("No_index_signature_with_a_parameter_of_type_0_was_found_on_type_1_7054"), S("No index signature with a parameter of type '{0}' was found on type '{1}'.")};
        static DiagnosticMessageStore _0_which_lacks_return_type_annotation_implicitly_has_an_1_yield_type = {7055, DiagnosticCategory::Error, S("_0_which_lacks_return_type_annotation_implicitly_has_an_1_yield_type_7055"), S("'{0}', which lacks return-type annotation, implicitly has an '{1}' yield type.")};
        static DiagnosticMessageStore The_inferred_type_of_this_node_exceeds_the_maximum_length_the_compiler_will_serialize_An_explicit_type_annotation_is_needed = {7056, DiagnosticCategory::Error, S("The_inferred_type_of_this_node_exceeds_the_maximum_length_the_compiler_will_serialize_An_explicit_ty_7056"), S("The inferred type of this node exceeds the maximum length the compiler will serialize. An explicit type annotation is needed.")};
        static DiagnosticMessageStore yield_expression_implicitly_results_in_an_any_type_because_its_containing_generator_lacks_a_return_type_annotation = {7057, DiagnosticCategory::Error, S("yield_expression_implicitly_results_in_an_any_type_because_its_containing_generator_lacks_a_return_t_7057"), S("'yield' expression implicitly results in an 'any' type because its containing generator lacks a return-type annotation.")};
        static DiagnosticMessageStore If_the_0_package_actually_exposes_this_module_try_adding_a_new_declaration_d_ts_file_containing_declare_module_1 = {7058, DiagnosticCategory::Error, S("If_the_0_package_actually_exposes_this_module_try_adding_a_new_declaration_d_ts_file_containing_decl_7058"), S("If the '{0}' package actually exposes this module, try adding a new declaration (.d.ts) file containing `declare module '{1}';`")};
        static DiagnosticMessageStore This_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_Use_an_as_expression_instead = {7059, DiagnosticCategory::Error, S("This_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_Use_an_as_expression_instead_7059"), S("This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.")};
        static DiagnosticMessageStore This_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_Add_a_trailing_comma_or_explicit_constraint = {7060, DiagnosticCategory::Error, S("This_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_Add_a_trailing_comma_or_explicit_cons_7060"), S("This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma or explicit constraint.")};
        static DiagnosticMessageStore A_mapped_type_may_not_declare_properties_or_methods = {7061, DiagnosticCategory::Error, S("A_mapped_type_may_not_declare_properties_or_methods_7061"), S("A mapped type may not declare properties or methods.")};
        static DiagnosticMessageStore You_cannot_rename_this_element = {8000, DiagnosticCategory::Error, S("You_cannot_rename_this_element_8000"), S("You cannot rename this element.")};
        static DiagnosticMessageStore You_cannot_rename_elements_that_are_defined_in_the_standard_TypeScript_library = {8001, DiagnosticCategory::Error, S("You_cannot_rename_elements_that_are_defined_in_the_standard_TypeScript_library_8001"), S("You cannot rename elements that are defined in the standard TypeScript library.")};
        static DiagnosticMessageStore import_can_only_be_used_in_TypeScript_files = {8002, DiagnosticCategory::Error, S("import_can_only_be_used_in_TypeScript_files_8002"), S("'import ... =' can only be used in TypeScript files.")};
        static DiagnosticMessageStore export_can_only_be_used_in_TypeScript_files = {8003, DiagnosticCategory::Error, S("export_can_only_be_used_in_TypeScript_files_8003"), S("'export =' can only be used in TypeScript files.")};
        static DiagnosticMessageStore Type_parameter_declarations_can_only_be_used_in_TypeScript_files = {8004, DiagnosticCategory::Error, S("Type_parameter_declarations_can_only_be_used_in_TypeScript_files_8004"), S("Type parameter declarations can only be used in TypeScript files.")};
        static DiagnosticMessageStore implements_clauses_can_only_be_used_in_TypeScript_files = {8005, DiagnosticCategory::Error, S("implements_clauses_can_only_be_used_in_TypeScript_files_8005"), S("'implements' clauses can only be used in TypeScript files.")};
        static DiagnosticMessageStore _0_declarations_can_only_be_used_in_TypeScript_files = {8006, DiagnosticCategory::Error, S("_0_declarations_can_only_be_used_in_TypeScript_files_8006"), S("'{0}' declarations can only be used in TypeScript files.")};
        static DiagnosticMessageStore Type_aliases_can_only_be_used_in_TypeScript_files = {8008, DiagnosticCategory::Error, S("Type_aliases_can_only_be_used_in_TypeScript_files_8008"), S("Type aliases can only be used in TypeScript files.")};
        static DiagnosticMessageStore The_0_modifier_can_only_be_used_in_TypeScript_files = {8009, DiagnosticCategory::Error, S("The_0_modifier_can_only_be_used_in_TypeScript_files_8009"), S("The '{0}' modifier can only be used in TypeScript files.")};
        static DiagnosticMessageStore Type_annotations_can_only_be_used_in_TypeScript_files = {8010, DiagnosticCategory::Error, S("Type_annotations_can_only_be_used_in_TypeScript_files_8010"), S("Type annotations can only be used in TypeScript files.")};
        static DiagnosticMessageStore Type_arguments_can_only_be_used_in_TypeScript_files = {8011, DiagnosticCategory::Error, S("Type_arguments_can_only_be_used_in_TypeScript_files_8011"), S("Type arguments can only be used in TypeScript files.")};
        static DiagnosticMessageStore Parameter_modifiers_can_only_be_used_in_TypeScript_files = {8012, DiagnosticCategory::Error, S("Parameter_modifiers_can_only_be_used_in_TypeScript_files_8012"), S("Parameter modifiers can only be used in TypeScript files.")};
        static DiagnosticMessageStore Non_null_assertions_can_only_be_used_in_TypeScript_files = {8013, DiagnosticCategory::Error, S("Non_null_assertions_can_only_be_used_in_TypeScript_files_8013"), S("Non-null assertions can only be used in TypeScript files.")};
        static DiagnosticMessageStore Type_assertion_expressions_can_only_be_used_in_TypeScript_files = {8016, DiagnosticCategory::Error, S("Type_assertion_expressions_can_only_be_used_in_TypeScript_files_8016"), S("Type assertion expressions can only be used in TypeScript files.")};
        static DiagnosticMessageStore Signature_declarations_can_only_be_used_in_TypeScript_files = {8017, DiagnosticCategory::Error, S("Signature_declarations_can_only_be_used_in_TypeScript_files_8017"), S("Signature declarations can only be used in TypeScript files.")};
        static DiagnosticMessageStore Report_errors_in_js_files = {8019, DiagnosticCategory::Message, S("Report_errors_in_js_files_8019"), S("Report errors in .js files.")};
        static DiagnosticMessageStore JSDoc_types_can_only_be_used_inside_documentation_comments = {8020, DiagnosticCategory::Error, S("JSDoc_types_can_only_be_used_inside_documentation_comments_8020"), S("JSDoc types can only be used inside documentation comments.")};
        static DiagnosticMessageStore JSDoc_typedef_tag_should_either_have_a_type_annotation_or_be_followed_by_property_or_member_tags = {8021, DiagnosticCategory::Error, S("JSDoc_typedef_tag_should_either_have_a_type_annotation_or_be_followed_by_property_or_member_tags_8021"), S("JSDoc '@typedef' tag should either have a type annotation or be followed by '@property' or '@member' tags.")};
        static DiagnosticMessageStore JSDoc_0_is_not_attached_to_a_class = {8022, DiagnosticCategory::Error, S("JSDoc_0_is_not_attached_to_a_class_8022"), S("JSDoc '@{0}' is not attached to a class.")};
        static DiagnosticMessageStore JSDoc_0_1_does_not_match_the_extends_2_clause = {8023, DiagnosticCategory::Error, S("JSDoc_0_1_does_not_match_the_extends_2_clause_8023"), S("JSDoc '@{0} {1}' does not match the 'extends {2}' clause.")};
        static DiagnosticMessageStore JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name = {8024, DiagnosticCategory::Error, S("JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name_8024"), S("JSDoc '@param' tag has name '{0}', but there is no parameter with that name.")};
        static DiagnosticMessageStore Class_declarations_cannot_have_more_than_one_augments_or_extends_tag = {8025, DiagnosticCategory::Error, S("Class_declarations_cannot_have_more_than_one_augments_or_extends_tag_8025"), S("Class declarations cannot have more than one '@augments' or '@extends' tag.")};
        static DiagnosticMessageStore Expected_0_type_arguments_provide_these_with_an_extends_tag = {8026, DiagnosticCategory::Error, S("Expected_0_type_arguments_provide_these_with_an_extends_tag_8026"), S("Expected {0} type arguments; provide these with an '@extends' tag.")};
        static DiagnosticMessageStore Expected_0_1_type_arguments_provide_these_with_an_extends_tag = {8027, DiagnosticCategory::Error, S("Expected_0_1_type_arguments_provide_these_with_an_extends_tag_8027"), S("Expected {0}-{1} type arguments; provide these with an '@extends' tag.")};
        static DiagnosticMessageStore JSDoc_may_only_appear_in_the_last_parameter_of_a_signature = {8028, DiagnosticCategory::Error, S("JSDoc_may_only_appear_in_the_last_parameter_of_a_signature_8028"), S("JSDoc '...' may only appear in the last parameter of a signature.")};
        static DiagnosticMessageStore JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name_It_would_match_arguments_if_it_had_an_array_type = {8029, DiagnosticCategory::Error, S("JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name_It_would_match_arguments_if_it_h_8029"), S("JSDoc '@param' tag has name '{0}', but there is no parameter with that name. It would match 'arguments' if it had an array type.")};
        static DiagnosticMessageStore The_type_of_a_function_declaration_must_match_the_function_s_signature = {8030, DiagnosticCategory::Error, S("The_type_of_a_function_declaration_must_match_the_function_s_signature_8030"), S("The type of a function declaration must match the function's signature.")};
        static DiagnosticMessageStore You_cannot_rename_a_module_via_a_global_import = {8031, DiagnosticCategory::Error, S("You_cannot_rename_a_module_via_a_global_import_8031"), S("You cannot rename a module via a global import.")};
        static DiagnosticMessageStore Qualified_name_0_is_not_allowed_without_a_leading_param_object_1 = {8032, DiagnosticCategory::Error, S("Qualified_name_0_is_not_allowed_without_a_leading_param_object_1_8032"), S("Qualified name '{0}' is not allowed without a leading '@param {object} {1}'.")};
        static DiagnosticMessageStore A_JSDoc_typedef_comment_may_not_contain_multiple_type_tags = {8033, DiagnosticCategory::Error, S("A_JSDoc_typedef_comment_may_not_contain_multiple_type_tags_8033"), S("A JSDoc '@typedef' comment may not contain multiple '@type' tags.")};
        static DiagnosticMessageStore The_tag_was_first_specified_here = {8034, DiagnosticCategory::Error, S("The_tag_was_first_specified_here_8034"), S("The tag was first specified here.")};
        static DiagnosticMessageStore You_cannot_rename_elements_that_are_defined_in_a_node_modules_folder = {8035, DiagnosticCategory::Error, S("You_cannot_rename_elements_that_are_defined_in_a_node_modules_folder_8035"), S("You cannot rename elements that are defined in a 'node_modules' folder.")};
        static DiagnosticMessageStore You_cannot_rename_elements_that_are_defined_in_another_node_modules_folder = {8036, DiagnosticCategory::Error, S("You_cannot_rename_elements_that_are_defined_in_another_node_modules_folder_8036"), S("You cannot rename elements that are defined in another 'node_modules' folder.")};
        static DiagnosticMessageStore Type_satisfaction_expressions_can_only_be_used_in_TypeScript_files = {8037, DiagnosticCategory::Error, S("Type_satisfaction_expressions_can_only_be_used_in_TypeScript_files_8037"), S("Type satisfaction expressions can only be used in TypeScript files.")};
        static DiagnosticMessageStore Decorators_may_not_appear_after_export_or_export_default_if_they_also_appear_before_export = {8038, DiagnosticCategory::Error, S("Decorators_may_not_appear_after_export_or_export_default_if_they_also_appear_before_export_8038"), S("Decorators may not appear after 'export' or 'export default' if they also appear before 'export'.")};
        static DiagnosticMessageStore A_JSDoc_template_tag_may_not_follow_a_typedef_callback_or_overload_tag = {8039, DiagnosticCategory::Error, S("A_JSDoc_template_tag_may_not_follow_a_typedef_callback_or_overload_tag_8039"), S("A JSDoc '@template' tag may not follow a '@typedef', '@callback', or '@overload' tag")};
        static DiagnosticMessageStore Declaration_emit_for_this_file_requires_using_private_name_0_An_explicit_type_annotation_may_unblock_declaration_emit = {9005, DiagnosticCategory::Error, S("Declaration_emit_for_this_file_requires_using_private_name_0_An_explicit_type_annotation_may_unblock_9005"), S("Declaration emit for this file requires using private name '{0}'. An explicit type annotation may unblock declaration emit.")};
        static DiagnosticMessageStore Declaration_emit_for_this_file_requires_using_private_name_0_from_module_1_An_explicit_type_annotation_may_unblock_declaration_emit = {9006, DiagnosticCategory::Error, S("Declaration_emit_for_this_file_requires_using_private_name_0_from_module_1_An_explicit_type_annotati_9006"), S("Declaration emit for this file requires using private name '{0}' from module '{1}'. An explicit type annotation may unblock declaration emit.")};
        static DiagnosticMessageStore JSX_attributes_must_only_be_assigned_a_non_empty_expression = {17000, DiagnosticCategory::Error, S("JSX_attributes_must_only_be_assigned_a_non_empty_expression_17000"), S("JSX attributes must only be assigned a non-empty 'expression'.")};
        static DiagnosticMessageStore JSX_elements_cannot_have_multiple_attributes_with_the_same_name = {17001, DiagnosticCategory::Error, S("JSX_elements_cannot_have_multiple_attributes_with_the_same_name_17001"), S("JSX elements cannot have multiple attributes with the same name.")};
        static DiagnosticMessageStore Expected_corresponding_JSX_closing_tag_for_0 = {17002, DiagnosticCategory::Error, S("Expected_corresponding_JSX_closing_tag_for_0_17002"), S("Expected corresponding JSX closing tag for '{0}'.")};
        static DiagnosticMessageStore Cannot_use_JSX_unless_the_jsx_flag_is_provided = {17004, DiagnosticCategory::Error, S("Cannot_use_JSX_unless_the_jsx_flag_is_provided_17004"), S("Cannot use JSX unless the '--jsx' flag is provided.")};
        static DiagnosticMessageStore A_constructor_cannot_contain_a_super_call_when_its_class_extends_null = {17005, DiagnosticCategory::Error, S("A_constructor_cannot_contain_a_super_call_when_its_class_extends_null_17005"), S("A constructor cannot contain a 'super' call when its class extends 'null'.")};
        static DiagnosticMessageStore An_unary_expression_with_the_0_operator_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_Consider_enclosing_the_expression_in_parentheses = {17006, DiagnosticCategory::Error, S("An_unary_expression_with_the_0_operator_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_ex_17006"), S("An unary expression with the '{0}' operator is not allowed in the left-hand side of an exponentiation expression. Consider enclosing the expression in parentheses.")};
        static DiagnosticMessageStore A_type_assertion_expression_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_Consider_enclosing_the_expression_in_parentheses = {17007, DiagnosticCategory::Error, S("A_type_assertion_expression_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_Con_17007"), S("A type assertion expression is not allowed in the left-hand side of an exponentiation expression. Consider enclosing the expression in parentheses.")};
        static DiagnosticMessageStore JSX_element_0_has_no_corresponding_closing_tag = {17008, DiagnosticCategory::Error, S("JSX_element_0_has_no_corresponding_closing_tag_17008"), S("JSX element '{0}' has no corresponding closing tag.")};
        static DiagnosticMessageStore super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class = {17009, DiagnosticCategory::Error, S("super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class_17009"), S("'super' must be called before accessing 'this' in the constructor of a derived class.")};
        static DiagnosticMessageStore Unknown_type_acquisition_option_0 = {17010, DiagnosticCategory::Error, S("Unknown_type_acquisition_option_0_17010"), S("Unknown type acquisition option '{0}'.")};
        static DiagnosticMessageStore super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class = {17011, DiagnosticCategory::Error, S("super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class_17011"), S("'super' must be called before accessing a property of 'super' in the constructor of a derived class.")};
        static DiagnosticMessageStore _0_is_not_a_valid_meta_property_for_keyword_1_Did_you_mean_2 = {17012, DiagnosticCategory::Error, S("_0_is_not_a_valid_meta_property_for_keyword_1_Did_you_mean_2_17012"), S("'{0}' is not a valid meta-property for keyword '{1}'. Did you mean '{2}'?")};
        static DiagnosticMessageStore Meta_property_0_is_only_allowed_in_the_body_of_a_function_declaration_function_expression_or_constructor = {17013, DiagnosticCategory::Error, S("Meta_property_0_is_only_allowed_in_the_body_of_a_function_declaration_function_expression_or_constru_17013"), S("Meta-property '{0}' is only allowed in the body of a function declaration, function expression, or constructor.")};
        static DiagnosticMessageStore JSX_fragment_has_no_corresponding_closing_tag = {17014, DiagnosticCategory::Error, S("JSX_fragment_has_no_corresponding_closing_tag_17014"), S("JSX fragment has no corresponding closing tag.")};
        static DiagnosticMessageStore Expected_corresponding_closing_tag_for_JSX_fragment = {17015, DiagnosticCategory::Error, S("Expected_corresponding_closing_tag_for_JSX_fragment_17015"), S("Expected corresponding closing tag for JSX fragment.")};
        static DiagnosticMessageStore The_jsxFragmentFactory_compiler_option_must_be_provided_to_use_JSX_fragments_with_the_jsxFactory_compiler_option = {17016, DiagnosticCategory::Error, S("The_jsxFragmentFactory_compiler_option_must_be_provided_to_use_JSX_fragments_with_the_jsxFactory_com_17016"), S("The 'jsxFragmentFactory' compiler option must be provided to use JSX fragments with the 'jsxFactory' compiler option.")};
        static DiagnosticMessageStore An_jsxFrag_pragma_is_required_when_using_an_jsx_pragma_with_JSX_fragments = {17017, DiagnosticCategory::Error, S("An_jsxFrag_pragma_is_required_when_using_an_jsx_pragma_with_JSX_fragments_17017"), S("An @jsxFrag pragma is required when using an @jsx pragma with JSX fragments.")};
        static DiagnosticMessageStore Unknown_type_acquisition_option_0_Did_you_mean_1 = {17018, DiagnosticCategory::Error, S("Unknown_type_acquisition_option_0_Did_you_mean_1_17018"), S("Unknown type acquisition option '{0}'. Did you mean '{1}'?")};
        static DiagnosticMessageStore _0_at_the_end_of_a_type_is_not_valid_TypeScript_syntax_Did_you_mean_to_write_1 = {17019, DiagnosticCategory::Error, S("_0_at_the_end_of_a_type_is_not_valid_TypeScript_syntax_Did_you_mean_to_write_1_17019"), S("'{0}' at the end of a type is not valid TypeScript syntax. Did you mean to write '{1}'?")};
        static DiagnosticMessageStore _0_at_the_start_of_a_type_is_not_valid_TypeScript_syntax_Did_you_mean_to_write_1 = {17020, DiagnosticCategory::Error, S("_0_at_the_start_of_a_type_is_not_valid_TypeScript_syntax_Did_you_mean_to_write_1_17020"), S("'{0}' at the start of a type is not valid TypeScript syntax. Did you mean to write '{1}'?")};
        static DiagnosticMessageStore Unicode_escape_sequence_cannot_appear_here = {17021, DiagnosticCategory::Error, S("Unicode_escape_sequence_cannot_appear_here_17021"), S("Unicode escape sequence cannot appear here.")};
        static DiagnosticMessageStore Circularity_detected_while_resolving_configuration_Colon_0 = {18000, DiagnosticCategory::Error, S("Circularity_detected_while_resolving_configuration_Colon_0_18000"), S("Circularity detected while resolving configuration: {0}")};
        static DiagnosticMessageStore The_files_list_in_config_file_0_is_empty = {18002, DiagnosticCategory::Error, S("The_files_list_in_config_file_0_is_empty_18002"), S("The 'files' list in config file '{0}' is empty.")};
        static DiagnosticMessageStore No_inputs_were_found_in_config_file_0_Specified_include_paths_were_1_and_exclude_paths_were_2 = {18003, DiagnosticCategory::Error, S("No_inputs_were_found_in_config_file_0_Specified_include_paths_were_1_and_exclude_paths_were_2_18003"), S("No inputs were found in config file '{0}'. Specified 'include' paths were '{1}' and 'exclude' paths were '{2}'.")};
        static DiagnosticMessageStore File_is_a_CommonJS_module_it_may_be_converted_to_an_ES_module = {80001, DiagnosticCategory::Suggestion, S("File_is_a_CommonJS_module_it_may_be_converted_to_an_ES_module_80001"), S("File is a CommonJS module; it may be converted to an ES module.")};
        static DiagnosticMessageStore This_constructor_function_may_be_converted_to_a_class_declaration = {80002, DiagnosticCategory::Suggestion, S("This_constructor_function_may_be_converted_to_a_class_declaration_80002"), S("This constructor function may be converted to a class declaration.")};
        static DiagnosticMessageStore Import_may_be_converted_to_a_default_import = {80003, DiagnosticCategory::Suggestion, S("Import_may_be_converted_to_a_default_import_80003"), S("Import may be converted to a default import.")};
        static DiagnosticMessageStore JSDoc_types_may_be_moved_to_TypeScript_types = {80004, DiagnosticCategory::Suggestion, S("JSDoc_types_may_be_moved_to_TypeScript_types_80004"), S("JSDoc types may be moved to TypeScript types.")};
        static DiagnosticMessageStore require_call_may_be_converted_to_an_import = {80005, DiagnosticCategory::Suggestion, S("require_call_may_be_converted_to_an_import_80005"), S("'require' call may be converted to an import.")};
        static DiagnosticMessageStore This_may_be_converted_to_an_async_function = {80006, DiagnosticCategory::Suggestion, S("This_may_be_converted_to_an_async_function_80006"), S("This may be converted to an async function.")};
        static DiagnosticMessageStore await_has_no_effect_on_the_type_of_this_expression = {80007, DiagnosticCategory::Suggestion, S("await_has_no_effect_on_the_type_of_this_expression_80007"), S("'await' has no effect on the type of this expression.")};
        static DiagnosticMessageStore Numeric_literals_with_absolute_values_equal_to_2_53_or_greater_are_too_large_to_be_represented_accurately_as_integers = {80008, DiagnosticCategory::Suggestion, S("Numeric_literals_with_absolute_values_equal_to_2_53_or_greater_are_too_large_to_be_represented_accur_80008"), S("Numeric literals with absolute values equal to 2^53 or greater are too large to be represented accurately as integers.")};
        static DiagnosticMessageStore JSDoc_typedef_may_be_converted_to_TypeScript_type = {80009, DiagnosticCategory::Suggestion, S("JSDoc_typedef_may_be_converted_to_TypeScript_type_80009"), S("JSDoc typedef may be converted to TypeScript type.")};
        static DiagnosticMessageStore JSDoc_typedefs_may_be_converted_to_TypeScript_types = {80010, DiagnosticCategory::Suggestion, S("JSDoc_typedefs_may_be_converted_to_TypeScript_types_80010"), S("JSDoc typedefs may be converted to TypeScript types.")};
        static DiagnosticMessageStore Add_missing_super_call = {90001, DiagnosticCategory::Message, S("Add_missing_super_call_90001"), S("Add missing 'super()' call")};
        static DiagnosticMessageStore Make_super_call_the_first_statement_in_the_constructor = {90002, DiagnosticCategory::Message, S("Make_super_call_the_first_statement_in_the_constructor_90002"), S("Make 'super()' call the first statement in the constructor")};
        static DiagnosticMessageStore Change_extends_to_implements = {90003, DiagnosticCategory::Message, S("Change_extends_to_implements_90003"), S("Change 'extends' to 'implements'")};
        static DiagnosticMessageStore Remove_unused_declaration_for_Colon_0 = {90004, DiagnosticCategory::Message, S("Remove_unused_declaration_for_Colon_0_90004"), S("Remove unused declaration for: '{0}'")};
        static DiagnosticMessageStore Remove_import_from_0 = {90005, DiagnosticCategory::Message, S("Remove_import_from_0_90005"), S("Remove import from '{0}'")};
        static DiagnosticMessageStore Implement_interface_0 = {90006, DiagnosticCategory::Message, S("Implement_interface_0_90006"), S("Implement interface '{0}'")};
        static DiagnosticMessageStore Implement_inherited_abstract_class = {90007, DiagnosticCategory::Message, S("Implement_inherited_abstract_class_90007"), S("Implement inherited abstract class")};
        static DiagnosticMessageStore Add_0_to_unresolved_variable = {90008, DiagnosticCategory::Message, S("Add_0_to_unresolved_variable_90008"), S("Add '{0}.' to unresolved variable")};
        static DiagnosticMessageStore Remove_variable_statement = {90010, DiagnosticCategory::Message, S("Remove_variable_statement_90010"), S("Remove variable statement")};
        static DiagnosticMessageStore Remove_template_tag = {90011, DiagnosticCategory::Message, S("Remove_template_tag_90011"), S("Remove template tag")};
        static DiagnosticMessageStore Remove_type_parameters = {90012, DiagnosticCategory::Message, S("Remove_type_parameters_90012"), S("Remove type parameters")};
        static DiagnosticMessageStore Import_0_from_1 = {90013, DiagnosticCategory::Message, S("Import_0_from_1_90013"), S("Import '{0}' from \"{1}\"")};
        static DiagnosticMessageStore Change_0_to_1 = {90014, DiagnosticCategory::Message, S("Change_0_to_1_90014"), S("Change '{0}' to '{1}'")};
        static DiagnosticMessageStore Declare_property_0 = {90016, DiagnosticCategory::Message, S("Declare_property_0_90016"), S("Declare property '{0}'")};
        static DiagnosticMessageStore Add_index_signature_for_property_0 = {90017, DiagnosticCategory::Message, S("Add_index_signature_for_property_0_90017"), S("Add index signature for property '{0}'")};
        static DiagnosticMessageStore Disable_checking_for_this_file = {90018, DiagnosticCategory::Message, S("Disable_checking_for_this_file_90018"), S("Disable checking for this file")};
        static DiagnosticMessageStore Ignore_this_error_message = {90019, DiagnosticCategory::Message, S("Ignore_this_error_message_90019"), S("Ignore this error message")};
        static DiagnosticMessageStore Initialize_property_0_in_the_constructor = {90020, DiagnosticCategory::Message, S("Initialize_property_0_in_the_constructor_90020"), S("Initialize property '{0}' in the constructor")};
        static DiagnosticMessageStore Initialize_static_property_0 = {90021, DiagnosticCategory::Message, S("Initialize_static_property_0_90021"), S("Initialize static property '{0}'")};
        static DiagnosticMessageStore Change_spelling_to_0 = {90022, DiagnosticCategory::Message, S("Change_spelling_to_0_90022"), S("Change spelling to '{0}'")};
        static DiagnosticMessageStore Declare_method_0 = {90023, DiagnosticCategory::Message, S("Declare_method_0_90023"), S("Declare method '{0}'")};
        static DiagnosticMessageStore Declare_static_method_0 = {90024, DiagnosticCategory::Message, S("Declare_static_method_0_90024"), S("Declare static method '{0}'")};
        static DiagnosticMessageStore Prefix_0_with_an_underscore = {90025, DiagnosticCategory::Message, S("Prefix_0_with_an_underscore_90025"), S("Prefix '{0}' with an underscore")};
        static DiagnosticMessageStore Rewrite_as_the_indexed_access_type_0 = {90026, DiagnosticCategory::Message, S("Rewrite_as_the_indexed_access_type_0_90026"), S("Rewrite as the indexed access type '{0}'")};
        static DiagnosticMessageStore Declare_static_property_0 = {90027, DiagnosticCategory::Message, S("Declare_static_property_0_90027"), S("Declare static property '{0}'")};
        static DiagnosticMessageStore Call_decorator_expression = {90028, DiagnosticCategory::Message, S("Call_decorator_expression_90028"), S("Call decorator expression")};
        static DiagnosticMessageStore Add_async_modifier_to_containing_function = {90029, DiagnosticCategory::Message, S("Add_async_modifier_to_containing_function_90029"), S("Add async modifier to containing function")};
        static DiagnosticMessageStore Replace_infer_0_with_unknown = {90030, DiagnosticCategory::Message, S("Replace_infer_0_with_unknown_90030"), S("Replace 'infer {0}' with 'unknown'")};
        static DiagnosticMessageStore Replace_all_unused_infer_with_unknown = {90031, DiagnosticCategory::Message, S("Replace_all_unused_infer_with_unknown_90031"), S("Replace all unused 'infer' with 'unknown'")};
        static DiagnosticMessageStore Add_parameter_name = {90034, DiagnosticCategory::Message, S("Add_parameter_name_90034"), S("Add parameter name")};
        static DiagnosticMessageStore Declare_private_property_0 = {90035, DiagnosticCategory::Message, S("Declare_private_property_0_90035"), S("Declare private property '{0}'")};
        static DiagnosticMessageStore Replace_0_with_Promise_1 = {90036, DiagnosticCategory::Message, S("Replace_0_with_Promise_1_90036"), S("Replace '{0}' with 'Promise<{1}>'")};
        static DiagnosticMessageStore Fix_all_incorrect_return_type_of_an_async_functions = {90037, DiagnosticCategory::Message, S("Fix_all_incorrect_return_type_of_an_async_functions_90037"), S("Fix all incorrect return type of an async functions")};
        static DiagnosticMessageStore Declare_private_method_0 = {90038, DiagnosticCategory::Message, S("Declare_private_method_0_90038"), S("Declare private method '{0}'")};
        static DiagnosticMessageStore Remove_unused_destructuring_declaration = {90039, DiagnosticCategory::Message, S("Remove_unused_destructuring_declaration_90039"), S("Remove unused destructuring declaration")};
        static DiagnosticMessageStore Remove_unused_declarations_for_Colon_0 = {90041, DiagnosticCategory::Message, S("Remove_unused_declarations_for_Colon_0_90041"), S("Remove unused declarations for: '{0}'")};
        static DiagnosticMessageStore Declare_a_private_field_named_0 = {90053, DiagnosticCategory::Message, S("Declare_a_private_field_named_0_90053"), S("Declare a private field named '{0}'.")};
        static DiagnosticMessageStore Includes_imports_of_types_referenced_by_0 = {90054, DiagnosticCategory::Message, S("Includes_imports_of_types_referenced_by_0_90054"), S("Includes imports of types referenced by '{0}'")};
        static DiagnosticMessageStore Remove_type_from_import_declaration_from_0 = {90055, DiagnosticCategory::Message, S("Remove_type_from_import_declaration_from_0_90055"), S("Remove 'type' from import declaration from \"{0}\"")};
        static DiagnosticMessageStore Remove_type_from_import_of_0_from_1 = {90056, DiagnosticCategory::Message, S("Remove_type_from_import_of_0_from_1_90056"), S("Remove 'type' from import of '{0}' from \"{1}\"")};
        static DiagnosticMessageStore Add_import_from_0 = {90057, DiagnosticCategory::Message, S("Add_import_from_0_90057"), S("Add import from \"{0}\"")};
        static DiagnosticMessageStore Update_import_from_0 = {90058, DiagnosticCategory::Message, S("Update_import_from_0_90058"), S("Update import from \"{0}\"")};
        static DiagnosticMessageStore Export_0_from_module_1 = {90059, DiagnosticCategory::Message, S("Export_0_from_module_1_90059"), S("Export '{0}' from module '{1}'")};
        static DiagnosticMessageStore Export_all_referenced_locals = {90060, DiagnosticCategory::Message, S("Export_all_referenced_locals_90060"), S("Export all referenced locals")};
        static DiagnosticMessageStore Convert_function_to_an_ES2015_class = {95001, DiagnosticCategory::Message, S("Convert_function_to_an_ES2015_class_95001"), S("Convert function to an ES2015 class")};
        static DiagnosticMessageStore Convert_0_to_1_in_0 = {95003, DiagnosticCategory::Message, S("Convert_0_to_1_in_0_95003"), S("Convert '{0}' to '{1} in {0}'")};
        static DiagnosticMessageStore Extract_to_0_in_1 = {95004, DiagnosticCategory::Message, S("Extract_to_0_in_1_95004"), S("Extract to {0} in {1}")};
        static DiagnosticMessageStore Extract_function = {95005, DiagnosticCategory::Message, S("Extract_function_95005"), S("Extract function")};
        static DiagnosticMessageStore Extract_constant = {95006, DiagnosticCategory::Message, S("Extract_constant_95006"), S("Extract constant")};
        static DiagnosticMessageStore Extract_to_0_in_enclosing_scope = {95007, DiagnosticCategory::Message, S("Extract_to_0_in_enclosing_scope_95007"), S("Extract to {0} in enclosing scope")};
        static DiagnosticMessageStore Extract_to_0_in_1_scope = {95008, DiagnosticCategory::Message, S("Extract_to_0_in_1_scope_95008"), S("Extract to {0} in {1} scope")};
        static DiagnosticMessageStore Annotate_with_type_from_JSDoc = {95009, DiagnosticCategory::Message, S("Annotate_with_type_from_JSDoc_95009"), S("Annotate with type from JSDoc")};
        static DiagnosticMessageStore Infer_type_of_0_from_usage = {95011, DiagnosticCategory::Message, S("Infer_type_of_0_from_usage_95011"), S("Infer type of '{0}' from usage")};
        static DiagnosticMessageStore Infer_parameter_types_from_usage = {95012, DiagnosticCategory::Message, S("Infer_parameter_types_from_usage_95012"), S("Infer parameter types from usage")};
        static DiagnosticMessageStore Convert_to_default_import = {95013, DiagnosticCategory::Message, S("Convert_to_default_import_95013"), S("Convert to default import")};
        static DiagnosticMessageStore Install_0 = {95014, DiagnosticCategory::Message, S("Install_0_95014"), S("Install '{0}'")};
        static DiagnosticMessageStore Replace_import_with_0 = {95015, DiagnosticCategory::Message, S("Replace_import_with_0_95015"), S("Replace import with '{0}'.")};
        static DiagnosticMessageStore Use_synthetic_default_member = {95016, DiagnosticCategory::Message, S("Use_synthetic_default_member_95016"), S("Use synthetic 'default' member.")};
        static DiagnosticMessageStore Convert_to_ES_module = {95017, DiagnosticCategory::Message, S("Convert_to_ES_module_95017"), S("Convert to ES module")};
        static DiagnosticMessageStore Add_undefined_type_to_property_0 = {95018, DiagnosticCategory::Message, S("Add_undefined_type_to_property_0_95018"), S("Add 'undefined' type to property '{0}'")};
        static DiagnosticMessageStore Add_initializer_to_property_0 = {95019, DiagnosticCategory::Message, S("Add_initializer_to_property_0_95019"), S("Add initializer to property '{0}'")};
        static DiagnosticMessageStore Add_definite_assignment_assertion_to_property_0 = {95020, DiagnosticCategory::Message, S("Add_definite_assignment_assertion_to_property_0_95020"), S("Add definite assignment assertion to property '{0}'")};
        static DiagnosticMessageStore Convert_all_type_literals_to_mapped_type = {95021, DiagnosticCategory::Message, S("Convert_all_type_literals_to_mapped_type_95021"), S("Convert all type literals to mapped type")};
        static DiagnosticMessageStore Add_all_missing_members = {95022, DiagnosticCategory::Message, S("Add_all_missing_members_95022"), S("Add all missing members")};
        static DiagnosticMessageStore Infer_all_types_from_usage = {95023, DiagnosticCategory::Message, S("Infer_all_types_from_usage_95023"), S("Infer all types from usage")};
        static DiagnosticMessageStore Delete_all_unused_declarations = {95024, DiagnosticCategory::Message, S("Delete_all_unused_declarations_95024"), S("Delete all unused declarations")};
        static DiagnosticMessageStore Prefix_all_unused_declarations_with_where_possible = {95025, DiagnosticCategory::Message, S("Prefix_all_unused_declarations_with_where_possible_95025"), S("Prefix all unused declarations with '_' where possible")};
        static DiagnosticMessageStore Fix_all_detected_spelling_errors = {95026, DiagnosticCategory::Message, S("Fix_all_detected_spelling_errors_95026"), S("Fix all detected spelling errors")};
        static DiagnosticMessageStore Add_initializers_to_all_uninitialized_properties = {95027, DiagnosticCategory::Message, S("Add_initializers_to_all_uninitialized_properties_95027"), S("Add initializers to all uninitialized properties")};
        static DiagnosticMessageStore Add_definite_assignment_assertions_to_all_uninitialized_properties = {95028, DiagnosticCategory::Message, S("Add_definite_assignment_assertions_to_all_uninitialized_properties_95028"), S("Add definite assignment assertions to all uninitialized properties")};
        static DiagnosticMessageStore Add_undefined_type_to_all_uninitialized_properties = {95029, DiagnosticCategory::Message, S("Add_undefined_type_to_all_uninitialized_properties_95029"), S("Add undefined type to all uninitialized properties")};
        static DiagnosticMessageStore Change_all_jsdoc_style_types_to_TypeScript = {95030, DiagnosticCategory::Message, S("Change_all_jsdoc_style_types_to_TypeScript_95030"), S("Change all jsdoc-style types to TypeScript")};
        static DiagnosticMessageStore Change_all_jsdoc_style_types_to_TypeScript_and_add_undefined_to_nullable_types = {95031, DiagnosticCategory::Message, S("Change_all_jsdoc_style_types_to_TypeScript_and_add_undefined_to_nullable_types_95031"), S("Change all jsdoc-style types to TypeScript (and add '| undefined' to nullable types)")};
        static DiagnosticMessageStore Implement_all_unimplemented_interfaces = {95032, DiagnosticCategory::Message, S("Implement_all_unimplemented_interfaces_95032"), S("Implement all unimplemented interfaces")};
        static DiagnosticMessageStore Install_all_missing_types_packages = {95033, DiagnosticCategory::Message, S("Install_all_missing_types_packages_95033"), S("Install all missing types packages")};
        static DiagnosticMessageStore Rewrite_all_as_indexed_access_types = {95034, DiagnosticCategory::Message, S("Rewrite_all_as_indexed_access_types_95034"), S("Rewrite all as indexed access types")};
        static DiagnosticMessageStore Convert_all_to_default_imports = {95035, DiagnosticCategory::Message, S("Convert_all_to_default_imports_95035"), S("Convert all to default imports")};
        static DiagnosticMessageStore Make_all_super_calls_the_first_statement_in_their_constructor = {95036, DiagnosticCategory::Message, S("Make_all_super_calls_the_first_statement_in_their_constructor_95036"), S("Make all 'super()' calls the first statement in their constructor")};
        static DiagnosticMessageStore Add_qualifier_to_all_unresolved_variables_matching_a_member_name = {95037, DiagnosticCategory::Message, S("Add_qualifier_to_all_unresolved_variables_matching_a_member_name_95037"), S("Add qualifier to all unresolved variables matching a member name")};
        static DiagnosticMessageStore Change_all_extended_interfaces_to_implements = {95038, DiagnosticCategory::Message, S("Change_all_extended_interfaces_to_implements_95038"), S("Change all extended interfaces to 'implements'")};
        static DiagnosticMessageStore Add_all_missing_super_calls = {95039, DiagnosticCategory::Message, S("Add_all_missing_super_calls_95039"), S("Add all missing super calls")};
        static DiagnosticMessageStore Implement_all_inherited_abstract_classes = {95040, DiagnosticCategory::Message, S("Implement_all_inherited_abstract_classes_95040"), S("Implement all inherited abstract classes")};
        static DiagnosticMessageStore Add_all_missing_async_modifiers = {95041, DiagnosticCategory::Message, S("Add_all_missing_async_modifiers_95041"), S("Add all missing 'async' modifiers")};
        static DiagnosticMessageStore Add_ts_ignore_to_all_error_messages = {95042, DiagnosticCategory::Message, S("Add_ts_ignore_to_all_error_messages_95042"), S("Add '@ts-ignore' to all error messages")};
        static DiagnosticMessageStore Annotate_everything_with_types_from_JSDoc = {95043, DiagnosticCategory::Message, S("Annotate_everything_with_types_from_JSDoc_95043"), S("Annotate everything with types from JSDoc")};
        static DiagnosticMessageStore Add_to_all_uncalled_decorators = {95044, DiagnosticCategory::Message, S("Add_to_all_uncalled_decorators_95044"), S("Add '()' to all uncalled decorators")};
        static DiagnosticMessageStore Convert_all_constructor_functions_to_classes = {95045, DiagnosticCategory::Message, S("Convert_all_constructor_functions_to_classes_95045"), S("Convert all constructor functions to classes")};
        static DiagnosticMessageStore Generate_get_and_set_accessors = {95046, DiagnosticCategory::Message, S("Generate_get_and_set_accessors_95046"), S("Generate 'get' and 'set' accessors")};
        static DiagnosticMessageStore Convert_require_to_import = {95047, DiagnosticCategory::Message, S("Convert_require_to_import_95047"), S("Convert 'require' to 'import'")};
        static DiagnosticMessageStore Convert_all_require_to_import = {95048, DiagnosticCategory::Message, S("Convert_all_require_to_import_95048"), S("Convert all 'require' to 'import'")};
        static DiagnosticMessageStore Move_to_a_new_file = {95049, DiagnosticCategory::Message, S("Move_to_a_new_file_95049"), S("Move to a new file")};
        static DiagnosticMessageStore Remove_unreachable_code = {95050, DiagnosticCategory::Message, S("Remove_unreachable_code_95050"), S("Remove unreachable code")};
        static DiagnosticMessageStore Remove_all_unreachable_code = {95051, DiagnosticCategory::Message, S("Remove_all_unreachable_code_95051"), S("Remove all unreachable code")};
        static DiagnosticMessageStore Add_missing_typeof = {95052, DiagnosticCategory::Message, S("Add_missing_typeof_95052"), S("Add missing 'typeof'")};
        static DiagnosticMessageStore Remove_unused_label = {95053, DiagnosticCategory::Message, S("Remove_unused_label_95053"), S("Remove unused label")};
        static DiagnosticMessageStore Remove_all_unused_labels = {95054, DiagnosticCategory::Message, S("Remove_all_unused_labels_95054"), S("Remove all unused labels")};
        static DiagnosticMessageStore Convert_0_to_mapped_object_type = {95055, DiagnosticCategory::Message, S("Convert_0_to_mapped_object_type_95055"), S("Convert '{0}' to mapped object type")};
        static DiagnosticMessageStore Convert_namespace_import_to_named_imports = {95056, DiagnosticCategory::Message, S("Convert_namespace_import_to_named_imports_95056"), S("Convert namespace import to named imports")};
        static DiagnosticMessageStore Convert_named_imports_to_namespace_import = {95057, DiagnosticCategory::Message, S("Convert_named_imports_to_namespace_import_95057"), S("Convert named imports to namespace import")};
        static DiagnosticMessageStore Add_or_remove_braces_in_an_arrow_function = {95058, DiagnosticCategory::Message, S("Add_or_remove_braces_in_an_arrow_function_95058"), S("Add or remove braces in an arrow function")};
        static DiagnosticMessageStore Add_braces_to_arrow_function = {95059, DiagnosticCategory::Message, S("Add_braces_to_arrow_function_95059"), S("Add braces to arrow function")};
        static DiagnosticMessageStore Remove_braces_from_arrow_function = {95060, DiagnosticCategory::Message, S("Remove_braces_from_arrow_function_95060"), S("Remove braces from arrow function")};
        static DiagnosticMessageStore Convert_default_export_to_named_export = {95061, DiagnosticCategory::Message, S("Convert_default_export_to_named_export_95061"), S("Convert default export to named export")};
        static DiagnosticMessageStore Convert_named_export_to_default_export = {95062, DiagnosticCategory::Message, S("Convert_named_export_to_default_export_95062"), S("Convert named export to default export")};
        static DiagnosticMessageStore Add_missing_enum_member_0 = {95063, DiagnosticCategory::Message, S("Add_missing_enum_member_0_95063"), S("Add missing enum member '{0}'")};
        static DiagnosticMessageStore Add_all_missing_imports = {95064, DiagnosticCategory::Message, S("Add_all_missing_imports_95064"), S("Add all missing imports")};
        static DiagnosticMessageStore Convert_to_async_function = {95065, DiagnosticCategory::Message, S("Convert_to_async_function_95065"), S("Convert to async function")};
        static DiagnosticMessageStore Convert_all_to_async_functions = {95066, DiagnosticCategory::Message, S("Convert_all_to_async_functions_95066"), S("Convert all to async functions")};
        static DiagnosticMessageStore Add_missing_call_parentheses = {95067, DiagnosticCategory::Message, S("Add_missing_call_parentheses_95067"), S("Add missing call parentheses")};
        static DiagnosticMessageStore Add_all_missing_call_parentheses = {95068, DiagnosticCategory::Message, S("Add_all_missing_call_parentheses_95068"), S("Add all missing call parentheses")};
        static DiagnosticMessageStore Add_unknown_conversion_for_non_overlapping_types = {95069, DiagnosticCategory::Message, S("Add_unknown_conversion_for_non_overlapping_types_95069"), S("Add 'unknown' conversion for non-overlapping types")};
        static DiagnosticMessageStore Add_unknown_to_all_conversions_of_non_overlapping_types = {95070, DiagnosticCategory::Message, S("Add_unknown_to_all_conversions_of_non_overlapping_types_95070"), S("Add 'unknown' to all conversions of non-overlapping types")};
        static DiagnosticMessageStore Add_missing_new_operator_to_call = {95071, DiagnosticCategory::Message, S("Add_missing_new_operator_to_call_95071"), S("Add missing 'new' operator to call")};
        static DiagnosticMessageStore Add_missing_new_operator_to_all_calls = {95072, DiagnosticCategory::Message, S("Add_missing_new_operator_to_all_calls_95072"), S("Add missing 'new' operator to all calls")};
        static DiagnosticMessageStore Add_names_to_all_parameters_without_names = {95073, DiagnosticCategory::Message, S("Add_names_to_all_parameters_without_names_95073"), S("Add names to all parameters without names")};
        static DiagnosticMessageStore Enable_the_experimentalDecorators_option_in_your_configuration_file = {95074, DiagnosticCategory::Message, S("Enable_the_experimentalDecorators_option_in_your_configuration_file_95074"), S("Enable the 'experimentalDecorators' option in your configuration file")};
        static DiagnosticMessageStore Convert_parameters_to_destructured_object = {95075, DiagnosticCategory::Message, S("Convert_parameters_to_destructured_object_95075"), S("Convert parameters to destructured object")};
        static DiagnosticMessageStore Extract_type = {95077, DiagnosticCategory::Message, S("Extract_type_95077"), S("Extract type")};
        static DiagnosticMessageStore Extract_to_type_alias = {95078, DiagnosticCategory::Message, S("Extract_to_type_alias_95078"), S("Extract to type alias")};
        static DiagnosticMessageStore Extract_to_typedef = {95079, DiagnosticCategory::Message, S("Extract_to_typedef_95079"), S("Extract to typedef")};
        static DiagnosticMessageStore Infer_this_type_of_0_from_usage = {95080, DiagnosticCategory::Message, S("Infer_this_type_of_0_from_usage_95080"), S("Infer 'this' type of '{0}' from usage")};
        static DiagnosticMessageStore Add_const_to_unresolved_variable = {95081, DiagnosticCategory::Message, S("Add_const_to_unresolved_variable_95081"), S("Add 'const' to unresolved variable")};
        static DiagnosticMessageStore Add_const_to_all_unresolved_variables = {95082, DiagnosticCategory::Message, S("Add_const_to_all_unresolved_variables_95082"), S("Add 'const' to all unresolved variables")};
        static DiagnosticMessageStore Add_await = {95083, DiagnosticCategory::Message, S("Add_await_95083"), S("Add 'await'")};
        static DiagnosticMessageStore Add_await_to_initializer_for_0 = {95084, DiagnosticCategory::Message, S("Add_await_to_initializer_for_0_95084"), S("Add 'await' to initializer for '{0}'")};
        static DiagnosticMessageStore Fix_all_expressions_possibly_missing_await = {95085, DiagnosticCategory::Message, S("Fix_all_expressions_possibly_missing_await_95085"), S("Fix all expressions possibly missing 'await'")};
        static DiagnosticMessageStore Remove_unnecessary_await = {95086, DiagnosticCategory::Message, S("Remove_unnecessary_await_95086"), S("Remove unnecessary 'await'")};
        static DiagnosticMessageStore Remove_all_unnecessary_uses_of_await = {95087, DiagnosticCategory::Message, S("Remove_all_unnecessary_uses_of_await_95087"), S("Remove all unnecessary uses of 'await'")};
        static DiagnosticMessageStore Enable_the_jsx_flag_in_your_configuration_file = {95088, DiagnosticCategory::Message, S("Enable_the_jsx_flag_in_your_configuration_file_95088"), S("Enable the '--jsx' flag in your configuration file")};
        static DiagnosticMessageStore Add_await_to_initializers = {95089, DiagnosticCategory::Message, S("Add_await_to_initializers_95089"), S("Add 'await' to initializers")};
        static DiagnosticMessageStore Extract_to_interface = {95090, DiagnosticCategory::Message, S("Extract_to_interface_95090"), S("Extract to interface")};
        static DiagnosticMessageStore Convert_to_a_bigint_numeric_literal = {95091, DiagnosticCategory::Message, S("Convert_to_a_bigint_numeric_literal_95091"), S("Convert to a bigint numeric literal")};
        static DiagnosticMessageStore Convert_all_to_bigint_numeric_literals = {95092, DiagnosticCategory::Message, S("Convert_all_to_bigint_numeric_literals_95092"), S("Convert all to bigint numeric literals")};
        static DiagnosticMessageStore Convert_const_to_let = {95093, DiagnosticCategory::Message, S("Convert_const_to_let_95093"), S("Convert 'const' to 'let'")};
        static DiagnosticMessageStore Prefix_with_declare = {95094, DiagnosticCategory::Message, S("Prefix_with_declare_95094"), S("Prefix with 'declare'")};
        static DiagnosticMessageStore Prefix_all_incorrect_property_declarations_with_declare = {95095, DiagnosticCategory::Message, S("Prefix_all_incorrect_property_declarations_with_declare_95095"), S("Prefix all incorrect property declarations with 'declare'")};
        static DiagnosticMessageStore Convert_to_template_string = {95096, DiagnosticCategory::Message, S("Convert_to_template_string_95096"), S("Convert to template string")};
        static DiagnosticMessageStore Add_export_to_make_this_file_into_a_module = {95097, DiagnosticCategory::Message, S("Add_export_to_make_this_file_into_a_module_95097"), S("Add 'export {}' to make this file into a module")};
        static DiagnosticMessageStore Set_the_target_option_in_your_configuration_file_to_0 = {95098, DiagnosticCategory::Message, S("Set_the_target_option_in_your_configuration_file_to_0_95098"), S("Set the 'target' option in your configuration file to '{0}'")};
        static DiagnosticMessageStore Set_the_module_option_in_your_configuration_file_to_0 = {95099, DiagnosticCategory::Message, S("Set_the_module_option_in_your_configuration_file_to_0_95099"), S("Set the 'module' option in your configuration file to '{0}'")};
        static DiagnosticMessageStore Convert_invalid_character_to_its_html_entity_code = {95100, DiagnosticCategory::Message, S("Convert_invalid_character_to_its_html_entity_code_95100"), S("Convert invalid character to its html entity code")};
        static DiagnosticMessageStore Convert_all_invalid_characters_to_HTML_entity_code = {95101, DiagnosticCategory::Message, S("Convert_all_invalid_characters_to_HTML_entity_code_95101"), S("Convert all invalid characters to HTML entity code")};
        static DiagnosticMessageStore Convert_all_const_to_let = {95102, DiagnosticCategory::Message, S("Convert_all_const_to_let_95102"), S("Convert all 'const' to 'let'")};
        static DiagnosticMessageStore Convert_function_expression_0_to_arrow_function = {95105, DiagnosticCategory::Message, S("Convert_function_expression_0_to_arrow_function_95105"), S("Convert function expression '{0}' to arrow function")};
        static DiagnosticMessageStore Convert_function_declaration_0_to_arrow_function = {95106, DiagnosticCategory::Message, S("Convert_function_declaration_0_to_arrow_function_95106"), S("Convert function declaration '{0}' to arrow function")};
        static DiagnosticMessageStore Fix_all_implicit_this_errors = {95107, DiagnosticCategory::Message, S("Fix_all_implicit_this_errors_95107"), S("Fix all implicit-'this' errors")};
        static DiagnosticMessageStore Wrap_invalid_character_in_an_expression_container = {95108, DiagnosticCategory::Message, S("Wrap_invalid_character_in_an_expression_container_95108"), S("Wrap invalid character in an expression container")};
        static DiagnosticMessageStore Wrap_all_invalid_characters_in_an_expression_container = {95109, DiagnosticCategory::Message, S("Wrap_all_invalid_characters_in_an_expression_container_95109"), S("Wrap all invalid characters in an expression container")};
        static DiagnosticMessageStore Visit_https_Colon_Slash_Slashaka_ms_Slashtsconfig_to_read_more_about_this_file = {95110, DiagnosticCategory::Message, S("Visit_https_Colon_Slash_Slashaka_ms_Slashtsconfig_to_read_more_about_this_file_95110"), S("Visit https://aka.ms/tsconfig to read more about this file")};
        static DiagnosticMessageStore Add_a_return_statement = {95111, DiagnosticCategory::Message, S("Add_a_return_statement_95111"), S("Add a return statement")};
        static DiagnosticMessageStore Remove_braces_from_arrow_function_body = {95112, DiagnosticCategory::Message, S("Remove_braces_from_arrow_function_body_95112"), S("Remove braces from arrow function body")};
        static DiagnosticMessageStore Wrap_the_following_body_with_parentheses_which_should_be_an_object_literal = {95113, DiagnosticCategory::Message, S("Wrap_the_following_body_with_parentheses_which_should_be_an_object_literal_95113"), S("Wrap the following body with parentheses which should be an object literal")};
        static DiagnosticMessageStore Add_all_missing_return_statement = {95114, DiagnosticCategory::Message, S("Add_all_missing_return_statement_95114"), S("Add all missing return statement")};
        static DiagnosticMessageStore Remove_braces_from_all_arrow_function_bodies_with_relevant_issues = {95115, DiagnosticCategory::Message, S("Remove_braces_from_all_arrow_function_bodies_with_relevant_issues_95115"), S("Remove braces from all arrow function bodies with relevant issues")};
        static DiagnosticMessageStore Wrap_all_object_literal_with_parentheses = {95116, DiagnosticCategory::Message, S("Wrap_all_object_literal_with_parentheses_95116"), S("Wrap all object literal with parentheses")};
        static DiagnosticMessageStore Move_labeled_tuple_element_modifiers_to_labels = {95117, DiagnosticCategory::Message, S("Move_labeled_tuple_element_modifiers_to_labels_95117"), S("Move labeled tuple element modifiers to labels")};
        static DiagnosticMessageStore Convert_overload_list_to_single_signature = {95118, DiagnosticCategory::Message, S("Convert_overload_list_to_single_signature_95118"), S("Convert overload list to single signature")};
        static DiagnosticMessageStore Generate_get_and_set_accessors_for_all_overriding_properties = {95119, DiagnosticCategory::Message, S("Generate_get_and_set_accessors_for_all_overriding_properties_95119"), S("Generate 'get' and 'set' accessors for all overriding properties")};
        static DiagnosticMessageStore Wrap_in_JSX_fragment = {95120, DiagnosticCategory::Message, S("Wrap_in_JSX_fragment_95120"), S("Wrap in JSX fragment")};
        static DiagnosticMessageStore Wrap_all_unparented_JSX_in_JSX_fragment = {95121, DiagnosticCategory::Message, S("Wrap_all_unparented_JSX_in_JSX_fragment_95121"), S("Wrap all unparented JSX in JSX fragment")};
        static DiagnosticMessageStore Convert_arrow_function_or_function_expression = {95122, DiagnosticCategory::Message, S("Convert_arrow_function_or_function_expression_95122"), S("Convert arrow function or function expression")};
        static DiagnosticMessageStore Convert_to_anonymous_function = {95123, DiagnosticCategory::Message, S("Convert_to_anonymous_function_95123"), S("Convert to anonymous function")};
        static DiagnosticMessageStore Convert_to_named_function = {95124, DiagnosticCategory::Message, S("Convert_to_named_function_95124"), S("Convert to named function")};
        static DiagnosticMessageStore Convert_to_arrow_function = {95125, DiagnosticCategory::Message, S("Convert_to_arrow_function_95125"), S("Convert to arrow function")};
        static DiagnosticMessageStore Remove_parentheses = {95126, DiagnosticCategory::Message, S("Remove_parentheses_95126"), S("Remove parentheses")};
        static DiagnosticMessageStore Could_not_find_a_containing_arrow_function = {95127, DiagnosticCategory::Message, S("Could_not_find_a_containing_arrow_function_95127"), S("Could not find a containing arrow function")};
        static DiagnosticMessageStore Containing_function_is_not_an_arrow_function = {95128, DiagnosticCategory::Message, S("Containing_function_is_not_an_arrow_function_95128"), S("Containing function is not an arrow function")};
        static DiagnosticMessageStore Could_not_find_export_statement = {95129, DiagnosticCategory::Message, S("Could_not_find_export_statement_95129"), S("Could not find export statement")};
        static DiagnosticMessageStore This_file_already_has_a_default_export = {95130, DiagnosticCategory::Message, S("This_file_already_has_a_default_export_95130"), S("This file already has a default export")};
        static DiagnosticMessageStore Could_not_find_import_clause = {95131, DiagnosticCategory::Message, S("Could_not_find_import_clause_95131"), S("Could not find import clause")};
        static DiagnosticMessageStore Could_not_find_namespace_import_or_named_imports = {95132, DiagnosticCategory::Message, S("Could_not_find_namespace_import_or_named_imports_95132"), S("Could not find namespace import or named imports")};
        static DiagnosticMessageStore Selection_is_not_a_valid_type_node = {95133, DiagnosticCategory::Message, S("Selection_is_not_a_valid_type_node_95133"), S("Selection is not a valid type node")};
        static DiagnosticMessageStore No_type_could_be_extracted_from_this_type_node = {95134, DiagnosticCategory::Message, S("No_type_could_be_extracted_from_this_type_node_95134"), S("No type could be extracted from this type node")};
        static DiagnosticMessageStore Could_not_find_property_for_which_to_generate_accessor = {95135, DiagnosticCategory::Message, S("Could_not_find_property_for_which_to_generate_accessor_95135"), S("Could not find property for which to generate accessor")};
        static DiagnosticMessageStore Name_is_not_valid = {95136, DiagnosticCategory::Message, S("Name_is_not_valid_95136"), S("Name is not valid")};
        static DiagnosticMessageStore Can_only_convert_property_with_modifier = {95137, DiagnosticCategory::Message, S("Can_only_convert_property_with_modifier_95137"), S("Can only convert property with modifier")};
        static DiagnosticMessageStore Switch_each_misused_0_to_1 = {95138, DiagnosticCategory::Message, S("Switch_each_misused_0_to_1_95138"), S("Switch each misused '{0}' to '{1}'")};
        static DiagnosticMessageStore Convert_to_optional_chain_expression = {95139, DiagnosticCategory::Message, S("Convert_to_optional_chain_expression_95139"), S("Convert to optional chain expression")};
        static DiagnosticMessageStore Could_not_find_convertible_access_expression = {95140, DiagnosticCategory::Message, S("Could_not_find_convertible_access_expression_95140"), S("Could not find convertible access expression")};
        static DiagnosticMessageStore Could_not_find_matching_access_expressions = {95141, DiagnosticCategory::Message, S("Could_not_find_matching_access_expressions_95141"), S("Could not find matching access expressions")};
        static DiagnosticMessageStore Can_only_convert_logical_AND_access_chains = {95142, DiagnosticCategory::Message, S("Can_only_convert_logical_AND_access_chains_95142"), S("Can only convert logical AND access chains")};
        static DiagnosticMessageStore Add_void_to_Promise_resolved_without_a_value = {95143, DiagnosticCategory::Message, S("Add_void_to_Promise_resolved_without_a_value_95143"), S("Add 'void' to Promise resolved without a value")};
        static DiagnosticMessageStore Add_void_to_all_Promises_resolved_without_a_value = {95144, DiagnosticCategory::Message, S("Add_void_to_all_Promises_resolved_without_a_value_95144"), S("Add 'void' to all Promises resolved without a value")};
        static DiagnosticMessageStore Use_element_access_for_0 = {95145, DiagnosticCategory::Message, S("Use_element_access_for_0_95145"), S("Use element access for '{0}'")};
        static DiagnosticMessageStore Use_element_access_for_all_undeclared_properties = {95146, DiagnosticCategory::Message, S("Use_element_access_for_all_undeclared_properties_95146"), S("Use element access for all undeclared properties.")};
        static DiagnosticMessageStore Delete_all_unused_imports = {95147, DiagnosticCategory::Message, S("Delete_all_unused_imports_95147"), S("Delete all unused imports")};
        static DiagnosticMessageStore Infer_function_return_type = {95148, DiagnosticCategory::Message, S("Infer_function_return_type_95148"), S("Infer function return type")};
        static DiagnosticMessageStore Return_type_must_be_inferred_from_a_function = {95149, DiagnosticCategory::Message, S("Return_type_must_be_inferred_from_a_function_95149"), S("Return type must be inferred from a function")};
        static DiagnosticMessageStore Could_not_determine_function_return_type = {95150, DiagnosticCategory::Message, S("Could_not_determine_function_return_type_95150"), S("Could not determine function return type")};
        static DiagnosticMessageStore Could_not_convert_to_arrow_function = {95151, DiagnosticCategory::Message, S("Could_not_convert_to_arrow_function_95151"), S("Could not convert to arrow function")};
        static DiagnosticMessageStore Could_not_convert_to_named_function = {95152, DiagnosticCategory::Message, S("Could_not_convert_to_named_function_95152"), S("Could not convert to named function")};
        static DiagnosticMessageStore Could_not_convert_to_anonymous_function = {95153, DiagnosticCategory::Message, S("Could_not_convert_to_anonymous_function_95153"), S("Could not convert to anonymous function")};
        static DiagnosticMessageStore Can_only_convert_string_concatenations_and_string_literals = {95154, DiagnosticCategory::Message, S("Can_only_convert_string_concatenations_and_string_literals_95154"), S("Can only convert string concatenations and string literals")};
        static DiagnosticMessageStore Selection_is_not_a_valid_statement_or_statements = {95155, DiagnosticCategory::Message, S("Selection_is_not_a_valid_statement_or_statements_95155"), S("Selection is not a valid statement or statements")};
        static DiagnosticMessageStore Add_missing_function_declaration_0 = {95156, DiagnosticCategory::Message, S("Add_missing_function_declaration_0_95156"), S("Add missing function declaration '{0}'")};
        static DiagnosticMessageStore Add_all_missing_function_declarations = {95157, DiagnosticCategory::Message, S("Add_all_missing_function_declarations_95157"), S("Add all missing function declarations")};
        static DiagnosticMessageStore Method_not_implemented = {95158, DiagnosticCategory::Message, S("Method_not_implemented_95158"), S("Method not implemented.")};
        static DiagnosticMessageStore Function_not_implemented = {95159, DiagnosticCategory::Message, S("Function_not_implemented_95159"), S("Function not implemented.")};
        static DiagnosticMessageStore Add_override_modifier = {95160, DiagnosticCategory::Message, S("Add_override_modifier_95160"), S("Add 'override' modifier")};
        static DiagnosticMessageStore Remove_override_modifier = {95161, DiagnosticCategory::Message, S("Remove_override_modifier_95161"), S("Remove 'override' modifier")};
        static DiagnosticMessageStore Add_all_missing_override_modifiers = {95162, DiagnosticCategory::Message, S("Add_all_missing_override_modifiers_95162"), S("Add all missing 'override' modifiers")};
        static DiagnosticMessageStore Remove_all_unnecessary_override_modifiers = {95163, DiagnosticCategory::Message, S("Remove_all_unnecessary_override_modifiers_95163"), S("Remove all unnecessary 'override' modifiers")};
        static DiagnosticMessageStore Can_only_convert_named_export = {95164, DiagnosticCategory::Message, S("Can_only_convert_named_export_95164"), S("Can only convert named export")};
        static DiagnosticMessageStore Add_missing_properties = {95165, DiagnosticCategory::Message, S("Add_missing_properties_95165"), S("Add missing properties")};
        static DiagnosticMessageStore Add_all_missing_properties = {95166, DiagnosticCategory::Message, S("Add_all_missing_properties_95166"), S("Add all missing properties")};
        static DiagnosticMessageStore Add_missing_attributes = {95167, DiagnosticCategory::Message, S("Add_missing_attributes_95167"), S("Add missing attributes")};
        static DiagnosticMessageStore Add_all_missing_attributes = {95168, DiagnosticCategory::Message, S("Add_all_missing_attributes_95168"), S("Add all missing attributes")};
        static DiagnosticMessageStore Add_undefined_to_optional_property_type = {95169, DiagnosticCategory::Message, S("Add_undefined_to_optional_property_type_95169"), S("Add 'undefined' to optional property type")};
        static DiagnosticMessageStore Convert_named_imports_to_default_import = {95170, DiagnosticCategory::Message, S("Convert_named_imports_to_default_import_95170"), S("Convert named imports to default import")};
        static DiagnosticMessageStore Delete_unused_param_tag_0 = {95171, DiagnosticCategory::Message, S("Delete_unused_param_tag_0_95171"), S("Delete unused '@param' tag '{0}'")};
        static DiagnosticMessageStore Delete_all_unused_param_tags = {95172, DiagnosticCategory::Message, S("Delete_all_unused_param_tags_95172"), S("Delete all unused '@param' tags")};
        static DiagnosticMessageStore Rename_param_tag_name_0_to_1 = {95173, DiagnosticCategory::Message, S("Rename_param_tag_name_0_to_1_95173"), S("Rename '@param' tag name '{0}' to '{1}'")};
        static DiagnosticMessageStore Use_0 = {95174, DiagnosticCategory::Message, S("Use_0_95174"), S("Use `{0}`.")};
        static DiagnosticMessageStore Use_Number_isNaN_in_all_conditions = {95175, DiagnosticCategory::Message, S("Use_Number_isNaN_in_all_conditions_95175"), S("Use `Number.isNaN` in all conditions.")};
        static DiagnosticMessageStore Convert_typedef_to_TypeScript_type = {95176, DiagnosticCategory::Message, S("Convert_typedef_to_TypeScript_type_95176"), S("Convert typedef to TypeScript type.")};
        static DiagnosticMessageStore Convert_all_typedef_to_TypeScript_types = {95177, DiagnosticCategory::Message, S("Convert_all_typedef_to_TypeScript_types_95177"), S("Convert all typedef to TypeScript types.")};
        static DiagnosticMessageStore Move_to_file = {95178, DiagnosticCategory::Message, S("Move_to_file_95178"), S("Move to file")};
        static DiagnosticMessageStore Cannot_move_to_file_selected_file_is_invalid = {95179, DiagnosticCategory::Message, S("Cannot_move_to_file_selected_file_is_invalid_95179"), S("Cannot move to file, selected file is invalid")};
        static DiagnosticMessageStore Use_import_type = {95180, DiagnosticCategory::Message, S("Use_import_type_95180"), S("Use 'import type'")};
        static DiagnosticMessageStore Use_type_0 = {95181, DiagnosticCategory::Message, S("Use_type_0_95181"), S("Use 'type {0}'")};
        static DiagnosticMessageStore Fix_all_with_type_only_imports = {95182, DiagnosticCategory::Message, S("Fix_all_with_type_only_imports_95182"), S("Fix all with type-only imports")};
        static DiagnosticMessageStore Cannot_move_statements_to_the_selected_file = {95183, DiagnosticCategory::Message, S("Cannot_move_statements_to_the_selected_file_95183"), S("Cannot move statements to the selected file")};
        static DiagnosticMessageStore Inline_variable = {95184, DiagnosticCategory::Message, S("Inline_variable_95184"), S("Inline variable")};
        static DiagnosticMessageStore Could_not_find_variable_to_inline = {95185, DiagnosticCategory::Message, S("Could_not_find_variable_to_inline_95185"), S("Could not find variable to inline.")};
        static DiagnosticMessageStore Variables_with_multiple_declarations_cannot_be_inlined = {95186, DiagnosticCategory::Message, S("Variables_with_multiple_declarations_cannot_be_inlined_95186"), S("Variables with multiple declarations cannot be inlined.")};
        static DiagnosticMessageStore Add_missing_comma_for_object_member_completion_0 = {95187, DiagnosticCategory::Message, S("Add_missing_comma_for_object_member_completion_0_95187"), S("Add missing comma for object member completion '{0}'.")};
        static DiagnosticMessageStore No_value_exists_in_scope_for_the_shorthand_property_0_Either_declare_one_or_provide_an_initializer = {18004, DiagnosticCategory::Error, S("No_value_exists_in_scope_for_the_shorthand_property_0_Either_declare_one_or_provide_an_initializer_18004"), S("No value exists in scope for the shorthand property '{0}'. Either declare one or provide an initializer.")};
        static DiagnosticMessageStore Classes_may_not_have_a_field_named_constructor = {18006, DiagnosticCategory::Error, S("Classes_may_not_have_a_field_named_constructor_18006"), S("Classes may not have a field named 'constructor'.")};
        static DiagnosticMessageStore JSX_expressions_may_not_use_the_comma_operator_Did_you_mean_to_write_an_array = {18007, DiagnosticCategory::Error, S("JSX_expressions_may_not_use_the_comma_operator_Did_you_mean_to_write_an_array_18007"), S("JSX expressions may not use the comma operator. Did you mean to write an array?")};
        static DiagnosticMessageStore Private_identifiers_cannot_be_used_as_parameters = {18009, DiagnosticCategory::Error, S("Private_identifiers_cannot_be_used_as_parameters_18009"), S("Private identifiers cannot be used as parameters.")};
        static DiagnosticMessageStore An_accessibility_modifier_cannot_be_used_with_a_private_identifier = {18010, DiagnosticCategory::Error, S("An_accessibility_modifier_cannot_be_used_with_a_private_identifier_18010"), S("An accessibility modifier cannot be used with a private identifier.")};
        static DiagnosticMessageStore The_operand_of_a_delete_operator_cannot_be_a_private_identifier = {18011, DiagnosticCategory::Error, S("The_operand_of_a_delete_operator_cannot_be_a_private_identifier_18011"), S("The operand of a 'delete' operator cannot be a private identifier.")};
        static DiagnosticMessageStore constructor_is_a_reserved_word = {18012, DiagnosticCategory::Error, S("constructor_is_a_reserved_word_18012"), S("'#constructor' is a reserved word.")};
        static DiagnosticMessageStore Property_0_is_not_accessible_outside_class_1_because_it_has_a_private_identifier = {18013, DiagnosticCategory::Error, S("Property_0_is_not_accessible_outside_class_1_because_it_has_a_private_identifier_18013"), S("Property '{0}' is not accessible outside class '{1}' because it has a private identifier.")};
        static DiagnosticMessageStore The_property_0_cannot_be_accessed_on_type_1_within_this_class_because_it_is_shadowed_by_another_private_identifier_with_the_same_spelling = {18014, DiagnosticCategory::Error, S("The_property_0_cannot_be_accessed_on_type_1_within_this_class_because_it_is_shadowed_by_another_priv_18014"), S("The property '{0}' cannot be accessed on type '{1}' within this class because it is shadowed by another private identifier with the same spelling.")};
        static DiagnosticMessageStore Property_0_in_type_1_refers_to_a_different_member_that_cannot_be_accessed_from_within_type_2 = {18015, DiagnosticCategory::Error, S("Property_0_in_type_1_refers_to_a_different_member_that_cannot_be_accessed_from_within_type_2_18015"), S("Property '{0}' in type '{1}' refers to a different member that cannot be accessed from within type '{2}'.")};
        static DiagnosticMessageStore Private_identifiers_are_not_allowed_outside_class_bodies = {18016, DiagnosticCategory::Error, S("Private_identifiers_are_not_allowed_outside_class_bodies_18016"), S("Private identifiers are not allowed outside class bodies.")};
        static DiagnosticMessageStore The_shadowing_declaration_of_0_is_defined_here = {18017, DiagnosticCategory::Error, S("The_shadowing_declaration_of_0_is_defined_here_18017"), S("The shadowing declaration of '{0}' is defined here")};
        static DiagnosticMessageStore The_declaration_of_0_that_you_probably_intended_to_use_is_defined_here = {18018, DiagnosticCategory::Error, S("The_declaration_of_0_that_you_probably_intended_to_use_is_defined_here_18018"), S("The declaration of '{0}' that you probably intended to use is defined here")};
        static DiagnosticMessageStore _0_modifier_cannot_be_used_with_a_private_identifier = {18019, DiagnosticCategory::Error, S("_0_modifier_cannot_be_used_with_a_private_identifier_18019"), S("'{0}' modifier cannot be used with a private identifier.")};
        static DiagnosticMessageStore An_enum_member_cannot_be_named_with_a_private_identifier = {18024, DiagnosticCategory::Error, S("An_enum_member_cannot_be_named_with_a_private_identifier_18024"), S("An enum member cannot be named with a private identifier.")};
        static DiagnosticMessageStore can_only_be_used_at_the_start_of_a_file = {18026, DiagnosticCategory::Error, S("can_only_be_used_at_the_start_of_a_file_18026"), S("'#!' can only be used at the start of a file.")};
        static DiagnosticMessageStore Compiler_reserves_name_0_when_emitting_private_identifier_downlevel = {18027, DiagnosticCategory::Error, S("Compiler_reserves_name_0_when_emitting_private_identifier_downlevel_18027"), S("Compiler reserves name '{0}' when emitting private identifier downlevel.")};
        static DiagnosticMessageStore Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher = {18028, DiagnosticCategory::Error, S("Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher_18028"), S("Private identifiers are only available when targeting ECMAScript 2015 and higher.")};
        static DiagnosticMessageStore Private_identifiers_are_not_allowed_in_variable_declarations = {18029, DiagnosticCategory::Error, S("Private_identifiers_are_not_allowed_in_variable_declarations_18029"), S("Private identifiers are not allowed in variable declarations.")};
        static DiagnosticMessageStore An_optional_chain_cannot_contain_private_identifiers = {18030, DiagnosticCategory::Error, S("An_optional_chain_cannot_contain_private_identifiers_18030"), S("An optional chain cannot contain private identifiers.")};
        static DiagnosticMessageStore The_intersection_0_was_reduced_to_never_because_property_1_has_conflicting_types_in_some_constituents = {18031, DiagnosticCategory::Error, S("The_intersection_0_was_reduced_to_never_because_property_1_has_conflicting_types_in_some_constituent_18031"), S("The intersection '{0}' was reduced to 'never' because property '{1}' has conflicting types in some constituents.")};
        static DiagnosticMessageStore The_intersection_0_was_reduced_to_never_because_property_1_exists_in_multiple_constituents_and_is_private_in_some = {18032, DiagnosticCategory::Error, S("The_intersection_0_was_reduced_to_never_because_property_1_exists_in_multiple_constituents_and_is_pr_18032"), S("The intersection '{0}' was reduced to 'never' because property '{1}' exists in multiple constituents and is private in some.")};
        static DiagnosticMessageStore Type_0_is_not_assignable_to_type_1_as_required_for_computed_enum_member_values = {18033, DiagnosticCategory::Error, S("Type_0_is_not_assignable_to_type_1_as_required_for_computed_enum_member_values_18033"), S("Type '{0}' is not assignable to type '{1}' as required for computed enum member values.")};
        static DiagnosticMessageStore Specify_the_JSX_fragment_factory_function_to_use_when_targeting_react_JSX_emit_with_jsxFactory_compiler_option_is_specified_e_g_Fragment = {18034, DiagnosticCategory::Message, S("Specify_the_JSX_fragment_factory_function_to_use_when_targeting_react_JSX_emit_with_jsxFactory_compi_18034"), S("Specify the JSX fragment factory function to use when targeting 'react' JSX emit with 'jsxFactory' compiler option is specified, e.g. 'Fragment'.")};
        static DiagnosticMessageStore Invalid_value_for_jsxFragmentFactory_0_is_not_a_valid_identifier_or_qualified_name = {18035, DiagnosticCategory::Error, S("Invalid_value_for_jsxFragmentFactory_0_is_not_a_valid_identifier_or_qualified_name_18035"), S("Invalid value for 'jsxFragmentFactory'. '{0}' is not a valid identifier or qualified-name.")};
        static DiagnosticMessageStore Class_decorators_can_t_be_used_with_static_private_identifier_Consider_removing_the_experimental_decorator = {18036, DiagnosticCategory::Error, S("Class_decorators_can_t_be_used_with_static_private_identifier_Consider_removing_the_experimental_dec_18036"), S("Class decorators can't be used with static private identifier. Consider removing the experimental decorator.")};
        static DiagnosticMessageStore await_expression_cannot_be_used_inside_a_class_static_block = {18037, DiagnosticCategory::Error, S("await_expression_cannot_be_used_inside_a_class_static_block_18037"), S("'await' expression cannot be used inside a class static block.")};
        static DiagnosticMessageStore for_await_loops_cannot_be_used_inside_a_class_static_block = {18038, DiagnosticCategory::Error, S("for_await_loops_cannot_be_used_inside_a_class_static_block_18038"), S("'for await' loops cannot be used inside a class static block.")};
        static DiagnosticMessageStore Invalid_use_of_0_It_cannot_be_used_inside_a_class_static_block = {18039, DiagnosticCategory::Error, S("Invalid_use_of_0_It_cannot_be_used_inside_a_class_static_block_18039"), S("Invalid use of '{0}'. It cannot be used inside a class static block.")};
        static DiagnosticMessageStore A_return_statement_cannot_be_used_inside_a_class_static_block = {18041, DiagnosticCategory::Error, S("A_return_statement_cannot_be_used_inside_a_class_static_block_18041"), S("A 'return' statement cannot be used inside a class static block.")};
        static DiagnosticMessageStore _0_is_a_type_and_cannot_be_imported_in_JavaScript_files_Use_1_in_a_JSDoc_type_annotation = {18042, DiagnosticCategory::Error, S("_0_is_a_type_and_cannot_be_imported_in_JavaScript_files_Use_1_in_a_JSDoc_type_annotation_18042"), S("'{0}' is a type and cannot be imported in JavaScript files. Use '{1}' in a JSDoc type annotation.")};
        static DiagnosticMessageStore Types_cannot_appear_in_export_declarations_in_JavaScript_files = {18043, DiagnosticCategory::Error, S("Types_cannot_appear_in_export_declarations_in_JavaScript_files_18043"), S("Types cannot appear in export declarations in JavaScript files.")};
        static DiagnosticMessageStore _0_is_automatically_exported_here = {18044, DiagnosticCategory::Message, S("_0_is_automatically_exported_here_18044"), S("'{0}' is automatically exported here.")};
        static DiagnosticMessageStore Properties_with_the_accessor_modifier_are_only_available_when_targeting_ECMAScript_2015_and_higher = {18045, DiagnosticCategory::Error, S("Properties_with_the_accessor_modifier_are_only_available_when_targeting_ECMAScript_2015_and_higher_18045"), S("Properties with the 'accessor' modifier are only available when targeting ECMAScript 2015 and higher.")};
        static DiagnosticMessageStore _0_is_of_type_unknown = {18046, DiagnosticCategory::Error, S("_0_is_of_type_unknown_18046"), S("'{0}' is of type 'unknown'.")};
        static DiagnosticMessageStore _0_is_possibly_null = {18047, DiagnosticCategory::Error, S("_0_is_possibly_null_18047"), S("'{0}' is possibly 'null'.")};
        static DiagnosticMessageStore _0_is_possibly_undefined = {18048, DiagnosticCategory::Error, S("_0_is_possibly_undefined_18048"), S("'{0}' is possibly 'undefined'.")};
        static DiagnosticMessageStore _0_is_possibly_null_or_undefined = {18049, DiagnosticCategory::Error, S("_0_is_possibly_null_or_undefined_18049"), S("'{0}' is possibly 'null' or 'undefined'.")};
        static DiagnosticMessageStore The_value_0_cannot_be_used_here = {18050, DiagnosticCategory::Error, S("The_value_0_cannot_be_used_here_18050"), S("The value '{0}' cannot be used here.")};
        static DiagnosticMessageStore Compiler_option_0_cannot_be_given_an_empty_string = {18051, DiagnosticCategory::Error, S("Compiler_option_0_cannot_be_given_an_empty_string_18051"), S("Compiler option '{0}' cannot be given an empty string.")};
        static DiagnosticMessageStore Non_abstract_class_0_does_not_implement_all_abstract_members_of_1 = {18052, DiagnosticCategory::Error, S("Non_abstract_class_0_does_not_implement_all_abstract_members_of_1_18052"), S("Non-abstract class '{0}' does not implement all abstract members of '{1}'")};
        static DiagnosticMessageStore Its_type_0_is_not_a_valid_JSX_element_type = {18053, DiagnosticCategory::Error, S("Its_type_0_is_not_a_valid_JSX_element_type_18053"), S("Its type '{0}' is not a valid JSX element type.")};
        static DiagnosticMessageStore await_using_statements_cannot_be_used_inside_a_class_static_block = {18054, DiagnosticCategory::Error, S("await_using_statements_cannot_be_used_inside_a_class_static_block_18054"), S("'await using' statements cannot be used inside a class static block.")};
    }

} // namespace ts