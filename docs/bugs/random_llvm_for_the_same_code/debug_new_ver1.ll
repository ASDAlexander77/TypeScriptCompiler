Args: tsc.exe --emit=mlir-llvm c:\temp\1.ts -debug 
Load new dialect in Context 
Load new dialect in Context ts
Load new dialect in Context std
Load new dialect in Context math
Load new dialect in Context llvm
Load new dialect in Context async

!! discovering 'ret type' & 'captured vars' for : main

!! variable = a type: !ts.union<!ts.number,!ts.string> op: %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>

!! variable = b type: !ts.union<!ts.boolean,!ts.number,!ts.string> op: %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>

!! variable: a type: !ts.ref<!ts.union<!ts.number,!ts.string>>

!! Dest type: !ts.union<!ts.number,!ts.string>

!! variable: b type: !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>

!! variable: a type: !ts.ref<!ts.union<!ts.number,!ts.string>>

!! Dest type: !ts.union<!ts.boolean,!ts.number,!ts.string>

!! variable: b type: !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>

!! variable: b type: !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>

!! variable = b type: !ts.number op: %13 = ts.Cast %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number

!! variable = a type: !ts.union<!ts.number,!ts.string> op: %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>

!! variable = b type: !ts.union<!ts.boolean,!ts.number,!ts.string> op: %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>

!! variable: a type: !ts.ref<!ts.union<!ts.number,!ts.string>>

!! Dest type: !ts.union<!ts.number,!ts.string>

!! variable: b type: !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>

!! variable: a type: !ts.ref<!ts.union<!ts.number,!ts.string>>

!! Dest type: !ts.union<!ts.boolean,!ts.number,!ts.string>

!! variable: b type: !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>

!! variable: b type: !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>

!! variable = b type: !ts.number op: %13 = ts.Cast %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number

!! reg. func: main type:() -> ()

!! reg. func: main num inputs:0

!! variable = a type: !ts.union<!ts.number,!ts.string> op: %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>

!! variable = b type: !ts.union<!ts.boolean,!ts.number,!ts.string> op: %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>

!! variable: a type: !ts.ref<!ts.union<!ts.number,!ts.string>>

!! Dest type: !ts.union<!ts.number,!ts.string>

!! variable: b type: !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>

!! variable: a type: !ts.ref<!ts.union<!ts.number,!ts.string>>

!! Dest type: !ts.union<!ts.boolean,!ts.number,!ts.string>

!! variable: b type: !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>

!! variable: b type: !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>

!! variable = b type: !ts.number op: %13 = ts.Cast %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number

!! re-process. func: main type:() -> ()

!! re-process. func: main num inputs:0
Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %6 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %7 = ts.Cast %6 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %7, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %8 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %9 = "ts.TypeOf"(%8) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %10 = ts.Constant {value = "number"} : !ts.string
  %11 = ts.LogicalBinary %9(34) %10 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%11) ( {
    %14 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %15 = ts.Cast %14 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %16 = ts.UnresolvedSymbolRef {identifier = @print} : none
    %17 = ts.Constant {value = "b number: "} : !ts.string
    %18 = ts.Cast %15 : !ts.number to !ts.string
    ts.Print(%17, %18) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %12 = ts.UnresolvedSymbolRef {identifier = @print} : none
  %13 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%13) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %13 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %14 = ts.Cast %13 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %15 = ts.UnresolvedSymbolRef {identifier = @print} : none
    %16 = ts.Constant {value = "b number: "} : !ts.string
    %17 = ts.Cast %14 : !ts.number to !ts.string
    ts.Print(%16, %17) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.UnresolvedSymbolRef {identifier = @print} : none
  %12 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%12) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %13 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %14 = ts.Cast %13 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %15 = ts.UnresolvedSymbolRef {identifier = @print} : none
    %16 = ts.Constant {value = "b number: "} : !ts.string
    %17 = ts.Cast %14 : !ts.number to !ts.string
    ts.Print(%16, %17) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.UnresolvedSymbolRef {identifier = @print} : none
  %12 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%12) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %13 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %14 = ts.Cast %13 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %15 = ts.UnresolvedSymbolRef {identifier = @print} : none
    %16 = ts.Constant {value = "b number: "} : !ts.string
    %17 = ts.Cast %14 : !ts.number to !ts.string
    ts.Print(%16, %17) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.UnresolvedSymbolRef {identifier = @print} : none
  %12 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%12) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnusedResults"
"`anonymous-namespace'::RemoveUnusedResults" result 0
Trying to match "`anonymous-namespace'::RemoveStaticCondition"
"`anonymous-namespace'::RemoveStaticCondition" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %13 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %14 = ts.Cast %13 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %15 = ts.UnresolvedSymbolRef {identifier = @print} : none
    %16 = ts.Constant {value = "b number: "} : !ts.string
    %17 = ts.Cast %14 : !ts.number to !ts.string
    ts.Print(%16, %17) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.UnresolvedSymbolRef {identifier = @print} : none
  %12 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%12) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %13 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %14 = ts.GetValueFromUnionOp %13 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %15 = ts.UnresolvedSymbolRef {identifier = @print} : none
    %16 = ts.Constant {value = "b number: "} : !ts.string
    %17 = ts.Cast %14 : !ts.number to !ts.string
    ts.Print(%16, %17) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.UnresolvedSymbolRef {identifier = @print} : none
  %12 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%12) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %13 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %14 = ts.GetValueFromUnionOp %13 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %15 = ts.Constant {value = "b number: "} : !ts.string
    %16 = ts.Cast %14 : !ts.number to !ts.string
    ts.Print(%15, %16) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.UnresolvedSymbolRef {identifier = @print} : none
  %12 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%12) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnusedResults"
"`anonymous-namespace'::RemoveUnusedResults" result 0
Trying to match "`anonymous-namespace'::RemoveStaticCondition"
"`anonymous-namespace'::RemoveStaticCondition" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnusedResults"
"`anonymous-namespace'::RemoveUnusedResults" result 0
Trying to match "`anonymous-namespace'::RemoveStaticCondition"
"`anonymous-namespace'::RemoveStaticCondition" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnusedResults"
"`anonymous-namespace'::RemoveUnusedResults" result 0
Trying to match "`anonymous-namespace'::RemoveStaticCondition"
"`anonymous-namespace'::RemoveStaticCondition" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnusedResults"
"`anonymous-namespace'::RemoveUnusedResults" result 0
Trying to match "`anonymous-namespace'::RemoveStaticCondition"
"`anonymous-namespace'::RemoveStaticCondition" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnusedResults"
"`anonymous-namespace'::RemoveUnusedResults" result 0
Trying to match "`anonymous-namespace'::RemoveStaticCondition"
"`anonymous-namespace'::RemoveStaticCondition" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnusedResults"
"`anonymous-namespace'::RemoveUnusedResults" result 0
Trying to match "`anonymous-namespace'::RemoveStaticCondition"
"`anonymous-namespace'::RemoveStaticCondition" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnusedResults"
"`anonymous-namespace'::RemoveUnusedResults" result 0
Trying to match "`anonymous-namespace'::RemoveStaticCondition"
"`anonymous-namespace'::RemoveStaticCondition" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnusedResults"
"`anonymous-namespace'::RemoveUnusedResults" result 0
Trying to match "`anonymous-namespace'::RemoveStaticCondition"
"`anonymous-namespace'::RemoveStaticCondition" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnusedResults"
"`anonymous-namespace'::RemoveUnusedResults" result 0
Trying to match "`anonymous-namespace'::RemoveStaticCondition"
"`anonymous-namespace'::RemoveStaticCondition" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


The pattern rewrite doesn't converge after scanning 10 times

//===-------------------------------------------===//
Legalizing operation : 'ts.Func'(0x1b3ca893ba0) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Entry'(0x1b3ca977a20) {
  "ts.Entry"() : () -> ()

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.Entry -> ()' {
Trying to match "`anonymous-namespace'::EntryOpLowering"
    ** Insert  : 'ts.ReturnInternal'(0x1b3ca976b80)
    ** Erase   : 'ts.Entry'(0x1b3ca977a20)
"`anonymous-namespace'::EntryOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'ts.ReturnInternal'(0x1b3ca976b80) {
      "ts.ReturnInternal"() : () -> ()

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
^bb1:  // no predecessors
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Variable'(0x1b3ca857100) {
  %0 = "ts.Variable"() {captured = false} : () -> !ts.ref<!ts.union<!ts.number,!ts.string>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Variable'(0x1b3ca857420) {
  %1 = "ts.Variable"() {captured = false} : () -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Constant'(0x1b3ca857240) {
  %2 = "ts.Constant"() {value = 1.000000e+01 : f64} : () -> !ts.number

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.TypeOf'(0x1b3ca7b0e40) {
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.TypeOf -> ()' {
Trying to match "`anonymous-namespace'::TypeOfOpLowering"
    ** Insert  : 'ts.Constant'(0x1b3ca85d320)
    ** Replace : 'ts.TypeOf'(0x1b3ca7b0e40)
"`anonymous-namespace'::TypeOfOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'ts.Constant'(0x1b3ca85d320) {
      %3 = "ts.Constant"() {value = "number"} : () -> !ts.string

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %5 = ts.CreateUnionInstance %2, %4 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %5, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %6 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %7 = ts.Cast %6 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %7, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %8 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %9 = "ts.TypeOf"(%8) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %10 = ts.Constant {value = "number"} : !ts.string
  %11 = ts.LogicalBinary %9(34) %10 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%11) ( {
    %13 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %14 = ts.GetValueFromUnionOp %13 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %15 = ts.Constant {value = "b number: "} : !ts.string
    %16 = ts.Cast %14 : !ts.number to !ts.string
    ts.Print(%15, %16) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %12 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%12) : !ts.string
  "ts.Exit"() : () -> ()
^bb1:  // no predecessors
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.CreateUnionInstance'(0x1b3ca8d7340) {
  %5 = "ts.CreateUnionInstance"(%2, %4) : (!ts.number, !ts.string) -> !ts.union<!ts.number,!ts.string>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Store'(0x1b3ca7fa210) {
  "ts.Store"(%5, %0) : (!ts.union<!ts.number,!ts.string>, !ts.ref<!ts.union<!ts.number,!ts.string>>) -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Load'(0x1b3ca7b0540) {
  %6 = "ts.Load"(%0) : (!ts.ref<!ts.union<!ts.number,!ts.string>>) -> !ts.union<!ts.number,!ts.string>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Cast'(0x1b3ca7b1980) {
  %7 = "ts.Cast"(%6) : (!ts.union<!ts.number,!ts.string>) -> !ts.union<!ts.boolean,!ts.number,!ts.string>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Store'(0x1b3ca7f77d0) {
  "ts.Store"(%7, %1) : (!ts.union<!ts.boolean,!ts.number,!ts.string>, !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>) -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Load'(0x1b3ca7b1ec0) {
  %8 = "ts.Load"(%1) : (!ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>) -> !ts.union<!ts.boolean,!ts.number,!ts.string>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.TypeOf'(0x1b3ca7b0d80) {
  %9 = "ts.TypeOf"(%8) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.TypeOf -> ()' {
Trying to match "`anonymous-namespace'::TypeOfOpLowering"
    ** Insert  : 'ts.GetTypeInfoFromUnionOp'(0x1b3ca7afe80)
    ** Replace : 'ts.TypeOf'(0x1b3ca7b0d80)
"`anonymous-namespace'::TypeOfOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'ts.GetTypeInfoFromUnionOp'(0x1b3ca7afe80) {
      %9 = "ts.GetTypeInfoFromUnionOp"(%8) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %5 = ts.CreateUnionInstance %2, %4 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %5, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %6 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %7 = ts.Cast %6 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %7, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %8 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %9 = ts.GetTypeInfoFromUnionOp %8 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %10 = "ts.TypeOf"(%8) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %11 = ts.Constant {value = "number"} : !ts.string
  %12 = ts.LogicalBinary %10(34) %11 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%12) ( {
    %14 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %15 = ts.GetValueFromUnionOp %14 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %16 = ts.Constant {value = "b number: "} : !ts.string
    %17 = ts.Cast %15 : !ts.number to !ts.string
    ts.Print(%16, %17) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %13 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%13) : !ts.string
  "ts.Exit"() : () -> ()
^bb1:  // no predecessors
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Constant'(0x1b3ca858320) {
  %11 = "ts.Constant"() {value = "number"} : () -> !ts.string

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.LogicalBinary'(0x1b3ca8d85a0) {
  %12 = "ts.LogicalBinary"(%10, %11) {opCode = 34 : i32} : (!ts.string, !ts.string) -> !ts.boolean

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.If'(0x1b3ca712820) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.If -> ()' {
Trying to match "`anonymous-namespace'::IfOpLowering"
    ** Insert  : 'std.br'(0x1b3ca8957d0)
    ** Erase   : 'ts.Result'(0x1b3ca978440)
    ** Insert  : 'ts.Cast'(0x1b3ca7b09c0)
    ** Insert  : 'std.cond_br'(0x1b3ca833d60)
    ** Replace : 'ts.If'(0x1b3ca712820)
"`anonymous-namespace'::IfOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'std.br'(0x1b3ca8957d0) {
      "std.br"()[^bb2] : () -> ()

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'ts.Cast'(0x1b3ca7b09c0) {
      %13 = "ts.Cast"(%12) : (!ts.boolean) -> i1

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'std.cond_br'(0x1b3ca833d60) {
      "std.cond_br"(%13)[^bb1, ^bb2] {operand_segment_sizes = dense<[1, 0, 0]> : vector<3xi32>} : (i1) -> ()

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %5 = ts.CreateUnionInstance %2, %4 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %5, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %6 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %7 = ts.Cast %6 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %7, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %8 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %9 = ts.GetTypeInfoFromUnionOp %8 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %10 = "ts.TypeOf"(%8) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %11 = ts.Constant {value = "number"} : !ts.string
  %12 = ts.LogicalBinary %10(34) %11 : !ts.string, !ts.string -> !ts.boolean
  %13 = ts.Cast %12 : !ts.boolean to i1
  cond_br %13, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %14 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %15 = ts.GetValueFromUnionOp %14 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %16 = ts.Constant {value = "b number: "} : !ts.string
  %17 = ts.Cast %15 : !ts.number to !ts.string
  ts.Print(%16, %17) : !ts.string, !ts.string
  "ts.Result"() : () -> ()
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  "ts.If"(%12) ( {
  },  {
  }) : (!ts.boolean) -> ()
  %18 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%18) : !ts.string
  "ts.Exit"() : () -> ()
^bb3:  // no predecessors
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Load'(0x1b3ca7b1a40) {
  %14 = "ts.Load"(%1) : (!ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>) -> !ts.union<!ts.boolean,!ts.number,!ts.string>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.GetValueFromUnionOp'(0x1b3ca7b1b00) {
  %15 = "ts.GetValueFromUnionOp"(%14) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.number

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Constant'(0x1b3ca858500) {
  %16 = "ts.Constant"() {value = "b number: "} : () -> !ts.string

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Cast'(0x1b3ca7b1bc0) {
  %17 = "ts.Cast"(%15) : (!ts.number) -> !ts.string

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Print'(0x1b3ca7f7cb0) {
  "ts.Print"(%16, %17) : (!ts.string, !ts.string) -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Result'(0x1b3ca978440) {
  "ts.Result"() : () -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Constant'(0x1b3ca8574c0) {
  %18 = "ts.Constant"() {value = "done."} : () -> !ts.string

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Print'(0x1b3ca894a10) {
  "ts.Print"(%18) : (!ts.string) -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Exit'(0x1b3ca9768b0) {
  "ts.Exit"() : () -> ()

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.Exit -> ()' {
Trying to match "`anonymous-namespace'::ExitOpLowering"
    ** Insert  : 'std.br'(0x1b3ca8962d0)
    ** Erase   : 'ts.Exit'(0x1b3ca9768b0)
"`anonymous-namespace'::ExitOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'std.br'(0x1b3ca8962d0) {
      "std.br"()[^bb3] : () -> ()

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %5 = ts.CreateUnionInstance %2, %4 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %5, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %6 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %7 = ts.Cast %6 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %7, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %8 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %9 = ts.GetTypeInfoFromUnionOp %8 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %10 = "ts.TypeOf"(%8) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string
  %11 = ts.Constant {value = "number"} : !ts.string
  %12 = ts.LogicalBinary %10(34) %11 : !ts.string, !ts.string -> !ts.boolean
  %13 = ts.Cast %12 : !ts.boolean to i1
  cond_br %13, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %14 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %15 = ts.GetValueFromUnionOp %14 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %16 = ts.Constant {value = "b number: "} : !ts.string
  %17 = ts.Cast %15 : !ts.number to !ts.string
  ts.Print(%16, %17) : !ts.string, !ts.string
  "ts.Result"() : () -> ()
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  "ts.If"(%12) ( {
  },  {
  }) : (!ts.boolean) -> ()
  %18 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%18) : !ts.string
  br ^bb3
  "ts.Exit"() : () -> ()
^bb3:  // pred: ^bb2
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

!! Processing function: 
main

!! AFTER FUNC DUMP: 
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  br ^bb3
^bb3:  // pred: ^bb2
  ts.ReturnInternal
}
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  br ^bb3
^bb3:  // pred: ^bb2
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  br ^bb3
^bb3:  // pred: ^bb2
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  br ^bb3
^bb3:  // pred: ^bb2
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  br ^bb3
^bb3:  // pred: ^bb2
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::SimplifyConstCondBranchPred"
"`anonymous-namespace'::SimplifyConstCondBranchPred" result 0
Trying to match "`anonymous-namespace'::SimplifyPassThroughCondBranch"
"`anonymous-namespace'::SimplifyPassThroughCondBranch" result 0
Trying to match "`anonymous-namespace'::SimplifyCondBranchIdenticalSuccessors"
"`anonymous-namespace'::SimplifyCondBranchIdenticalSuccessors" result 0
Trying to match "`anonymous-namespace'::SimplifyCondBranchFromCondBranchOnSameCondition"
"`anonymous-namespace'::SimplifyCondBranchFromCondBranchOnSameCondition" result 0
Trying to match "`anonymous-namespace'::CondBranchTruthPropagation"
"`anonymous-namespace'::CondBranchTruthPropagation" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  br ^bb3
^bb3:  // pred: ^bb2
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  br ^bb3
^bb3:  // pred: ^bb2
  ts.ReturnInternal
}


Trying to match ""
"" result 0
Trying to match ""
"" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::SimplifyConstCondBranchPred"
"`anonymous-namespace'::SimplifyConstCondBranchPred" result 0
Trying to match "`anonymous-namespace'::SimplifyPassThroughCondBranch"
"`anonymous-namespace'::SimplifyPassThroughCondBranch" result 0
Trying to match "`anonymous-namespace'::SimplifyCondBranchIdenticalSuccessors"
"`anonymous-namespace'::SimplifyCondBranchIdenticalSuccessors" result 0
Trying to match "`anonymous-namespace'::SimplifyCondBranchFromCondBranchOnSameCondition"
"`anonymous-namespace'::SimplifyCondBranchFromCondBranchOnSameCondition" result 0
Trying to match "`anonymous-namespace'::CondBranchTruthPropagation"
"`anonymous-namespace'::CondBranchTruthPropagation" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match ""
"" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::SimplifyConstCondBranchPred"
"`anonymous-namespace'::SimplifyConstCondBranchPred" result 0
Trying to match "`anonymous-namespace'::SimplifyPassThroughCondBranch"
"`anonymous-namespace'::SimplifyPassThroughCondBranch" result 0
Trying to match "`anonymous-namespace'::SimplifyCondBranchIdenticalSuccessors"
"`anonymous-namespace'::SimplifyCondBranchIdenticalSuccessors" result 0
Trying to match "`anonymous-namespace'::SimplifyCondBranchFromCondBranchOnSameCondition"
"`anonymous-namespace'::SimplifyCondBranchFromCondBranchOnSameCondition" result 0
Trying to match "`anonymous-namespace'::CondBranchTruthPropagation"
"`anonymous-namespace'::CondBranchTruthPropagation" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match ""
"" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::SimplifyConstCondBranchPred"
"`anonymous-namespace'::SimplifyConstCondBranchPred" result 0
Trying to match "`anonymous-namespace'::SimplifyPassThroughCondBranch"
"`anonymous-namespace'::SimplifyPassThroughCondBranch" result 0
Trying to match "`anonymous-namespace'::SimplifyCondBranchIdenticalSuccessors"
"`anonymous-namespace'::SimplifyCondBranchIdenticalSuccessors" result 0
Trying to match "`anonymous-namespace'::SimplifyCondBranchFromCondBranchOnSameCondition"
"`anonymous-namespace'::SimplifyCondBranchFromCondBranchOnSameCondition" result 0
Trying to match "`anonymous-namespace'::CondBranchTruthPropagation"
"`anonymous-namespace'::CondBranchTruthPropagation" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match ""
"" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::SimplifyConstCondBranchPred"
"`anonymous-namespace'::SimplifyConstCondBranchPred" result 0
Trying to match "`anonymous-namespace'::SimplifyPassThroughCondBranch"
"`anonymous-namespace'::SimplifyPassThroughCondBranch" result 0
Trying to match "`anonymous-namespace'::SimplifyCondBranchIdenticalSuccessors"
"`anonymous-namespace'::SimplifyCondBranchIdenticalSuccessors" result 0
Trying to match "`anonymous-namespace'::SimplifyCondBranchFromCondBranchOnSameCondition"
"`anonymous-namespace'::SimplifyCondBranchFromCondBranchOnSameCondition" result 0
Trying to match "`anonymous-namespace'::CondBranchTruthPropagation"
"`anonymous-namespace'::CondBranchTruthPropagation" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match ""
"" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::SimplifyConstCondBranchPred"
"`anonymous-namespace'::SimplifyConstCondBranchPred" result 0
Trying to match "`anonymous-namespace'::SimplifyPassThroughCondBranch"
"`anonymous-namespace'::SimplifyPassThroughCondBranch" result 0
Trying to match "`anonymous-namespace'::SimplifyCondBranchIdenticalSuccessors"
"`anonymous-namespace'::SimplifyCondBranchIdenticalSuccessors" result 0
Trying to match "`anonymous-namespace'::SimplifyCondBranchFromCondBranchOnSameCondition"
"`anonymous-namespace'::SimplifyCondBranchFromCondBranchOnSameCondition" result 0
Trying to match "`anonymous-namespace'::CondBranchTruthPropagation"
"`anonymous-namespace'::CondBranchTruthPropagation" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match ""
"" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::SimplifyConstCondBranchPred"
"`anonymous-namespace'::SimplifyConstCondBranchPred" result 0
Trying to match "`anonymous-namespace'::SimplifyPassThroughCondBranch"
"`anonymous-namespace'::SimplifyPassThroughCondBranch" result 0
Trying to match "`anonymous-namespace'::SimplifyCondBranchIdenticalSuccessors"
"`anonymous-namespace'::SimplifyCondBranchIdenticalSuccessors" result 0
Trying to match "`anonymous-namespace'::SimplifyCondBranchFromCondBranchOnSameCondition"
"`anonymous-namespace'::SimplifyCondBranchFromCondBranchOnSameCondition" result 0
Trying to match "`anonymous-namespace'::CondBranchTruthPropagation"
"`anonymous-namespace'::CondBranchTruthPropagation" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match ""
"" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::SimplifyConstCondBranchPred"
"`anonymous-namespace'::SimplifyConstCondBranchPred" result 0
Trying to match "`anonymous-namespace'::SimplifyPassThroughCondBranch"
"`anonymous-namespace'::SimplifyPassThroughCondBranch" result 0
Trying to match "`anonymous-namespace'::SimplifyCondBranchIdenticalSuccessors"
"`anonymous-namespace'::SimplifyCondBranchIdenticalSuccessors" result 0
Trying to match "`anonymous-namespace'::SimplifyCondBranchFromCondBranchOnSameCondition"
"`anonymous-namespace'::SimplifyCondBranchFromCondBranchOnSameCondition" result 0
Trying to match "`anonymous-namespace'::CondBranchTruthPropagation"
"`anonymous-namespace'::CondBranchTruthPropagation" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match ""
"" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::SimplifyConstCondBranchPred"
"`anonymous-namespace'::SimplifyConstCondBranchPred" result 0
Trying to match "`anonymous-namespace'::SimplifyPassThroughCondBranch"
"`anonymous-namespace'::SimplifyPassThroughCondBranch" result 0
Trying to match "`anonymous-namespace'::SimplifyCondBranchIdenticalSuccessors"
"`anonymous-namespace'::SimplifyCondBranchIdenticalSuccessors" result 0
Trying to match "`anonymous-namespace'::SimplifyCondBranchFromCondBranchOnSameCondition"
"`anonymous-namespace'::SimplifyCondBranchFromCondBranchOnSameCondition" result 0
Trying to match "`anonymous-namespace'::CondBranchTruthPropagation"
"`anonymous-namespace'::CondBranchTruthPropagation" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match ""
"" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::SimplifyConstCondBranchPred"
"`anonymous-namespace'::SimplifyConstCondBranchPred" result 0
Trying to match "`anonymous-namespace'::SimplifyPassThroughCondBranch"
"`anonymous-namespace'::SimplifyPassThroughCondBranch" result 0
Trying to match "`anonymous-namespace'::SimplifyCondBranchIdenticalSuccessors"
"`anonymous-namespace'::SimplifyCondBranchIdenticalSuccessors" result 0
Trying to match "`anonymous-namespace'::SimplifyCondBranchFromCondBranchOnSameCondition"
"`anonymous-namespace'::SimplifyCondBranchFromCondBranchOnSameCondition" result 0
Trying to match "`anonymous-namespace'::CondBranchTruthPropagation"
"`anonymous-namespace'::CondBranchTruthPropagation" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %6, %1 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match ""
"" result 0
The pattern rewrite doesn't converge after scanning 10 times

Insert const at: 
%0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>

const to insert: 
%2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
** Insert  : 'ts.Constant'(0x1b3ca85c1a0)

const to insert: 
%3 = ts.Constant {value = "number"} : !ts.string
** Insert  : 'ts.Constant'(0x1b3ca857240)

const to insert: 
%9 = ts.Constant {value = "number"} : !ts.string
** Insert  : 'ts.Constant'(0x1b3ca85cba0)

const to insert: 
%14 = ts.Constant {value = "b number: "} : !ts.string
** Insert  : 'ts.Constant'(0x1b3ca858320)

const to insert: 
%16 = ts.Constant {value = "done."} : !ts.string
** Insert  : 'ts.Constant'(0x1b3ca8572e0)

!! AFTER CONST RELOC FUNC DUMP: 
ts.Func @main () -> ()  {
  %0 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %1 = ts.Constant {value = "number"} : !ts.string
  %2 = ts.Constant {value = "number"} : !ts.string
  %3 = ts.Constant {value = "b number: "} : !ts.string
  %4 = ts.Constant {value = "done."} : !ts.string
  %5 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %6 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %7 = ts.CreateUnionInstance %0, %1 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %7, %5 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %8 = ts.Load(%5) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %9 = ts.Cast %8 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %9, %6 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %10 = ts.Load(%6) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %11 = ts.GetTypeInfoFromUnionOp %10 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %12 = ts.LogicalBinary %11(34) %2 : !ts.string, !ts.string -> !ts.boolean
  %13 = ts.Cast %12 : !ts.boolean to i1
  cond_br %13, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %14 = ts.Load(%6) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %15 = ts.GetValueFromUnionOp %14 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %16 = ts.Cast %15 : !ts.number to !ts.string
  ts.Print(%3, %16) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%4) : !ts.string
  ts.ReturnInternal
}
Outlined 0 functions built from async.execute operations

//===-------------------------------------------===//
Legalizing operation : 'module'(0x1b3ca8948b0) {
  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Func'(0x1b3ca893ba0) {
  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Constant'(0x1b3ca85c1a0) {
  %0 = "ts.Constant"() {value = 1.000000e+01 : f64} : () -> !ts.number

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Constant'(0x1b3ca857240) {
  %1 = "ts.Constant"() {value = "number"} : () -> !ts.string

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Constant'(0x1b3ca85cba0) {
  %2 = "ts.Constant"() {value = "number"} : () -> !ts.string

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Constant'(0x1b3ca858320) {
  %3 = "ts.Constant"() {value = "b number: "} : () -> !ts.string

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Constant'(0x1b3ca8572e0) {
  %4 = "ts.Constant"() {value = "done."} : () -> !ts.string

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Variable'(0x1b3ca857100) {
  %5 = "ts.Variable"() {captured = false} : () -> !ts.ref<!ts.union<!ts.number,!ts.string>>

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Variable'(0x1b3ca857420) {
  %6 = "ts.Variable"() {captured = false} : () -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.CreateUnionInstance'(0x1b3ca8d7340) {
  %7 = "ts.CreateUnionInstance"(%0, %1) : (!ts.number, !ts.string) -> !ts.union<!ts.number,!ts.string>

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Store'(0x1b3ca7fa210) {
  "ts.Store"(%7, %5) : (!ts.union<!ts.number,!ts.string>, !ts.ref<!ts.union<!ts.number,!ts.string>>) -> ()

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Load'(0x1b3ca7b0540) {
  %8 = "ts.Load"(%5) : (!ts.ref<!ts.union<!ts.number,!ts.string>>) -> !ts.union<!ts.number,!ts.string>

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Cast'(0x1b3ca7b1980) {
  %9 = "ts.Cast"(%8) : (!ts.union<!ts.number,!ts.string>) -> !ts.union<!ts.boolean,!ts.number,!ts.string>

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Store'(0x1b3ca7f77d0) {
  "ts.Store"(%9, %6) : (!ts.union<!ts.boolean,!ts.number,!ts.string>, !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>) -> ()

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Load'(0x1b3ca7b1ec0) {
  %10 = "ts.Load"(%6) : (!ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>) -> !ts.union<!ts.boolean,!ts.number,!ts.string>

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.GetTypeInfoFromUnionOp'(0x1b3ca7afe80) {
  %11 = "ts.GetTypeInfoFromUnionOp"(%10) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.LogicalBinary'(0x1b3ca8d85a0) {
  %12 = "ts.LogicalBinary"(%11, %2) {opCode = 34 : i32} : (!ts.string, !ts.string) -> !ts.boolean

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Cast'(0x1b3ca7b09c0) {
  %13 = "ts.Cast"(%12) : (!ts.boolean) -> i1

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'std.cond_br'(0x1b3ca833d60) {
  "std.cond_br"(%13)[^bb1, ^bb2] {operand_segment_sizes = dense<[1, 0, 0]> : vector<3xi32>} : (i1) -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Print'(0x1b3ca894a10) {
  "ts.Print"(%4) : (!ts.string) -> ()

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.ReturnInternal'(0x1b3ca976b80) {
  "ts.ReturnInternal"() : () -> ()

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Load'(0x1b3ca7b1a40) {
  %14 = "ts.Load"(%6) : (!ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>) -> !ts.union<!ts.boolean,!ts.number,!ts.string>

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.GetValueFromUnionOp'(0x1b3ca7b1b00) {
  %15 = "ts.GetValueFromUnionOp"(%14) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.number

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Cast'(0x1b3ca7b1bc0) {
  %16 = "ts.Cast"(%15) : (!ts.number) -> !ts.string

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Print'(0x1b3ca7f7cb0) {
  "ts.Print"(%3, %16) : (!ts.string, !ts.string) -> ()

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'std.br'(0x1b3ca8957d0) {
  "std.br"()[^bb2] : () -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'module'(0x1b3ca8948b0) {
  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Func'(0x1b3ca893ba0) {
  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Constant'(0x1b3ca85c1a0) {
  %0 = "ts.Constant"() {value = 1.000000e+01 : f64} : () -> !ts.number

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Constant'(0x1b3ca857240) {
  %1 = "ts.Constant"() {value = "number"} : () -> !ts.string

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Constant'(0x1b3ca85cba0) {
  %2 = "ts.Constant"() {value = "number"} : () -> !ts.string

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Constant'(0x1b3ca858320) {
  %3 = "ts.Constant"() {value = "b number: "} : () -> !ts.string

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Constant'(0x1b3ca8572e0) {
  %4 = "ts.Constant"() {value = "done."} : () -> !ts.string

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Variable'(0x1b3ca857100) {
  %5 = "ts.Variable"() {captured = false} : () -> !ts.ref<!ts.union<!ts.number,!ts.string>>

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Variable'(0x1b3ca857420) {
  %6 = "ts.Variable"() {captured = false} : () -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.CreateUnionInstance'(0x1b3ca8d7340) {
  %7 = "ts.CreateUnionInstance"(%0, %1) : (!ts.number, !ts.string) -> !ts.union<!ts.number,!ts.string>

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Store'(0x1b3ca7fa210) {
  "ts.Store"(%7, %5) : (!ts.union<!ts.number,!ts.string>, !ts.ref<!ts.union<!ts.number,!ts.string>>) -> ()

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Load'(0x1b3ca7b0540) {
  %8 = "ts.Load"(%5) : (!ts.ref<!ts.union<!ts.number,!ts.string>>) -> !ts.union<!ts.number,!ts.string>

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Cast'(0x1b3ca7b1980) {
  %9 = "ts.Cast"(%8) : (!ts.union<!ts.number,!ts.string>) -> !ts.union<!ts.boolean,!ts.number,!ts.string>

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Store'(0x1b3ca7f77d0) {
  "ts.Store"(%9, %6) : (!ts.union<!ts.boolean,!ts.number,!ts.string>, !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>) -> ()

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Load'(0x1b3ca7b1ec0) {
  %10 = "ts.Load"(%6) : (!ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>) -> !ts.union<!ts.boolean,!ts.number,!ts.string>

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.GetTypeInfoFromUnionOp'(0x1b3ca7afe80) {
  %11 = "ts.GetTypeInfoFromUnionOp"(%10) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.LogicalBinary'(0x1b3ca8d85a0) {
  %12 = "ts.LogicalBinary"(%11, %2) {opCode = 34 : i32} : (!ts.string, !ts.string) -> !ts.boolean

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Cast'(0x1b3ca7b09c0) {
  %13 = "ts.Cast"(%12) : (!ts.boolean) -> i1

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'std.cond_br'(0x1b3ca833d60) {
  "std.cond_br"(%13)[^bb1, ^bb2] {operand_segment_sizes = dense<[1, 0, 0]> : vector<3xi32>} : (i1) -> ()

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Print'(0x1b3ca894a10) {
  "ts.Print"(%4) : (!ts.string) -> ()

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.ReturnInternal'(0x1b3ca976b80) {
  "ts.ReturnInternal"() : () -> ()

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Load'(0x1b3ca7b1a40) {
  %14 = "ts.Load"(%6) : (!ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>) -> !ts.union<!ts.boolean,!ts.number,!ts.string>

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.GetValueFromUnionOp'(0x1b3ca7b1b00) {
  %15 = "ts.GetValueFromUnionOp"(%14) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.number

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Cast'(0x1b3ca7b1bc0) {
  %16 = "ts.Cast"(%15) : (!ts.number) -> !ts.string

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Print'(0x1b3ca7f7cb0) {
  "ts.Print"(%3, %16) : (!ts.string, !ts.string) -> ()

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'std.br'(0x1b3ca8957d0) {
  "std.br"()[^bb2] : () -> ()

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x1b3ca893830) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x1b3ca894ac0) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x1b3ca893150) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FunctionLikeSignatureConversion"
"`anonymous-namespace'::FunctionLikeSignatureConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'func'(0x1b3ca893150) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  ts.Func @main () -> ()  {
    %0 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %1 = ts.Constant {value = "number"} : !ts.string
    %2 = ts.Constant {value = "number"} : !ts.string
    %3 = ts.Constant {value = "b number: "} : !ts.string
    %4 = ts.Constant {value = "done."} : !ts.string
    %5 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %6 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %7 = ts.CreateUnionInstance %0, %1 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    ts.Store %7, %5 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %8 = ts.Load(%5) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %9 = ts.Cast %8 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
    ts.Store %9, %6 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %10 = ts.Load(%6) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %11 = ts.GetTypeInfoFromUnionOp %10 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
    %12 = ts.LogicalBinary %11(34) %2 : !ts.string, !ts.string -> !ts.boolean
    %13 = ts.Cast %12 : !ts.boolean to i1
    cond_br %13, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %14 = ts.Load(%6) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %15 = ts.GetValueFromUnionOp %14 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %16 = ts.Cast %15 : !ts.number to !ts.string
    ts.Print(%3, %16) : !ts.string, !ts.string
    br ^bb2
  ^bb2:  // 2 preds: ^bb0, ^bb1
    ts.Print(%4) : !ts.string
    ts.ReturnInternal
  }
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !async.group
  func private @mlirAsyncRuntimeEmplaceToken(!async.token)
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetTokenError(!async.token)
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeIsTokenError(!async.token) -> i1
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsGroupError(!async.group) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!async.token)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!async.group)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!async.token, !async.group) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!async.token, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!async.group, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x1b3ca892910) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x1b3ca893200) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FunctionLikeSignatureConversion"
"`anonymous-namespace'::FunctionLikeSignatureConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'func'(0x1b3ca893200) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  ts.Func @main () -> ()  {
    %0 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %1 = ts.Constant {value = "number"} : !ts.string
    %2 = ts.Constant {value = "number"} : !ts.string
    %3 = ts.Constant {value = "b number: "} : !ts.string
    %4 = ts.Constant {value = "done."} : !ts.string
    %5 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %6 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %7 = ts.CreateUnionInstance %0, %1 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    ts.Store %7, %5 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %8 = ts.Load(%5) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %9 = ts.Cast %8 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
    ts.Store %9, %6 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %10 = ts.Load(%6) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %11 = ts.GetTypeInfoFromUnionOp %10 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
    %12 = ts.LogicalBinary %11(34) %2 : !ts.string, !ts.string -> !ts.boolean
    %13 = ts.Cast %12 : !ts.boolean to i1
    cond_br %13, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %14 = ts.Load(%6) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %15 = ts.GetValueFromUnionOp %14 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %16 = ts.Cast %15 : !ts.number to !ts.string
    ts.Print(%3, %16) : !ts.string, !ts.string
    br ^bb2
  ^bb2:  // 2 preds: ^bb0, ^bb1
    ts.Print(%4) : !ts.string
    ts.ReturnInternal
  }
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeEmplaceToken(!async.token)
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetTokenError(!async.token)
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeIsTokenError(!async.token) -> i1
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsGroupError(!async.group) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!async.token)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!async.group)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!async.token, !async.group) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!async.token, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!async.group, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x1b3ca894f90) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FunctionLikeSignatureConversion"
"`anonymous-namespace'::FunctionLikeSignatureConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'func'(0x1b3ca894f90) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  ts.Func @main () -> ()  {
    %0 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %1 = ts.Constant {value = "number"} : !ts.string
    %2 = ts.Constant {value = "number"} : !ts.string
    %3 = ts.Constant {value = "b number: "} : !ts.string
    %4 = ts.Constant {value = "done."} : !ts.string
    %5 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %6 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %7 = ts.CreateUnionInstance %0, %1 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    ts.Store %7, %5 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %8 = ts.Load(%5) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %9 = ts.Cast %8 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
    ts.Store %9, %6 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %10 = ts.Load(%6) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %11 = ts.GetTypeInfoFromUnionOp %10 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
    %12 = ts.LogicalBinary %11(34) %2 : !ts.string, !ts.string -> !ts.boolean
    %13 = ts.Cast %12 : !ts.boolean to i1
    cond_br %13, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %14 = ts.Load(%6) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %15 = ts.GetValueFromUnionOp %14 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %16 = ts.Cast %15 : !ts.number to !ts.string
    ts.Print(%3, %16) : !ts.string, !ts.string
    br ^bb2
  ^bb2:  // 2 preds: ^bb0, ^bb1
    ts.Print(%4) : !ts.string
    ts.ReturnInternal
  }
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetTokenError(!async.token)
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeIsTokenError(!async.token) -> i1
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsGroupError(!async.group) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!async.token)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!async.group)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!async.token, !async.group) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!async.token, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!async.group, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x1b3ca893c50) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x1b3ca894d80) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FunctionLikeSignatureConversion"
"`anonymous-namespace'::FunctionLikeSignatureConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'func'(0x1b3ca894d80) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  ts.Func @main () -> ()  {
    %0 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %1 = ts.Constant {value = "number"} : !ts.string
    %2 = ts.Constant {value = "number"} : !ts.string
    %3 = ts.Constant {value = "b number: "} : !ts.string
    %4 = ts.Constant {value = "done."} : !ts.string
    %5 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %6 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %7 = ts.CreateUnionInstance %0, %1 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    ts.Store %7, %5 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %8 = ts.Load(%5) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %9 = ts.Cast %8 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
    ts.Store %9, %6 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %10 = ts.Load(%6) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %11 = ts.GetTypeInfoFromUnionOp %10 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
    %12 = ts.LogicalBinary %11(34) %2 : !ts.string, !ts.string -> !ts.boolean
    %13 = ts.Cast %12 : !ts.boolean to i1
    cond_br %13, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %14 = ts.Load(%6) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %15 = ts.GetValueFromUnionOp %14 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %16 = ts.Cast %15 : !ts.number to !ts.string
    ts.Print(%3, %16) : !ts.string, !ts.string
    br ^bb2
  ^bb2:  // 2 preds: ^bb0, ^bb1
    ts.Print(%4) : !ts.string
    ts.ReturnInternal
  }
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeIsTokenError(!async.token) -> i1
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsGroupError(!async.group) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!async.token)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!async.group)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!async.token, !async.group) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!async.token, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!async.group, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x1b3ca8938e0) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x1b3ca8932b0) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FunctionLikeSignatureConversion"
"`anonymous-namespace'::FunctionLikeSignatureConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'func'(0x1b3ca8932b0) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  ts.Func @main () -> ()  {
    %0 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %1 = ts.Constant {value = "number"} : !ts.string
    %2 = ts.Constant {value = "number"} : !ts.string
    %3 = ts.Constant {value = "b number: "} : !ts.string
    %4 = ts.Constant {value = "done."} : !ts.string
    %5 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %6 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %7 = ts.CreateUnionInstance %0, %1 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    ts.Store %7, %5 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %8 = ts.Load(%5) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %9 = ts.Cast %8 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
    ts.Store %9, %6 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %10 = ts.Load(%6) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %11 = ts.GetTypeInfoFromUnionOp %10 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
    %12 = ts.LogicalBinary %11(34) %2 : !ts.string, !ts.string -> !ts.boolean
    %13 = ts.Cast %12 : !ts.boolean to i1
    cond_br %13, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %14 = ts.Load(%6) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %15 = ts.GetValueFromUnionOp %14 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %16 = ts.Cast %15 : !ts.number to !ts.string
    ts.Print(%3, %16) : !ts.string, !ts.string
    br ^bb2
  ^bb2:  // 2 preds: ^bb0, ^bb1
    ts.Print(%4) : !ts.string
    ts.ReturnInternal
  }
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsGroupError(!async.group) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!async.token)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!async.group)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!async.token, !async.group) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!async.token, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!async.group, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x1b3ca894cd0) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x1b3ca893360) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FunctionLikeSignatureConversion"
"`anonymous-namespace'::FunctionLikeSignatureConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'func'(0x1b3ca893360) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  ts.Func @main () -> ()  {
    %0 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %1 = ts.Constant {value = "number"} : !ts.string
    %2 = ts.Constant {value = "number"} : !ts.string
    %3 = ts.Constant {value = "b number: "} : !ts.string
    %4 = ts.Constant {value = "done."} : !ts.string
    %5 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %6 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %7 = ts.CreateUnionInstance %0, %1 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    ts.Store %7, %5 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %8 = ts.Load(%5) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %9 = ts.Cast %8 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
    ts.Store %9, %6 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %10 = ts.Load(%6) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %11 = ts.GetTypeInfoFromUnionOp %10 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
    %12 = ts.LogicalBinary %11(34) %2 : !ts.string, !ts.string -> !ts.boolean
    %13 = ts.Cast %12 : !ts.boolean to i1
    cond_br %13, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %14 = ts.Load(%6) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %15 = ts.GetValueFromUnionOp %14 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %16 = ts.Cast %15 : !ts.number to !ts.string
    ts.Print(%3, %16) : !ts.string, !ts.string
    br ^bb2
  ^bb2:  // 2 preds: ^bb0, ^bb1
    ts.Print(%4) : !ts.string
    ts.ReturnInternal
  }
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!async.token)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!async.group)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!async.token, !async.group) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!async.token, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!async.group, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x1b3ca8950f0) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FunctionLikeSignatureConversion"
"`anonymous-namespace'::FunctionLikeSignatureConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'func'(0x1b3ca8950f0) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  ts.Func @main () -> ()  {
    %0 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %1 = ts.Constant {value = "number"} : !ts.string
    %2 = ts.Constant {value = "number"} : !ts.string
    %3 = ts.Constant {value = "b number: "} : !ts.string
    %4 = ts.Constant {value = "done."} : !ts.string
    %5 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %6 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %7 = ts.CreateUnionInstance %0, %1 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    ts.Store %7, %5 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %8 = ts.Load(%5) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %9 = ts.Cast %8 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
    ts.Store %9, %6 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %10 = ts.Load(%6) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %11 = ts.GetTypeInfoFromUnionOp %10 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
    %12 = ts.LogicalBinary %11(34) %2 : !ts.string, !ts.string -> !ts.boolean
    %13 = ts.Cast %12 : !ts.boolean to i1
    cond_br %13, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %14 = ts.Load(%6) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %15 = ts.GetValueFromUnionOp %14 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %16 = ts.Cast %15 : !ts.number to !ts.string
    ts.Print(%3, %16) : !ts.string, !ts.string
    br ^bb2
  ^bb2:  // 2 preds: ^bb0, ^bb1
    ts.Print(%4) : !ts.string
    ts.ReturnInternal
  }
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!async.group)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!async.token, !async.group) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!async.token, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!async.group, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x1b3ca8929c0) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x1b3ca894ee0) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FunctionLikeSignatureConversion"
"`anonymous-namespace'::FunctionLikeSignatureConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'func'(0x1b3ca894ee0) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  ts.Func @main () -> ()  {
    %0 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %1 = ts.Constant {value = "number"} : !ts.string
    %2 = ts.Constant {value = "number"} : !ts.string
    %3 = ts.Constant {value = "b number: "} : !ts.string
    %4 = ts.Constant {value = "done."} : !ts.string
    %5 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %6 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %7 = ts.CreateUnionInstance %0, %1 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    ts.Store %7, %5 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %8 = ts.Load(%5) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %9 = ts.Cast %8 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
    ts.Store %9, %6 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %10 = ts.Load(%6) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %11 = ts.GetTypeInfoFromUnionOp %10 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
    %12 = ts.LogicalBinary %11(34) %2 : !ts.string, !ts.string -> !ts.boolean
    %13 = ts.Cast %12 : !ts.boolean to i1
    cond_br %13, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %14 = ts.Load(%6) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %15 = ts.GetValueFromUnionOp %14 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %16 = ts.Cast %15 : !ts.number to !ts.string
    ts.Print(%3, %16) : !ts.string, !ts.string
    br ^bb2
  ^bb2:  // 2 preds: ^bb0, ^bb1
    ts.Print(%4) : !ts.string
    ts.ReturnInternal
  }
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!async.token, !async.group) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!async.token, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!async.group, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x1b3ca8925a0) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x1b3ca892650) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x1b3ca892700) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FunctionLikeSignatureConversion"
"`anonymous-namespace'::FunctionLikeSignatureConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'func'(0x1b3ca892700) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  ts.Func @main () -> ()  {
    %0 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %1 = ts.Constant {value = "number"} : !ts.string
    %2 = ts.Constant {value = "number"} : !ts.string
    %3 = ts.Constant {value = "b number: "} : !ts.string
    %4 = ts.Constant {value = "done."} : !ts.string
    %5 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %6 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %7 = ts.CreateUnionInstance %0, %1 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    ts.Store %7, %5 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %8 = ts.Load(%5) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %9 = ts.Cast %8 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
    ts.Store %9, %6 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %10 = ts.Load(%6) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %11 = ts.GetTypeInfoFromUnionOp %10 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
    %12 = ts.LogicalBinary %11(34) %2 : !ts.string, !ts.string -> !ts.boolean
    %13 = ts.Cast %12 : !ts.boolean to i1
    cond_br %13, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %14 = ts.Load(%6) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %15 = ts.GetValueFromUnionOp %14 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %16 = ts.Cast %15 : !ts.number to !ts.string
    ts.Print(%3, %16) : !ts.string, !ts.string
    br ^bb2
  ^bb2:  // 2 preds: ^bb0, ^bb1
    ts.Print(%4) : !ts.string
    ts.ReturnInternal
  }
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!async.token, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!async.group, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x1b3ca892860) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FunctionLikeSignatureConversion"
"`anonymous-namespace'::FunctionLikeSignatureConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'func'(0x1b3ca892860) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  ts.Func @main () -> ()  {
    %0 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %1 = ts.Constant {value = "number"} : !ts.string
    %2 = ts.Constant {value = "number"} : !ts.string
    %3 = ts.Constant {value = "b number: "} : !ts.string
    %4 = ts.Constant {value = "done."} : !ts.string
    %5 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %6 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %7 = ts.CreateUnionInstance %0, %1 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    ts.Store %7, %5 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %8 = ts.Load(%5) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %9 = ts.Cast %8 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
    ts.Store %9, %6 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %10 = ts.Load(%6) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %11 = ts.GetTypeInfoFromUnionOp %10 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
    %12 = ts.LogicalBinary %11(34) %2 : !ts.string, !ts.string -> !ts.boolean
    %13 = ts.Cast %12 : !ts.boolean to i1
    cond_br %13, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %14 = ts.Load(%6) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %15 = ts.GetValueFromUnionOp %14 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %16 = ts.Cast %15 : !ts.number to !ts.string
    ts.Print(%3, %16) : !ts.string, !ts.string
    br ^bb2
  ^bb2:  // 2 preds: ^bb0, ^bb1
    ts.Print(%4) : !ts.string
    ts.ReturnInternal
  }
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!async.group, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x1b3ca892a70) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x1b3ca894490) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FunctionLikeSignatureConversion"
"`anonymous-namespace'::FunctionLikeSignatureConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'func'(0x1b3ca894490) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  ts.Func @main () -> ()  {
    %0 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %1 = ts.Constant {value = "number"} : !ts.string
    %2 = ts.Constant {value = "number"} : !ts.string
    %3 = ts.Constant {value = "b number: "} : !ts.string
    %4 = ts.Constant {value = "done."} : !ts.string
    %5 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %6 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %7 = ts.CreateUnionInstance %0, %1 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    ts.Store %7, %5 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %8 = ts.Load(%5) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %9 = ts.Cast %8 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
    ts.Store %9, %6 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %10 = ts.Load(%6) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %11 = ts.GetTypeInfoFromUnionOp %10 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
    %12 = ts.LogicalBinary %11(34) %2 : !ts.string, !ts.string -> !ts.boolean
    %13 = ts.Cast %12 : !ts.boolean to i1
    cond_br %13, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %14 = ts.Load(%6) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %15 = ts.GetValueFromUnionOp %14 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %16 = ts.Cast %15 : !ts.number to !ts.string
    ts.Print(%3, %16) : !ts.string, !ts.string
    br ^bb2
  ^bb2:  // 2 preds: ^bb0, ^bb1
    ts.Print(%4) : !ts.string
    ts.ReturnInternal
  }
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x1b3ca894330) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x1b3ca892b20) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

!! BEFORE DUMP: 
module @"c:\\temp\\1.ts"  {
  ts.Func @main () -> ()  {
    %0 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %1 = ts.Constant {value = "number"} : !ts.string
    %2 = ts.Constant {value = "number"} : !ts.string
    %3 = ts.Constant {value = "b number: "} : !ts.string
    %4 = ts.Constant {value = "done."} : !ts.string
    %5 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %6 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %7 = ts.CreateUnionInstance %0, %1 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    ts.Store %7, %5 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %8 = ts.Load(%5) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %9 = ts.Cast %8 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
    ts.Store %9, %6 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %10 = ts.Load(%6) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %11 = ts.GetTypeInfoFromUnionOp %10 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
    %12 = ts.LogicalBinary %11(34) %2 : !ts.string, !ts.string -> !ts.boolean
    %13 = ts.Cast %12 : !ts.boolean to i1
    cond_br %13, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %14 = ts.Load(%6) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %15 = ts.GetValueFromUnionOp %14 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %16 = ts.Cast %15 : !ts.number to !ts.string
    ts.Print(%3, %16) : !ts.string, !ts.string
    br ^bb2
  ^bb2:  // 2 preds: ^bb0, ^bb1
    ts.Print(%4) : !ts.string
    ts.ReturnInternal
  }
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}
Ignoring pattern 'unrealized_conversion_cast' because it is impossible to match or cannot lead to legal IR (by cost model)

//===-------------------------------------------===//
Legalizing operation : 'module'(0x1b3ca8948b0) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Func'(0x1b3ca893ba0) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.Func -> ()' {
Trying to match "`anonymous-namespace'::FuncOpLowering"
    ** Insert  : 'func'(0x1b3ca89aa50)
    ** Erase   : 'ts.Func'(0x1b3ca893ba0)
"`anonymous-namespace'::FuncOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'func'(0x1b3ca89aa50) {
      * Fold {
      } -> FAILURE : unable to fold

      * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FuncOpConversion"
        ** Insert  : 'llvm.func'(0x1b3ca89d390)
        ** Erase   : 'func'(0x1b3ca89aa50)
"`anonymous-namespace'::FuncOpConversion" result 1

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.func'(0x1b3ca89d390) {
        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//
      } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  llvm.func @main() {
    %0 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %1 = ts.Constant {value = "number"} : !ts.string
    %2 = ts.Constant {value = "number"} : !ts.string
    %3 = ts.Constant {value = "b number: "} : !ts.string
    %4 = ts.Constant {value = "done."} : !ts.string
    %5 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %6 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %7 = ts.CreateUnionInstance %0, %1 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    ts.Store %7, %5 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %8 = ts.Load(%5) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %9 = ts.Cast %8 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
    ts.Store %9, %6 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %10 = ts.Load(%6) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %11 = ts.GetTypeInfoFromUnionOp %10 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
    %12 = ts.LogicalBinary %11(34) %2 : !ts.string, !ts.string -> !ts.boolean
    %13 = ts.Cast %12 : !ts.boolean to i1
    cond_br %13, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %14 = ts.Load(%6) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %15 = ts.GetValueFromUnionOp %14 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %16 = ts.Cast %15 : !ts.number to !ts.string
    ts.Print(%3, %16) : !ts.string, !ts.string
    br ^bb2
  ^bb2:  // 2 preds: ^bb0, ^bb1
    ts.Print(%4) : !ts.string
    ts.ReturnInternal
  }
  func @main()
  ts.Func @main () -> ()  {
  }
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


    } -> SUCCESS
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  llvm.func @main() {
    %0 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %1 = ts.Constant {value = "number"} : !ts.string
    %2 = ts.Constant {value = "number"} : !ts.string
    %3 = ts.Constant {value = "b number: "} : !ts.string
    %4 = ts.Constant {value = "done."} : !ts.string
    %5 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %6 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %7 = ts.CreateUnionInstance %0, %1 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    ts.Store %7, %5 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %8 = ts.Load(%5) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %9 = ts.Cast %8 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
    ts.Store %9, %6 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %10 = ts.Load(%6) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %11 = ts.GetTypeInfoFromUnionOp %10 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
    %12 = ts.LogicalBinary %11(34) %2 : !ts.string, !ts.string -> !ts.boolean
    %13 = ts.Cast %12 : !ts.boolean to i1
    cond_br %13, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %14 = ts.Load(%6) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %15 = ts.GetValueFromUnionOp %14 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %16 = ts.Cast %15 : !ts.number to !ts.string
    ts.Print(%3, %16) : !ts.string, !ts.string
    br ^bb2
  ^bb2:  // 2 preds: ^bb0, ^bb1
    ts.Print(%4) : !ts.string
    ts.ReturnInternal
  }
  func @main()
  ts.Func @main () -> ()  {
  }
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Constant'(0x1b3ca85c1a0) {
  %0 = "ts.Constant"() {value = 1.000000e+01 : f64} : () -> !ts.number

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.Constant -> ()' {
Trying to match "`anonymous-namespace'::ConstantOpLowering"
    ** Insert  : 'std.constant'(0x1b3ca85d8c0)
    ** Replace : 'ts.Constant'(0x1b3ca85c1a0)
"`anonymous-namespace'::ConstantOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'std.constant'(0x1b3ca85d8c0) {
      %0 = "std.constant"() {value = 1.000000e+01 : f64} : () -> f64

      * Fold {
      } -> FAILURE : unable to fold

      * Pattern : 'std.constant -> ()' {
Trying to match "`anonymous-namespace'::ConstantOpLowering"
        ** Insert  : 'llvm.mlir.constant'(0x1b3ca85cec0)
        ** Replace : 'std.constant'(0x1b3ca85d8c0)
"`anonymous-namespace'::ConstantOpLowering" result 1

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.mlir.constant'(0x1b3ca85cec0) {
          %0 = "llvm.mlir.constant"() {value = 1.000000e+01 : f64} : () -> f64

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//
      } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %1 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %2 = ts.Constant {value = "number"} : !ts.string
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.Constant {value = "b number: "} : !ts.string
  %5 = ts.Constant {value = "done."} : !ts.string
  %6 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %7 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %8 = ts.CreateUnionInstance %1, %2 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %8, %6 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %9 = ts.Load(%6) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %10 = ts.Cast %9 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %10, %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %11 = ts.Load(%7) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %12 = ts.GetTypeInfoFromUnionOp %11 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %13 = ts.LogicalBinary %12(34) %3 : !ts.string, !ts.string -> !ts.boolean
  %14 = ts.Cast %13 : !ts.boolean to i1
  cond_br %14, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %15 = ts.Load(%7) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %16 = ts.GetValueFromUnionOp %15 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %17 = ts.Cast %16 : !ts.number to !ts.string
  ts.Print(%4, %17) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%5) : !ts.string
  ts.ReturnInternal
}


    } -> SUCCESS
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %1 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %2 = ts.Constant {value = "number"} : !ts.string
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.Constant {value = "b number: "} : !ts.string
  %5 = ts.Constant {value = "done."} : !ts.string
  %6 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %7 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %8 = ts.CreateUnionInstance %1, %2 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %8, %6 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %9 = ts.Load(%6) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %10 = ts.Cast %9 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %10, %7 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %11 = ts.Load(%7) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %12 = ts.GetTypeInfoFromUnionOp %11 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %13 = ts.LogicalBinary %12(34) %3 : !ts.string, !ts.string -> !ts.boolean
  %14 = ts.Cast %13 : !ts.boolean to i1
  cond_br %14, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %15 = ts.Load(%7) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %16 = ts.GetValueFromUnionOp %15 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %17 = ts.Cast %16 : !ts.number to !ts.string
  ts.Print(%4, %17) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%5) : !ts.string
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Constant'(0x1b3ca857240) {
  %3 = "ts.Constant"() {value = "number"} : () -> !ts.string

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.Constant -> ()' {
Trying to match "`anonymous-namespace'::ConstantOpLowering"
    ** Insert  : 'llvm.mlir.global'(0x1b3ca89c520)
    ** Insert  : 'llvm.mlir.addressof'(0x1b3ca85c6a0)
    ** Insert  : 'llvm.mlir.constant'(0x1b3ca85b840)
    ** Insert  : 'llvm.getelementptr'(0x1b3ca712830)
    ** Replace : 'ts.Constant'(0x1b3ca857240)
"`anonymous-namespace'::ConstantOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.mlir.global'(0x1b3ca89c520) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.mlir.addressof'(0x1b3ca85c6a0) {
      %3 = "llvm.mlir.addressof"() {global_name = @s_9237349086447201248} : () -> !llvm.ptr<array<7 x i8>>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.mlir.constant'(0x1b3ca85b840) {
      %4 = "llvm.mlir.constant"() {value = 0 : i64} : () -> i64

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.getelementptr'(0x1b3ca712830) {
      %5 = "llvm.getelementptr"(%3, %4, %4) : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %1 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %2 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %3 = llvm.mlir.constant(0 : i64) : i64
  %4 = llvm.getelementptr %2[%3, %3] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %5 = ts.Constant {value = "number"} : !ts.string
  %6 = ts.Constant {value = "number"} : !ts.string
  %7 = ts.Constant {value = "b number: "} : !ts.string
  %8 = ts.Constant {value = "done."} : !ts.string
  %9 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %10 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %11 = ts.CreateUnionInstance %1, %5 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %11, %9 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %12 = ts.Load(%9) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %13 = ts.Cast %12 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %13, %10 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %14 = ts.Load(%10) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %15 = ts.GetTypeInfoFromUnionOp %14 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %16 = ts.LogicalBinary %15(34) %6 : !ts.string, !ts.string -> !ts.boolean
  %17 = ts.Cast %16 : !ts.boolean to i1
  cond_br %17, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %18 = ts.Load(%10) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %19 = ts.GetValueFromUnionOp %18 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %20 = ts.Cast %19 : !ts.number to !ts.string
  ts.Print(%7, %20) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%8) : !ts.string
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Constant'(0x1b3ca85cba0) {
  %7 = "ts.Constant"() {value = "number"} : () -> !ts.string

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.Constant -> ()' {
Trying to match "`anonymous-namespace'::ConstantOpLowering"
    ** Insert  : 'llvm.mlir.addressof'(0x1b3ca85bb60)
    ** Insert  : 'llvm.mlir.constant'(0x1b3ca85b200)
    ** Insert  : 'llvm.getelementptr'(0x1b3ca71e230)
    ** Replace : 'ts.Constant'(0x1b3ca85cba0)
"`anonymous-namespace'::ConstantOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.mlir.addressof'(0x1b3ca85bb60) {
      %7 = "llvm.mlir.addressof"() {global_name = @s_9237349086447201248} : () -> !llvm.ptr<array<7 x i8>>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.mlir.constant'(0x1b3ca85b200) {
      %8 = "llvm.mlir.constant"() {value = 0 : i64} : () -> i64

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.getelementptr'(0x1b3ca71e230) {
      %9 = "llvm.getelementptr"(%7, %8, %8) : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %1 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %2 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %3 = llvm.mlir.constant(0 : i64) : i64
  %4 = llvm.getelementptr %2[%3, %3] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %5 = ts.Constant {value = "number"} : !ts.string
  %6 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %7 = llvm.mlir.constant(0 : i64) : i64
  %8 = llvm.getelementptr %6[%7, %7] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.Constant {value = "b number: "} : !ts.string
  %11 = ts.Constant {value = "done."} : !ts.string
  %12 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %13 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %14 = ts.CreateUnionInstance %1, %5 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %14, %12 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %15 = ts.Load(%12) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %16 = ts.Cast %15 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %16, %13 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %17 = ts.Load(%13) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %18 = ts.GetTypeInfoFromUnionOp %17 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %19 = ts.LogicalBinary %18(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %20 = ts.Cast %19 : !ts.boolean to i1
  cond_br %20, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %21 = ts.Load(%13) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %22 = ts.GetValueFromUnionOp %21 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %23 = ts.Cast %22 : !ts.number to !ts.string
  ts.Print(%10, %23) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%11) : !ts.string
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Constant'(0x1b3ca858320) {
  %11 = "ts.Constant"() {value = "b number: "} : () -> !ts.string

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.Constant -> ()' {
Trying to match "`anonymous-namespace'::ConstantOpLowering"
    ** Insert  : 'llvm.mlir.global'(0x1b3ca89ce10)
    ** Insert  : 'llvm.mlir.addressof'(0x1b3ca85bca0)
    ** Insert  : 'llvm.mlir.constant'(0x1b3ca85ba20)
    ** Insert  : 'llvm.getelementptr'(0x1b3ca71c930)
    ** Replace : 'ts.Constant'(0x1b3ca858320)
"`anonymous-namespace'::ConstantOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.mlir.global'(0x1b3ca89ce10) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.mlir.addressof'(0x1b3ca85bca0) {
      %11 = "llvm.mlir.addressof"() {global_name = @s_13617892236937420068} : () -> !llvm.ptr<array<11 x i8>>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.mlir.constant'(0x1b3ca85ba20) {
      %12 = "llvm.mlir.constant"() {value = 0 : i64} : () -> i64

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.getelementptr'(0x1b3ca71c930) {
      %13 = "llvm.getelementptr"(%11, %12, %12) : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %1 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %2 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %3 = llvm.mlir.constant(0 : i64) : i64
  %4 = llvm.getelementptr %2[%3, %3] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %5 = ts.Constant {value = "number"} : !ts.string
  %6 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %7 = llvm.mlir.constant(0 : i64) : i64
  %8 = llvm.getelementptr %6[%7, %7] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %11 = llvm.mlir.constant(0 : i64) : i64
  %12 = llvm.getelementptr %10[%11, %11] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %13 = ts.Constant {value = "b number: "} : !ts.string
  %14 = ts.Constant {value = "done."} : !ts.string
  %15 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %16 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %17 = ts.CreateUnionInstance %1, %5 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %17, %15 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %18 = ts.Load(%15) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %19 = ts.Cast %18 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %19, %16 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %20 = ts.Load(%16) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %21 = ts.GetTypeInfoFromUnionOp %20 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %22 = ts.LogicalBinary %21(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %23 = ts.Cast %22 : !ts.boolean to i1
  cond_br %23, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %24 = ts.Load(%16) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %25 = ts.GetValueFromUnionOp %24 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %26 = ts.Cast %25 : !ts.number to !ts.string
  ts.Print(%13, %26) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%14) : !ts.string
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Constant'(0x1b3ca8572e0) {
  %15 = "ts.Constant"() {value = "done."} : () -> !ts.string

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.Constant -> ()' {
Trying to match "`anonymous-namespace'::ConstantOpLowering"
    ** Insert  : 'llvm.mlir.global'(0x1b3ca89c730)
    ** Insert  : 'llvm.mlir.addressof'(0x1b3ca85c880)
    ** Insert  : 'llvm.mlir.constant'(0x1b3ca85ca60)
    ** Insert  : 'llvm.getelementptr'(0x1b3ca71df30)
    ** Replace : 'ts.Constant'(0x1b3ca8572e0)
"`anonymous-namespace'::ConstantOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.mlir.global'(0x1b3ca89c730) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.mlir.addressof'(0x1b3ca85c880) {
      %15 = "llvm.mlir.addressof"() {global_name = @s_6682479467004374669} : () -> !llvm.ptr<array<6 x i8>>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.mlir.constant'(0x1b3ca85ca60) {
      %16 = "llvm.mlir.constant"() {value = 0 : i64} : () -> i64

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.getelementptr'(0x1b3ca71df30) {
      %17 = "llvm.getelementptr"(%15, %16, %16) : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %1 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %2 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %3 = llvm.mlir.constant(0 : i64) : i64
  %4 = llvm.getelementptr %2[%3, %3] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %5 = ts.Constant {value = "number"} : !ts.string
  %6 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %7 = llvm.mlir.constant(0 : i64) : i64
  %8 = llvm.getelementptr %6[%7, %7] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %11 = llvm.mlir.constant(0 : i64) : i64
  %12 = llvm.getelementptr %10[%11, %11] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %13 = ts.Constant {value = "b number: "} : !ts.string
  %14 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "done."} : !ts.string
  %18 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %19 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %20 = ts.CreateUnionInstance %1, %5 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %20, %18 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %21 = ts.Load(%18) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %22 = ts.Cast %21 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %22, %19 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %23 = ts.Load(%19) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %24 = ts.GetTypeInfoFromUnionOp %23 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %25 = ts.LogicalBinary %24(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %26 = ts.Cast %25 : !ts.boolean to i1
  cond_br %26, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %27 = ts.Load(%19) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %28 = ts.GetValueFromUnionOp %27 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %29 = ts.Cast %28 : !ts.number to !ts.string
  ts.Print(%13, %29) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%17) : !ts.string
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Variable'(0x1b3ca857100) {
  %19 = "ts.Variable"() {captured = false} : () -> !ts.ref<!ts.union<!ts.number,!ts.string>>

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.Variable -> ()' {
Trying to match "`anonymous-namespace'::VariableOpLowering"

!! variable allocation: !ts.union<!ts.number,!ts.string> is captured: 0
    ** Insert  : 'llvm.mlir.constant'(0x1b3ca85c060)
    ** Insert  : 'llvm.alloca'(0x1b3ca7b15c0)
    ** Replace : 'ts.Variable'(0x1b3ca857100)
"`anonymous-namespace'::VariableOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.mlir.constant'(0x1b3ca85c060) {
      %0 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.alloca'(0x1b3ca7b15c0) {
      %1 = "llvm.alloca"(%0) : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %2 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %3 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %4 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %5 = llvm.mlir.constant(0 : i64) : i64
  %6 = llvm.getelementptr %4[%5, %5] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %7 = ts.Constant {value = "number"} : !ts.string
  %8 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %9 = llvm.mlir.constant(0 : i64) : i64
  %10 = llvm.getelementptr %8[%9, %9] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %11 = ts.Constant {value = "number"} : !ts.string
  %12 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %13 = llvm.mlir.constant(0 : i64) : i64
  %14 = llvm.getelementptr %12[%13, %13] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %15 = ts.Constant {value = "b number: "} : !ts.string
  %16 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %17 = llvm.mlir.constant(0 : i64) : i64
  %18 = llvm.getelementptr %16[%17, %17] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %19 = ts.Constant {value = "done."} : !ts.string
  %20 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %21 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %22 = ts.CreateUnionInstance %3, %7 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %22, %20 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %23 = ts.Load(%20) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %24 = ts.Cast %23 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %24, %21 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %25 = ts.Load(%21) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %26 = ts.GetTypeInfoFromUnionOp %25 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %27 = ts.LogicalBinary %26(34) %11 : !ts.string, !ts.string -> !ts.boolean
  %28 = ts.Cast %27 : !ts.boolean to i1
  cond_br %28, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %29 = ts.Load(%21) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %30 = ts.GetValueFromUnionOp %29 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %31 = ts.Cast %30 : !ts.number to !ts.string
  ts.Print(%15, %31) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%19) : !ts.string
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Variable'(0x1b3ca857420) {
  %22 = "ts.Variable"() {captured = false} : () -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.Variable -> ()' {
Trying to match "`anonymous-namespace'::VariableOpLowering"

!! variable allocation: !ts.union<!ts.boolean,!ts.number,!ts.string> is captured: 0
    ** Insert  : 'llvm.mlir.constant'(0x1b3ca85d1e0)
    ** Insert  : 'llvm.alloca'(0x1b3ca7b0d80)
    ** Replace : 'ts.Variable'(0x1b3ca857420)
"`anonymous-namespace'::VariableOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.mlir.constant'(0x1b3ca85d1e0) {
      %0 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.alloca'(0x1b3ca7b0d80) {
      %1 = "llvm.alloca"(%0) : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %4 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %5 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %6 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %7 = llvm.mlir.constant(0 : i64) : i64
  %8 = llvm.getelementptr %6[%7, %7] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %11 = llvm.mlir.constant(0 : i64) : i64
  %12 = llvm.getelementptr %10[%11, %11] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %13 = ts.Constant {value = "number"} : !ts.string
  %14 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "b number: "} : !ts.string
  %18 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "done."} : !ts.string
  %22 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %23 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %24 = ts.CreateUnionInstance %5, %9 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %24, %22 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %25 = ts.Load(%22) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %26 = ts.Cast %25 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %26, %23 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %27 = ts.Load(%23) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %28 = ts.GetTypeInfoFromUnionOp %27 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %29 = ts.LogicalBinary %28(34) %13 : !ts.string, !ts.string -> !ts.boolean
  %30 = ts.Cast %29 : !ts.boolean to i1
  cond_br %30, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %31 = ts.Load(%23) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %32 = ts.GetValueFromUnionOp %31 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %33 = ts.Cast %32 : !ts.number to !ts.string
  ts.Print(%17, %33) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%21) : !ts.string
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.CreateUnionInstance'(0x1b3ca8d7340) {
  %25 = "ts.CreateUnionInstance"(%6, %10) : (!ts.number, !ts.string) -> !ts.union<!ts.number,!ts.string>

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.CreateUnionInstance -> ()' {
Trying to match "`anonymous-namespace'::CreateUnionInstanceOpLowering"
    ** Insert  : 'llvm.mlir.undef'(0x1b3ca85bde0)
    ** Insert  : 'llvm.insertvalue'(0x1b3ca8d8a00)
    ** Insert  : 'llvm.insertvalue'(0x1b3ca8d9aa0)
    ** Insert  : 'ts.Variable'(0x1b3ca7b1f80)
    ** Insert  : 'ts.Variable'(0x1b3ca85cc40)
    ** Insert  : 'ts.MemoryCopy'(0x1b3ca7faa30)
    ** Insert  : 'ts.Load'(0x1b3ca7b0fc0)
    ** Replace : 'ts.CreateUnionInstance'(0x1b3ca8d7340)
"`anonymous-namespace'::CreateUnionInstanceOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.mlir.undef'(0x1b3ca85bde0) {
      %25 = "llvm.mlir.undef"() : () -> !llvm.struct<(ptr<i8>, f64)>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.insertvalue'(0x1b3ca8d8a00) {
      %26 = "llvm.insertvalue"(%25, %10) {position = [0 : i32]} : (!llvm.struct<(ptr<i8>, f64)>, !ts.string) -> !llvm.struct<(ptr<i8>, f64)>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.insertvalue'(0x1b3ca8d9aa0) {
      %27 = "llvm.insertvalue"(%26, %6) {position = [1 : i32]} : (!llvm.struct<(ptr<i8>, f64)>, !ts.number) -> !llvm.struct<(ptr<i8>, f64)>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'ts.Variable'(0x1b3ca7b1f80) {
      %28 = "ts.Variable"(%27) {captured = false} : (!llvm.struct<(ptr<i8>, f64)>) -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>

      * Fold {
      } -> FAILURE : unable to fold

      * Pattern : 'ts.Variable -> ()' {
Trying to match "`anonymous-namespace'::VariableOpLowering"

!! variable allocation: !llvm.struct<(ptr<i8>, f64)> is captured: 0
        ** Insert  : 'llvm.mlir.constant'(0x1b3ca85bac0)
        ** Insert  : 'llvm.alloca'(0x1b3ca7b1c80)
        ** Insert  : 'llvm.store'(0x1b3ca7fd950)
        ** Replace : 'ts.Variable'(0x1b3ca7b1f80)
"`anonymous-namespace'::VariableOpLowering" result 1

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.mlir.constant'(0x1b3ca85bac0) {
          %0 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.alloca'(0x1b3ca7b1c80) {
          %1 = "llvm.alloca"(%0) : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.store'(0x1b3ca7fd950) {
          "llvm.store"(%29, %1) : (!llvm.struct<(ptr<i8>, f64)>, !llvm.ptr<struct<(ptr<i8>, f64)>>) -> ()

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//
      } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %7 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %8 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %9 = llvm.mlir.constant(0 : i64) : i64
  %10 = llvm.getelementptr %8[%9, %9] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %11 = ts.Constant {value = "number"} : !ts.string
  %12 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %13 = llvm.mlir.constant(0 : i64) : i64
  %14 = llvm.getelementptr %12[%13, %13] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %15 = ts.Constant {value = "number"} : !ts.string
  %16 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %17 = llvm.mlir.constant(0 : i64) : i64
  %18 = llvm.getelementptr %16[%17, %17] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %19 = ts.Constant {value = "b number: "} : !ts.string
  %20 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %21 = llvm.mlir.constant(0 : i64) : i64
  %22 = llvm.getelementptr %20[%21, %21] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %23 = ts.Constant {value = "done."} : !ts.string
  %24 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %25 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %26 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %27 = llvm.insertvalue %11, %26[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %28 = llvm.insertvalue %7, %27[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %28, %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %29 = ts.Variable(%28) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  "ts.MemoryCopy"(%30, %29) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %31 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %32 = ts.CreateUnionInstance %7, %11 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %32, %24 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %33 = ts.Load(%24) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %34 = ts.Cast %33 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %34, %25 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %35 = ts.Load(%25) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %36 = ts.GetTypeInfoFromUnionOp %35 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %37 = ts.LogicalBinary %36(34) %15 : !ts.string, !ts.string -> !ts.boolean
  %38 = ts.Cast %37 : !ts.boolean to i1
  cond_br %38, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %39 = ts.Load(%25) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %40 = ts.GetValueFromUnionOp %39 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %41 = ts.Cast %40 : !ts.number to !ts.string
  ts.Print(%19, %41) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%23) : !ts.string
  ts.ReturnInternal
}


    } -> SUCCESS
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'ts.Variable'(0x1b3ca85cc40) {
      %31 = "ts.Variable"() {captured = false} : () -> !ts.ref<!ts.union<!ts.number,!ts.string>>

      * Fold {
      } -> FAILURE : unable to fold

      * Pattern : 'ts.Variable -> ()' {
Trying to match "`anonymous-namespace'::VariableOpLowering"

!! variable allocation: !ts.union<!ts.number,!ts.string> is captured: 0
        ** Insert  : 'llvm.mlir.constant'(0x1b3ca85bc00)
        ** Insert  : 'llvm.alloca'(0x1b3ca7afdc0)
        ** Replace : 'ts.Variable'(0x1b3ca85cc40)
"`anonymous-namespace'::VariableOpLowering" result 1

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.mlir.constant'(0x1b3ca85bc00) {
          %0 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.alloca'(0x1b3ca7afdc0) {
          %1 = "llvm.alloca"(%0) : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//
      } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %9 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %10 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %11 = llvm.mlir.constant(0 : i64) : i64
  %12 = llvm.getelementptr %10[%11, %11] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %13 = ts.Constant {value = "number"} : !ts.string
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "b number: "} : !ts.string
  %22 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "done."} : !ts.string
  %26 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %27 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %28 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %29 = llvm.insertvalue %13, %28[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %30 = llvm.insertvalue %9, %29[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %30, %3 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %31 = ts.Variable(%30) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %32 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  "ts.MemoryCopy"(%32, %31) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %33 = ts.Load(%32) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %34 = ts.CreateUnionInstance %9, %13 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %34, %26 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %35 = ts.Load(%26) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %36 = ts.Cast %35 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %36, %27 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %37 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %38 = ts.GetTypeInfoFromUnionOp %37 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %39 = ts.LogicalBinary %38(34) %17 : !ts.string, !ts.string -> !ts.boolean
  %40 = ts.Cast %39 : !ts.boolean to i1
  cond_br %40, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %41 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %42 = ts.GetValueFromUnionOp %41 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %43 = ts.Cast %42 : !ts.number to !ts.string
  ts.Print(%21, %43) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%25) : !ts.string
  ts.ReturnInternal
}


    } -> SUCCESS
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'ts.MemoryCopy'(0x1b3ca7faa30) {
      "ts.MemoryCopy"(%33, %32) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()

      * Fold {
      } -> FAILURE : unable to fold

      * Pattern : 'ts.MemoryCopy -> ()' {
Trying to match "`anonymous-namespace'::MemoryCopyOpLowering"
        ** Insert  : 'llvm.func'(0x1b3ca89b130)
        ** Insert  : 'llvm.bitcast'(0x1b3ca7b0e40)
        ** Insert  : 'llvm.bitcast'(0x1b3ca7b1e00)
        ** Insert  : 'ts.SizeOf'(0x1b3ca85d3c0)
        ** Insert  : 'ts.SizeOf'(0x1b3ca85d500)
        ** Insert  : 'llvm.icmp'(0x1b3ca8d9fe0)
        ** Insert  : 'llvm.select'(0x1b3ca71e430)
        ** Insert  : 'llvm.mlir.constant'(0x1b3ca85cf60)
        ** Insert  : 'llvm.call'(0x1b3ca7d3df0)
        ** Erase   : 'ts.MemoryCopy'(0x1b3ca7faa30)
"`anonymous-namespace'::MemoryCopyOpLowering" result 1

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.func'(0x1b3ca89b130) {
        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.bitcast'(0x1b3ca7b0e40) {
          %34 = "llvm.bitcast"(%1) : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>) -> !llvm.ptr<i8>

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.bitcast'(0x1b3ca7b1e00) {
          %35 = "llvm.bitcast"(%3) : (!llvm.ptr<struct<(ptr<i8>, f64)>>) -> !llvm.ptr<i8>

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'ts.SizeOf'(0x1b3ca85d3c0) {
          %36 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64

          * Fold {
          } -> FAILURE : unable to fold

          * Pattern : 'ts.SizeOf -> ()' {
Trying to match "`anonymous-namespace'::SizeOfOpLowering"
            ** Insert  : 'llvm.mlir.null'(0x1b3ca85b3e0)

!! size of - storage type: [!llvm.struct<(ptr<i8>, f64)>] llvm storage type: [!llvm.struct<(ptr<i8>, f64)>] llvm ptr: [!llvm.ptr<struct<(ptr<i8>, f64)>>] value: [%35 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>]
            ** Insert  : 'llvm.mlir.constant'(0x1b3ca85c2e0)
            ** Insert  : 'llvm.getelementptr'(0x1b3ca8d6d20)
            ** Insert  : 'llvm.ptrtoint'(0x1b3ca7b1680)
            ** Replace : 'ts.SizeOf'(0x1b3ca85d3c0)
"`anonymous-namespace'::SizeOfOpLowering" result 1

            //===-------------------------------------------===//
            Legalizing operation : 'llvm.mlir.null'(0x1b3ca85b3e0) {
              %36 = "llvm.mlir.null"() : () -> !llvm.ptr<struct<(ptr<i8>, f64)>>

            } -> SUCCESS : operation marked legal by the target
            //===-------------------------------------------===//

            //===-------------------------------------------===//
            Legalizing operation : 'llvm.mlir.constant'(0x1b3ca85c2e0) {
              %37 = "llvm.mlir.constant"() {value = 1 : i64} : () -> i64

            } -> SUCCESS : operation marked legal by the target
            //===-------------------------------------------===//

            //===-------------------------------------------===//
            Legalizing operation : 'llvm.getelementptr'(0x1b3ca8d6d20) {
              %38 = "llvm.getelementptr"(%36, %37) : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>

            } -> SUCCESS : operation marked legal by the target
            //===-------------------------------------------===//

            //===-------------------------------------------===//
            Legalizing operation : 'llvm.ptrtoint'(0x1b3ca7b1680) {
              %39 = "llvm.ptrtoint"(%38) : (!llvm.ptr<struct<(ptr<i8>, f64)>>) -> i64

            } -> SUCCESS : operation marked legal by the target
            //===-------------------------------------------===//
          } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %9 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %10 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %11 = llvm.mlir.constant(0 : i64) : i64
  %12 = llvm.getelementptr %10[%11, %11] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %13 = ts.Constant {value = "number"} : !ts.string
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "b number: "} : !ts.string
  %22 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "done."} : !ts.string
  %26 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %27 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %28 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %29 = llvm.insertvalue %13, %28[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %30 = llvm.insertvalue %9, %29[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %30, %3 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %31 = ts.Variable(%30) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %32 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %33 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %34 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %35 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %36 = llvm.mlir.constant(1 : i64) : i64
  %37 = llvm.getelementptr %35[%36] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %38 = llvm.ptrtoint %37 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %39 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %40 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %41 = llvm.icmp "ult" %39, %40 : i64
  %42 = llvm.select %41, %39, %40 : i1, i64
  %43 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%33, %34, %42, %43) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%32, %31) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %44 = ts.Load(%32) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %45 = ts.CreateUnionInstance %9, %13 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %45, %26 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %46 = ts.Load(%26) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %47 = ts.Cast %46 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %47, %27 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %48 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %49 = ts.GetTypeInfoFromUnionOp %48 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %50 = ts.LogicalBinary %49(34) %17 : !ts.string, !ts.string -> !ts.boolean
  %51 = ts.Cast %50 : !ts.boolean to i1
  cond_br %51, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %52 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %53 = ts.GetValueFromUnionOp %52 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %54 = ts.Cast %53 : !ts.number to !ts.string
  ts.Print(%21, %54) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%25) : !ts.string
  ts.ReturnInternal
}


        } -> SUCCESS
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'ts.SizeOf'(0x1b3ca85d500) {
          %41 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64

          * Fold {
          } -> FAILURE : unable to fold

          * Pattern : 'ts.SizeOf -> ()' {
Trying to match "`anonymous-namespace'::SizeOfOpLowering"
            ** Insert  : 'llvm.mlir.null'(0x1b3ca85cce0)

!! size of - storage type: [!llvm.struct<(ptr<i8>, ptr<i8>)>] llvm storage type: [!llvm.struct<(ptr<i8>, ptr<i8>)>] llvm ptr: [!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>] value: [%40 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>]
            ** Insert  : 'llvm.mlir.constant'(0x1b3ca85be80)
            ** Insert  : 'llvm.getelementptr'(0x1b3ca8d6fc0)
            ** Insert  : 'llvm.ptrtoint'(0x1b3ca7af280)
            ** Replace : 'ts.SizeOf'(0x1b3ca85d500)
"`anonymous-namespace'::SizeOfOpLowering" result 1

            //===-------------------------------------------===//
            Legalizing operation : 'llvm.mlir.null'(0x1b3ca85cce0) {
              %41 = "llvm.mlir.null"() : () -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>

            } -> SUCCESS : operation marked legal by the target
            //===-------------------------------------------===//

            //===-------------------------------------------===//
            Legalizing operation : 'llvm.mlir.constant'(0x1b3ca85be80) {
              %42 = "llvm.mlir.constant"() {value = 1 : i64} : () -> i64

            } -> SUCCESS : operation marked legal by the target
            //===-------------------------------------------===//

            //===-------------------------------------------===//
            Legalizing operation : 'llvm.getelementptr'(0x1b3ca8d6fc0) {
              %43 = "llvm.getelementptr"(%41, %42) : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>

            } -> SUCCESS : operation marked legal by the target
            //===-------------------------------------------===//

            //===-------------------------------------------===//
            Legalizing operation : 'llvm.ptrtoint'(0x1b3ca7af280) {
              %44 = "llvm.ptrtoint"(%43) : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>) -> i64

            } -> SUCCESS : operation marked legal by the target
            //===-------------------------------------------===//
          } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %9 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %10 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %11 = llvm.mlir.constant(0 : i64) : i64
  %12 = llvm.getelementptr %10[%11, %11] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %13 = ts.Constant {value = "number"} : !ts.string
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "b number: "} : !ts.string
  %22 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "done."} : !ts.string
  %26 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %27 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %28 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %29 = llvm.insertvalue %13, %28[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %30 = llvm.insertvalue %9, %29[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %30, %3 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %31 = ts.Variable(%30) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %32 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %33 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %34 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %35 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %36 = llvm.mlir.constant(1 : i64) : i64
  %37 = llvm.getelementptr %35[%36] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %38 = llvm.ptrtoint %37 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %39 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %40 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %41 = llvm.mlir.constant(1 : i64) : i64
  %42 = llvm.getelementptr %40[%41] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %43 = llvm.ptrtoint %42 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %44 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %45 = llvm.icmp "ult" %39, %44 : i64
  %46 = llvm.select %45, %39, %44 : i1, i64
  %47 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%33, %34, %46, %47) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%32, %31) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %48 = ts.Load(%32) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %49 = ts.CreateUnionInstance %9, %13 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %49, %26 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %50 = ts.Load(%26) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %51 = ts.Cast %50 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %51, %27 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %52 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %53 = ts.GetTypeInfoFromUnionOp %52 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %54 = ts.LogicalBinary %53(34) %17 : !ts.string, !ts.string -> !ts.boolean
  %55 = ts.Cast %54 : !ts.boolean to i1
  cond_br %55, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %56 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %57 = ts.GetValueFromUnionOp %56 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %58 = ts.Cast %57 : !ts.number to !ts.string
  ts.Print(%21, %58) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%25) : !ts.string
  ts.ReturnInternal
}


        } -> SUCCESS
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.icmp'(0x1b3ca8d9fe0) {
          %46 = "llvm.icmp"(%40, %45) {predicate = 6 : i64} : (i64, i64) -> i1

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.select'(0x1b3ca71e430) {
          %47 = "llvm.select"(%46, %40, %45) : (i1, i64, i64) -> i64

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.mlir.constant'(0x1b3ca85cf60) {
          %48 = "llvm.mlir.constant"() {value = false} : () -> i1

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.call'(0x1b3ca7d3df0) {
          "llvm.call"(%34, %35, %47, %48) {callee = @llvm.memcpy.p0i8.p0i8.i64} : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//
      } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %9 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %10 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %11 = llvm.mlir.constant(0 : i64) : i64
  %12 = llvm.getelementptr %10[%11, %11] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %13 = ts.Constant {value = "number"} : !ts.string
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "b number: "} : !ts.string
  %22 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "done."} : !ts.string
  %26 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %27 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %28 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %29 = llvm.insertvalue %13, %28[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %30 = llvm.insertvalue %9, %29[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %30, %3 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %31 = ts.Variable(%30) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %32 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %33 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %34 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %35 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %36 = llvm.mlir.constant(1 : i64) : i64
  %37 = llvm.getelementptr %35[%36] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %38 = llvm.ptrtoint %37 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %39 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %40 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %41 = llvm.mlir.constant(1 : i64) : i64
  %42 = llvm.getelementptr %40[%41] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %43 = llvm.ptrtoint %42 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %44 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %45 = llvm.icmp "ult" %39, %44 : i64
  %46 = llvm.select %45, %39, %44 : i1, i64
  %47 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%33, %34, %46, %47) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%32, %31) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %48 = ts.Load(%32) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %49 = ts.CreateUnionInstance %9, %13 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %49, %26 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %50 = ts.Load(%26) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %51 = ts.Cast %50 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %51, %27 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %52 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %53 = ts.GetTypeInfoFromUnionOp %52 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %54 = ts.LogicalBinary %53(34) %17 : !ts.string, !ts.string -> !ts.boolean
  %55 = ts.Cast %54 : !ts.boolean to i1
  cond_br %55, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %56 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %57 = ts.GetValueFromUnionOp %56 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %58 = ts.Cast %57 : !ts.number to !ts.string
  ts.Print(%21, %58) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%25) : !ts.string
  ts.ReturnInternal
}


    } -> SUCCESS
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'ts.Load'(0x1b3ca7b0fc0) {
      %49 = "ts.Load"(%33) : (!ts.ref<!ts.union<!ts.number,!ts.string>>) -> !ts.union<!ts.number,!ts.string>

      * Fold {
      } -> FAILURE : unable to fold

      * Pattern : 'ts.Load -> ()' {
Trying to match "`anonymous-namespace'::LoadOpLowering"
        ** Insert  : 'llvm.load'(0x1b3ca7b1080)
        ** Replace : 'ts.Load'(0x1b3ca7b0fc0)
"`anonymous-namespace'::LoadOpLowering" result 1

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.load'(0x1b3ca7b1080) {
          %49 = "llvm.load"(%1) : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>) -> !llvm.struct<(ptr<i8>, ptr<i8>)>

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//
      } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %9 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %10 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %11 = llvm.mlir.constant(0 : i64) : i64
  %12 = llvm.getelementptr %10[%11, %11] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %13 = ts.Constant {value = "number"} : !ts.string
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "b number: "} : !ts.string
  %22 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "done."} : !ts.string
  %26 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %27 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %28 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %29 = llvm.insertvalue %13, %28[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %30 = llvm.insertvalue %9, %29[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %30, %3 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %31 = ts.Variable(%30) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %32 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %33 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %34 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %35 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %36 = llvm.mlir.constant(1 : i64) : i64
  %37 = llvm.getelementptr %35[%36] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %38 = llvm.ptrtoint %37 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %39 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %40 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %41 = llvm.mlir.constant(1 : i64) : i64
  %42 = llvm.getelementptr %40[%41] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %43 = llvm.ptrtoint %42 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %44 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %45 = llvm.icmp "ult" %39, %44 : i64
  %46 = llvm.select %45, %39, %44 : i1, i64
  %47 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%33, %34, %46, %47) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%32, %31) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %48 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %49 = ts.Load(%32) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %50 = ts.CreateUnionInstance %9, %13 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %50, %26 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %51 = ts.Load(%26) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %52 = ts.Cast %51 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %52, %27 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %53 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %54 = ts.GetTypeInfoFromUnionOp %53 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %55 = ts.LogicalBinary %54(34) %17 : !ts.string, !ts.string -> !ts.boolean
  %56 = ts.Cast %55 : !ts.boolean to i1
  cond_br %56, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %57 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %58 = ts.GetValueFromUnionOp %57 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %59 = ts.Cast %58 : !ts.number to !ts.string
  ts.Print(%21, %59) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%25) : !ts.string
  ts.ReturnInternal
}


    } -> SUCCESS
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %9 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %10 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %11 = llvm.mlir.constant(0 : i64) : i64
  %12 = llvm.getelementptr %10[%11, %11] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %13 = ts.Constant {value = "number"} : !ts.string
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "b number: "} : !ts.string
  %22 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "done."} : !ts.string
  %26 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %27 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %28 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %29 = llvm.insertvalue %13, %28[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %30 = llvm.insertvalue %9, %29[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %30, %3 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %31 = ts.Variable(%30) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %32 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %33 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %34 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %35 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %36 = llvm.mlir.constant(1 : i64) : i64
  %37 = llvm.getelementptr %35[%36] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %38 = llvm.ptrtoint %37 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %39 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %40 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %41 = llvm.mlir.constant(1 : i64) : i64
  %42 = llvm.getelementptr %40[%41] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %43 = llvm.ptrtoint %42 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %44 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %45 = llvm.icmp "ult" %39, %44 : i64
  %46 = llvm.select %45, %39, %44 : i1, i64
  %47 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%33, %34, %46, %47) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%32, %31) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %48 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %49 = ts.Load(%32) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %50 = ts.CreateUnionInstance %9, %13 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %50, %26 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %51 = ts.Load(%26) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %52 = ts.Cast %51 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %52, %27 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %53 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %54 = ts.GetTypeInfoFromUnionOp %53 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %55 = ts.LogicalBinary %54(34) %17 : !ts.string, !ts.string -> !ts.boolean
  %56 = ts.Cast %55 : !ts.boolean to i1
  cond_br %56, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %57 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %58 = ts.GetValueFromUnionOp %57 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %59 = ts.Cast %58 : !ts.number to !ts.string
  ts.Print(%21, %59) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%25) : !ts.string
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Store'(0x1b3ca7fa210) {
  "ts.Store"(%51, %27) : (!ts.union<!ts.number,!ts.string>, !ts.ref<!ts.union<!ts.number,!ts.string>>) -> ()

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.Store -> ()' {
Trying to match "`anonymous-namespace'::StoreOpLowering"
    ** Insert  : 'llvm.store'(0x1b3ca7fa960)
    ** Replace : 'ts.Store'(0x1b3ca7fa210)
"`anonymous-namespace'::StoreOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.store'(0x1b3ca7fa960) {
      "llvm.store"(%49, %7) : (!llvm.struct<(ptr<i8>, ptr<i8>)>, !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>) -> ()

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %9 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %10 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %11 = llvm.mlir.constant(0 : i64) : i64
  %12 = llvm.getelementptr %10[%11, %11] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %13 = ts.Constant {value = "number"} : !ts.string
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "b number: "} : !ts.string
  %22 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "done."} : !ts.string
  %26 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %27 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %28 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %29 = llvm.insertvalue %13, %28[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %30 = llvm.insertvalue %9, %29[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %30, %3 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %31 = ts.Variable(%30) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %32 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %33 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %34 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %35 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %36 = llvm.mlir.constant(1 : i64) : i64
  %37 = llvm.getelementptr %35[%36] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %38 = llvm.ptrtoint %37 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %39 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %40 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %41 = llvm.mlir.constant(1 : i64) : i64
  %42 = llvm.getelementptr %40[%41] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %43 = llvm.ptrtoint %42 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %44 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %45 = llvm.icmp "ult" %39, %44 : i64
  %46 = llvm.select %45, %39, %44 : i1, i64
  %47 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%33, %34, %46, %47) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%32, %31) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %48 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %49 = ts.Load(%32) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %50 = ts.CreateUnionInstance %9, %13 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %48, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %50, %26 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %51 = ts.Load(%26) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %52 = ts.Cast %51 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %52, %27 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %53 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %54 = ts.GetTypeInfoFromUnionOp %53 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %55 = ts.LogicalBinary %54(34) %17 : !ts.string, !ts.string -> !ts.boolean
  %56 = ts.Cast %55 : !ts.boolean to i1
  cond_br %56, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %57 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %58 = ts.GetValueFromUnionOp %57 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %59 = ts.Cast %58 : !ts.number to !ts.string
  ts.Print(%21, %59) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%25) : !ts.string
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Load'(0x1b3ca7b0540) {
  %52 = "ts.Load"(%27) : (!ts.ref<!ts.union<!ts.number,!ts.string>>) -> !ts.union<!ts.number,!ts.string>

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.Load -> ()' {
Trying to match "`anonymous-namespace'::LoadOpLowering"
    ** Insert  : 'llvm.load'(0x1b3ca7b2040)
    ** Replace : 'ts.Load'(0x1b3ca7b0540)
"`anonymous-namespace'::LoadOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.load'(0x1b3ca7b2040) {
      %52 = "llvm.load"(%7) : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>) -> !llvm.struct<(ptr<i8>, ptr<i8>)>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %9 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %10 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %11 = llvm.mlir.constant(0 : i64) : i64
  %12 = llvm.getelementptr %10[%11, %11] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %13 = ts.Constant {value = "number"} : !ts.string
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "b number: "} : !ts.string
  %22 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "done."} : !ts.string
  %26 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %27 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %28 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %29 = llvm.insertvalue %13, %28[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %30 = llvm.insertvalue %9, %29[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %30, %3 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %31 = ts.Variable(%30) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %32 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %33 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %34 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %35 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %36 = llvm.mlir.constant(1 : i64) : i64
  %37 = llvm.getelementptr %35[%36] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %38 = llvm.ptrtoint %37 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %39 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %40 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %41 = llvm.mlir.constant(1 : i64) : i64
  %42 = llvm.getelementptr %40[%41] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %43 = llvm.ptrtoint %42 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %44 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %45 = llvm.icmp "ult" %39, %44 : i64
  %46 = llvm.select %45, %39, %44 : i1, i64
  %47 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%33, %34, %46, %47) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%32, %31) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %48 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %49 = ts.Load(%32) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %50 = ts.CreateUnionInstance %9, %13 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %48, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %50, %26 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %51 = llvm.load %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %52 = ts.Load(%26) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %53 = ts.Cast %52 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %53, %27 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %54 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %55 = ts.GetTypeInfoFromUnionOp %54 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %56 = ts.LogicalBinary %55(34) %17 : !ts.string, !ts.string -> !ts.boolean
  %57 = ts.Cast %56 : !ts.boolean to i1
  cond_br %57, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %58 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %59 = ts.GetValueFromUnionOp %58 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %60 = ts.Cast %59 : !ts.number to !ts.string
  ts.Print(%21, %60) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%25) : !ts.string
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Cast'(0x1b3ca7b1980) {
  %54 = "ts.Cast"(%53) : (!ts.union<!ts.number,!ts.string>) -> !ts.union<!ts.boolean,!ts.number,!ts.string>

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.Cast -> ()' {
Trying to match "`anonymous-namespace'::CastOpLowering"
    ** Insert  : 'ts.GetValueFromUnionOp'(0x1b3ca7af400)
    ** Insert  : 'ts.GetTypeInfoFromUnionOp'(0x1b3ca7b12c0)
    ** Insert  : 'ts.CreateUnionInstance'(0x1b3ca8d8bc0)
    ** Replace : 'ts.Cast'(0x1b3ca7b1980)
"`anonymous-namespace'::CastOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'ts.GetValueFromUnionOp'(0x1b3ca7af400) {
      %54 = "ts.GetValueFromUnionOp"(%52) : (!llvm.struct<(ptr<i8>, ptr<i8>)>) -> !llvm.ptr<i8>

      * Fold {
      } -> FAILURE : unable to fold

      * Pattern : 'ts.GetValueFromUnionOp -> ()' {
Trying to match "`anonymous-namespace'::GetValueFromUnionOpLowering"
        ** Insert  : 'llvm.extractvalue'(0x1b3ca7b1500)
        ** Replace : 'ts.GetValueFromUnionOp'(0x1b3ca7af400)
"`anonymous-namespace'::GetValueFromUnionOpLowering" result 1

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.extractvalue'(0x1b3ca7b1500) {
          %54 = "llvm.extractvalue"(%52) {position = [1 : i32]} : (!llvm.struct<(ptr<i8>, ptr<i8>)>) -> !llvm.ptr<i8>

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//
      } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %9 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %10 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %11 = llvm.mlir.constant(0 : i64) : i64
  %12 = llvm.getelementptr %10[%11, %11] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %13 = ts.Constant {value = "number"} : !ts.string
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "b number: "} : !ts.string
  %22 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "done."} : !ts.string
  %26 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %27 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %28 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %29 = llvm.insertvalue %13, %28[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %30 = llvm.insertvalue %9, %29[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %30, %3 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %31 = ts.Variable(%30) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %32 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %33 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %34 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %35 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %36 = llvm.mlir.constant(1 : i64) : i64
  %37 = llvm.getelementptr %35[%36] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %38 = llvm.ptrtoint %37 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %39 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %40 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %41 = llvm.mlir.constant(1 : i64) : i64
  %42 = llvm.getelementptr %40[%41] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %43 = llvm.ptrtoint %42 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %44 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %45 = llvm.icmp "ult" %39, %44 : i64
  %46 = llvm.select %45, %39, %44 : i1, i64
  %47 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%33, %34, %46, %47) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%32, %31) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %48 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %49 = ts.Load(%32) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %50 = ts.CreateUnionInstance %9, %13 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %48, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %50, %26 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %51 = llvm.load %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %52 = ts.Load(%26) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %53 = llvm.extractvalue %51[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %54 = ts.GetValueFromUnionOp %51 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %55 = ts.GetTypeInfoFromUnionOp %51 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %56 = ts.CreateUnionInstance %54, %55 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
  %57 = ts.Cast %52 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %57, %27 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %58 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %59 = ts.GetTypeInfoFromUnionOp %58 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %60 = ts.LogicalBinary %59(34) %17 : !ts.string, !ts.string -> !ts.boolean
  %61 = ts.Cast %60 : !ts.boolean to i1
  cond_br %61, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %62 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %63 = ts.GetValueFromUnionOp %62 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %64 = ts.Cast %63 : !ts.number to !ts.string
  ts.Print(%21, %64) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%25) : !ts.string
  ts.ReturnInternal
}


    } -> SUCCESS
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'ts.GetTypeInfoFromUnionOp'(0x1b3ca7b12c0) {
      %56 = "ts.GetTypeInfoFromUnionOp"(%52) : (!llvm.struct<(ptr<i8>, ptr<i8>)>) -> !ts.string

      * Fold {
      } -> FAILURE : unable to fold

      * Pattern : 'ts.GetTypeInfoFromUnionOp -> ()' {
Trying to match "`anonymous-namespace'::GetTypeInfoFromUnionOpLowering"
        ** Insert  : 'llvm.extractvalue'(0x1b3ca7b1740)
        ** Replace : 'ts.GetTypeInfoFromUnionOp'(0x1b3ca7b12c0)
"`anonymous-namespace'::GetTypeInfoFromUnionOpLowering" result 1

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.extractvalue'(0x1b3ca7b1740) {
          %56 = "llvm.extractvalue"(%52) {position = [0 : i32]} : (!llvm.struct<(ptr<i8>, ptr<i8>)>) -> !llvm.ptr<i8>

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//
      } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %9 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %10 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %11 = llvm.mlir.constant(0 : i64) : i64
  %12 = llvm.getelementptr %10[%11, %11] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %13 = ts.Constant {value = "number"} : !ts.string
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "b number: "} : !ts.string
  %22 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "done."} : !ts.string
  %26 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %27 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %28 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %29 = llvm.insertvalue %13, %28[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %30 = llvm.insertvalue %9, %29[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %30, %3 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %31 = ts.Variable(%30) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %32 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %33 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %34 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %35 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %36 = llvm.mlir.constant(1 : i64) : i64
  %37 = llvm.getelementptr %35[%36] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %38 = llvm.ptrtoint %37 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %39 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %40 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %41 = llvm.mlir.constant(1 : i64) : i64
  %42 = llvm.getelementptr %40[%41] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %43 = llvm.ptrtoint %42 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %44 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %45 = llvm.icmp "ult" %39, %44 : i64
  %46 = llvm.select %45, %39, %44 : i1, i64
  %47 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%33, %34, %46, %47) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%32, %31) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %48 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %49 = ts.Load(%32) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %50 = ts.CreateUnionInstance %9, %13 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %48, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %50, %26 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %51 = llvm.load %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %52 = ts.Load(%26) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %53 = llvm.extractvalue %51[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %54 = ts.GetValueFromUnionOp %51 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %55 = llvm.extractvalue %51[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %56 = ts.GetTypeInfoFromUnionOp %51 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %57 = ts.CreateUnionInstance %54, %56 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
  %58 = ts.Cast %52 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %58, %27 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %59 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %60 = ts.GetTypeInfoFromUnionOp %59 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %61 = ts.LogicalBinary %60(34) %17 : !ts.string, !ts.string -> !ts.boolean
  %62 = ts.Cast %61 : !ts.boolean to i1
  cond_br %62, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %63 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %64 = ts.GetValueFromUnionOp %63 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %65 = ts.Cast %64 : !ts.number to !ts.string
  ts.Print(%21, %65) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%25) : !ts.string
  ts.ReturnInternal
}


    } -> SUCCESS
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'ts.CreateUnionInstance'(0x1b3ca8d8bc0) {
      %58 = "ts.CreateUnionInstance"(%55, %57) : (!llvm.ptr<i8>, !ts.string) -> !ts.union<!ts.boolean,!ts.number,!ts.string>

      * Fold {
      } -> FAILURE : unable to fold

      * Pattern : 'ts.CreateUnionInstance -> ()' {
Trying to match "`anonymous-namespace'::CreateUnionInstanceOpLowering"
        ** Insert  : 'llvm.mlir.undef'(0x1b3ca85b980)
        ** Insert  : 'llvm.insertvalue'(0x1b3ca8d7180)
        ** Insert  : 'llvm.insertvalue'(0x1b3ca8d8ca0)
        ** Replace : 'ts.CreateUnionInstance'(0x1b3ca8d8bc0)
"`anonymous-namespace'::CreateUnionInstanceOpLowering" result 1

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.mlir.undef'(0x1b3ca85b980) {
          %58 = "llvm.mlir.undef"() : () -> !llvm.struct<(ptr<i8>, ptr<i8>)>

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.insertvalue'(0x1b3ca8d7180) {
          %59 = "llvm.insertvalue"(%58, %57) {position = [0 : i32]} : (!llvm.struct<(ptr<i8>, ptr<i8>)>, !ts.string) -> !llvm.struct<(ptr<i8>, ptr<i8>)>

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.insertvalue'(0x1b3ca8d8ca0) {
          %60 = "llvm.insertvalue"(%59, %55) {position = [1 : i32]} : (!llvm.struct<(ptr<i8>, ptr<i8>)>, !llvm.ptr<i8>) -> !llvm.struct<(ptr<i8>, ptr<i8>)>

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//
      } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %9 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %10 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %11 = llvm.mlir.constant(0 : i64) : i64
  %12 = llvm.getelementptr %10[%11, %11] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %13 = ts.Constant {value = "number"} : !ts.string
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "b number: "} : !ts.string
  %22 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "done."} : !ts.string
  %26 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %27 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %28 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %29 = llvm.insertvalue %13, %28[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %30 = llvm.insertvalue %9, %29[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %30, %3 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %31 = ts.Variable(%30) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %32 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %33 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %34 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %35 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %36 = llvm.mlir.constant(1 : i64) : i64
  %37 = llvm.getelementptr %35[%36] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %38 = llvm.ptrtoint %37 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %39 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %40 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %41 = llvm.mlir.constant(1 : i64) : i64
  %42 = llvm.getelementptr %40[%41] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %43 = llvm.ptrtoint %42 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %44 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %45 = llvm.icmp "ult" %39, %44 : i64
  %46 = llvm.select %45, %39, %44 : i1, i64
  %47 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%33, %34, %46, %47) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%32, %31) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %48 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %49 = ts.Load(%32) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %50 = ts.CreateUnionInstance %9, %13 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %48, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %50, %26 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %51 = llvm.load %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %52 = ts.Load(%26) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %53 = llvm.extractvalue %51[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %54 = ts.GetValueFromUnionOp %51 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %55 = llvm.extractvalue %51[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %56 = ts.GetTypeInfoFromUnionOp %51 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %57 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = llvm.insertvalue %56, %57[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %59 = llvm.insertvalue %54, %58[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.CreateUnionInstance %54, %56 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
  %61 = ts.Cast %52 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %61, %27 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %62 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %63 = ts.GetTypeInfoFromUnionOp %62 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %64 = ts.LogicalBinary %63(34) %17 : !ts.string, !ts.string -> !ts.boolean
  %65 = ts.Cast %64 : !ts.boolean to i1
  cond_br %65, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %66 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %67 = ts.GetValueFromUnionOp %66 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %68 = ts.Cast %67 : !ts.number to !ts.string
  ts.Print(%21, %68) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%25) : !ts.string
  ts.ReturnInternal
}


    } -> SUCCESS
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %9 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %10 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %11 = llvm.mlir.constant(0 : i64) : i64
  %12 = llvm.getelementptr %10[%11, %11] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %13 = ts.Constant {value = "number"} : !ts.string
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "b number: "} : !ts.string
  %22 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "done."} : !ts.string
  %26 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %27 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %28 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %29 = llvm.insertvalue %13, %28[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %30 = llvm.insertvalue %9, %29[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %30, %3 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %31 = ts.Variable(%30) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %32 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %33 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %34 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %35 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %36 = llvm.mlir.constant(1 : i64) : i64
  %37 = llvm.getelementptr %35[%36] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %38 = llvm.ptrtoint %37 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %39 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %40 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %41 = llvm.mlir.constant(1 : i64) : i64
  %42 = llvm.getelementptr %40[%41] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %43 = llvm.ptrtoint %42 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %44 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %45 = llvm.icmp "ult" %39, %44 : i64
  %46 = llvm.select %45, %39, %44 : i1, i64
  %47 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%33, %34, %46, %47) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%32, %31) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %48 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %49 = ts.Load(%32) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %50 = ts.CreateUnionInstance %9, %13 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %48, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %50, %26 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %51 = llvm.load %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %52 = ts.Load(%26) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %53 = llvm.extractvalue %51[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %54 = ts.GetValueFromUnionOp %51 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %55 = llvm.extractvalue %51[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %56 = ts.GetTypeInfoFromUnionOp %51 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %57 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = llvm.insertvalue %56, %57[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %59 = llvm.insertvalue %54, %58[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.CreateUnionInstance %54, %56 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
  %61 = ts.Cast %52 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  ts.Store %61, %27 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %62 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %63 = ts.GetTypeInfoFromUnionOp %62 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %64 = ts.LogicalBinary %63(34) %17 : !ts.string, !ts.string -> !ts.boolean
  %65 = ts.Cast %64 : !ts.boolean to i1
  cond_br %65, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %66 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %67 = ts.GetValueFromUnionOp %66 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %68 = ts.Cast %67 : !ts.number to !ts.string
  ts.Print(%21, %68) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%25) : !ts.string
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Store'(0x1b3ca7f77d0) {
  "ts.Store"(%62, %28) : (!ts.union<!ts.boolean,!ts.number,!ts.string>, !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>) -> ()

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.Store -> ()' {
Trying to match "`anonymous-namespace'::StoreOpLowering"
    ** Insert  : 'llvm.store'(0x1b3ca7fb320)
    ** Replace : 'ts.Store'(0x1b3ca7f77d0)
"`anonymous-namespace'::StoreOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.store'(0x1b3ca7fb320) {
      "llvm.store"(%60, %5) : (!llvm.struct<(ptr<i8>, ptr<i8>)>, !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>) -> ()

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %9 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %10 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %11 = llvm.mlir.constant(0 : i64) : i64
  %12 = llvm.getelementptr %10[%11, %11] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %13 = ts.Constant {value = "number"} : !ts.string
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "b number: "} : !ts.string
  %22 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "done."} : !ts.string
  %26 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %27 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %28 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %29 = llvm.insertvalue %13, %28[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %30 = llvm.insertvalue %9, %29[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %30, %3 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %31 = ts.Variable(%30) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %32 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %33 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %34 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %35 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %36 = llvm.mlir.constant(1 : i64) : i64
  %37 = llvm.getelementptr %35[%36] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %38 = llvm.ptrtoint %37 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %39 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %40 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %41 = llvm.mlir.constant(1 : i64) : i64
  %42 = llvm.getelementptr %40[%41] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %43 = llvm.ptrtoint %42 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %44 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %45 = llvm.icmp "ult" %39, %44 : i64
  %46 = llvm.select %45, %39, %44 : i1, i64
  %47 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%33, %34, %46, %47) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%32, %31) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %48 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %49 = ts.Load(%32) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %50 = ts.CreateUnionInstance %9, %13 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %48, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %50, %26 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %51 = llvm.load %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %52 = ts.Load(%26) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %53 = llvm.extractvalue %51[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %54 = ts.GetValueFromUnionOp %51 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %55 = llvm.extractvalue %51[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %56 = ts.GetTypeInfoFromUnionOp %51 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %57 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = llvm.insertvalue %56, %57[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %59 = llvm.insertvalue %54, %58[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.CreateUnionInstance %54, %56 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
  %61 = ts.Cast %52 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  llvm.store %59, %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %61, %27 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %62 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %63 = ts.GetTypeInfoFromUnionOp %62 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %64 = ts.LogicalBinary %63(34) %17 : !ts.string, !ts.string -> !ts.boolean
  %65 = ts.Cast %64 : !ts.boolean to i1
  cond_br %65, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %66 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %67 = ts.GetValueFromUnionOp %66 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %68 = ts.Cast %67 : !ts.number to !ts.string
  ts.Print(%21, %68) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%25) : !ts.string
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Load'(0x1b3ca7b1ec0) {
  %63 = "ts.Load"(%28) : (!ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>) -> !ts.union<!ts.boolean,!ts.number,!ts.string>

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.Load -> ()' {
Trying to match "`anonymous-namespace'::LoadOpLowering"
    ** Insert  : 'llvm.load'(0x1b3ca7b0b40)
    ** Replace : 'ts.Load'(0x1b3ca7b1ec0)
"`anonymous-namespace'::LoadOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.load'(0x1b3ca7b0b40) {
      %63 = "llvm.load"(%5) : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>) -> !llvm.struct<(ptr<i8>, ptr<i8>)>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %9 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %10 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %11 = llvm.mlir.constant(0 : i64) : i64
  %12 = llvm.getelementptr %10[%11, %11] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %13 = ts.Constant {value = "number"} : !ts.string
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "b number: "} : !ts.string
  %22 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "done."} : !ts.string
  %26 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %27 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %28 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %29 = llvm.insertvalue %13, %28[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %30 = llvm.insertvalue %9, %29[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %30, %3 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %31 = ts.Variable(%30) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %32 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %33 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %34 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %35 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %36 = llvm.mlir.constant(1 : i64) : i64
  %37 = llvm.getelementptr %35[%36] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %38 = llvm.ptrtoint %37 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %39 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %40 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %41 = llvm.mlir.constant(1 : i64) : i64
  %42 = llvm.getelementptr %40[%41] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %43 = llvm.ptrtoint %42 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %44 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %45 = llvm.icmp "ult" %39, %44 : i64
  %46 = llvm.select %45, %39, %44 : i1, i64
  %47 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%33, %34, %46, %47) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%32, %31) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %48 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %49 = ts.Load(%32) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %50 = ts.CreateUnionInstance %9, %13 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %48, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %50, %26 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %51 = llvm.load %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %52 = ts.Load(%26) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %53 = llvm.extractvalue %51[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %54 = ts.GetValueFromUnionOp %51 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %55 = llvm.extractvalue %51[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %56 = ts.GetTypeInfoFromUnionOp %51 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %57 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = llvm.insertvalue %56, %57[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %59 = llvm.insertvalue %54, %58[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.CreateUnionInstance %54, %56 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
  %61 = ts.Cast %52 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  llvm.store %59, %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %61, %27 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %62 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %63 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %64 = ts.GetTypeInfoFromUnionOp %63 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %65 = ts.LogicalBinary %64(34) %17 : !ts.string, !ts.string -> !ts.boolean
  %66 = ts.Cast %65 : !ts.boolean to i1
  cond_br %66, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %67 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %68 = ts.GetValueFromUnionOp %67 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %69 = ts.Cast %68 : !ts.number to !ts.string
  ts.Print(%21, %69) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%25) : !ts.string
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.GetTypeInfoFromUnionOp'(0x1b3ca7afe80) {
  %65 = "ts.GetTypeInfoFromUnionOp"(%64) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.string

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.GetTypeInfoFromUnionOp -> ()' {
Trying to match "`anonymous-namespace'::GetTypeInfoFromUnionOpLowering"
    ** Insert  : 'llvm.extractvalue'(0x1b3ca7af100)
    ** Replace : 'ts.GetTypeInfoFromUnionOp'(0x1b3ca7afe80)
"`anonymous-namespace'::GetTypeInfoFromUnionOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.extractvalue'(0x1b3ca7af100) {
      %65 = "llvm.extractvalue"(%63) {position = [0 : i32]} : (!llvm.struct<(ptr<i8>, ptr<i8>)>) -> !llvm.ptr<i8>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %9 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %10 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %11 = llvm.mlir.constant(0 : i64) : i64
  %12 = llvm.getelementptr %10[%11, %11] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %13 = ts.Constant {value = "number"} : !ts.string
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "b number: "} : !ts.string
  %22 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "done."} : !ts.string
  %26 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %27 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %28 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %29 = llvm.insertvalue %13, %28[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %30 = llvm.insertvalue %9, %29[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %30, %3 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %31 = ts.Variable(%30) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %32 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %33 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %34 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %35 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %36 = llvm.mlir.constant(1 : i64) : i64
  %37 = llvm.getelementptr %35[%36] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %38 = llvm.ptrtoint %37 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %39 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %40 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %41 = llvm.mlir.constant(1 : i64) : i64
  %42 = llvm.getelementptr %40[%41] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %43 = llvm.ptrtoint %42 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %44 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %45 = llvm.icmp "ult" %39, %44 : i64
  %46 = llvm.select %45, %39, %44 : i1, i64
  %47 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%33, %34, %46, %47) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%32, %31) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %48 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %49 = ts.Load(%32) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %50 = ts.CreateUnionInstance %9, %13 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %48, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %50, %26 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %51 = llvm.load %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %52 = ts.Load(%26) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %53 = llvm.extractvalue %51[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %54 = ts.GetValueFromUnionOp %51 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %55 = llvm.extractvalue %51[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %56 = ts.GetTypeInfoFromUnionOp %51 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %57 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = llvm.insertvalue %56, %57[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %59 = llvm.insertvalue %54, %58[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.CreateUnionInstance %54, %56 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
  %61 = ts.Cast %52 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  llvm.store %59, %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %61, %27 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %62 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %63 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %64 = llvm.extractvalue %62[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %65 = ts.GetTypeInfoFromUnionOp %63 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %66 = ts.LogicalBinary %65(34) %17 : !ts.string, !ts.string -> !ts.boolean
  %67 = ts.Cast %66 : !ts.boolean to i1
  cond_br %67, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %68 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %69 = ts.GetValueFromUnionOp %68 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %70 = ts.Cast %69 : !ts.number to !ts.string
  ts.Print(%21, %70) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%25) : !ts.string
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.LogicalBinary'(0x1b3ca8d85a0) {
  %67 = "ts.LogicalBinary"(%66, %18) {opCode = 34 : i32} : (!ts.string, !ts.string) -> !ts.boolean

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.LogicalBinary -> ()' {
Trying to match "`anonymous-namespace'::LogicalBinaryOpLowering"
    ** Insert  : 'ts.StringCompare'(0x1b3ca8d8d80)
    ** Replace : 'ts.LogicalBinary'(0x1b3ca8d85a0)
"`anonymous-namespace'::LogicalBinaryOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'ts.StringCompare'(0x1b3ca8d8d80) {
      %67 = "ts.StringCompare"(%65, %17) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean

      * Fold {
      } -> FAILURE : unable to fold

      * Pattern : 'ts.StringCompare -> ()' {
Trying to match "`anonymous-namespace'::StringCompareOpLowering"
        ** Insert  : 'llvm.func'(0x1b3ca89ac60)
        ** Insert  : 'llvm.mlir.constant'(0x1b3ca85d5a0)
        ** Insert  : 'llvm.ptrtoint'(0x1b3ca7af580)
        ** Insert  : 'llvm.ptrtoint'(0x1b3ca7b0cc0)
        ** Insert  : 'llvm.icmp'(0x1b3ca8d8f40)
        ** Insert  : 'llvm.icmp'(0x1b3ca8d9100)
        ** Insert  : 'ts.Cast'(0x1b3ca7b0600)
        ** Insert  : 'ts.Cast'(0x1b3ca7b0000)
        ** Insert  : 'llvm.and'(0x1b3ca8d9560)
        ** Insert  : 'llvm.mlir.constant'(0x1b3ca85cd80)
        ** Insert  : 'llvm.icmp'(0x1b3ca8d9640)
        ** Insert  : 'llvm.mlir.constant'(0x1b3ca85d780)
        ** Insert  : 'llvm.call'(0x1b3ca8da440)
        ** Insert  : 'llvm.icmp'(0x1b3ca8da8a0)
        ** Insert  : 'llvm.icmp'(0x1b3ca8da6e0)
        ** Insert  : 'llvm.br'(0x1b3ca89cf70)
        ** Insert  : 'llvm.br'(0x1b3ca7fd6e0)
        ** Insert  : 'llvm.br'(0x1b3ca7fdaf0)
        ** Insert  : 'llvm.cond_br'(0x1b3ca8354d0)
        ** Replace : 'ts.StringCompare'(0x1b3ca8d8d80)
"`anonymous-namespace'::StringCompareOpLowering" result 1

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.func'(0x1b3ca89ac60) {
        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.mlir.constant'(0x1b3ca85d5a0) {
          %67 = "llvm.mlir.constant"() {value = 0 : i64} : () -> i64

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.ptrtoint'(0x1b3ca7af580) {
          %68 = "llvm.ptrtoint"(%65) : (!llvm.ptr<i8>) -> i64

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.ptrtoint'(0x1b3ca7b0cc0) {
          %69 = "llvm.ptrtoint"(%17) : (!llvm.ptr<i8>) -> i64

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.icmp'(0x1b3ca8d8f40) {
          %70 = "llvm.icmp"(%68, %67) {predicate = 1 : i64} : (i64, i64) -> i1

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.icmp'(0x1b3ca8d9100) {
          %71 = "llvm.icmp"(%69, %67) {predicate = 1 : i64} : (i64, i64) -> i1

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'ts.Cast'(0x1b3ca7b0600) {
          %72 = "ts.Cast"(%70) : (i1) -> i32

          * Fold {
          } -> FAILURE : unable to fold

          * Pattern : 'ts.Cast -> ()' {
Trying to match "`anonymous-namespace'::CastOpLowering"
            ** Insert  : 'std.zexti'(0x1b3ca7af640)
            ** Replace : 'ts.Cast'(0x1b3ca7b0600)
"`anonymous-namespace'::CastOpLowering" result 1

            //===-------------------------------------------===//
            Legalizing operation : 'std.zexti'(0x1b3ca7af640) {
              %72 = "std.zexti"(%70) : (i1) -> i32

              * Fold {
              } -> FAILURE : unable to fold

              * Pattern : 'std.zexti -> ()' {
Trying to match "mlir::VectorConvertToLLVMPattern<class mlir::ZeroExtendIOp,class mlir::LLVM::ZExtOp>"
                ** Insert  : 'llvm.zext'(0x1b3ca7af700)
                ** Replace : 'std.zexti'(0x1b3ca7af640)
"mlir::VectorConvertToLLVMPattern<class mlir::ZeroExtendIOp,class mlir::LLVM::ZExtOp>" result 1

                //===-------------------------------------------===//
                Legalizing operation : 'llvm.zext'(0x1b3ca7af700) {
                  %72 = "llvm.zext"(%70) : (i1) -> i32

                } -> SUCCESS : operation marked legal by the target
                //===-------------------------------------------===//
              } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %9 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %10 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %11 = llvm.mlir.constant(0 : i64) : i64
  %12 = llvm.getelementptr %10[%11, %11] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %13 = ts.Constant {value = "number"} : !ts.string
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "b number: "} : !ts.string
  %22 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "done."} : !ts.string
  %26 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %27 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %28 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %29 = llvm.insertvalue %13, %28[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %30 = llvm.insertvalue %9, %29[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %30, %3 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %31 = ts.Variable(%30) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %32 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %33 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %34 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %35 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %36 = llvm.mlir.constant(1 : i64) : i64
  %37 = llvm.getelementptr %35[%36] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %38 = llvm.ptrtoint %37 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %39 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %40 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %41 = llvm.mlir.constant(1 : i64) : i64
  %42 = llvm.getelementptr %40[%41] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %43 = llvm.ptrtoint %42 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %44 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %45 = llvm.icmp "ult" %39, %44 : i64
  %46 = llvm.select %45, %39, %44 : i1, i64
  %47 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%33, %34, %46, %47) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%32, %31) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %48 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %49 = ts.Load(%32) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %50 = ts.CreateUnionInstance %9, %13 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %48, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %50, %26 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %51 = llvm.load %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %52 = ts.Load(%26) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %53 = llvm.extractvalue %51[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %54 = ts.GetValueFromUnionOp %51 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %55 = llvm.extractvalue %51[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %56 = ts.GetTypeInfoFromUnionOp %51 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %57 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = llvm.insertvalue %56, %57[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %59 = llvm.insertvalue %54, %58[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.CreateUnionInstance %54, %56 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
  %61 = ts.Cast %52 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  llvm.store %59, %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %61, %27 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %62 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %63 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %64 = llvm.extractvalue %62[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %65 = ts.GetTypeInfoFromUnionOp %63 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %66 = llvm.mlir.constant(0 : i64) : i64
  %67 = llvm.ptrtoint %64 : !llvm.ptr<i8> to i64
  %68 = llvm.ptrtoint %16 : !llvm.ptr<i8> to i64
  %69 = llvm.icmp "ne" %67, %66 : i64
  %70 = llvm.icmp "ne" %68, %66 : i64
  %71 = llvm.zext %69 : i1 to i32
  %72 = zexti %69 : i1 to i32
  %73 = ts.Cast %69 : i1 to i32
  %74 = ts.Cast %70 : i1 to i32
  %75 = llvm.and %73, %74  : i32
  %76 = llvm.mlir.constant(0 : i32) : i32
  %77 = llvm.icmp "ne" %75, %76 : i32
  llvm.cond_br %77, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %78 = llvm.mlir.constant(0 : i32) : i32
  %79 = llvm.call @strcmp(%64, %16) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %80 = llvm.icmp "eq" %79, %78 : i32
  llvm.br ^bb3(%80 : i1)
^bb2:  // pred: ^bb0
  %81 = llvm.icmp "eq" %67, %68 : i64
  llvm.br ^bb3(%81 : i1)
^bb3(%82: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %83 = "ts.StringCompare"(%64, %16) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %84 = ts.LogicalBinary %65(34) %17 : !ts.string, !ts.string -> !ts.boolean
  %85 = ts.Cast %84 : !ts.boolean to i1
  cond_br %85, ^bb5, ^bb6
^bb5:  // pred: ^bb4
  %86 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %87 = ts.GetValueFromUnionOp %86 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %88 = ts.Cast %87 : !ts.number to !ts.string
  ts.Print(%21, %88) : !ts.string, !ts.string
  br ^bb6
^bb6:  // 2 preds: ^bb4, ^bb5
  ts.Print(%25) : !ts.string
  ts.ReturnInternal
}


            } -> SUCCESS
            //===-------------------------------------------===//
          } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %9 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %10 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %11 = llvm.mlir.constant(0 : i64) : i64
  %12 = llvm.getelementptr %10[%11, %11] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %13 = ts.Constant {value = "number"} : !ts.string
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "b number: "} : !ts.string
  %22 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "done."} : !ts.string
  %26 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %27 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %28 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %29 = llvm.insertvalue %13, %28[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %30 = llvm.insertvalue %9, %29[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %30, %3 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %31 = ts.Variable(%30) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %32 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %33 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %34 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %35 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %36 = llvm.mlir.constant(1 : i64) : i64
  %37 = llvm.getelementptr %35[%36] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %38 = llvm.ptrtoint %37 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %39 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %40 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %41 = llvm.mlir.constant(1 : i64) : i64
  %42 = llvm.getelementptr %40[%41] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %43 = llvm.ptrtoint %42 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %44 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %45 = llvm.icmp "ult" %39, %44 : i64
  %46 = llvm.select %45, %39, %44 : i1, i64
  %47 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%33, %34, %46, %47) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%32, %31) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %48 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %49 = ts.Load(%32) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %50 = ts.CreateUnionInstance %9, %13 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %48, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %50, %26 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %51 = llvm.load %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %52 = ts.Load(%26) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %53 = llvm.extractvalue %51[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %54 = ts.GetValueFromUnionOp %51 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %55 = llvm.extractvalue %51[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %56 = ts.GetTypeInfoFromUnionOp %51 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %57 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = llvm.insertvalue %56, %57[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %59 = llvm.insertvalue %54, %58[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.CreateUnionInstance %54, %56 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
  %61 = ts.Cast %52 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  llvm.store %59, %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %61, %27 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %62 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %63 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %64 = llvm.extractvalue %62[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %65 = ts.GetTypeInfoFromUnionOp %63 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %66 = llvm.mlir.constant(0 : i64) : i64
  %67 = llvm.ptrtoint %64 : !llvm.ptr<i8> to i64
  %68 = llvm.ptrtoint %16 : !llvm.ptr<i8> to i64
  %69 = llvm.icmp "ne" %67, %66 : i64
  %70 = llvm.icmp "ne" %68, %66 : i64
  %71 = llvm.zext %69 : i1 to i32
  %72 = zexti %69 : i1 to i32
  %73 = ts.Cast %69 : i1 to i32
  %74 = ts.Cast %70 : i1 to i32
  %75 = llvm.and %73, %74  : i32
  %76 = llvm.mlir.constant(0 : i32) : i32
  %77 = llvm.icmp "ne" %75, %76 : i32
  llvm.cond_br %77, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %78 = llvm.mlir.constant(0 : i32) : i32
  %79 = llvm.call @strcmp(%64, %16) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %80 = llvm.icmp "eq" %79, %78 : i32
  llvm.br ^bb3(%80 : i1)
^bb2:  // pred: ^bb0
  %81 = llvm.icmp "eq" %67, %68 : i64
  llvm.br ^bb3(%81 : i1)
^bb3(%82: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %83 = "ts.StringCompare"(%64, %16) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %84 = ts.LogicalBinary %65(34) %17 : !ts.string, !ts.string -> !ts.boolean
  %85 = ts.Cast %84 : !ts.boolean to i1
  cond_br %85, ^bb5, ^bb6
^bb5:  // pred: ^bb4
  %86 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %87 = ts.GetValueFromUnionOp %86 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %88 = ts.Cast %87 : !ts.number to !ts.string
  ts.Print(%21, %88) : !ts.string, !ts.string
  br ^bb6
^bb6:  // 2 preds: ^bb4, ^bb5
  ts.Print(%25) : !ts.string
  ts.ReturnInternal
}


        } -> SUCCESS
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'ts.Cast'(0x1b3ca7b0000) {
          %75 = "ts.Cast"(%71) : (i1) -> i32

          * Fold {
          } -> FAILURE : unable to fold

          * Pattern : 'ts.Cast -> ()' {
Trying to match "`anonymous-namespace'::CastOpLowering"
            ** Insert  : 'std.zexti'(0x1b3ca7afd00)
            ** Replace : 'ts.Cast'(0x1b3ca7b0000)
"`anonymous-namespace'::CastOpLowering" result 1

            //===-------------------------------------------===//
            Legalizing operation : 'std.zexti'(0x1b3ca7afd00) {
              %75 = "std.zexti"(%71) : (i1) -> i32

              * Fold {
              } -> FAILURE : unable to fold

              * Pattern : 'std.zexti -> ()' {
Trying to match "mlir::VectorConvertToLLVMPattern<class mlir::ZeroExtendIOp,class mlir::LLVM::ZExtOp>"
                ** Insert  : 'llvm.zext'(0x1b3ca7b03c0)
                ** Replace : 'std.zexti'(0x1b3ca7afd00)
"mlir::VectorConvertToLLVMPattern<class mlir::ZeroExtendIOp,class mlir::LLVM::ZExtOp>" result 1

                //===-------------------------------------------===//
                Legalizing operation : 'llvm.zext'(0x1b3ca7b03c0) {
                  %75 = "llvm.zext"(%71) : (i1) -> i32

                } -> SUCCESS : operation marked legal by the target
                //===-------------------------------------------===//
              } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %9 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %10 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %11 = llvm.mlir.constant(0 : i64) : i64
  %12 = llvm.getelementptr %10[%11, %11] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %13 = ts.Constant {value = "number"} : !ts.string
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "b number: "} : !ts.string
  %22 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "done."} : !ts.string
  %26 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %27 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %28 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %29 = llvm.insertvalue %13, %28[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %30 = llvm.insertvalue %9, %29[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %30, %3 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %31 = ts.Variable(%30) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %32 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %33 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %34 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %35 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %36 = llvm.mlir.constant(1 : i64) : i64
  %37 = llvm.getelementptr %35[%36] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %38 = llvm.ptrtoint %37 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %39 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %40 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %41 = llvm.mlir.constant(1 : i64) : i64
  %42 = llvm.getelementptr %40[%41] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %43 = llvm.ptrtoint %42 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %44 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %45 = llvm.icmp "ult" %39, %44 : i64
  %46 = llvm.select %45, %39, %44 : i1, i64
  %47 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%33, %34, %46, %47) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%32, %31) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %48 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %49 = ts.Load(%32) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %50 = ts.CreateUnionInstance %9, %13 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %48, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %50, %26 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %51 = llvm.load %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %52 = ts.Load(%26) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %53 = llvm.extractvalue %51[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %54 = ts.GetValueFromUnionOp %51 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %55 = llvm.extractvalue %51[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %56 = ts.GetTypeInfoFromUnionOp %51 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %57 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = llvm.insertvalue %56, %57[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %59 = llvm.insertvalue %54, %58[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.CreateUnionInstance %54, %56 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
  %61 = ts.Cast %52 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  llvm.store %59, %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %61, %27 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %62 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %63 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %64 = llvm.extractvalue %62[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %65 = ts.GetTypeInfoFromUnionOp %63 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %66 = llvm.mlir.constant(0 : i64) : i64
  %67 = llvm.ptrtoint %64 : !llvm.ptr<i8> to i64
  %68 = llvm.ptrtoint %16 : !llvm.ptr<i8> to i64
  %69 = llvm.icmp "ne" %67, %66 : i64
  %70 = llvm.icmp "ne" %68, %66 : i64
  %71 = llvm.zext %69 : i1 to i32
  %72 = zexti %69 : i1 to i32
  %73 = ts.Cast %69 : i1 to i32
  %74 = llvm.zext %70 : i1 to i32
  %75 = zexti %70 : i1 to i32
  %76 = ts.Cast %70 : i1 to i32
  %77 = llvm.and %73, %76  : i32
  %78 = llvm.mlir.constant(0 : i32) : i32
  %79 = llvm.icmp "ne" %77, %78 : i32
  llvm.cond_br %79, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %80 = llvm.mlir.constant(0 : i32) : i32
  %81 = llvm.call @strcmp(%64, %16) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %82 = llvm.icmp "eq" %81, %80 : i32
  llvm.br ^bb3(%82 : i1)
^bb2:  // pred: ^bb0
  %83 = llvm.icmp "eq" %67, %68 : i64
  llvm.br ^bb3(%83 : i1)
^bb3(%84: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %85 = "ts.StringCompare"(%64, %16) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %86 = ts.LogicalBinary %65(34) %17 : !ts.string, !ts.string -> !ts.boolean
  %87 = ts.Cast %86 : !ts.boolean to i1
  cond_br %87, ^bb5, ^bb6
^bb5:  // pred: ^bb4
  %88 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %89 = ts.GetValueFromUnionOp %88 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %90 = ts.Cast %89 : !ts.number to !ts.string
  ts.Print(%21, %90) : !ts.string, !ts.string
  br ^bb6
^bb6:  // 2 preds: ^bb4, ^bb5
  ts.Print(%25) : !ts.string
  ts.ReturnInternal
}


            } -> SUCCESS
            //===-------------------------------------------===//
          } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %9 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %10 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %11 = llvm.mlir.constant(0 : i64) : i64
  %12 = llvm.getelementptr %10[%11, %11] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %13 = ts.Constant {value = "number"} : !ts.string
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "b number: "} : !ts.string
  %22 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "done."} : !ts.string
  %26 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %27 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %28 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %29 = llvm.insertvalue %13, %28[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %30 = llvm.insertvalue %9, %29[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %30, %3 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %31 = ts.Variable(%30) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %32 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %33 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %34 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %35 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %36 = llvm.mlir.constant(1 : i64) : i64
  %37 = llvm.getelementptr %35[%36] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %38 = llvm.ptrtoint %37 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %39 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %40 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %41 = llvm.mlir.constant(1 : i64) : i64
  %42 = llvm.getelementptr %40[%41] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %43 = llvm.ptrtoint %42 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %44 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %45 = llvm.icmp "ult" %39, %44 : i64
  %46 = llvm.select %45, %39, %44 : i1, i64
  %47 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%33, %34, %46, %47) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%32, %31) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %48 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %49 = ts.Load(%32) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %50 = ts.CreateUnionInstance %9, %13 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %48, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %50, %26 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %51 = llvm.load %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %52 = ts.Load(%26) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %53 = llvm.extractvalue %51[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %54 = ts.GetValueFromUnionOp %51 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %55 = llvm.extractvalue %51[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %56 = ts.GetTypeInfoFromUnionOp %51 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %57 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = llvm.insertvalue %56, %57[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %59 = llvm.insertvalue %54, %58[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.CreateUnionInstance %54, %56 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
  %61 = ts.Cast %52 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  llvm.store %59, %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %61, %27 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %62 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %63 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %64 = llvm.extractvalue %62[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %65 = ts.GetTypeInfoFromUnionOp %63 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %66 = llvm.mlir.constant(0 : i64) : i64
  %67 = llvm.ptrtoint %64 : !llvm.ptr<i8> to i64
  %68 = llvm.ptrtoint %16 : !llvm.ptr<i8> to i64
  %69 = llvm.icmp "ne" %67, %66 : i64
  %70 = llvm.icmp "ne" %68, %66 : i64
  %71 = llvm.zext %69 : i1 to i32
  %72 = zexti %69 : i1 to i32
  %73 = ts.Cast %69 : i1 to i32
  %74 = llvm.zext %70 : i1 to i32
  %75 = zexti %70 : i1 to i32
  %76 = ts.Cast %70 : i1 to i32
  %77 = llvm.and %73, %76  : i32
  %78 = llvm.mlir.constant(0 : i32) : i32
  %79 = llvm.icmp "ne" %77, %78 : i32
  llvm.cond_br %79, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %80 = llvm.mlir.constant(0 : i32) : i32
  %81 = llvm.call @strcmp(%64, %16) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %82 = llvm.icmp "eq" %81, %80 : i32
  llvm.br ^bb3(%82 : i1)
^bb2:  // pred: ^bb0
  %83 = llvm.icmp "eq" %67, %68 : i64
  llvm.br ^bb3(%83 : i1)
^bb3(%84: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %85 = "ts.StringCompare"(%64, %16) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %86 = ts.LogicalBinary %65(34) %17 : !ts.string, !ts.string -> !ts.boolean
  %87 = ts.Cast %86 : !ts.boolean to i1
  cond_br %87, ^bb5, ^bb6
^bb5:  // pred: ^bb4
  %88 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %89 = ts.GetValueFromUnionOp %88 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %90 = ts.Cast %89 : !ts.number to !ts.string
  ts.Print(%21, %90) : !ts.string, !ts.string
  br ^bb6
^bb6:  // 2 preds: ^bb4, ^bb5
  ts.Print(%25) : !ts.string
  ts.ReturnInternal
}


        } -> SUCCESS
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.and'(0x1b3ca8d9560) {
          %78 = "llvm.and"(%74, %77) : (i32, i32) -> i32

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.mlir.constant'(0x1b3ca85cd80) {
          %79 = "llvm.mlir.constant"() {value = 0 : i32} : () -> i32

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.icmp'(0x1b3ca8d9640) {
          %80 = "llvm.icmp"(%78, %79) {predicate = 1 : i64} : (i32, i32) -> i1

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.mlir.constant'(0x1b3ca85d780) {
          %81 = "llvm.mlir.constant"() {value = 0 : i32} : () -> i32

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.call'(0x1b3ca8da440) {
          %82 = "llvm.call"(%65, %17) {callee = @strcmp} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.icmp'(0x1b3ca8da8a0) {
          %83 = "llvm.icmp"(%82, %81) {predicate = 0 : i64} : (i32, i32) -> i1

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.icmp'(0x1b3ca8da6e0) {
          %84 = "llvm.icmp"(%68, %69) {predicate = 0 : i64} : (i64, i64) -> i1

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.br'(0x1b3ca89cf70) {
          "llvm.br"()[^bb4] : () -> ()

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.br'(0x1b3ca7fd6e0) {
          "llvm.br"(%83)[^bb3] : (i1) -> ()

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.br'(0x1b3ca7fdaf0) {
          "llvm.br"(%84)[^bb3] : (i1) -> ()

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.cond_br'(0x1b3ca8354d0) {
          "llvm.cond_br"(%80)[^bb1, ^bb2] {operand_segment_sizes = dense<[1, 0, 0]> : vector<3xi32>} : (i1) -> ()

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//
      } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %9 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %10 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %11 = llvm.mlir.constant(0 : i64) : i64
  %12 = llvm.getelementptr %10[%11, %11] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %13 = ts.Constant {value = "number"} : !ts.string
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "b number: "} : !ts.string
  %22 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "done."} : !ts.string
  %26 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %27 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %28 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %29 = llvm.insertvalue %13, %28[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %30 = llvm.insertvalue %9, %29[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %30, %3 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %31 = ts.Variable(%30) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %32 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %33 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %34 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %35 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %36 = llvm.mlir.constant(1 : i64) : i64
  %37 = llvm.getelementptr %35[%36] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %38 = llvm.ptrtoint %37 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %39 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %40 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %41 = llvm.mlir.constant(1 : i64) : i64
  %42 = llvm.getelementptr %40[%41] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %43 = llvm.ptrtoint %42 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %44 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %45 = llvm.icmp "ult" %39, %44 : i64
  %46 = llvm.select %45, %39, %44 : i1, i64
  %47 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%33, %34, %46, %47) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%32, %31) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %48 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %49 = ts.Load(%32) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %50 = ts.CreateUnionInstance %9, %13 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %48, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %50, %26 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %51 = llvm.load %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %52 = ts.Load(%26) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %53 = llvm.extractvalue %51[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %54 = ts.GetValueFromUnionOp %51 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %55 = llvm.extractvalue %51[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %56 = ts.GetTypeInfoFromUnionOp %51 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %57 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = llvm.insertvalue %56, %57[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %59 = llvm.insertvalue %54, %58[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.CreateUnionInstance %54, %56 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
  %61 = ts.Cast %52 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  llvm.store %59, %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %61, %27 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %62 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %63 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %64 = llvm.extractvalue %62[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %65 = ts.GetTypeInfoFromUnionOp %63 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %66 = llvm.mlir.constant(0 : i64) : i64
  %67 = llvm.ptrtoint %64 : !llvm.ptr<i8> to i64
  %68 = llvm.ptrtoint %16 : !llvm.ptr<i8> to i64
  %69 = llvm.icmp "ne" %67, %66 : i64
  %70 = llvm.icmp "ne" %68, %66 : i64
  %71 = llvm.zext %69 : i1 to i32
  %72 = zexti %69 : i1 to i32
  %73 = ts.Cast %69 : i1 to i32
  %74 = llvm.zext %70 : i1 to i32
  %75 = zexti %70 : i1 to i32
  %76 = ts.Cast %70 : i1 to i32
  %77 = llvm.and %73, %76  : i32
  %78 = llvm.mlir.constant(0 : i32) : i32
  %79 = llvm.icmp "ne" %77, %78 : i32
  llvm.cond_br %79, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %80 = llvm.mlir.constant(0 : i32) : i32
  %81 = llvm.call @strcmp(%64, %16) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %82 = llvm.icmp "eq" %81, %80 : i32
  llvm.br ^bb3(%82 : i1)
^bb2:  // pred: ^bb0
  %83 = llvm.icmp "eq" %67, %68 : i64
  llvm.br ^bb3(%83 : i1)
^bb3(%84: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %85 = "ts.StringCompare"(%64, %16) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %86 = ts.LogicalBinary %65(34) %17 : !ts.string, !ts.string -> !ts.boolean
  %87 = ts.Cast %86 : !ts.boolean to i1
  cond_br %87, ^bb5, ^bb6
^bb5:  // pred: ^bb4
  %88 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %89 = ts.GetValueFromUnionOp %88 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %90 = ts.Cast %89 : !ts.number to !ts.string
  ts.Print(%21, %90) : !ts.string, !ts.string
  br ^bb6
^bb6:  // 2 preds: ^bb4, ^bb5
  ts.Print(%25) : !ts.string
  ts.ReturnInternal
}


    } -> SUCCESS
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %9 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %10 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %11 = llvm.mlir.constant(0 : i64) : i64
  %12 = llvm.getelementptr %10[%11, %11] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %13 = ts.Constant {value = "number"} : !ts.string
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "b number: "} : !ts.string
  %22 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "done."} : !ts.string
  %26 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %27 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %28 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %29 = llvm.insertvalue %13, %28[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %30 = llvm.insertvalue %9, %29[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %30, %3 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %31 = ts.Variable(%30) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %32 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %33 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %34 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %35 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %36 = llvm.mlir.constant(1 : i64) : i64
  %37 = llvm.getelementptr %35[%36] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %38 = llvm.ptrtoint %37 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %39 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %40 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %41 = llvm.mlir.constant(1 : i64) : i64
  %42 = llvm.getelementptr %40[%41] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %43 = llvm.ptrtoint %42 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %44 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %45 = llvm.icmp "ult" %39, %44 : i64
  %46 = llvm.select %45, %39, %44 : i1, i64
  %47 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%33, %34, %46, %47) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%32, %31) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %48 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %49 = ts.Load(%32) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %50 = ts.CreateUnionInstance %9, %13 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %48, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %50, %26 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %51 = llvm.load %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %52 = ts.Load(%26) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %53 = llvm.extractvalue %51[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %54 = ts.GetValueFromUnionOp %51 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %55 = llvm.extractvalue %51[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %56 = ts.GetTypeInfoFromUnionOp %51 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %57 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = llvm.insertvalue %56, %57[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %59 = llvm.insertvalue %54, %58[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.CreateUnionInstance %54, %56 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
  %61 = ts.Cast %52 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  llvm.store %59, %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %61, %27 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %62 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %63 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %64 = llvm.extractvalue %62[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %65 = ts.GetTypeInfoFromUnionOp %63 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %66 = llvm.mlir.constant(0 : i64) : i64
  %67 = llvm.ptrtoint %64 : !llvm.ptr<i8> to i64
  %68 = llvm.ptrtoint %16 : !llvm.ptr<i8> to i64
  %69 = llvm.icmp "ne" %67, %66 : i64
  %70 = llvm.icmp "ne" %68, %66 : i64
  %71 = llvm.zext %69 : i1 to i32
  %72 = zexti %69 : i1 to i32
  %73 = ts.Cast %69 : i1 to i32
  %74 = llvm.zext %70 : i1 to i32
  %75 = zexti %70 : i1 to i32
  %76 = ts.Cast %70 : i1 to i32
  %77 = llvm.and %73, %76  : i32
  %78 = llvm.mlir.constant(0 : i32) : i32
  %79 = llvm.icmp "ne" %77, %78 : i32
  llvm.cond_br %79, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %80 = llvm.mlir.constant(0 : i32) : i32
  %81 = llvm.call @strcmp(%64, %16) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %82 = llvm.icmp "eq" %81, %80 : i32
  llvm.br ^bb3(%82 : i1)
^bb2:  // pred: ^bb0
  %83 = llvm.icmp "eq" %67, %68 : i64
  llvm.br ^bb3(%83 : i1)
^bb3(%84: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %85 = "ts.StringCompare"(%64, %16) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %86 = ts.LogicalBinary %65(34) %17 : !ts.string, !ts.string -> !ts.boolean
  %87 = ts.Cast %86 : !ts.boolean to i1
  cond_br %87, ^bb5, ^bb6
^bb5:  // pred: ^bb4
  %88 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %89 = ts.GetValueFromUnionOp %88 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %90 = ts.Cast %89 : !ts.number to !ts.string
  ts.Print(%21, %90) : !ts.string, !ts.string
  br ^bb6
^bb6:  // 2 preds: ^bb4, ^bb5
  ts.Print(%25) : !ts.string
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Cast'(0x1b3ca7b09c0) {
  %88 = "ts.Cast"(%87) : (!ts.boolean) -> i1

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.Cast -> ()' {
Trying to match "`anonymous-namespace'::CastOpLowering"
    ** Replace : 'ts.Cast'(0x1b3ca7b09c0)
"`anonymous-namespace'::CastOpLowering" result 1
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %9 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %10 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %11 = llvm.mlir.constant(0 : i64) : i64
  %12 = llvm.getelementptr %10[%11, %11] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %13 = ts.Constant {value = "number"} : !ts.string
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "b number: "} : !ts.string
  %22 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "done."} : !ts.string
  %26 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %27 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %28 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %29 = llvm.insertvalue %13, %28[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %30 = llvm.insertvalue %9, %29[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %30, %3 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %31 = ts.Variable(%30) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %32 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %33 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %34 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %35 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %36 = llvm.mlir.constant(1 : i64) : i64
  %37 = llvm.getelementptr %35[%36] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %38 = llvm.ptrtoint %37 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %39 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %40 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %41 = llvm.mlir.constant(1 : i64) : i64
  %42 = llvm.getelementptr %40[%41] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %43 = llvm.ptrtoint %42 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %44 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %45 = llvm.icmp "ult" %39, %44 : i64
  %46 = llvm.select %45, %39, %44 : i1, i64
  %47 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%33, %34, %46, %47) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%32, %31) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %48 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %49 = ts.Load(%32) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %50 = ts.CreateUnionInstance %9, %13 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %48, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %50, %26 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %51 = llvm.load %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %52 = ts.Load(%26) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %53 = llvm.extractvalue %51[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %54 = ts.GetValueFromUnionOp %51 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %55 = llvm.extractvalue %51[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %56 = ts.GetTypeInfoFromUnionOp %51 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %57 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = llvm.insertvalue %56, %57[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %59 = llvm.insertvalue %54, %58[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.CreateUnionInstance %54, %56 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
  %61 = ts.Cast %52 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  llvm.store %59, %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %61, %27 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %62 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %63 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %64 = llvm.extractvalue %62[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %65 = ts.GetTypeInfoFromUnionOp %63 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %66 = llvm.mlir.constant(0 : i64) : i64
  %67 = llvm.ptrtoint %64 : !llvm.ptr<i8> to i64
  %68 = llvm.ptrtoint %16 : !llvm.ptr<i8> to i64
  %69 = llvm.icmp "ne" %67, %66 : i64
  %70 = llvm.icmp "ne" %68, %66 : i64
  %71 = llvm.zext %69 : i1 to i32
  %72 = zexti %69 : i1 to i32
  %73 = ts.Cast %69 : i1 to i32
  %74 = llvm.zext %70 : i1 to i32
  %75 = zexti %70 : i1 to i32
  %76 = ts.Cast %70 : i1 to i32
  %77 = llvm.and %73, %76  : i32
  %78 = llvm.mlir.constant(0 : i32) : i32
  %79 = llvm.icmp "ne" %77, %78 : i32
  llvm.cond_br %79, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %80 = llvm.mlir.constant(0 : i32) : i32
  %81 = llvm.call @strcmp(%64, %16) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %82 = llvm.icmp "eq" %81, %80 : i32
  llvm.br ^bb3(%82 : i1)
^bb2:  // pred: ^bb0
  %83 = llvm.icmp "eq" %67, %68 : i64
  llvm.br ^bb3(%83 : i1)
^bb3(%84: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %85 = "ts.StringCompare"(%64, %16) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %86 = ts.LogicalBinary %65(34) %17 : !ts.string, !ts.string -> !ts.boolean
  %87 = ts.Cast %86 : !ts.boolean to i1
  cond_br %87, ^bb5, ^bb6
^bb5:  // pred: ^bb4
  %88 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %89 = ts.GetValueFromUnionOp %88 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %90 = ts.Cast %89 : !ts.number to !ts.string
  ts.Print(%21, %90) : !ts.string, !ts.string
  br ^bb6
^bb6:  // 2 preds: ^bb4, ^bb5
  ts.Print(%25) : !ts.string
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'std.cond_br'(0x1b3ca833d60) {
  "std.cond_br"(%88)[^bb5, ^bb6] {operand_segment_sizes = dense<[1, 0, 0]> : vector<3xi32>} : (i1) -> ()

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'std.cond_br -> ()' {
Trying to match "`anonymous-namespace'::CondBranchOpLowering"
    ** Insert  : 'llvm.cond_br'(0x1b3ca833400)
    ** Replace : 'std.cond_br'(0x1b3ca833d60)
"`anonymous-namespace'::CondBranchOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.cond_br'(0x1b3ca833400) {
      "llvm.cond_br"(%85)[^bb5, ^bb6] {operand_segment_sizes = dense<[1, 0, 0]> : vector<3xi32>} : (i1) -> ()

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %9 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %10 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %11 = llvm.mlir.constant(0 : i64) : i64
  %12 = llvm.getelementptr %10[%11, %11] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %13 = ts.Constant {value = "number"} : !ts.string
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "b number: "} : !ts.string
  %22 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "done."} : !ts.string
  %26 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %27 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %28 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %29 = llvm.insertvalue %13, %28[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %30 = llvm.insertvalue %9, %29[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %30, %3 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %31 = ts.Variable(%30) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %32 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %33 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %34 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %35 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %36 = llvm.mlir.constant(1 : i64) : i64
  %37 = llvm.getelementptr %35[%36] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %38 = llvm.ptrtoint %37 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %39 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %40 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %41 = llvm.mlir.constant(1 : i64) : i64
  %42 = llvm.getelementptr %40[%41] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %43 = llvm.ptrtoint %42 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %44 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %45 = llvm.icmp "ult" %39, %44 : i64
  %46 = llvm.select %45, %39, %44 : i1, i64
  %47 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%33, %34, %46, %47) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%32, %31) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %48 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %49 = ts.Load(%32) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %50 = ts.CreateUnionInstance %9, %13 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %48, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %50, %26 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %51 = llvm.load %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %52 = ts.Load(%26) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %53 = llvm.extractvalue %51[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %54 = ts.GetValueFromUnionOp %51 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %55 = llvm.extractvalue %51[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %56 = ts.GetTypeInfoFromUnionOp %51 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %57 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = llvm.insertvalue %56, %57[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %59 = llvm.insertvalue %54, %58[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.CreateUnionInstance %54, %56 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
  %61 = ts.Cast %52 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  llvm.store %59, %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %61, %27 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %62 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %63 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %64 = llvm.extractvalue %62[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %65 = ts.GetTypeInfoFromUnionOp %63 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %66 = llvm.mlir.constant(0 : i64) : i64
  %67 = llvm.ptrtoint %64 : !llvm.ptr<i8> to i64
  %68 = llvm.ptrtoint %16 : !llvm.ptr<i8> to i64
  %69 = llvm.icmp "ne" %67, %66 : i64
  %70 = llvm.icmp "ne" %68, %66 : i64
  %71 = llvm.zext %69 : i1 to i32
  %72 = zexti %69 : i1 to i32
  %73 = ts.Cast %69 : i1 to i32
  %74 = llvm.zext %70 : i1 to i32
  %75 = zexti %70 : i1 to i32
  %76 = ts.Cast %70 : i1 to i32
  %77 = llvm.and %73, %76  : i32
  %78 = llvm.mlir.constant(0 : i32) : i32
  %79 = llvm.icmp "ne" %77, %78 : i32
  llvm.cond_br %79, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %80 = llvm.mlir.constant(0 : i32) : i32
  %81 = llvm.call @strcmp(%64, %16) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %82 = llvm.icmp "eq" %81, %80 : i32
  llvm.br ^bb3(%82 : i1)
^bb2:  // pred: ^bb0
  %83 = llvm.icmp "eq" %67, %68 : i64
  llvm.br ^bb3(%83 : i1)
^bb3(%84: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %85 = "ts.StringCompare"(%64, %16) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %86 = ts.LogicalBinary %65(34) %17 : !ts.string, !ts.string -> !ts.boolean
  %87 = ts.Cast %86 : !ts.boolean to i1
  llvm.cond_br %84, ^bb5, ^bb6
  cond_br %87, ^bb5, ^bb6
^bb5:  // 2 preds: ^bb4, ^bb4
  %88 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %89 = ts.GetValueFromUnionOp %88 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %90 = ts.Cast %89 : !ts.number to !ts.string
  ts.Print(%21, %90) : !ts.string, !ts.string
  br ^bb6
^bb6:  // 3 preds: ^bb4, ^bb4, ^bb5
  ts.Print(%25) : !ts.string
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Print'(0x1b3ca894a10) {
  "ts.Print"(%26) : (!ts.string) -> ()

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.Print -> ()' {
Trying to match "`anonymous-namespace'::PrintOpLowering"
    ** Insert  : 'llvm.func'(0x1b3ca89bce0)
    ** Insert  : 'llvm.call'(0x1b3ca7af880)
    ** Erase   : 'ts.Print'(0x1b3ca894a10)
"`anonymous-namespace'::PrintOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x1b3ca89bce0) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.call'(0x1b3ca7af880) {
      %92 = "llvm.call"(%25) {callee = @puts} : (!llvm.ptr<i8>) -> i32

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %9 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %10 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %11 = llvm.mlir.constant(0 : i64) : i64
  %12 = llvm.getelementptr %10[%11, %11] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %13 = ts.Constant {value = "number"} : !ts.string
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "b number: "} : !ts.string
  %22 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "done."} : !ts.string
  %26 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %27 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %28 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %29 = llvm.insertvalue %13, %28[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %30 = llvm.insertvalue %9, %29[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %30, %3 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %31 = ts.Variable(%30) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %32 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %33 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %34 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %35 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %36 = llvm.mlir.constant(1 : i64) : i64
  %37 = llvm.getelementptr %35[%36] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %38 = llvm.ptrtoint %37 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %39 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %40 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %41 = llvm.mlir.constant(1 : i64) : i64
  %42 = llvm.getelementptr %40[%41] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %43 = llvm.ptrtoint %42 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %44 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %45 = llvm.icmp "ult" %39, %44 : i64
  %46 = llvm.select %45, %39, %44 : i1, i64
  %47 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%33, %34, %46, %47) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%32, %31) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %48 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %49 = ts.Load(%32) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %50 = ts.CreateUnionInstance %9, %13 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %48, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %50, %26 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %51 = llvm.load %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %52 = ts.Load(%26) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %53 = llvm.extractvalue %51[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %54 = ts.GetValueFromUnionOp %51 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %55 = llvm.extractvalue %51[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %56 = ts.GetTypeInfoFromUnionOp %51 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %57 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = llvm.insertvalue %56, %57[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %59 = llvm.insertvalue %54, %58[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.CreateUnionInstance %54, %56 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
  %61 = ts.Cast %52 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  llvm.store %59, %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %61, %27 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %62 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %63 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %64 = llvm.extractvalue %62[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %65 = ts.GetTypeInfoFromUnionOp %63 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %66 = llvm.mlir.constant(0 : i64) : i64
  %67 = llvm.ptrtoint %64 : !llvm.ptr<i8> to i64
  %68 = llvm.ptrtoint %16 : !llvm.ptr<i8> to i64
  %69 = llvm.icmp "ne" %67, %66 : i64
  %70 = llvm.icmp "ne" %68, %66 : i64
  %71 = llvm.zext %69 : i1 to i32
  %72 = zexti %69 : i1 to i32
  %73 = ts.Cast %69 : i1 to i32
  %74 = llvm.zext %70 : i1 to i32
  %75 = zexti %70 : i1 to i32
  %76 = ts.Cast %70 : i1 to i32
  %77 = llvm.and %73, %76  : i32
  %78 = llvm.mlir.constant(0 : i32) : i32
  %79 = llvm.icmp "ne" %77, %78 : i32
  llvm.cond_br %79, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %80 = llvm.mlir.constant(0 : i32) : i32
  %81 = llvm.call @strcmp(%64, %16) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %82 = llvm.icmp "eq" %81, %80 : i32
  llvm.br ^bb3(%82 : i1)
^bb2:  // pred: ^bb0
  %83 = llvm.icmp "eq" %67, %68 : i64
  llvm.br ^bb3(%83 : i1)
^bb3(%84: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %85 = "ts.StringCompare"(%64, %16) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %86 = ts.LogicalBinary %65(34) %17 : !ts.string, !ts.string -> !ts.boolean
  %87 = ts.Cast %86 : !ts.boolean to i1
  llvm.cond_br %84, ^bb5, ^bb6
  cond_br %87, ^bb5, ^bb6
^bb5:  // 2 preds: ^bb4, ^bb4
  %88 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %89 = ts.GetValueFromUnionOp %88 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %90 = ts.Cast %89 : !ts.number to !ts.string
  ts.Print(%21, %90) : !ts.string, !ts.string
  br ^bb6
^bb6:  // 3 preds: ^bb4, ^bb4, ^bb5
  %91 = llvm.call @puts(%24) : (!llvm.ptr<i8>) -> i32
  ts.Print(%25) : !ts.string
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.ReturnInternal'(0x1b3ca976b80) {
  "ts.ReturnInternal"() : () -> ()

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.ReturnInternal -> ()' {
Trying to match "`anonymous-namespace'::ReturnInternalOpLowering"
    ** Insert  : 'llvm.return'(0x1b3ca977240)
    ** Replace : 'ts.ReturnInternal'(0x1b3ca976b80)
"`anonymous-namespace'::ReturnInternalOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.return'(0x1b3ca977240) {
      "llvm.return"() : () -> ()

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %9 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %10 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %11 = llvm.mlir.constant(0 : i64) : i64
  %12 = llvm.getelementptr %10[%11, %11] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %13 = ts.Constant {value = "number"} : !ts.string
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "b number: "} : !ts.string
  %22 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "done."} : !ts.string
  %26 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %27 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %28 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %29 = llvm.insertvalue %13, %28[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %30 = llvm.insertvalue %9, %29[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %30, %3 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %31 = ts.Variable(%30) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %32 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %33 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %34 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %35 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %36 = llvm.mlir.constant(1 : i64) : i64
  %37 = llvm.getelementptr %35[%36] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %38 = llvm.ptrtoint %37 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %39 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %40 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %41 = llvm.mlir.constant(1 : i64) : i64
  %42 = llvm.getelementptr %40[%41] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %43 = llvm.ptrtoint %42 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %44 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %45 = llvm.icmp "ult" %39, %44 : i64
  %46 = llvm.select %45, %39, %44 : i1, i64
  %47 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%33, %34, %46, %47) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%32, %31) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %48 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %49 = ts.Load(%32) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %50 = ts.CreateUnionInstance %9, %13 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %48, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %50, %26 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %51 = llvm.load %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %52 = ts.Load(%26) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %53 = llvm.extractvalue %51[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %54 = ts.GetValueFromUnionOp %51 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %55 = llvm.extractvalue %51[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %56 = ts.GetTypeInfoFromUnionOp %51 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %57 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = llvm.insertvalue %56, %57[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %59 = llvm.insertvalue %54, %58[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.CreateUnionInstance %54, %56 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
  %61 = ts.Cast %52 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  llvm.store %59, %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %61, %27 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %62 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %63 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %64 = llvm.extractvalue %62[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %65 = ts.GetTypeInfoFromUnionOp %63 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %66 = llvm.mlir.constant(0 : i64) : i64
  %67 = llvm.ptrtoint %64 : !llvm.ptr<i8> to i64
  %68 = llvm.ptrtoint %16 : !llvm.ptr<i8> to i64
  %69 = llvm.icmp "ne" %67, %66 : i64
  %70 = llvm.icmp "ne" %68, %66 : i64
  %71 = llvm.zext %69 : i1 to i32
  %72 = zexti %69 : i1 to i32
  %73 = ts.Cast %69 : i1 to i32
  %74 = llvm.zext %70 : i1 to i32
  %75 = zexti %70 : i1 to i32
  %76 = ts.Cast %70 : i1 to i32
  %77 = llvm.and %73, %76  : i32
  %78 = llvm.mlir.constant(0 : i32) : i32
  %79 = llvm.icmp "ne" %77, %78 : i32
  llvm.cond_br %79, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %80 = llvm.mlir.constant(0 : i32) : i32
  %81 = llvm.call @strcmp(%64, %16) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %82 = llvm.icmp "eq" %81, %80 : i32
  llvm.br ^bb3(%82 : i1)
^bb2:  // pred: ^bb0
  %83 = llvm.icmp "eq" %67, %68 : i64
  llvm.br ^bb3(%83 : i1)
^bb3(%84: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %85 = "ts.StringCompare"(%64, %16) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %86 = ts.LogicalBinary %65(34) %17 : !ts.string, !ts.string -> !ts.boolean
  %87 = ts.Cast %86 : !ts.boolean to i1
  llvm.cond_br %84, ^bb5, ^bb6
  cond_br %87, ^bb5, ^bb6
^bb5:  // 2 preds: ^bb4, ^bb4
  %88 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %89 = ts.GetValueFromUnionOp %88 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %90 = ts.Cast %89 : !ts.number to !ts.string
  ts.Print(%21, %90) : !ts.string, !ts.string
  br ^bb6
^bb6:  // 3 preds: ^bb4, ^bb4, ^bb5
  %91 = llvm.call @puts(%24) : (!llvm.ptr<i8>) -> i32
  ts.Print(%25) : !ts.string
  llvm.return
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Load'(0x1b3ca7b1a40) {
  %89 = "ts.Load"(%28) : (!ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>) -> !ts.union<!ts.boolean,!ts.number,!ts.string>

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.Load -> ()' {
Trying to match "`anonymous-namespace'::LoadOpLowering"
    ** Insert  : 'llvm.load'(0x1b3ca7b0180)
    ** Replace : 'ts.Load'(0x1b3ca7b1a40)
"`anonymous-namespace'::LoadOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.load'(0x1b3ca7b0180) {
      %89 = "llvm.load"(%5) : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>) -> !llvm.struct<(ptr<i8>, ptr<i8>)>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %9 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %10 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %11 = llvm.mlir.constant(0 : i64) : i64
  %12 = llvm.getelementptr %10[%11, %11] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %13 = ts.Constant {value = "number"} : !ts.string
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "b number: "} : !ts.string
  %22 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "done."} : !ts.string
  %26 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %27 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %28 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %29 = llvm.insertvalue %13, %28[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %30 = llvm.insertvalue %9, %29[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %30, %3 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %31 = ts.Variable(%30) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %32 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %33 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %34 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %35 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %36 = llvm.mlir.constant(1 : i64) : i64
  %37 = llvm.getelementptr %35[%36] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %38 = llvm.ptrtoint %37 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %39 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %40 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %41 = llvm.mlir.constant(1 : i64) : i64
  %42 = llvm.getelementptr %40[%41] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %43 = llvm.ptrtoint %42 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %44 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %45 = llvm.icmp "ult" %39, %44 : i64
  %46 = llvm.select %45, %39, %44 : i1, i64
  %47 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%33, %34, %46, %47) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%32, %31) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %48 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %49 = ts.Load(%32) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %50 = ts.CreateUnionInstance %9, %13 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %48, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %50, %26 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %51 = llvm.load %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %52 = ts.Load(%26) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %53 = llvm.extractvalue %51[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %54 = ts.GetValueFromUnionOp %51 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %55 = llvm.extractvalue %51[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %56 = ts.GetTypeInfoFromUnionOp %51 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %57 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = llvm.insertvalue %56, %57[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %59 = llvm.insertvalue %54, %58[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.CreateUnionInstance %54, %56 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
  %61 = ts.Cast %52 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  llvm.store %59, %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %61, %27 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %62 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %63 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %64 = llvm.extractvalue %62[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %65 = ts.GetTypeInfoFromUnionOp %63 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %66 = llvm.mlir.constant(0 : i64) : i64
  %67 = llvm.ptrtoint %64 : !llvm.ptr<i8> to i64
  %68 = llvm.ptrtoint %16 : !llvm.ptr<i8> to i64
  %69 = llvm.icmp "ne" %67, %66 : i64
  %70 = llvm.icmp "ne" %68, %66 : i64
  %71 = llvm.zext %69 : i1 to i32
  %72 = zexti %69 : i1 to i32
  %73 = ts.Cast %69 : i1 to i32
  %74 = llvm.zext %70 : i1 to i32
  %75 = zexti %70 : i1 to i32
  %76 = ts.Cast %70 : i1 to i32
  %77 = llvm.and %73, %76  : i32
  %78 = llvm.mlir.constant(0 : i32) : i32
  %79 = llvm.icmp "ne" %77, %78 : i32
  llvm.cond_br %79, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %80 = llvm.mlir.constant(0 : i32) : i32
  %81 = llvm.call @strcmp(%64, %16) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %82 = llvm.icmp "eq" %81, %80 : i32
  llvm.br ^bb3(%82 : i1)
^bb2:  // pred: ^bb0
  %83 = llvm.icmp "eq" %67, %68 : i64
  llvm.br ^bb3(%83 : i1)
^bb3(%84: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %85 = "ts.StringCompare"(%64, %16) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %86 = ts.LogicalBinary %65(34) %17 : !ts.string, !ts.string -> !ts.boolean
  %87 = ts.Cast %86 : !ts.boolean to i1
  llvm.cond_br %84, ^bb5, ^bb6
  cond_br %87, ^bb5, ^bb6
^bb5:  // 2 preds: ^bb4, ^bb4
  %88 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %89 = ts.Load(%27) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %90 = ts.GetValueFromUnionOp %89 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %91 = ts.Cast %90 : !ts.number to !ts.string
  ts.Print(%21, %91) : !ts.string, !ts.string
  br ^bb6
^bb6:  // 3 preds: ^bb4, ^bb4, ^bb5
  %92 = llvm.call @puts(%24) : (!llvm.ptr<i8>) -> i32
  ts.Print(%25) : !ts.string
  llvm.return
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.GetValueFromUnionOp'(0x1b3ca7b1b00) {
  %91 = "ts.GetValueFromUnionOp"(%90) : (!ts.union<!ts.boolean,!ts.number,!ts.string>) -> !ts.number

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.GetValueFromUnionOp -> ()' {
Trying to match "`anonymous-namespace'::GetValueFromUnionOpLowering"
    ** Insert  : 'ts.Variable'(0x1b3ca7afac0)
    ** Insert  : 'ts.Variable'(0x1b3ca85d820)
    ** Insert  : 'ts.MemoryCopy'(0x1b3ca7fd540)
    ** Insert  : 'ts.Load'(0x1b3ca7aff40)
    ** Insert  : 'llvm.extractvalue'(0x1b3ca7b00c0)
    ** Replace : 'ts.GetValueFromUnionOp'(0x1b3ca7b1b00)
"`anonymous-namespace'::GetValueFromUnionOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'ts.Variable'(0x1b3ca7afac0) {
      %91 = "ts.Variable"(%89) {captured = false} : (!llvm.struct<(ptr<i8>, ptr<i8>)>) -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>

      * Fold {
      } -> FAILURE : unable to fold

      * Pattern : 'ts.Variable -> ()' {
Trying to match "`anonymous-namespace'::VariableOpLowering"

!! variable allocation: !llvm.struct<(ptr<i8>, ptr<i8>)> is captured: 0
        ** Insert  : 'llvm.mlir.constant'(0x1b3ca85c100)
        ** Insert  : 'llvm.alloca'(0x1b3ca7b0240)
        ** Insert  : 'llvm.store'(0x1b3ca7fcec0)
        ** Replace : 'ts.Variable'(0x1b3ca7afac0)
"`anonymous-namespace'::VariableOpLowering" result 1

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.mlir.constant'(0x1b3ca85c100) {
          %0 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.alloca'(0x1b3ca7b0240) {
          %1 = "llvm.alloca"(%0) : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.store'(0x1b3ca7fcec0) {
          "llvm.store"(%91, %1) : (!llvm.struct<(ptr<i8>, ptr<i8>)>, !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>) -> ()

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//
      } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %10 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %11 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %12 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %13 = llvm.mlir.constant(0 : i64) : i64
  %14 = llvm.getelementptr %12[%13, %13] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %15 = ts.Constant {value = "number"} : !ts.string
  %16 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %17 = llvm.mlir.constant(0 : i64) : i64
  %18 = llvm.getelementptr %16[%17, %17] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %19 = ts.Constant {value = "number"} : !ts.string
  %20 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %21 = llvm.mlir.constant(0 : i64) : i64
  %22 = llvm.getelementptr %20[%21, %21] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %23 = ts.Constant {value = "b number: "} : !ts.string
  %24 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %25 = llvm.mlir.constant(0 : i64) : i64
  %26 = llvm.getelementptr %24[%25, %25] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %27 = ts.Constant {value = "done."} : !ts.string
  %28 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %29 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %30 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %31 = llvm.insertvalue %15, %30[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %32 = llvm.insertvalue %11, %31[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %32, %5 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %33 = ts.Variable(%32) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %34 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %35 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %36 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %37 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %38 = llvm.mlir.constant(1 : i64) : i64
  %39 = llvm.getelementptr %37[%38] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %40 = llvm.ptrtoint %39 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %41 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %42 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %43 = llvm.mlir.constant(1 : i64) : i64
  %44 = llvm.getelementptr %42[%43] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %45 = llvm.ptrtoint %44 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %46 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %47 = llvm.icmp "ult" %41, %46 : i64
  %48 = llvm.select %47, %41, %46 : i1, i64
  %49 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%35, %36, %48, %49) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%34, %33) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %50 = llvm.load %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %51 = ts.Load(%34) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %52 = ts.CreateUnionInstance %11, %15 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %50, %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %52, %28 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %53 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %54 = ts.Load(%28) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %55 = llvm.extractvalue %53[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %56 = ts.GetValueFromUnionOp %53 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %57 = llvm.extractvalue %53[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = ts.GetTypeInfoFromUnionOp %53 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %59 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = llvm.insertvalue %58, %59[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %61 = llvm.insertvalue %56, %60[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %62 = ts.CreateUnionInstance %56, %58 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
  %63 = ts.Cast %54 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  llvm.store %61, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %63, %29 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %64 = llvm.load %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %65 = ts.Load(%29) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %66 = llvm.extractvalue %64[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %67 = ts.GetTypeInfoFromUnionOp %65 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %68 = llvm.mlir.constant(0 : i64) : i64
  %69 = llvm.ptrtoint %66 : !llvm.ptr<i8> to i64
  %70 = llvm.ptrtoint %18 : !llvm.ptr<i8> to i64
  %71 = llvm.icmp "ne" %69, %68 : i64
  %72 = llvm.icmp "ne" %70, %68 : i64
  %73 = llvm.zext %71 : i1 to i32
  %74 = zexti %71 : i1 to i32
  %75 = ts.Cast %71 : i1 to i32
  %76 = llvm.zext %72 : i1 to i32
  %77 = zexti %72 : i1 to i32
  %78 = ts.Cast %72 : i1 to i32
  %79 = llvm.and %75, %78  : i32
  %80 = llvm.mlir.constant(0 : i32) : i32
  %81 = llvm.icmp "ne" %79, %80 : i32
  llvm.cond_br %81, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %82 = llvm.mlir.constant(0 : i32) : i32
  %83 = llvm.call @strcmp(%66, %18) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %84 = llvm.icmp "eq" %83, %82 : i32
  llvm.br ^bb3(%84 : i1)
^bb2:  // pred: ^bb0
  %85 = llvm.icmp "eq" %69, %70 : i64
  llvm.br ^bb3(%85 : i1)
^bb3(%86: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %87 = "ts.StringCompare"(%66, %18) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %88 = ts.LogicalBinary %67(34) %19 : !ts.string, !ts.string -> !ts.boolean
  %89 = ts.Cast %88 : !ts.boolean to i1
  llvm.cond_br %86, ^bb5, ^bb6
  cond_br %89, ^bb5, ^bb6
^bb5:  // 2 preds: ^bb4, ^bb4
  %90 = llvm.load %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %91 = ts.Load(%29) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  llvm.store %90, %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %92 = ts.Variable(%90) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %93 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  "ts.MemoryCopy"(%93, %92) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %94 = ts.Load(%93) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
  %95 = llvm.extractvalue %94[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %96 = ts.GetValueFromUnionOp %91 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %97 = ts.Cast %96 : !ts.number to !ts.string
  ts.Print(%23, %97) : !ts.string, !ts.string
  br ^bb6
^bb6:  // 3 preds: ^bb4, ^bb4, ^bb5
  %98 = llvm.call @puts(%26) : (!llvm.ptr<i8>) -> i32
  ts.Print(%27) : !ts.string
  llvm.return
  ts.ReturnInternal
}


    } -> SUCCESS
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'ts.Variable'(0x1b3ca85d820) {
      %94 = "ts.Variable"() {captured = false} : () -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>

      * Fold {
      } -> FAILURE : unable to fold

      * Pattern : 'ts.Variable -> ()' {
Trying to match "`anonymous-namespace'::VariableOpLowering"

!! variable allocation: !llvm.struct<(ptr<i8>, f64)> is captured: 0
        ** Insert  : 'llvm.mlir.constant'(0x1b3ca85b5c0)
        ** Insert  : 'llvm.alloca'(0x1b3ca7b0480)
        ** Replace : 'ts.Variable'(0x1b3ca85d820)
"`anonymous-namespace'::VariableOpLowering" result 1

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.mlir.constant'(0x1b3ca85b5c0) {
          %0 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.alloca'(0x1b3ca7b0480) {
          %1 = "llvm.alloca"(%0) : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//
      } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "number"} : !ts.string
  %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "b number: "} : !ts.string
  %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %27 = llvm.mlir.constant(0 : i64) : i64
  %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %29 = ts.Constant {value = "done."} : !ts.string
  %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %40 = llvm.mlir.constant(1 : i64) : i64
  %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %45 = llvm.mlir.constant(1 : i64) : i64
  %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %49 = llvm.icmp "ult" %43, %48 : i64
  %50 = llvm.select %49, %43, %48 : i1, i64
  %51 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %64 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
  %65 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  llvm.store %63, %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %65, %31 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %66 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %67 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %68 = llvm.extractvalue %66[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %69 = ts.GetTypeInfoFromUnionOp %67 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %70 = llvm.mlir.constant(0 : i64) : i64
  %71 = llvm.ptrtoint %68 : !llvm.ptr<i8> to i64
  %72 = llvm.ptrtoint %20 : !llvm.ptr<i8> to i64
  %73 = llvm.icmp "ne" %71, %70 : i64
  %74 = llvm.icmp "ne" %72, %70 : i64
  %75 = llvm.zext %73 : i1 to i32
  %76 = zexti %73 : i1 to i32
  %77 = ts.Cast %73 : i1 to i32
  %78 = llvm.zext %74 : i1 to i32
  %79 = zexti %74 : i1 to i32
  %80 = ts.Cast %74 : i1 to i32
  %81 = llvm.and %77, %80  : i32
  %82 = llvm.mlir.constant(0 : i32) : i32
  %83 = llvm.icmp "ne" %81, %82 : i32
  llvm.cond_br %83, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %84 = llvm.mlir.constant(0 : i32) : i32
  %85 = llvm.call @strcmp(%68, %20) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %86 = llvm.icmp "eq" %85, %84 : i32
  llvm.br ^bb3(%86 : i1)
^bb2:  // pred: ^bb0
  %87 = llvm.icmp "eq" %71, %72 : i64
  llvm.br ^bb3(%87 : i1)
^bb3(%88: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %89 = "ts.StringCompare"(%68, %20) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %90 = ts.LogicalBinary %69(34) %21 : !ts.string, !ts.string -> !ts.boolean
  %91 = ts.Cast %90 : !ts.boolean to i1
  llvm.cond_br %88, ^bb5, ^bb6
  cond_br %91, ^bb5, ^bb6
^bb5:  // 2 preds: ^bb4, ^bb4
  %92 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %93 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  llvm.store %92, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %94 = ts.Variable(%92) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %95 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  "ts.MemoryCopy"(%95, %94) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %96 = ts.Load(%95) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
  %97 = llvm.extractvalue %96[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %98 = ts.GetValueFromUnionOp %93 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %99 = ts.Cast %98 : !ts.number to !ts.string
  ts.Print(%25, %99) : !ts.string, !ts.string
  br ^bb6
^bb6:  // 3 preds: ^bb4, ^bb4, ^bb5
  %100 = llvm.call @puts(%28) : (!llvm.ptr<i8>) -> i32
  ts.Print(%29) : !ts.string
  llvm.return
  ts.ReturnInternal
}


    } -> SUCCESS
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'ts.MemoryCopy'(0x1b3ca7fd540) {
      "ts.MemoryCopy"(%96, %95) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()

      * Fold {
      } -> FAILURE : unable to fold

      * Pattern : 'ts.MemoryCopy -> ()' {
Trying to match "`anonymous-namespace'::MemoryCopyOpLowering"
        ** Insert  : 'llvm.bitcast'(0x1b3ca7b1140)
        ** Insert  : 'llvm.bitcast'(0x1b3ca7b42c0)
        ** Insert  : 'ts.SizeOf'(0x1b3ca85b660)
        ** Insert  : 'ts.SizeOf'(0x1b3ca85c240)
        ** Insert  : 'llvm.icmp'(0x1b3ca8da520)
        ** Insert  : 'llvm.select'(0x1b3ca71e530)
        ** Insert  : 'llvm.mlir.constant'(0x1b3ca85c380)
        ** Insert  : 'llvm.call'(0x1b3ca7d4780)
        ** Erase   : 'ts.MemoryCopy'(0x1b3ca7fd540)
"`anonymous-namespace'::MemoryCopyOpLowering" result 1

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.bitcast'(0x1b3ca7b1140) {
          %97 = "llvm.bitcast"(%1) : (!llvm.ptr<struct<(ptr<i8>, f64)>>) -> !llvm.ptr<i8>

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.bitcast'(0x1b3ca7b42c0) {
          %98 = "llvm.bitcast"(%3) : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>) -> !llvm.ptr<i8>

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'ts.SizeOf'(0x1b3ca85b660) {
          %99 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64

          * Fold {
          } -> FAILURE : unable to fold

          * Pattern : 'ts.SizeOf -> ()' {
Trying to match "`anonymous-namespace'::SizeOfOpLowering"
            ** Insert  : 'llvm.mlir.null'(0x1b3ca85ce20)

!! size of - storage type: [!llvm.struct<(ptr<i8>, ptr<i8>)>] llvm storage type: [!llvm.struct<(ptr<i8>, ptr<i8>)>] llvm ptr: [!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>] value: [%98 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>]
            ** Insert  : 'llvm.mlir.constant'(0x1b3ca85c4c0)
            ** Insert  : 'llvm.getelementptr'(0x1b3ca8dafa0)
            ** Insert  : 'llvm.ptrtoint'(0x1b3ca7b4a40)
            ** Replace : 'ts.SizeOf'(0x1b3ca85b660)
"`anonymous-namespace'::SizeOfOpLowering" result 1

            //===-------------------------------------------===//
            Legalizing operation : 'llvm.mlir.null'(0x1b3ca85ce20) {
              %99 = "llvm.mlir.null"() : () -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>

            } -> SUCCESS : operation marked legal by the target
            //===-------------------------------------------===//

            //===-------------------------------------------===//
            Legalizing operation : 'llvm.mlir.constant'(0x1b3ca85c4c0) {
              %100 = "llvm.mlir.constant"() {value = 1 : i64} : () -> i64

            } -> SUCCESS : operation marked legal by the target
            //===-------------------------------------------===//

            //===-------------------------------------------===//
            Legalizing operation : 'llvm.getelementptr'(0x1b3ca8dafa0) {
              %101 = "llvm.getelementptr"(%99, %100) : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>

            } -> SUCCESS : operation marked legal by the target
            //===-------------------------------------------===//

            //===-------------------------------------------===//
            Legalizing operation : 'llvm.ptrtoint'(0x1b3ca7b4a40) {
              %102 = "llvm.ptrtoint"(%101) : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>) -> i64

            } -> SUCCESS : operation marked legal by the target
            //===-------------------------------------------===//
          } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "number"} : !ts.string
  %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "b number: "} : !ts.string
  %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %27 = llvm.mlir.constant(0 : i64) : i64
  %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %29 = ts.Constant {value = "done."} : !ts.string
  %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %40 = llvm.mlir.constant(1 : i64) : i64
  %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %45 = llvm.mlir.constant(1 : i64) : i64
  %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %49 = llvm.icmp "ult" %43, %48 : i64
  %50 = llvm.select %49, %43, %48 : i1, i64
  %51 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %64 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
  %65 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  llvm.store %63, %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %65, %31 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %66 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %67 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %68 = llvm.extractvalue %66[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %69 = ts.GetTypeInfoFromUnionOp %67 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %70 = llvm.mlir.constant(0 : i64) : i64
  %71 = llvm.ptrtoint %68 : !llvm.ptr<i8> to i64
  %72 = llvm.ptrtoint %20 : !llvm.ptr<i8> to i64
  %73 = llvm.icmp "ne" %71, %70 : i64
  %74 = llvm.icmp "ne" %72, %70 : i64
  %75 = llvm.zext %73 : i1 to i32
  %76 = zexti %73 : i1 to i32
  %77 = ts.Cast %73 : i1 to i32
  %78 = llvm.zext %74 : i1 to i32
  %79 = zexti %74 : i1 to i32
  %80 = ts.Cast %74 : i1 to i32
  %81 = llvm.and %77, %80  : i32
  %82 = llvm.mlir.constant(0 : i32) : i32
  %83 = llvm.icmp "ne" %81, %82 : i32
  llvm.cond_br %83, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %84 = llvm.mlir.constant(0 : i32) : i32
  %85 = llvm.call @strcmp(%68, %20) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %86 = llvm.icmp "eq" %85, %84 : i32
  llvm.br ^bb3(%86 : i1)
^bb2:  // pred: ^bb0
  %87 = llvm.icmp "eq" %71, %72 : i64
  llvm.br ^bb3(%87 : i1)
^bb3(%88: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %89 = "ts.StringCompare"(%68, %20) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %90 = ts.LogicalBinary %69(34) %21 : !ts.string, !ts.string -> !ts.boolean
  %91 = ts.Cast %90 : !ts.boolean to i1
  llvm.cond_br %88, ^bb5, ^bb6
  cond_br %91, ^bb5, ^bb6
^bb5:  // 2 preds: ^bb4, ^bb4
  %92 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %93 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  llvm.store %92, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %94 = ts.Variable(%92) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %95 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %96 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %97 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %98 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %99 = llvm.mlir.constant(1 : i64) : i64
  %100 = llvm.getelementptr %98[%99] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %101 = llvm.ptrtoint %100 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %102 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %103 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %104 = llvm.icmp "ult" %102, %103 : i64
  %105 = llvm.select %104, %102, %103 : i1, i64
  %106 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%96, %97, %105, %106) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%95, %94) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %107 = ts.Load(%95) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
  %108 = llvm.extractvalue %107[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %109 = ts.GetValueFromUnionOp %93 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %110 = ts.Cast %109 : !ts.number to !ts.string
  ts.Print(%25, %110) : !ts.string, !ts.string
  br ^bb6
^bb6:  // 3 preds: ^bb4, ^bb4, ^bb5
  %111 = llvm.call @puts(%28) : (!llvm.ptr<i8>) -> i32
  ts.Print(%29) : !ts.string
  llvm.return
  ts.ReturnInternal
}


        } -> SUCCESS
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'ts.SizeOf'(0x1b3ca85c240) {
          %104 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64

          * Fold {
          } -> FAILURE : unable to fold

          * Pattern : 'ts.SizeOf -> ()' {
Trying to match "`anonymous-namespace'::SizeOfOpLowering"
            ** Insert  : 'llvm.mlir.null'(0x1b3ca85db40)

!! size of - storage type: [!llvm.struct<(ptr<i8>, f64)>] llvm storage type: [!llvm.struct<(ptr<i8>, f64)>] llvm ptr: [!llvm.ptr<struct<(ptr<i8>, f64)>>] value: [%103 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>]
            ** Insert  : 'llvm.mlir.constant'(0x1b3ca85e220)
            ** Insert  : 'llvm.getelementptr'(0x1b3ca8dbb00)
            ** Insert  : 'llvm.ptrtoint'(0x1b3ca7b3cc0)
            ** Replace : 'ts.SizeOf'(0x1b3ca85c240)
"`anonymous-namespace'::SizeOfOpLowering" result 1

            //===-------------------------------------------===//
            Legalizing operation : 'llvm.mlir.null'(0x1b3ca85db40) {
              %104 = "llvm.mlir.null"() : () -> !llvm.ptr<struct<(ptr<i8>, f64)>>

            } -> SUCCESS : operation marked legal by the target
            //===-------------------------------------------===//

            //===-------------------------------------------===//
            Legalizing operation : 'llvm.mlir.constant'(0x1b3ca85e220) {
              %105 = "llvm.mlir.constant"() {value = 1 : i64} : () -> i64

            } -> SUCCESS : operation marked legal by the target
            //===-------------------------------------------===//

            //===-------------------------------------------===//
            Legalizing operation : 'llvm.getelementptr'(0x1b3ca8dbb00) {
              %106 = "llvm.getelementptr"(%104, %105) : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>

            } -> SUCCESS : operation marked legal by the target
            //===-------------------------------------------===//

            //===-------------------------------------------===//
            Legalizing operation : 'llvm.ptrtoint'(0x1b3ca7b3cc0) {
              %107 = "llvm.ptrtoint"(%106) : (!llvm.ptr<struct<(ptr<i8>, f64)>>) -> i64

            } -> SUCCESS : operation marked legal by the target
            //===-------------------------------------------===//
          } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "number"} : !ts.string
  %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "b number: "} : !ts.string
  %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %27 = llvm.mlir.constant(0 : i64) : i64
  %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %29 = ts.Constant {value = "done."} : !ts.string
  %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %40 = llvm.mlir.constant(1 : i64) : i64
  %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %45 = llvm.mlir.constant(1 : i64) : i64
  %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %49 = llvm.icmp "ult" %43, %48 : i64
  %50 = llvm.select %49, %43, %48 : i1, i64
  %51 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %64 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
  %65 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  llvm.store %63, %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %65, %31 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %66 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %67 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %68 = llvm.extractvalue %66[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %69 = ts.GetTypeInfoFromUnionOp %67 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %70 = llvm.mlir.constant(0 : i64) : i64
  %71 = llvm.ptrtoint %68 : !llvm.ptr<i8> to i64
  %72 = llvm.ptrtoint %20 : !llvm.ptr<i8> to i64
  %73 = llvm.icmp "ne" %71, %70 : i64
  %74 = llvm.icmp "ne" %72, %70 : i64
  %75 = llvm.zext %73 : i1 to i32
  %76 = zexti %73 : i1 to i32
  %77 = ts.Cast %73 : i1 to i32
  %78 = llvm.zext %74 : i1 to i32
  %79 = zexti %74 : i1 to i32
  %80 = ts.Cast %74 : i1 to i32
  %81 = llvm.and %77, %80  : i32
  %82 = llvm.mlir.constant(0 : i32) : i32
  %83 = llvm.icmp "ne" %81, %82 : i32
  llvm.cond_br %83, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %84 = llvm.mlir.constant(0 : i32) : i32
  %85 = llvm.call @strcmp(%68, %20) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %86 = llvm.icmp "eq" %85, %84 : i32
  llvm.br ^bb3(%86 : i1)
^bb2:  // pred: ^bb0
  %87 = llvm.icmp "eq" %71, %72 : i64
  llvm.br ^bb3(%87 : i1)
^bb3(%88: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %89 = "ts.StringCompare"(%68, %20) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %90 = ts.LogicalBinary %69(34) %21 : !ts.string, !ts.string -> !ts.boolean
  %91 = ts.Cast %90 : !ts.boolean to i1
  llvm.cond_br %88, ^bb5, ^bb6
  cond_br %91, ^bb5, ^bb6
^bb5:  // 2 preds: ^bb4, ^bb4
  %92 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %93 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  llvm.store %92, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %94 = ts.Variable(%92) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %95 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %96 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %97 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %98 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %99 = llvm.mlir.constant(1 : i64) : i64
  %100 = llvm.getelementptr %98[%99] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %101 = llvm.ptrtoint %100 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %102 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %103 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %104 = llvm.mlir.constant(1 : i64) : i64
  %105 = llvm.getelementptr %103[%104] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %106 = llvm.ptrtoint %105 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %107 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %108 = llvm.icmp "ult" %102, %107 : i64
  %109 = llvm.select %108, %102, %107 : i1, i64
  %110 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%96, %97, %109, %110) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%95, %94) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %111 = ts.Load(%95) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
  %112 = llvm.extractvalue %111[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %113 = ts.GetValueFromUnionOp %93 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %114 = ts.Cast %113 : !ts.number to !ts.string
  ts.Print(%25, %114) : !ts.string, !ts.string
  br ^bb6
^bb6:  // 3 preds: ^bb4, ^bb4, ^bb5
  %115 = llvm.call @puts(%28) : (!llvm.ptr<i8>) -> i32
  ts.Print(%29) : !ts.string
  llvm.return
  ts.ReturnInternal
}


        } -> SUCCESS
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.icmp'(0x1b3ca8da520) {
          %109 = "llvm.icmp"(%103, %108) {predicate = 6 : i64} : (i64, i64) -> i1

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.select'(0x1b3ca71e530) {
          %110 = "llvm.select"(%109, %103, %108) : (i1, i64, i64) -> i64

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.mlir.constant'(0x1b3ca85c380) {
          %111 = "llvm.mlir.constant"() {value = false} : () -> i1

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.call'(0x1b3ca7d4780) {
          "llvm.call"(%97, %98, %110, %111) {callee = @llvm.memcpy.p0i8.p0i8.i64} : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//
      } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "number"} : !ts.string
  %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "b number: "} : !ts.string
  %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %27 = llvm.mlir.constant(0 : i64) : i64
  %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %29 = ts.Constant {value = "done."} : !ts.string
  %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %40 = llvm.mlir.constant(1 : i64) : i64
  %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %45 = llvm.mlir.constant(1 : i64) : i64
  %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %49 = llvm.icmp "ult" %43, %48 : i64
  %50 = llvm.select %49, %43, %48 : i1, i64
  %51 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %64 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
  %65 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  llvm.store %63, %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %65, %31 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %66 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %67 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %68 = llvm.extractvalue %66[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %69 = ts.GetTypeInfoFromUnionOp %67 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %70 = llvm.mlir.constant(0 : i64) : i64
  %71 = llvm.ptrtoint %68 : !llvm.ptr<i8> to i64
  %72 = llvm.ptrtoint %20 : !llvm.ptr<i8> to i64
  %73 = llvm.icmp "ne" %71, %70 : i64
  %74 = llvm.icmp "ne" %72, %70 : i64
  %75 = llvm.zext %73 : i1 to i32
  %76 = zexti %73 : i1 to i32
  %77 = ts.Cast %73 : i1 to i32
  %78 = llvm.zext %74 : i1 to i32
  %79 = zexti %74 : i1 to i32
  %80 = ts.Cast %74 : i1 to i32
  %81 = llvm.and %77, %80  : i32
  %82 = llvm.mlir.constant(0 : i32) : i32
  %83 = llvm.icmp "ne" %81, %82 : i32
  llvm.cond_br %83, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %84 = llvm.mlir.constant(0 : i32) : i32
  %85 = llvm.call @strcmp(%68, %20) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %86 = llvm.icmp "eq" %85, %84 : i32
  llvm.br ^bb3(%86 : i1)
^bb2:  // pred: ^bb0
  %87 = llvm.icmp "eq" %71, %72 : i64
  llvm.br ^bb3(%87 : i1)
^bb3(%88: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %89 = "ts.StringCompare"(%68, %20) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %90 = ts.LogicalBinary %69(34) %21 : !ts.string, !ts.string -> !ts.boolean
  %91 = ts.Cast %90 : !ts.boolean to i1
  llvm.cond_br %88, ^bb5, ^bb6
  cond_br %91, ^bb5, ^bb6
^bb5:  // 2 preds: ^bb4, ^bb4
  %92 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %93 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  llvm.store %92, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %94 = ts.Variable(%92) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %95 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %96 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %97 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %98 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %99 = llvm.mlir.constant(1 : i64) : i64
  %100 = llvm.getelementptr %98[%99] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %101 = llvm.ptrtoint %100 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %102 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %103 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %104 = llvm.mlir.constant(1 : i64) : i64
  %105 = llvm.getelementptr %103[%104] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %106 = llvm.ptrtoint %105 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %107 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %108 = llvm.icmp "ult" %102, %107 : i64
  %109 = llvm.select %108, %102, %107 : i1, i64
  %110 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%96, %97, %109, %110) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%95, %94) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %111 = ts.Load(%95) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
  %112 = llvm.extractvalue %111[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %113 = ts.GetValueFromUnionOp %93 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %114 = ts.Cast %113 : !ts.number to !ts.string
  ts.Print(%25, %114) : !ts.string, !ts.string
  br ^bb6
^bb6:  // 3 preds: ^bb4, ^bb4, ^bb5
  %115 = llvm.call @puts(%28) : (!llvm.ptr<i8>) -> i32
  ts.Print(%29) : !ts.string
  llvm.return
  ts.ReturnInternal
}


    } -> SUCCESS
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'ts.Load'(0x1b3ca7aff40) {
      %112 = "ts.Load"(%96) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> !llvm.struct<(ptr<i8>, f64)>

      * Fold {
      } -> FAILURE : unable to fold

      * Pattern : 'ts.Load -> ()' {
Trying to match "`anonymous-namespace'::LoadOpLowering"
        ** Insert  : 'llvm.load'(0x1b3ca7b3540)
        ** Replace : 'ts.Load'(0x1b3ca7aff40)
"`anonymous-namespace'::LoadOpLowering" result 1

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.load'(0x1b3ca7b3540) {
          %112 = "llvm.load"(%1) : (!llvm.ptr<struct<(ptr<i8>, f64)>>) -> !llvm.struct<(ptr<i8>, f64)>

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//
      } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "number"} : !ts.string
  %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "b number: "} : !ts.string
  %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %27 = llvm.mlir.constant(0 : i64) : i64
  %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %29 = ts.Constant {value = "done."} : !ts.string
  %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %40 = llvm.mlir.constant(1 : i64) : i64
  %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %45 = llvm.mlir.constant(1 : i64) : i64
  %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %49 = llvm.icmp "ult" %43, %48 : i64
  %50 = llvm.select %49, %43, %48 : i1, i64
  %51 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %64 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
  %65 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  llvm.store %63, %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %65, %31 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %66 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %67 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %68 = llvm.extractvalue %66[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %69 = ts.GetTypeInfoFromUnionOp %67 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %70 = llvm.mlir.constant(0 : i64) : i64
  %71 = llvm.ptrtoint %68 : !llvm.ptr<i8> to i64
  %72 = llvm.ptrtoint %20 : !llvm.ptr<i8> to i64
  %73 = llvm.icmp "ne" %71, %70 : i64
  %74 = llvm.icmp "ne" %72, %70 : i64
  %75 = llvm.zext %73 : i1 to i32
  %76 = zexti %73 : i1 to i32
  %77 = ts.Cast %73 : i1 to i32
  %78 = llvm.zext %74 : i1 to i32
  %79 = zexti %74 : i1 to i32
  %80 = ts.Cast %74 : i1 to i32
  %81 = llvm.and %77, %80  : i32
  %82 = llvm.mlir.constant(0 : i32) : i32
  %83 = llvm.icmp "ne" %81, %82 : i32
  llvm.cond_br %83, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %84 = llvm.mlir.constant(0 : i32) : i32
  %85 = llvm.call @strcmp(%68, %20) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %86 = llvm.icmp "eq" %85, %84 : i32
  llvm.br ^bb3(%86 : i1)
^bb2:  // pred: ^bb0
  %87 = llvm.icmp "eq" %71, %72 : i64
  llvm.br ^bb3(%87 : i1)
^bb3(%88: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %89 = "ts.StringCompare"(%68, %20) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %90 = ts.LogicalBinary %69(34) %21 : !ts.string, !ts.string -> !ts.boolean
  %91 = ts.Cast %90 : !ts.boolean to i1
  llvm.cond_br %88, ^bb5, ^bb6
  cond_br %91, ^bb5, ^bb6
^bb5:  // 2 preds: ^bb4, ^bb4
  %92 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %93 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  llvm.store %92, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %94 = ts.Variable(%92) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %95 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %96 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %97 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %98 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %99 = llvm.mlir.constant(1 : i64) : i64
  %100 = llvm.getelementptr %98[%99] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %101 = llvm.ptrtoint %100 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %102 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %103 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %104 = llvm.mlir.constant(1 : i64) : i64
  %105 = llvm.getelementptr %103[%104] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %106 = llvm.ptrtoint %105 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %107 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %108 = llvm.icmp "ult" %102, %107 : i64
  %109 = llvm.select %108, %102, %107 : i1, i64
  %110 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%96, %97, %109, %110) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%95, %94) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %111 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %112 = ts.Load(%95) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
  %113 = llvm.extractvalue %112[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %114 = ts.GetValueFromUnionOp %93 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %115 = ts.Cast %114 : !ts.number to !ts.string
  ts.Print(%25, %115) : !ts.string, !ts.string
  br ^bb6
^bb6:  // 3 preds: ^bb4, ^bb4, ^bb5
  %116 = llvm.call @puts(%28) : (!llvm.ptr<i8>) -> i32
  ts.Print(%29) : !ts.string
  llvm.return
  ts.ReturnInternal
}


    } -> SUCCESS
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.extractvalue'(0x1b3ca7b00c0) {
      %114 = "llvm.extractvalue"(%113) {position = [1 : i32]} : (!llvm.struct<(ptr<i8>, f64)>) -> f64

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "number"} : !ts.string
  %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "b number: "} : !ts.string
  %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %27 = llvm.mlir.constant(0 : i64) : i64
  %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %29 = ts.Constant {value = "done."} : !ts.string
  %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %40 = llvm.mlir.constant(1 : i64) : i64
  %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %45 = llvm.mlir.constant(1 : i64) : i64
  %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %49 = llvm.icmp "ult" %43, %48 : i64
  %50 = llvm.select %49, %43, %48 : i1, i64
  %51 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %64 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
  %65 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  llvm.store %63, %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %65, %31 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %66 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %67 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %68 = llvm.extractvalue %66[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %69 = ts.GetTypeInfoFromUnionOp %67 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %70 = llvm.mlir.constant(0 : i64) : i64
  %71 = llvm.ptrtoint %68 : !llvm.ptr<i8> to i64
  %72 = llvm.ptrtoint %20 : !llvm.ptr<i8> to i64
  %73 = llvm.icmp "ne" %71, %70 : i64
  %74 = llvm.icmp "ne" %72, %70 : i64
  %75 = llvm.zext %73 : i1 to i32
  %76 = zexti %73 : i1 to i32
  %77 = ts.Cast %73 : i1 to i32
  %78 = llvm.zext %74 : i1 to i32
  %79 = zexti %74 : i1 to i32
  %80 = ts.Cast %74 : i1 to i32
  %81 = llvm.and %77, %80  : i32
  %82 = llvm.mlir.constant(0 : i32) : i32
  %83 = llvm.icmp "ne" %81, %82 : i32
  llvm.cond_br %83, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %84 = llvm.mlir.constant(0 : i32) : i32
  %85 = llvm.call @strcmp(%68, %20) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %86 = llvm.icmp "eq" %85, %84 : i32
  llvm.br ^bb3(%86 : i1)
^bb2:  // pred: ^bb0
  %87 = llvm.icmp "eq" %71, %72 : i64
  llvm.br ^bb3(%87 : i1)
^bb3(%88: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %89 = "ts.StringCompare"(%68, %20) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %90 = ts.LogicalBinary %69(34) %21 : !ts.string, !ts.string -> !ts.boolean
  %91 = ts.Cast %90 : !ts.boolean to i1
  llvm.cond_br %88, ^bb5, ^bb6
  cond_br %91, ^bb5, ^bb6
^bb5:  // 2 preds: ^bb4, ^bb4
  %92 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %93 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  llvm.store %92, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %94 = ts.Variable(%92) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %95 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %96 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %97 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %98 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %99 = llvm.mlir.constant(1 : i64) : i64
  %100 = llvm.getelementptr %98[%99] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %101 = llvm.ptrtoint %100 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %102 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %103 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %104 = llvm.mlir.constant(1 : i64) : i64
  %105 = llvm.getelementptr %103[%104] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %106 = llvm.ptrtoint %105 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %107 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %108 = llvm.icmp "ult" %102, %107 : i64
  %109 = llvm.select %108, %102, %107 : i1, i64
  %110 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%96, %97, %109, %110) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%95, %94) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %111 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %112 = ts.Load(%95) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
  %113 = llvm.extractvalue %112[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %114 = ts.GetValueFromUnionOp %93 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %115 = ts.Cast %114 : !ts.number to !ts.string
  ts.Print(%25, %115) : !ts.string, !ts.string
  br ^bb6
^bb6:  // 3 preds: ^bb4, ^bb4, ^bb5
  %116 = llvm.call @puts(%28) : (!llvm.ptr<i8>) -> i32
  ts.Print(%29) : !ts.string
  llvm.return
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Cast'(0x1b3ca7b1bc0) {
  %116 = "ts.Cast"(%115) : (!ts.number) -> !ts.string

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.Cast -> ()' {
Trying to match "`anonymous-namespace'::CastOpLowering"
    ** Insert  : 'llvm.func'(0x1b3ca89ae70)
    ** Insert  : 'llvm.mlir.constant'(0x1b3ca85fda0)
    ** Insert  : 'std.zexti'(0x1b3ca7b2880)
    ** Insert  : 'llvm.call'(0x1b3ca7b5040)
    ** Insert  : 'llvm.bitcast'(0x1b3ca7b4680)
    ** Insert  : 'llvm.mlir.global'(0x1b3ca89cb50)
    ** Insert  : 'llvm.mlir.addressof'(0x1b3ca85dc80)
    ** Insert  : 'llvm.mlir.constant'(0x1b3ca85ff80)
    ** Insert  : 'llvm.getelementptr'(0x1b3ca71e630)
    ** Insert  : 'llvm.call'(0x1b3ca791110)
    ** Replace : 'ts.Cast'(0x1b3ca7b1bc0)
"`anonymous-namespace'::CastOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x1b3ca89ae70) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.mlir.constant'(0x1b3ca85fda0) {
      %116 = "llvm.mlir.constant"() {value = 50 : i32} : () -> i32

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'std.zexti'(0x1b3ca7b2880) {
      %117 = "std.zexti"(%116) : (i32) -> i64

      * Fold {
      } -> FAILURE : unable to fold

      * Pattern : 'std.zexti -> ()' {
Trying to match "mlir::VectorConvertToLLVMPattern<class mlir::ZeroExtendIOp,class mlir::LLVM::ZExtOp>"
        ** Insert  : 'llvm.zext'(0x1b3ca7b2580)
        ** Replace : 'std.zexti'(0x1b3ca7b2880)
"mlir::VectorConvertToLLVMPattern<class mlir::ZeroExtendIOp,class mlir::LLVM::ZExtOp>" result 1

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.zext'(0x1b3ca7b2580) {
          %117 = "llvm.zext"(%116) : (i32) -> i64

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//
      } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "number"} : !ts.string
  %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "b number: "} : !ts.string
  %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %27 = llvm.mlir.constant(0 : i64) : i64
  %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %29 = ts.Constant {value = "done."} : !ts.string
  %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %40 = llvm.mlir.constant(1 : i64) : i64
  %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %45 = llvm.mlir.constant(1 : i64) : i64
  %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %49 = llvm.icmp "ult" %43, %48 : i64
  %50 = llvm.select %49, %43, %48 : i1, i64
  %51 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %64 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
  %65 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  llvm.store %63, %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %65, %31 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %66 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %67 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %68 = llvm.extractvalue %66[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %69 = ts.GetTypeInfoFromUnionOp %67 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %70 = llvm.mlir.constant(0 : i64) : i64
  %71 = llvm.ptrtoint %68 : !llvm.ptr<i8> to i64
  %72 = llvm.ptrtoint %20 : !llvm.ptr<i8> to i64
  %73 = llvm.icmp "ne" %71, %70 : i64
  %74 = llvm.icmp "ne" %72, %70 : i64
  %75 = llvm.zext %73 : i1 to i32
  %76 = zexti %73 : i1 to i32
  %77 = ts.Cast %73 : i1 to i32
  %78 = llvm.zext %74 : i1 to i32
  %79 = zexti %74 : i1 to i32
  %80 = ts.Cast %74 : i1 to i32
  %81 = llvm.and %77, %80  : i32
  %82 = llvm.mlir.constant(0 : i32) : i32
  %83 = llvm.icmp "ne" %81, %82 : i32
  llvm.cond_br %83, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %84 = llvm.mlir.constant(0 : i32) : i32
  %85 = llvm.call @strcmp(%68, %20) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %86 = llvm.icmp "eq" %85, %84 : i32
  llvm.br ^bb3(%86 : i1)
^bb2:  // pred: ^bb0
  %87 = llvm.icmp "eq" %71, %72 : i64
  llvm.br ^bb3(%87 : i1)
^bb3(%88: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %89 = "ts.StringCompare"(%68, %20) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %90 = ts.LogicalBinary %69(34) %21 : !ts.string, !ts.string -> !ts.boolean
  %91 = ts.Cast %90 : !ts.boolean to i1
  llvm.cond_br %88, ^bb5, ^bb6
  cond_br %91, ^bb5, ^bb6
^bb5:  // 2 preds: ^bb4, ^bb4
  %92 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %93 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  llvm.store %92, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %94 = ts.Variable(%92) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %95 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %96 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %97 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %98 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %99 = llvm.mlir.constant(1 : i64) : i64
  %100 = llvm.getelementptr %98[%99] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %101 = llvm.ptrtoint %100 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %102 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %103 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %104 = llvm.mlir.constant(1 : i64) : i64
  %105 = llvm.getelementptr %103[%104] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %106 = llvm.ptrtoint %105 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %107 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %108 = llvm.icmp "ult" %102, %107 : i64
  %109 = llvm.select %108, %102, %107 : i1, i64
  %110 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%96, %97, %109, %110) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%95, %94) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %111 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %112 = ts.Load(%95) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
  %113 = llvm.extractvalue %112[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %114 = ts.GetValueFromUnionOp %93 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %115 = llvm.mlir.constant(50 : i32) : i32
  %116 = llvm.zext %115 : i32 to i64
  %117 = zexti %115 : i32 to i64
  %118 = llvm.call @malloc(%117) : (i64) -> !llvm.ptr<i8>
  %119 = llvm.bitcast %118 : !llvm.ptr<i8> to !llvm.ptr<i8>
  %120 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
  %121 = llvm.mlir.constant(0 : i64) : i64
  %122 = llvm.getelementptr %120[%121, %121] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %123 = llvm.call @sprintf_s(%119, %115, %122, %113) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
  %124 = ts.Cast %114 : !ts.number to !ts.string
  ts.Print(%25, %124) : !ts.string, !ts.string
  br ^bb6
^bb6:  // 3 preds: ^bb4, ^bb4, ^bb5
  %125 = llvm.call @puts(%28) : (!llvm.ptr<i8>) -> i32
  ts.Print(%29) : !ts.string
  llvm.return
  ts.ReturnInternal
}


    } -> SUCCESS
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.call'(0x1b3ca7b5040) {
      %119 = "llvm.call"(%118) {callee = @malloc} : (i64) -> !llvm.ptr<i8>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.bitcast'(0x1b3ca7b4680) {
      %120 = "llvm.bitcast"(%119) : (!llvm.ptr<i8>) -> !llvm.ptr<i8>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.mlir.global'(0x1b3ca89cb50) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.mlir.addressof'(0x1b3ca85dc80) {
      %121 = "llvm.mlir.addressof"() {global_name = @frmt_555404038213028357} : () -> !llvm.ptr<array<3 x i8>>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.mlir.constant'(0x1b3ca85ff80) {
      %122 = "llvm.mlir.constant"() {value = 0 : i64} : () -> i64

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.getelementptr'(0x1b3ca71e630) {
      %123 = "llvm.getelementptr"(%121, %122, %122) : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.call'(0x1b3ca791110) {
      %124 = "llvm.call"(%120, %116, %123, %114) {callee = @sprintf_s} : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "number"} : !ts.string
  %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "b number: "} : !ts.string
  %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %27 = llvm.mlir.constant(0 : i64) : i64
  %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %29 = ts.Constant {value = "done."} : !ts.string
  %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %40 = llvm.mlir.constant(1 : i64) : i64
  %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %45 = llvm.mlir.constant(1 : i64) : i64
  %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %49 = llvm.icmp "ult" %43, %48 : i64
  %50 = llvm.select %49, %43, %48 : i1, i64
  %51 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %64 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
  %65 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  llvm.store %63, %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %65, %31 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %66 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %67 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %68 = llvm.extractvalue %66[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %69 = ts.GetTypeInfoFromUnionOp %67 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %70 = llvm.mlir.constant(0 : i64) : i64
  %71 = llvm.ptrtoint %68 : !llvm.ptr<i8> to i64
  %72 = llvm.ptrtoint %20 : !llvm.ptr<i8> to i64
  %73 = llvm.icmp "ne" %71, %70 : i64
  %74 = llvm.icmp "ne" %72, %70 : i64
  %75 = llvm.zext %73 : i1 to i32
  %76 = zexti %73 : i1 to i32
  %77 = ts.Cast %73 : i1 to i32
  %78 = llvm.zext %74 : i1 to i32
  %79 = zexti %74 : i1 to i32
  %80 = ts.Cast %74 : i1 to i32
  %81 = llvm.and %77, %80  : i32
  %82 = llvm.mlir.constant(0 : i32) : i32
  %83 = llvm.icmp "ne" %81, %82 : i32
  llvm.cond_br %83, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %84 = llvm.mlir.constant(0 : i32) : i32
  %85 = llvm.call @strcmp(%68, %20) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %86 = llvm.icmp "eq" %85, %84 : i32
  llvm.br ^bb3(%86 : i1)
^bb2:  // pred: ^bb0
  %87 = llvm.icmp "eq" %71, %72 : i64
  llvm.br ^bb3(%87 : i1)
^bb3(%88: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %89 = "ts.StringCompare"(%68, %20) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %90 = ts.LogicalBinary %69(34) %21 : !ts.string, !ts.string -> !ts.boolean
  %91 = ts.Cast %90 : !ts.boolean to i1
  llvm.cond_br %88, ^bb5, ^bb6
  cond_br %91, ^bb5, ^bb6
^bb5:  // 2 preds: ^bb4, ^bb4
  %92 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %93 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  llvm.store %92, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %94 = ts.Variable(%92) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %95 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %96 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %97 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %98 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %99 = llvm.mlir.constant(1 : i64) : i64
  %100 = llvm.getelementptr %98[%99] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %101 = llvm.ptrtoint %100 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %102 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %103 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %104 = llvm.mlir.constant(1 : i64) : i64
  %105 = llvm.getelementptr %103[%104] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %106 = llvm.ptrtoint %105 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %107 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %108 = llvm.icmp "ult" %102, %107 : i64
  %109 = llvm.select %108, %102, %107 : i1, i64
  %110 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%96, %97, %109, %110) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%95, %94) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %111 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %112 = ts.Load(%95) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
  %113 = llvm.extractvalue %112[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %114 = ts.GetValueFromUnionOp %93 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %115 = llvm.mlir.constant(50 : i32) : i32
  %116 = llvm.zext %115 : i32 to i64
  %117 = zexti %115 : i32 to i64
  %118 = llvm.call @malloc(%117) : (i64) -> !llvm.ptr<i8>
  %119 = llvm.bitcast %118 : !llvm.ptr<i8> to !llvm.ptr<i8>
  %120 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
  %121 = llvm.mlir.constant(0 : i64) : i64
  %122 = llvm.getelementptr %120[%121, %121] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %123 = llvm.call @sprintf_s(%119, %115, %122, %113) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
  %124 = ts.Cast %114 : !ts.number to !ts.string
  ts.Print(%25, %124) : !ts.string, !ts.string
  br ^bb6
^bb6:  // 3 preds: ^bb4, ^bb4, ^bb5
  %125 = llvm.call @puts(%28) : (!llvm.ptr<i8>) -> i32
  ts.Print(%29) : !ts.string
  llvm.return
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Print'(0x1b3ca7f7cb0) {
  "ts.Print"(%26, %125) : (!ts.string, !ts.string) -> ()

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.Print -> ()' {
Trying to match "`anonymous-namespace'::PrintOpLowering"
    ** Insert  : 'ts.Constant'(0x1b3ca85ea40)
    ** Insert  : 'llvm.intr.stacksave'(0x1b3ca85eae0)
    ** Insert  : 'ts.StringConcat'(0x1b3ca71f030)
    ** Insert  : 'llvm.call'(0x1b3ca7b2940)
    ** Insert  : 'llvm.intr.stackrestore'(0x1b3ca89c7e0)
    ** Erase   : 'ts.Print'(0x1b3ca7f7cb0)
"`anonymous-namespace'::PrintOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'ts.Constant'(0x1b3ca85ea40) {
      %126 = "ts.Constant"() {value = " "} : () -> !ts.string

      * Fold {
      } -> FAILURE : unable to fold

      * Pattern : 'ts.Constant -> ()' {
Trying to match "`anonymous-namespace'::ConstantOpLowering"
        ** Insert  : 'llvm.mlir.global'(0x1b3ca89b340)
        ** Insert  : 'llvm.mlir.addressof'(0x1b3ca85e860)
        ** Insert  : 'llvm.mlir.constant'(0x1b3ca85e360)
        ** Insert  : 'llvm.getelementptr'(0x1b3ca71e930)
        ** Replace : 'ts.Constant'(0x1b3ca85ea40)
"`anonymous-namespace'::ConstantOpLowering" result 1

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.mlir.global'(0x1b3ca89b340) {
        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.mlir.addressof'(0x1b3ca85e860) {
          %126 = "llvm.mlir.addressof"() {global_name = @s_12638117931323064703} : () -> !llvm.ptr<array<2 x i8>>

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.mlir.constant'(0x1b3ca85e360) {
          %127 = "llvm.mlir.constant"() {value = 0 : i64} : () -> i64

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.getelementptr'(0x1b3ca71e930) {
          %128 = "llvm.getelementptr"(%126, %127, %127) : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//
      } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "number"} : !ts.string
  %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "b number: "} : !ts.string
  %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %27 = llvm.mlir.constant(0 : i64) : i64
  %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %29 = ts.Constant {value = "done."} : !ts.string
  %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %40 = llvm.mlir.constant(1 : i64) : i64
  %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %45 = llvm.mlir.constant(1 : i64) : i64
  %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %49 = llvm.icmp "ult" %43, %48 : i64
  %50 = llvm.select %49, %43, %48 : i1, i64
  %51 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %64 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
  %65 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  llvm.store %63, %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %65, %31 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %66 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %67 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %68 = llvm.extractvalue %66[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %69 = ts.GetTypeInfoFromUnionOp %67 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %70 = llvm.mlir.constant(0 : i64) : i64
  %71 = llvm.ptrtoint %68 : !llvm.ptr<i8> to i64
  %72 = llvm.ptrtoint %20 : !llvm.ptr<i8> to i64
  %73 = llvm.icmp "ne" %71, %70 : i64
  %74 = llvm.icmp "ne" %72, %70 : i64
  %75 = llvm.zext %73 : i1 to i32
  %76 = zexti %73 : i1 to i32
  %77 = ts.Cast %73 : i1 to i32
  %78 = llvm.zext %74 : i1 to i32
  %79 = zexti %74 : i1 to i32
  %80 = ts.Cast %74 : i1 to i32
  %81 = llvm.and %77, %80  : i32
  %82 = llvm.mlir.constant(0 : i32) : i32
  %83 = llvm.icmp "ne" %81, %82 : i32
  llvm.cond_br %83, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %84 = llvm.mlir.constant(0 : i32) : i32
  %85 = llvm.call @strcmp(%68, %20) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %86 = llvm.icmp "eq" %85, %84 : i32
  llvm.br ^bb3(%86 : i1)
^bb2:  // pred: ^bb0
  %87 = llvm.icmp "eq" %71, %72 : i64
  llvm.br ^bb3(%87 : i1)
^bb3(%88: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %89 = "ts.StringCompare"(%68, %20) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %90 = ts.LogicalBinary %69(34) %21 : !ts.string, !ts.string -> !ts.boolean
  %91 = ts.Cast %90 : !ts.boolean to i1
  llvm.cond_br %88, ^bb5, ^bb6
  cond_br %91, ^bb5, ^bb6
^bb5:  // 2 preds: ^bb4, ^bb4
  %92 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %93 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  llvm.store %92, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %94 = ts.Variable(%92) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %95 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %96 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %97 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %98 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %99 = llvm.mlir.constant(1 : i64) : i64
  %100 = llvm.getelementptr %98[%99] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %101 = llvm.ptrtoint %100 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %102 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %103 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %104 = llvm.mlir.constant(1 : i64) : i64
  %105 = llvm.getelementptr %103[%104] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %106 = llvm.ptrtoint %105 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %107 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %108 = llvm.icmp "ult" %102, %107 : i64
  %109 = llvm.select %108, %102, %107 : i1, i64
  %110 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%96, %97, %109, %110) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%95, %94) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %111 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %112 = ts.Load(%95) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
  %113 = llvm.extractvalue %112[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %114 = ts.GetValueFromUnionOp %93 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %115 = llvm.mlir.constant(50 : i32) : i32
  %116 = llvm.zext %115 : i32 to i64
  %117 = zexti %115 : i32 to i64
  %118 = llvm.call @malloc(%117) : (i64) -> !llvm.ptr<i8>
  %119 = llvm.bitcast %118 : !llvm.ptr<i8> to !llvm.ptr<i8>
  %120 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
  %121 = llvm.mlir.constant(0 : i64) : i64
  %122 = llvm.getelementptr %120[%121, %121] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %123 = llvm.call @sprintf_s(%119, %115, %122, %113) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
  %124 = ts.Cast %114 : !ts.number to !ts.string
  %125 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
  %126 = llvm.mlir.constant(0 : i64) : i64
  %127 = llvm.getelementptr %125[%126, %126] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %128 = ts.Constant {value = " "} : !ts.string
  %129 = llvm.intr.stacksave : !llvm.ptr<i8>
  %130 = "ts.StringConcat"(%24, %128, %119) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
  %131 = llvm.call @puts(%130) : (!ts.string) -> i32
  llvm.intr.stackrestore %129
  ts.Print(%25, %124) : !ts.string, !ts.string
  br ^bb6
^bb6:  // 3 preds: ^bb4, ^bb4, ^bb5
  %132 = llvm.call @puts(%28) : (!llvm.ptr<i8>) -> i32
  ts.Print(%29) : !ts.string
  llvm.return
  ts.ReturnInternal
}


    } -> SUCCESS
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.intr.stacksave'(0x1b3ca85eae0) {
      %130 = "llvm.intr.stacksave"() : () -> !llvm.ptr<i8>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'ts.StringConcat'(0x1b3ca71f030) {
      %131 = "ts.StringConcat"(%25, %129, %120) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string

      * Fold {
      } -> FAILURE : unable to fold

      * Pattern : 'ts.StringConcat -> ()' {
Trying to match "`anonymous-namespace'::StringConcatOpLowering"
        ** Insert  : 'llvm.func'(0x1b3ca89af20)
        ** Insert  : 'llvm.func'(0x1b3ca89c890)
        ** Insert  : 'llvm.func'(0x1b3ca89bad0)
        ** Insert  : 'llvm.mlir.constant'(0x1b3ca85e400)
        ** Insert  : 'llvm.call'(0x1b3ca7b3600)
        ** Insert  : 'llvm.add'(0x1b3ca8dab40)
        ** Insert  : 'llvm.call'(0x1b3ca7b2100)
        ** Insert  : 'llvm.add'(0x1b3ca8db4e0)
        ** Insert  : 'llvm.call'(0x1b3ca7b36c0)
        ** Insert  : 'llvm.add'(0x1b3ca8dad00)
        ** Insert  : 'llvm.alloca'(0x1b3ca7b4140)
        ** Insert  : 'llvm.call'(0x1b3ca8dac20)
        ** Insert  : 'llvm.call'(0x1b3ca8dade0)
        ** Insert  : 'llvm.call'(0x1b3ca8daec0)
        ** Replace : 'ts.StringConcat'(0x1b3ca71f030)
"`anonymous-namespace'::StringConcatOpLowering" result 1

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.func'(0x1b3ca89af20) {
        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.func'(0x1b3ca89c890) {
        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.func'(0x1b3ca89bad0) {
        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.mlir.constant'(0x1b3ca85e400) {
          %131 = "llvm.mlir.constant"() {value = 1 : i64} : () -> i64

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.call'(0x1b3ca7b3600) {
          %132 = "llvm.call"(%25) {callee = @strlen} : (!llvm.ptr<i8>) -> i64

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.add'(0x1b3ca8dab40) {
          %133 = "llvm.add"(%131, %132) : (i64, i64) -> i64

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.call'(0x1b3ca7b2100) {
          %134 = "llvm.call"(%128) {callee = @strlen} : (!llvm.ptr<i8>) -> i64

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.add'(0x1b3ca8db4e0) {
          %135 = "llvm.add"(%133, %134) : (i64, i64) -> i64

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.call'(0x1b3ca7b36c0) {
          %136 = "llvm.call"(%120) {callee = @strlen} : (!llvm.ptr<i8>) -> i64

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.add'(0x1b3ca8dad00) {
          %137 = "llvm.add"(%135, %136) : (i64, i64) -> i64

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.alloca'(0x1b3ca7b4140) {
          %138 = "llvm.alloca"(%137) {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.call'(0x1b3ca8dac20) {
          %139 = "llvm.call"(%138, %25) {callee = @strcpy} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.call'(0x1b3ca8dade0) {
          %140 = "llvm.call"(%139, %128) {callee = @strcat} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.call'(0x1b3ca8daec0) {
          %141 = "llvm.call"(%140, %120) {callee = @strcat} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//
      } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "number"} : !ts.string
  %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "b number: "} : !ts.string
  %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %27 = llvm.mlir.constant(0 : i64) : i64
  %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %29 = ts.Constant {value = "done."} : !ts.string
  %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %40 = llvm.mlir.constant(1 : i64) : i64
  %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %45 = llvm.mlir.constant(1 : i64) : i64
  %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %49 = llvm.icmp "ult" %43, %48 : i64
  %50 = llvm.select %49, %43, %48 : i1, i64
  %51 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %64 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
  %65 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  llvm.store %63, %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %65, %31 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %66 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %67 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %68 = llvm.extractvalue %66[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %69 = ts.GetTypeInfoFromUnionOp %67 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %70 = llvm.mlir.constant(0 : i64) : i64
  %71 = llvm.ptrtoint %68 : !llvm.ptr<i8> to i64
  %72 = llvm.ptrtoint %20 : !llvm.ptr<i8> to i64
  %73 = llvm.icmp "ne" %71, %70 : i64
  %74 = llvm.icmp "ne" %72, %70 : i64
  %75 = llvm.zext %73 : i1 to i32
  %76 = zexti %73 : i1 to i32
  %77 = ts.Cast %73 : i1 to i32
  %78 = llvm.zext %74 : i1 to i32
  %79 = zexti %74 : i1 to i32
  %80 = ts.Cast %74 : i1 to i32
  %81 = llvm.and %77, %80  : i32
  %82 = llvm.mlir.constant(0 : i32) : i32
  %83 = llvm.icmp "ne" %81, %82 : i32
  llvm.cond_br %83, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %84 = llvm.mlir.constant(0 : i32) : i32
  %85 = llvm.call @strcmp(%68, %20) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %86 = llvm.icmp "eq" %85, %84 : i32
  llvm.br ^bb3(%86 : i1)
^bb2:  // pred: ^bb0
  %87 = llvm.icmp "eq" %71, %72 : i64
  llvm.br ^bb3(%87 : i1)
^bb3(%88: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %89 = "ts.StringCompare"(%68, %20) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %90 = ts.LogicalBinary %69(34) %21 : !ts.string, !ts.string -> !ts.boolean
  %91 = ts.Cast %90 : !ts.boolean to i1
  llvm.cond_br %88, ^bb5, ^bb6
  cond_br %91, ^bb5, ^bb6
^bb5:  // 2 preds: ^bb4, ^bb4
  %92 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %93 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  llvm.store %92, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %94 = ts.Variable(%92) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %95 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %96 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %97 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %98 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %99 = llvm.mlir.constant(1 : i64) : i64
  %100 = llvm.getelementptr %98[%99] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %101 = llvm.ptrtoint %100 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %102 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %103 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %104 = llvm.mlir.constant(1 : i64) : i64
  %105 = llvm.getelementptr %103[%104] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %106 = llvm.ptrtoint %105 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %107 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %108 = llvm.icmp "ult" %102, %107 : i64
  %109 = llvm.select %108, %102, %107 : i1, i64
  %110 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%96, %97, %109, %110) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%95, %94) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %111 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %112 = ts.Load(%95) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
  %113 = llvm.extractvalue %112[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %114 = ts.GetValueFromUnionOp %93 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %115 = llvm.mlir.constant(50 : i32) : i32
  %116 = llvm.zext %115 : i32 to i64
  %117 = zexti %115 : i32 to i64
  %118 = llvm.call @malloc(%117) : (i64) -> !llvm.ptr<i8>
  %119 = llvm.bitcast %118 : !llvm.ptr<i8> to !llvm.ptr<i8>
  %120 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
  %121 = llvm.mlir.constant(0 : i64) : i64
  %122 = llvm.getelementptr %120[%121, %121] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %123 = llvm.call @sprintf_s(%119, %115, %122, %113) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
  %124 = ts.Cast %114 : !ts.number to !ts.string
  %125 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
  %126 = llvm.mlir.constant(0 : i64) : i64
  %127 = llvm.getelementptr %125[%126, %126] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %128 = ts.Constant {value = " "} : !ts.string
  %129 = llvm.intr.stacksave : !llvm.ptr<i8>
  %130 = llvm.mlir.constant(1 : i64) : i64
  %131 = llvm.call @strlen(%24) : (!llvm.ptr<i8>) -> i64
  %132 = llvm.add %130, %131  : i64
  %133 = llvm.call @strlen(%127) : (!llvm.ptr<i8>) -> i64
  %134 = llvm.add %132, %133  : i64
  %135 = llvm.call @strlen(%119) : (!llvm.ptr<i8>) -> i64
  %136 = llvm.add %134, %135  : i64
  %137 = llvm.alloca %136 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
  %138 = llvm.call @strcpy(%137, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  %139 = llvm.call @strcat(%138, %127) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  %140 = llvm.call @strcat(%139, %119) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  %141 = "ts.StringConcat"(%24, %128, %119) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
  %142 = llvm.call @puts(%141) : (!ts.string) -> i32
  llvm.intr.stackrestore %129
  ts.Print(%25, %124) : !ts.string, !ts.string
  br ^bb6
^bb6:  // 3 preds: ^bb4, ^bb4, ^bb5
  %143 = llvm.call @puts(%28) : (!llvm.ptr<i8>) -> i32
  ts.Print(%29) : !ts.string
  llvm.return
  ts.ReturnInternal
}


    } -> SUCCESS
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.call'(0x1b3ca7b2940) {
      %143 = "llvm.call"(%142) {callee = @puts} : (!ts.string) -> i32

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.intr.stackrestore'(0x1b3ca89c7e0) {
      "llvm.intr.stackrestore"(%130) : (!llvm.ptr<i8>) -> ()

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "number"} : !ts.string
  %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "b number: "} : !ts.string
  %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %27 = llvm.mlir.constant(0 : i64) : i64
  %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %29 = ts.Constant {value = "done."} : !ts.string
  %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %40 = llvm.mlir.constant(1 : i64) : i64
  %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %45 = llvm.mlir.constant(1 : i64) : i64
  %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %49 = llvm.icmp "ult" %43, %48 : i64
  %50 = llvm.select %49, %43, %48 : i1, i64
  %51 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %64 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
  %65 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  llvm.store %63, %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %65, %31 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %66 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %67 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %68 = llvm.extractvalue %66[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %69 = ts.GetTypeInfoFromUnionOp %67 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %70 = llvm.mlir.constant(0 : i64) : i64
  %71 = llvm.ptrtoint %68 : !llvm.ptr<i8> to i64
  %72 = llvm.ptrtoint %20 : !llvm.ptr<i8> to i64
  %73 = llvm.icmp "ne" %71, %70 : i64
  %74 = llvm.icmp "ne" %72, %70 : i64
  %75 = llvm.zext %73 : i1 to i32
  %76 = zexti %73 : i1 to i32
  %77 = ts.Cast %73 : i1 to i32
  %78 = llvm.zext %74 : i1 to i32
  %79 = zexti %74 : i1 to i32
  %80 = ts.Cast %74 : i1 to i32
  %81 = llvm.and %77, %80  : i32
  %82 = llvm.mlir.constant(0 : i32) : i32
  %83 = llvm.icmp "ne" %81, %82 : i32
  llvm.cond_br %83, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %84 = llvm.mlir.constant(0 : i32) : i32
  %85 = llvm.call @strcmp(%68, %20) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %86 = llvm.icmp "eq" %85, %84 : i32
  llvm.br ^bb3(%86 : i1)
^bb2:  // pred: ^bb0
  %87 = llvm.icmp "eq" %71, %72 : i64
  llvm.br ^bb3(%87 : i1)
^bb3(%88: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %89 = "ts.StringCompare"(%68, %20) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %90 = ts.LogicalBinary %69(34) %21 : !ts.string, !ts.string -> !ts.boolean
  %91 = ts.Cast %90 : !ts.boolean to i1
  llvm.cond_br %88, ^bb5, ^bb6
  cond_br %91, ^bb5, ^bb6
^bb5:  // 2 preds: ^bb4, ^bb4
  %92 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %93 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  llvm.store %92, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %94 = ts.Variable(%92) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %95 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %96 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %97 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %98 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %99 = llvm.mlir.constant(1 : i64) : i64
  %100 = llvm.getelementptr %98[%99] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %101 = llvm.ptrtoint %100 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %102 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %103 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %104 = llvm.mlir.constant(1 : i64) : i64
  %105 = llvm.getelementptr %103[%104] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %106 = llvm.ptrtoint %105 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %107 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %108 = llvm.icmp "ult" %102, %107 : i64
  %109 = llvm.select %108, %102, %107 : i1, i64
  %110 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%96, %97, %109, %110) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%95, %94) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %111 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %112 = ts.Load(%95) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
  %113 = llvm.extractvalue %112[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %114 = ts.GetValueFromUnionOp %93 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %115 = llvm.mlir.constant(50 : i32) : i32
  %116 = llvm.zext %115 : i32 to i64
  %117 = zexti %115 : i32 to i64
  %118 = llvm.call @malloc(%117) : (i64) -> !llvm.ptr<i8>
  %119 = llvm.bitcast %118 : !llvm.ptr<i8> to !llvm.ptr<i8>
  %120 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
  %121 = llvm.mlir.constant(0 : i64) : i64
  %122 = llvm.getelementptr %120[%121, %121] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %123 = llvm.call @sprintf_s(%119, %115, %122, %113) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
  %124 = ts.Cast %114 : !ts.number to !ts.string
  %125 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
  %126 = llvm.mlir.constant(0 : i64) : i64
  %127 = llvm.getelementptr %125[%126, %126] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %128 = ts.Constant {value = " "} : !ts.string
  %129 = llvm.intr.stacksave : !llvm.ptr<i8>
  %130 = llvm.mlir.constant(1 : i64) : i64
  %131 = llvm.call @strlen(%24) : (!llvm.ptr<i8>) -> i64
  %132 = llvm.add %130, %131  : i64
  %133 = llvm.call @strlen(%127) : (!llvm.ptr<i8>) -> i64
  %134 = llvm.add %132, %133  : i64
  %135 = llvm.call @strlen(%119) : (!llvm.ptr<i8>) -> i64
  %136 = llvm.add %134, %135  : i64
  %137 = llvm.alloca %136 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
  %138 = llvm.call @strcpy(%137, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  %139 = llvm.call @strcat(%138, %127) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  %140 = llvm.call @strcat(%139, %119) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  %141 = "ts.StringConcat"(%24, %128, %119) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
  %142 = llvm.call @puts(%141) : (!ts.string) -> i32
  llvm.intr.stackrestore %129
  ts.Print(%25, %124) : !ts.string, !ts.string
  br ^bb6
^bb6:  // 3 preds: ^bb4, ^bb4, ^bb5
  %143 = llvm.call @puts(%28) : (!llvm.ptr<i8>) -> i32
  ts.Print(%29) : !ts.string
  llvm.return
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'std.br'(0x1b3ca8957d0) {
  "std.br"()[^bb6] : () -> ()

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'std.br -> ()' {
Trying to match "`anonymous-namespace'::BranchOpLowering"
    ** Insert  : 'llvm.br'(0x1b3ca89b970)
    ** Replace : 'std.br'(0x1b3ca8957d0)
"`anonymous-namespace'::BranchOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.br'(0x1b3ca89b970) {
      "llvm.br"()[^bb6] : () -> ()

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "number"} : !ts.string
  %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "b number: "} : !ts.string
  %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %27 = llvm.mlir.constant(0 : i64) : i64
  %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %29 = ts.Constant {value = "done."} : !ts.string
  %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %40 = llvm.mlir.constant(1 : i64) : i64
  %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %45 = llvm.mlir.constant(1 : i64) : i64
  %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %49 = llvm.icmp "ult" %43, %48 : i64
  %50 = llvm.select %49, %43, %48 : i1, i64
  %51 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %64 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
  %65 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  llvm.store %63, %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %65, %31 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %66 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %67 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %68 = llvm.extractvalue %66[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %69 = ts.GetTypeInfoFromUnionOp %67 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %70 = llvm.mlir.constant(0 : i64) : i64
  %71 = llvm.ptrtoint %68 : !llvm.ptr<i8> to i64
  %72 = llvm.ptrtoint %20 : !llvm.ptr<i8> to i64
  %73 = llvm.icmp "ne" %71, %70 : i64
  %74 = llvm.icmp "ne" %72, %70 : i64
  %75 = llvm.zext %73 : i1 to i32
  %76 = zexti %73 : i1 to i32
  %77 = ts.Cast %73 : i1 to i32
  %78 = llvm.zext %74 : i1 to i32
  %79 = zexti %74 : i1 to i32
  %80 = ts.Cast %74 : i1 to i32
  %81 = llvm.and %77, %80  : i32
  %82 = llvm.mlir.constant(0 : i32) : i32
  %83 = llvm.icmp "ne" %81, %82 : i32
  llvm.cond_br %83, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %84 = llvm.mlir.constant(0 : i32) : i32
  %85 = llvm.call @strcmp(%68, %20) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %86 = llvm.icmp "eq" %85, %84 : i32
  llvm.br ^bb3(%86 : i1)
^bb2:  // pred: ^bb0
  %87 = llvm.icmp "eq" %71, %72 : i64
  llvm.br ^bb3(%87 : i1)
^bb3(%88: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %89 = "ts.StringCompare"(%68, %20) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %90 = ts.LogicalBinary %69(34) %21 : !ts.string, !ts.string -> !ts.boolean
  %91 = ts.Cast %90 : !ts.boolean to i1
  llvm.cond_br %88, ^bb5, ^bb6
  cond_br %91, ^bb5, ^bb6
^bb5:  // 2 preds: ^bb4, ^bb4
  %92 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %93 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  llvm.store %92, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %94 = ts.Variable(%92) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %95 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %96 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %97 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %98 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %99 = llvm.mlir.constant(1 : i64) : i64
  %100 = llvm.getelementptr %98[%99] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %101 = llvm.ptrtoint %100 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %102 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %103 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %104 = llvm.mlir.constant(1 : i64) : i64
  %105 = llvm.getelementptr %103[%104] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %106 = llvm.ptrtoint %105 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %107 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %108 = llvm.icmp "ult" %102, %107 : i64
  %109 = llvm.select %108, %102, %107 : i1, i64
  %110 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%96, %97, %109, %110) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%95, %94) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %111 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %112 = ts.Load(%95) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
  %113 = llvm.extractvalue %112[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %114 = ts.GetValueFromUnionOp %93 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %115 = llvm.mlir.constant(50 : i32) : i32
  %116 = llvm.zext %115 : i32 to i64
  %117 = zexti %115 : i32 to i64
  %118 = llvm.call @malloc(%117) : (i64) -> !llvm.ptr<i8>
  %119 = llvm.bitcast %118 : !llvm.ptr<i8> to !llvm.ptr<i8>
  %120 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
  %121 = llvm.mlir.constant(0 : i64) : i64
  %122 = llvm.getelementptr %120[%121, %121] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %123 = llvm.call @sprintf_s(%119, %115, %122, %113) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
  %124 = ts.Cast %114 : !ts.number to !ts.string
  %125 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
  %126 = llvm.mlir.constant(0 : i64) : i64
  %127 = llvm.getelementptr %125[%126, %126] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %128 = ts.Constant {value = " "} : !ts.string
  %129 = llvm.intr.stacksave : !llvm.ptr<i8>
  %130 = llvm.mlir.constant(1 : i64) : i64
  %131 = llvm.call @strlen(%24) : (!llvm.ptr<i8>) -> i64
  %132 = llvm.add %130, %131  : i64
  %133 = llvm.call @strlen(%127) : (!llvm.ptr<i8>) -> i64
  %134 = llvm.add %132, %133  : i64
  %135 = llvm.call @strlen(%119) : (!llvm.ptr<i8>) -> i64
  %136 = llvm.add %134, %135  : i64
  %137 = llvm.alloca %136 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
  %138 = llvm.call @strcpy(%137, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  %139 = llvm.call @strcat(%138, %127) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  %140 = llvm.call @strcat(%139, %119) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  %141 = "ts.StringConcat"(%24, %128, %119) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
  %142 = llvm.call @puts(%141) : (!ts.string) -> i32
  llvm.intr.stackrestore %129
  ts.Print(%25, %124) : !ts.string, !ts.string
  llvm.br ^bb6
  br ^bb6
^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
  %143 = llvm.call @puts(%28) : (!llvm.ptr<i8>) -> i32
  ts.Print(%29) : !ts.string
  llvm.return
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x1b3ca893830) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FuncOpConversion"
    ** Insert  : 'llvm.func'(0x1b3ca89b600)
    ** Erase   : 'func'(0x1b3ca893830)
"`anonymous-namespace'::FuncOpConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x1b3ca89b600) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  llvm.func @strcat(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strcpy(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strlen(!llvm.ptr<i8>) -> i64
  llvm.func @sprintf_s(!llvm.ptr<i8>, i32, !llvm.ptr<i8>, ...) -> i32
  llvm.func @puts(!llvm.ptr<i8>) -> i32
  llvm.func @strcmp(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  llvm.func @llvm.memcpy.p0i8.p0i8.i64(!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1)
  llvm.mlir.global internal constant @s_9237349086447201248("number\00")
  llvm.mlir.global internal constant @s_13617892236937420068("b number: \00")
  llvm.mlir.global internal constant @s_6682479467004374669("done.\00")
  llvm.mlir.global internal constant @frmt_555404038213028357("%g\00")
  llvm.mlir.global internal constant @s_12638117931323064703(" \00")
  llvm.func @main() {
    %0 = llvm.mlir.constant(1 : i32) : i32
    %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %2 = llvm.mlir.constant(1 : i32) : i32
    %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %4 = llvm.mlir.constant(1 : i32) : i32
    %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %6 = llvm.mlir.constant(1 : i32) : i32
    %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %8 = llvm.mlir.constant(1 : i32) : i32
    %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %10 = llvm.mlir.constant(1 : i32) : i32
    %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
    %cst = constant 1.000000e+01 : f64
    %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %15 = llvm.mlir.constant(0 : i64) : i64
    %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %17 = ts.Constant {value = "number"} : !ts.string
    %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %19 = llvm.mlir.constant(0 : i64) : i64
    %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %21 = ts.Constant {value = "number"} : !ts.string
    %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
    %23 = llvm.mlir.constant(0 : i64) : i64
    %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %25 = ts.Constant {value = "b number: "} : !ts.string
    %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
    %27 = llvm.mlir.constant(0 : i64) : i64
    %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %29 = ts.Constant {value = "done."} : !ts.string
    %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
    %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %40 = llvm.mlir.constant(1 : i64) : i64
    %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %45 = llvm.mlir.constant(1 : i64) : i64
    %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %49 = llvm.icmp "ult" %43, %48 : i64
    %50 = llvm.select %49, %43, %48 : i1, i64
    %51 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
    %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
    %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
    %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %64 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
    %65 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
    llvm.store %63, %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %65, %31 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %66 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %67 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %68 = llvm.extractvalue %66[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %69 = ts.GetTypeInfoFromUnionOp %67 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
    %70 = llvm.mlir.constant(0 : i64) : i64
    %71 = llvm.ptrtoint %68 : !llvm.ptr<i8> to i64
    %72 = llvm.ptrtoint %20 : !llvm.ptr<i8> to i64
    %73 = llvm.icmp "ne" %71, %70 : i64
    %74 = llvm.icmp "ne" %72, %70 : i64
    %75 = llvm.zext %73 : i1 to i32
    %76 = zexti %73 : i1 to i32
    %77 = ts.Cast %73 : i1 to i32
    %78 = llvm.zext %74 : i1 to i32
    %79 = zexti %74 : i1 to i32
    %80 = ts.Cast %74 : i1 to i32
    %81 = llvm.and %77, %80  : i32
    %82 = llvm.mlir.constant(0 : i32) : i32
    %83 = llvm.icmp "ne" %81, %82 : i32
    llvm.cond_br %83, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %84 = llvm.mlir.constant(0 : i32) : i32
    %85 = llvm.call @strcmp(%68, %20) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
    %86 = llvm.icmp "eq" %85, %84 : i32
    llvm.br ^bb3(%86 : i1)
  ^bb2:  // pred: ^bb0
    %87 = llvm.icmp "eq" %71, %72 : i64
    llvm.br ^bb3(%87 : i1)
  ^bb3(%88: i1):  // 2 preds: ^bb1, ^bb2
    llvm.br ^bb4
  ^bb4:  // pred: ^bb3
    %89 = "ts.StringCompare"(%68, %20) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
    %90 = ts.LogicalBinary %69(34) %21 : !ts.string, !ts.string -> !ts.boolean
    %91 = ts.Cast %90 : !ts.boolean to i1
    llvm.cond_br %88, ^bb5, ^bb6
    cond_br %91, ^bb5, ^bb6
  ^bb5:  // 2 preds: ^bb4, ^bb4
    %92 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %93 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    llvm.store %92, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %94 = ts.Variable(%92) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
    %95 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %96 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %97 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %98 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %99 = llvm.mlir.constant(1 : i64) : i64
    %100 = llvm.getelementptr %98[%99] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %101 = llvm.ptrtoint %100 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %102 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %103 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %104 = llvm.mlir.constant(1 : i64) : i64
    %105 = llvm.getelementptr %103[%104] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %106 = llvm.ptrtoint %105 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %107 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %108 = llvm.icmp "ult" %102, %107 : i64
    %109 = llvm.select %108, %102, %107 : i1, i64
    %110 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%96, %97, %109, %110) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%95, %94) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
    %111 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %112 = ts.Load(%95) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
    %113 = llvm.extractvalue %112[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %114 = ts.GetValueFromUnionOp %93 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %115 = llvm.mlir.constant(50 : i32) : i32
    %116 = llvm.zext %115 : i32 to i64
    %117 = zexti %115 : i32 to i64
    %118 = llvm.call @malloc(%117) : (i64) -> !llvm.ptr<i8>
    %119 = llvm.bitcast %118 : !llvm.ptr<i8> to !llvm.ptr<i8>
    %120 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
    %121 = llvm.mlir.constant(0 : i64) : i64
    %122 = llvm.getelementptr %120[%121, %121] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %123 = llvm.call @sprintf_s(%119, %115, %122, %113) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
    %124 = ts.Cast %114 : !ts.number to !ts.string
    %125 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
    %126 = llvm.mlir.constant(0 : i64) : i64
    %127 = llvm.getelementptr %125[%126, %126] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %128 = ts.Constant {value = " "} : !ts.string
    %129 = llvm.intr.stacksave : !llvm.ptr<i8>
    %130 = llvm.mlir.constant(1 : i64) : i64
    %131 = llvm.call @strlen(%24) : (!llvm.ptr<i8>) -> i64
    %132 = llvm.add %130, %131  : i64
    %133 = llvm.call @strlen(%127) : (!llvm.ptr<i8>) -> i64
    %134 = llvm.add %132, %133  : i64
    %135 = llvm.call @strlen(%119) : (!llvm.ptr<i8>) -> i64
    %136 = llvm.add %134, %135  : i64
    %137 = llvm.alloca %136 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
    %138 = llvm.call @strcpy(%137, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %139 = llvm.call @strcat(%138, %127) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %140 = llvm.call @strcat(%139, %119) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %141 = "ts.StringConcat"(%24, %128, %119) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
    %142 = llvm.call @puts(%141) : (!ts.string) -> i32
    llvm.intr.stackrestore %129
    ts.Print(%25, %124) : !ts.string, !ts.string
    llvm.br ^bb6
    br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
    %143 = llvm.call @puts(%28) : (!llvm.ptr<i8>) -> i32
    ts.Print(%29) : !ts.string
    llvm.return
    ts.ReturnInternal
  }
  func @main()
  ts.Func @main () -> ()  {
  }
  llvm.func @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x1b3ca894ac0) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FuncOpConversion"
    ** Insert  : 'llvm.func'(0x1b3ca89d230)
    ** Erase   : 'func'(0x1b3ca894ac0)
"`anonymous-namespace'::FuncOpConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x1b3ca89d230) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  llvm.func @strcat(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strcpy(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strlen(!llvm.ptr<i8>) -> i64
  llvm.func @sprintf_s(!llvm.ptr<i8>, i32, !llvm.ptr<i8>, ...) -> i32
  llvm.func @puts(!llvm.ptr<i8>) -> i32
  llvm.func @strcmp(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  llvm.func @llvm.memcpy.p0i8.p0i8.i64(!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1)
  llvm.mlir.global internal constant @s_9237349086447201248("number\00")
  llvm.mlir.global internal constant @s_13617892236937420068("b number: \00")
  llvm.mlir.global internal constant @s_6682479467004374669("done.\00")
  llvm.mlir.global internal constant @frmt_555404038213028357("%g\00")
  llvm.mlir.global internal constant @s_12638117931323064703(" \00")
  llvm.func @main() {
    %0 = llvm.mlir.constant(1 : i32) : i32
    %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %2 = llvm.mlir.constant(1 : i32) : i32
    %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %4 = llvm.mlir.constant(1 : i32) : i32
    %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %6 = llvm.mlir.constant(1 : i32) : i32
    %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %8 = llvm.mlir.constant(1 : i32) : i32
    %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %10 = llvm.mlir.constant(1 : i32) : i32
    %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
    %cst = constant 1.000000e+01 : f64
    %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %15 = llvm.mlir.constant(0 : i64) : i64
    %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %17 = ts.Constant {value = "number"} : !ts.string
    %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %19 = llvm.mlir.constant(0 : i64) : i64
    %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %21 = ts.Constant {value = "number"} : !ts.string
    %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
    %23 = llvm.mlir.constant(0 : i64) : i64
    %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %25 = ts.Constant {value = "b number: "} : !ts.string
    %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
    %27 = llvm.mlir.constant(0 : i64) : i64
    %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %29 = ts.Constant {value = "done."} : !ts.string
    %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
    %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %40 = llvm.mlir.constant(1 : i64) : i64
    %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %45 = llvm.mlir.constant(1 : i64) : i64
    %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %49 = llvm.icmp "ult" %43, %48 : i64
    %50 = llvm.select %49, %43, %48 : i1, i64
    %51 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
    %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
    %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
    %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %64 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
    %65 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
    llvm.store %63, %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %65, %31 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %66 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %67 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %68 = llvm.extractvalue %66[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %69 = ts.GetTypeInfoFromUnionOp %67 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
    %70 = llvm.mlir.constant(0 : i64) : i64
    %71 = llvm.ptrtoint %68 : !llvm.ptr<i8> to i64
    %72 = llvm.ptrtoint %20 : !llvm.ptr<i8> to i64
    %73 = llvm.icmp "ne" %71, %70 : i64
    %74 = llvm.icmp "ne" %72, %70 : i64
    %75 = llvm.zext %73 : i1 to i32
    %76 = zexti %73 : i1 to i32
    %77 = ts.Cast %73 : i1 to i32
    %78 = llvm.zext %74 : i1 to i32
    %79 = zexti %74 : i1 to i32
    %80 = ts.Cast %74 : i1 to i32
    %81 = llvm.and %77, %80  : i32
    %82 = llvm.mlir.constant(0 : i32) : i32
    %83 = llvm.icmp "ne" %81, %82 : i32
    llvm.cond_br %83, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %84 = llvm.mlir.constant(0 : i32) : i32
    %85 = llvm.call @strcmp(%68, %20) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
    %86 = llvm.icmp "eq" %85, %84 : i32
    llvm.br ^bb3(%86 : i1)
  ^bb2:  // pred: ^bb0
    %87 = llvm.icmp "eq" %71, %72 : i64
    llvm.br ^bb3(%87 : i1)
  ^bb3(%88: i1):  // 2 preds: ^bb1, ^bb2
    llvm.br ^bb4
  ^bb4:  // pred: ^bb3
    %89 = "ts.StringCompare"(%68, %20) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
    %90 = ts.LogicalBinary %69(34) %21 : !ts.string, !ts.string -> !ts.boolean
    %91 = ts.Cast %90 : !ts.boolean to i1
    llvm.cond_br %88, ^bb5, ^bb6
    cond_br %91, ^bb5, ^bb6
  ^bb5:  // 2 preds: ^bb4, ^bb4
    %92 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %93 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    llvm.store %92, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %94 = ts.Variable(%92) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
    %95 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %96 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %97 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %98 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %99 = llvm.mlir.constant(1 : i64) : i64
    %100 = llvm.getelementptr %98[%99] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %101 = llvm.ptrtoint %100 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %102 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %103 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %104 = llvm.mlir.constant(1 : i64) : i64
    %105 = llvm.getelementptr %103[%104] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %106 = llvm.ptrtoint %105 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %107 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %108 = llvm.icmp "ult" %102, %107 : i64
    %109 = llvm.select %108, %102, %107 : i1, i64
    %110 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%96, %97, %109, %110) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%95, %94) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
    %111 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %112 = ts.Load(%95) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
    %113 = llvm.extractvalue %112[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %114 = ts.GetValueFromUnionOp %93 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %115 = llvm.mlir.constant(50 : i32) : i32
    %116 = llvm.zext %115 : i32 to i64
    %117 = zexti %115 : i32 to i64
    %118 = llvm.call @malloc(%117) : (i64) -> !llvm.ptr<i8>
    %119 = llvm.bitcast %118 : !llvm.ptr<i8> to !llvm.ptr<i8>
    %120 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
    %121 = llvm.mlir.constant(0 : i64) : i64
    %122 = llvm.getelementptr %120[%121, %121] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %123 = llvm.call @sprintf_s(%119, %115, %122, %113) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
    %124 = ts.Cast %114 : !ts.number to !ts.string
    %125 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
    %126 = llvm.mlir.constant(0 : i64) : i64
    %127 = llvm.getelementptr %125[%126, %126] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %128 = ts.Constant {value = " "} : !ts.string
    %129 = llvm.intr.stacksave : !llvm.ptr<i8>
    %130 = llvm.mlir.constant(1 : i64) : i64
    %131 = llvm.call @strlen(%24) : (!llvm.ptr<i8>) -> i64
    %132 = llvm.add %130, %131  : i64
    %133 = llvm.call @strlen(%127) : (!llvm.ptr<i8>) -> i64
    %134 = llvm.add %132, %133  : i64
    %135 = llvm.call @strlen(%119) : (!llvm.ptr<i8>) -> i64
    %136 = llvm.add %134, %135  : i64
    %137 = llvm.alloca %136 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
    %138 = llvm.call @strcpy(%137, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %139 = llvm.call @strcat(%138, %127) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %140 = llvm.call @strcat(%139, %119) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %141 = "ts.StringConcat"(%24, %128, %119) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
    %142 = llvm.call @puts(%141) : (!ts.string) -> i32
    llvm.intr.stackrestore %129
    ts.Print(%25, %124) : !ts.string, !ts.string
    llvm.br ^bb6
    br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
    %143 = llvm.call @puts(%28) : (!llvm.ptr<i8>) -> i32
    ts.Print(%29) : !ts.string
    llvm.return
    ts.ReturnInternal
  }
  func @main()
  ts.Func @main () -> ()  {
  }
  llvm.func @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x1b3ca893150) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FuncOpConversion"
    ** Insert  : 'llvm.func'(0x1b3ca89c940)
    ** Erase   : 'func'(0x1b3ca893150)
"`anonymous-namespace'::FuncOpConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x1b3ca89c940) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  llvm.func @strcat(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strcpy(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strlen(!llvm.ptr<i8>) -> i64
  llvm.func @sprintf_s(!llvm.ptr<i8>, i32, !llvm.ptr<i8>, ...) -> i32
  llvm.func @puts(!llvm.ptr<i8>) -> i32
  llvm.func @strcmp(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  llvm.func @llvm.memcpy.p0i8.p0i8.i64(!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1)
  llvm.mlir.global internal constant @s_9237349086447201248("number\00")
  llvm.mlir.global internal constant @s_13617892236937420068("b number: \00")
  llvm.mlir.global internal constant @s_6682479467004374669("done.\00")
  llvm.mlir.global internal constant @frmt_555404038213028357("%g\00")
  llvm.mlir.global internal constant @s_12638117931323064703(" \00")
  llvm.func @main() {
    %0 = llvm.mlir.constant(1 : i32) : i32
    %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %2 = llvm.mlir.constant(1 : i32) : i32
    %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %4 = llvm.mlir.constant(1 : i32) : i32
    %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %6 = llvm.mlir.constant(1 : i32) : i32
    %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %8 = llvm.mlir.constant(1 : i32) : i32
    %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %10 = llvm.mlir.constant(1 : i32) : i32
    %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
    %cst = constant 1.000000e+01 : f64
    %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %15 = llvm.mlir.constant(0 : i64) : i64
    %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %17 = ts.Constant {value = "number"} : !ts.string
    %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %19 = llvm.mlir.constant(0 : i64) : i64
    %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %21 = ts.Constant {value = "number"} : !ts.string
    %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
    %23 = llvm.mlir.constant(0 : i64) : i64
    %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %25 = ts.Constant {value = "b number: "} : !ts.string
    %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
    %27 = llvm.mlir.constant(0 : i64) : i64
    %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %29 = ts.Constant {value = "done."} : !ts.string
    %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
    %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %40 = llvm.mlir.constant(1 : i64) : i64
    %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %45 = llvm.mlir.constant(1 : i64) : i64
    %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %49 = llvm.icmp "ult" %43, %48 : i64
    %50 = llvm.select %49, %43, %48 : i1, i64
    %51 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
    %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
    %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
    %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %64 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
    %65 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
    llvm.store %63, %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %65, %31 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %66 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %67 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %68 = llvm.extractvalue %66[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %69 = ts.GetTypeInfoFromUnionOp %67 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
    %70 = llvm.mlir.constant(0 : i64) : i64
    %71 = llvm.ptrtoint %68 : !llvm.ptr<i8> to i64
    %72 = llvm.ptrtoint %20 : !llvm.ptr<i8> to i64
    %73 = llvm.icmp "ne" %71, %70 : i64
    %74 = llvm.icmp "ne" %72, %70 : i64
    %75 = llvm.zext %73 : i1 to i32
    %76 = zexti %73 : i1 to i32
    %77 = ts.Cast %73 : i1 to i32
    %78 = llvm.zext %74 : i1 to i32
    %79 = zexti %74 : i1 to i32
    %80 = ts.Cast %74 : i1 to i32
    %81 = llvm.and %77, %80  : i32
    %82 = llvm.mlir.constant(0 : i32) : i32
    %83 = llvm.icmp "ne" %81, %82 : i32
    llvm.cond_br %83, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %84 = llvm.mlir.constant(0 : i32) : i32
    %85 = llvm.call @strcmp(%68, %20) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
    %86 = llvm.icmp "eq" %85, %84 : i32
    llvm.br ^bb3(%86 : i1)
  ^bb2:  // pred: ^bb0
    %87 = llvm.icmp "eq" %71, %72 : i64
    llvm.br ^bb3(%87 : i1)
  ^bb3(%88: i1):  // 2 preds: ^bb1, ^bb2
    llvm.br ^bb4
  ^bb4:  // pred: ^bb3
    %89 = "ts.StringCompare"(%68, %20) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
    %90 = ts.LogicalBinary %69(34) %21 : !ts.string, !ts.string -> !ts.boolean
    %91 = ts.Cast %90 : !ts.boolean to i1
    llvm.cond_br %88, ^bb5, ^bb6
    cond_br %91, ^bb5, ^bb6
  ^bb5:  // 2 preds: ^bb4, ^bb4
    %92 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %93 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    llvm.store %92, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %94 = ts.Variable(%92) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
    %95 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %96 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %97 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %98 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %99 = llvm.mlir.constant(1 : i64) : i64
    %100 = llvm.getelementptr %98[%99] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %101 = llvm.ptrtoint %100 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %102 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %103 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %104 = llvm.mlir.constant(1 : i64) : i64
    %105 = llvm.getelementptr %103[%104] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %106 = llvm.ptrtoint %105 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %107 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %108 = llvm.icmp "ult" %102, %107 : i64
    %109 = llvm.select %108, %102, %107 : i1, i64
    %110 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%96, %97, %109, %110) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%95, %94) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
    %111 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %112 = ts.Load(%95) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
    %113 = llvm.extractvalue %112[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %114 = ts.GetValueFromUnionOp %93 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %115 = llvm.mlir.constant(50 : i32) : i32
    %116 = llvm.zext %115 : i32 to i64
    %117 = zexti %115 : i32 to i64
    %118 = llvm.call @malloc(%117) : (i64) -> !llvm.ptr<i8>
    %119 = llvm.bitcast %118 : !llvm.ptr<i8> to !llvm.ptr<i8>
    %120 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
    %121 = llvm.mlir.constant(0 : i64) : i64
    %122 = llvm.getelementptr %120[%121, %121] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %123 = llvm.call @sprintf_s(%119, %115, %122, %113) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
    %124 = ts.Cast %114 : !ts.number to !ts.string
    %125 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
    %126 = llvm.mlir.constant(0 : i64) : i64
    %127 = llvm.getelementptr %125[%126, %126] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %128 = ts.Constant {value = " "} : !ts.string
    %129 = llvm.intr.stacksave : !llvm.ptr<i8>
    %130 = llvm.mlir.constant(1 : i64) : i64
    %131 = llvm.call @strlen(%24) : (!llvm.ptr<i8>) -> i64
    %132 = llvm.add %130, %131  : i64
    %133 = llvm.call @strlen(%127) : (!llvm.ptr<i8>) -> i64
    %134 = llvm.add %132, %133  : i64
    %135 = llvm.call @strlen(%119) : (!llvm.ptr<i8>) -> i64
    %136 = llvm.add %134, %135  : i64
    %137 = llvm.alloca %136 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
    %138 = llvm.call @strcpy(%137, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %139 = llvm.call @strcat(%138, %127) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %140 = llvm.call @strcat(%139, %119) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %141 = "ts.StringConcat"(%24, %128, %119) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
    %142 = llvm.call @puts(%141) : (!ts.string) -> i32
    llvm.intr.stackrestore %129
    ts.Print(%25, %124) : !ts.string, !ts.string
    llvm.br ^bb6
    br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
    %143 = llvm.call @puts(%28) : (!llvm.ptr<i8>) -> i32
    ts.Print(%29) : !ts.string
    llvm.return
    ts.ReturnInternal
  }
  func @main()
  ts.Func @main () -> ()  {
  }
  llvm.func @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x1b3ca892910) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FuncOpConversion"
    ** Insert  : 'llvm.func'(0x1b3ca89afd0)
    ** Erase   : 'func'(0x1b3ca892910)
"`anonymous-namespace'::FuncOpConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x1b3ca89afd0) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  llvm.func @strcat(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strcpy(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strlen(!llvm.ptr<i8>) -> i64
  llvm.func @sprintf_s(!llvm.ptr<i8>, i32, !llvm.ptr<i8>, ...) -> i32
  llvm.func @puts(!llvm.ptr<i8>) -> i32
  llvm.func @strcmp(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  llvm.func @llvm.memcpy.p0i8.p0i8.i64(!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1)
  llvm.mlir.global internal constant @s_9237349086447201248("number\00")
  llvm.mlir.global internal constant @s_13617892236937420068("b number: \00")
  llvm.mlir.global internal constant @s_6682479467004374669("done.\00")
  llvm.mlir.global internal constant @frmt_555404038213028357("%g\00")
  llvm.mlir.global internal constant @s_12638117931323064703(" \00")
  llvm.func @main() {
    %0 = llvm.mlir.constant(1 : i32) : i32
    %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %2 = llvm.mlir.constant(1 : i32) : i32
    %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %4 = llvm.mlir.constant(1 : i32) : i32
    %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %6 = llvm.mlir.constant(1 : i32) : i32
    %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %8 = llvm.mlir.constant(1 : i32) : i32
    %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %10 = llvm.mlir.constant(1 : i32) : i32
    %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
    %cst = constant 1.000000e+01 : f64
    %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %15 = llvm.mlir.constant(0 : i64) : i64
    %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %17 = ts.Constant {value = "number"} : !ts.string
    %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %19 = llvm.mlir.constant(0 : i64) : i64
    %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %21 = ts.Constant {value = "number"} : !ts.string
    %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
    %23 = llvm.mlir.constant(0 : i64) : i64
    %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %25 = ts.Constant {value = "b number: "} : !ts.string
    %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
    %27 = llvm.mlir.constant(0 : i64) : i64
    %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %29 = ts.Constant {value = "done."} : !ts.string
    %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
    %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %40 = llvm.mlir.constant(1 : i64) : i64
    %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %45 = llvm.mlir.constant(1 : i64) : i64
    %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %49 = llvm.icmp "ult" %43, %48 : i64
    %50 = llvm.select %49, %43, %48 : i1, i64
    %51 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
    %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
    %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
    %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %64 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
    %65 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
    llvm.store %63, %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %65, %31 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %66 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %67 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %68 = llvm.extractvalue %66[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %69 = ts.GetTypeInfoFromUnionOp %67 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
    %70 = llvm.mlir.constant(0 : i64) : i64
    %71 = llvm.ptrtoint %68 : !llvm.ptr<i8> to i64
    %72 = llvm.ptrtoint %20 : !llvm.ptr<i8> to i64
    %73 = llvm.icmp "ne" %71, %70 : i64
    %74 = llvm.icmp "ne" %72, %70 : i64
    %75 = llvm.zext %73 : i1 to i32
    %76 = zexti %73 : i1 to i32
    %77 = ts.Cast %73 : i1 to i32
    %78 = llvm.zext %74 : i1 to i32
    %79 = zexti %74 : i1 to i32
    %80 = ts.Cast %74 : i1 to i32
    %81 = llvm.and %77, %80  : i32
    %82 = llvm.mlir.constant(0 : i32) : i32
    %83 = llvm.icmp "ne" %81, %82 : i32
    llvm.cond_br %83, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %84 = llvm.mlir.constant(0 : i32) : i32
    %85 = llvm.call @strcmp(%68, %20) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
    %86 = llvm.icmp "eq" %85, %84 : i32
    llvm.br ^bb3(%86 : i1)
  ^bb2:  // pred: ^bb0
    %87 = llvm.icmp "eq" %71, %72 : i64
    llvm.br ^bb3(%87 : i1)
  ^bb3(%88: i1):  // 2 preds: ^bb1, ^bb2
    llvm.br ^bb4
  ^bb4:  // pred: ^bb3
    %89 = "ts.StringCompare"(%68, %20) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
    %90 = ts.LogicalBinary %69(34) %21 : !ts.string, !ts.string -> !ts.boolean
    %91 = ts.Cast %90 : !ts.boolean to i1
    llvm.cond_br %88, ^bb5, ^bb6
    cond_br %91, ^bb5, ^bb6
  ^bb5:  // 2 preds: ^bb4, ^bb4
    %92 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %93 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    llvm.store %92, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %94 = ts.Variable(%92) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
    %95 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %96 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %97 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %98 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %99 = llvm.mlir.constant(1 : i64) : i64
    %100 = llvm.getelementptr %98[%99] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %101 = llvm.ptrtoint %100 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %102 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %103 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %104 = llvm.mlir.constant(1 : i64) : i64
    %105 = llvm.getelementptr %103[%104] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %106 = llvm.ptrtoint %105 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %107 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %108 = llvm.icmp "ult" %102, %107 : i64
    %109 = llvm.select %108, %102, %107 : i1, i64
    %110 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%96, %97, %109, %110) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%95, %94) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
    %111 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %112 = ts.Load(%95) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
    %113 = llvm.extractvalue %112[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %114 = ts.GetValueFromUnionOp %93 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %115 = llvm.mlir.constant(50 : i32) : i32
    %116 = llvm.zext %115 : i32 to i64
    %117 = zexti %115 : i32 to i64
    %118 = llvm.call @malloc(%117) : (i64) -> !llvm.ptr<i8>
    %119 = llvm.bitcast %118 : !llvm.ptr<i8> to !llvm.ptr<i8>
    %120 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
    %121 = llvm.mlir.constant(0 : i64) : i64
    %122 = llvm.getelementptr %120[%121, %121] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %123 = llvm.call @sprintf_s(%119, %115, %122, %113) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
    %124 = ts.Cast %114 : !ts.number to !ts.string
    %125 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
    %126 = llvm.mlir.constant(0 : i64) : i64
    %127 = llvm.getelementptr %125[%126, %126] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %128 = ts.Constant {value = " "} : !ts.string
    %129 = llvm.intr.stacksave : !llvm.ptr<i8>
    %130 = llvm.mlir.constant(1 : i64) : i64
    %131 = llvm.call @strlen(%24) : (!llvm.ptr<i8>) -> i64
    %132 = llvm.add %130, %131  : i64
    %133 = llvm.call @strlen(%127) : (!llvm.ptr<i8>) -> i64
    %134 = llvm.add %132, %133  : i64
    %135 = llvm.call @strlen(%119) : (!llvm.ptr<i8>) -> i64
    %136 = llvm.add %134, %135  : i64
    %137 = llvm.alloca %136 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
    %138 = llvm.call @strcpy(%137, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %139 = llvm.call @strcat(%138, %127) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %140 = llvm.call @strcat(%139, %119) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %141 = "ts.StringConcat"(%24, %128, %119) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
    %142 = llvm.call @puts(%141) : (!ts.string) -> i32
    llvm.intr.stackrestore %129
    ts.Print(%25, %124) : !ts.string, !ts.string
    llvm.br ^bb6
    br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
    %143 = llvm.call @puts(%28) : (!llvm.ptr<i8>) -> i32
    ts.Print(%29) : !ts.string
    llvm.return
    ts.ReturnInternal
  }
  func @main()
  ts.Func @main () -> ()  {
  }
  llvm.func @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x1b3ca893200) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FuncOpConversion"
    ** Insert  : 'llvm.func'(0x1b3ca89c5d0)
    ** Erase   : 'func'(0x1b3ca893200)
"`anonymous-namespace'::FuncOpConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x1b3ca89c5d0) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  llvm.func @strcat(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strcpy(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strlen(!llvm.ptr<i8>) -> i64
  llvm.func @sprintf_s(!llvm.ptr<i8>, i32, !llvm.ptr<i8>, ...) -> i32
  llvm.func @puts(!llvm.ptr<i8>) -> i32
  llvm.func @strcmp(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  llvm.func @llvm.memcpy.p0i8.p0i8.i64(!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1)
  llvm.mlir.global internal constant @s_9237349086447201248("number\00")
  llvm.mlir.global internal constant @s_13617892236937420068("b number: \00")
  llvm.mlir.global internal constant @s_6682479467004374669("done.\00")
  llvm.mlir.global internal constant @frmt_555404038213028357("%g\00")
  llvm.mlir.global internal constant @s_12638117931323064703(" \00")
  llvm.func @main() {
    %0 = llvm.mlir.constant(1 : i32) : i32
    %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %2 = llvm.mlir.constant(1 : i32) : i32
    %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %4 = llvm.mlir.constant(1 : i32) : i32
    %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %6 = llvm.mlir.constant(1 : i32) : i32
    %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %8 = llvm.mlir.constant(1 : i32) : i32
    %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %10 = llvm.mlir.constant(1 : i32) : i32
    %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
    %cst = constant 1.000000e+01 : f64
    %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %15 = llvm.mlir.constant(0 : i64) : i64
    %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %17 = ts.Constant {value = "number"} : !ts.string
    %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %19 = llvm.mlir.constant(0 : i64) : i64
    %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %21 = ts.Constant {value = "number"} : !ts.string
    %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
    %23 = llvm.mlir.constant(0 : i64) : i64
    %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %25 = ts.Constant {value = "b number: "} : !ts.string
    %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
    %27 = llvm.mlir.constant(0 : i64) : i64
    %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %29 = ts.Constant {value = "done."} : !ts.string
    %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
    %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %40 = llvm.mlir.constant(1 : i64) : i64
    %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %45 = llvm.mlir.constant(1 : i64) : i64
    %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %49 = llvm.icmp "ult" %43, %48 : i64
    %50 = llvm.select %49, %43, %48 : i1, i64
    %51 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
    %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
    %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
    %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %64 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
    %65 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
    llvm.store %63, %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %65, %31 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %66 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %67 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %68 = llvm.extractvalue %66[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %69 = ts.GetTypeInfoFromUnionOp %67 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
    %70 = llvm.mlir.constant(0 : i64) : i64
    %71 = llvm.ptrtoint %68 : !llvm.ptr<i8> to i64
    %72 = llvm.ptrtoint %20 : !llvm.ptr<i8> to i64
    %73 = llvm.icmp "ne" %71, %70 : i64
    %74 = llvm.icmp "ne" %72, %70 : i64
    %75 = llvm.zext %73 : i1 to i32
    %76 = zexti %73 : i1 to i32
    %77 = ts.Cast %73 : i1 to i32
    %78 = llvm.zext %74 : i1 to i32
    %79 = zexti %74 : i1 to i32
    %80 = ts.Cast %74 : i1 to i32
    %81 = llvm.and %77, %80  : i32
    %82 = llvm.mlir.constant(0 : i32) : i32
    %83 = llvm.icmp "ne" %81, %82 : i32
    llvm.cond_br %83, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %84 = llvm.mlir.constant(0 : i32) : i32
    %85 = llvm.call @strcmp(%68, %20) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
    %86 = llvm.icmp "eq" %85, %84 : i32
    llvm.br ^bb3(%86 : i1)
  ^bb2:  // pred: ^bb0
    %87 = llvm.icmp "eq" %71, %72 : i64
    llvm.br ^bb3(%87 : i1)
  ^bb3(%88: i1):  // 2 preds: ^bb1, ^bb2
    llvm.br ^bb4
  ^bb4:  // pred: ^bb3
    %89 = "ts.StringCompare"(%68, %20) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
    %90 = ts.LogicalBinary %69(34) %21 : !ts.string, !ts.string -> !ts.boolean
    %91 = ts.Cast %90 : !ts.boolean to i1
    llvm.cond_br %88, ^bb5, ^bb6
    cond_br %91, ^bb5, ^bb6
  ^bb5:  // 2 preds: ^bb4, ^bb4
    %92 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %93 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    llvm.store %92, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %94 = ts.Variable(%92) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
    %95 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %96 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %97 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %98 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %99 = llvm.mlir.constant(1 : i64) : i64
    %100 = llvm.getelementptr %98[%99] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %101 = llvm.ptrtoint %100 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %102 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %103 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %104 = llvm.mlir.constant(1 : i64) : i64
    %105 = llvm.getelementptr %103[%104] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %106 = llvm.ptrtoint %105 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %107 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %108 = llvm.icmp "ult" %102, %107 : i64
    %109 = llvm.select %108, %102, %107 : i1, i64
    %110 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%96, %97, %109, %110) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%95, %94) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
    %111 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %112 = ts.Load(%95) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
    %113 = llvm.extractvalue %112[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %114 = ts.GetValueFromUnionOp %93 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %115 = llvm.mlir.constant(50 : i32) : i32
    %116 = llvm.zext %115 : i32 to i64
    %117 = zexti %115 : i32 to i64
    %118 = llvm.call @malloc(%117) : (i64) -> !llvm.ptr<i8>
    %119 = llvm.bitcast %118 : !llvm.ptr<i8> to !llvm.ptr<i8>
    %120 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
    %121 = llvm.mlir.constant(0 : i64) : i64
    %122 = llvm.getelementptr %120[%121, %121] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %123 = llvm.call @sprintf_s(%119, %115, %122, %113) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
    %124 = ts.Cast %114 : !ts.number to !ts.string
    %125 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
    %126 = llvm.mlir.constant(0 : i64) : i64
    %127 = llvm.getelementptr %125[%126, %126] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %128 = ts.Constant {value = " "} : !ts.string
    %129 = llvm.intr.stacksave : !llvm.ptr<i8>
    %130 = llvm.mlir.constant(1 : i64) : i64
    %131 = llvm.call @strlen(%24) : (!llvm.ptr<i8>) -> i64
    %132 = llvm.add %130, %131  : i64
    %133 = llvm.call @strlen(%127) : (!llvm.ptr<i8>) -> i64
    %134 = llvm.add %132, %133  : i64
    %135 = llvm.call @strlen(%119) : (!llvm.ptr<i8>) -> i64
    %136 = llvm.add %134, %135  : i64
    %137 = llvm.alloca %136 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
    %138 = llvm.call @strcpy(%137, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %139 = llvm.call @strcat(%138, %127) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %140 = llvm.call @strcat(%139, %119) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %141 = "ts.StringConcat"(%24, %128, %119) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
    %142 = llvm.call @puts(%141) : (!ts.string) -> i32
    llvm.intr.stackrestore %129
    ts.Print(%25, %124) : !ts.string, !ts.string
    llvm.br ^bb6
    br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
    %143 = llvm.call @puts(%28) : (!llvm.ptr<i8>) -> i32
    ts.Print(%29) : !ts.string
    llvm.return
    ts.ReturnInternal
  }
  func @main()
  ts.Func @main () -> ()  {
  }
  llvm.func @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x1b3ca894f90) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FuncOpConversion"
    ** Insert  : 'llvm.func'(0x1b3ca89be40)
    ** Erase   : 'func'(0x1b3ca894f90)
"`anonymous-namespace'::FuncOpConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x1b3ca89be40) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  llvm.func @strcat(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strcpy(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strlen(!llvm.ptr<i8>) -> i64
  llvm.func @sprintf_s(!llvm.ptr<i8>, i32, !llvm.ptr<i8>, ...) -> i32
  llvm.func @puts(!llvm.ptr<i8>) -> i32
  llvm.func @strcmp(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  llvm.func @llvm.memcpy.p0i8.p0i8.i64(!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1)
  llvm.mlir.global internal constant @s_9237349086447201248("number\00")
  llvm.mlir.global internal constant @s_13617892236937420068("b number: \00")
  llvm.mlir.global internal constant @s_6682479467004374669("done.\00")
  llvm.mlir.global internal constant @frmt_555404038213028357("%g\00")
  llvm.mlir.global internal constant @s_12638117931323064703(" \00")
  llvm.func @main() {
    %0 = llvm.mlir.constant(1 : i32) : i32
    %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %2 = llvm.mlir.constant(1 : i32) : i32
    %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %4 = llvm.mlir.constant(1 : i32) : i32
    %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %6 = llvm.mlir.constant(1 : i32) : i32
    %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %8 = llvm.mlir.constant(1 : i32) : i32
    %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %10 = llvm.mlir.constant(1 : i32) : i32
    %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
    %cst = constant 1.000000e+01 : f64
    %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %15 = llvm.mlir.constant(0 : i64) : i64
    %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %17 = ts.Constant {value = "number"} : !ts.string
    %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %19 = llvm.mlir.constant(0 : i64) : i64
    %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %21 = ts.Constant {value = "number"} : !ts.string
    %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
    %23 = llvm.mlir.constant(0 : i64) : i64
    %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %25 = ts.Constant {value = "b number: "} : !ts.string
    %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
    %27 = llvm.mlir.constant(0 : i64) : i64
    %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %29 = ts.Constant {value = "done."} : !ts.string
    %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
    %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %40 = llvm.mlir.constant(1 : i64) : i64
    %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %45 = llvm.mlir.constant(1 : i64) : i64
    %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %49 = llvm.icmp "ult" %43, %48 : i64
    %50 = llvm.select %49, %43, %48 : i1, i64
    %51 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
    %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
    %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
    %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %64 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
    %65 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
    llvm.store %63, %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %65, %31 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %66 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %67 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %68 = llvm.extractvalue %66[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %69 = ts.GetTypeInfoFromUnionOp %67 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
    %70 = llvm.mlir.constant(0 : i64) : i64
    %71 = llvm.ptrtoint %68 : !llvm.ptr<i8> to i64
    %72 = llvm.ptrtoint %20 : !llvm.ptr<i8> to i64
    %73 = llvm.icmp "ne" %71, %70 : i64
    %74 = llvm.icmp "ne" %72, %70 : i64
    %75 = llvm.zext %73 : i1 to i32
    %76 = zexti %73 : i1 to i32
    %77 = ts.Cast %73 : i1 to i32
    %78 = llvm.zext %74 : i1 to i32
    %79 = zexti %74 : i1 to i32
    %80 = ts.Cast %74 : i1 to i32
    %81 = llvm.and %77, %80  : i32
    %82 = llvm.mlir.constant(0 : i32) : i32
    %83 = llvm.icmp "ne" %81, %82 : i32
    llvm.cond_br %83, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %84 = llvm.mlir.constant(0 : i32) : i32
    %85 = llvm.call @strcmp(%68, %20) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
    %86 = llvm.icmp "eq" %85, %84 : i32
    llvm.br ^bb3(%86 : i1)
  ^bb2:  // pred: ^bb0
    %87 = llvm.icmp "eq" %71, %72 : i64
    llvm.br ^bb3(%87 : i1)
  ^bb3(%88: i1):  // 2 preds: ^bb1, ^bb2
    llvm.br ^bb4
  ^bb4:  // pred: ^bb3
    %89 = "ts.StringCompare"(%68, %20) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
    %90 = ts.LogicalBinary %69(34) %21 : !ts.string, !ts.string -> !ts.boolean
    %91 = ts.Cast %90 : !ts.boolean to i1
    llvm.cond_br %88, ^bb5, ^bb6
    cond_br %91, ^bb5, ^bb6
  ^bb5:  // 2 preds: ^bb4, ^bb4
    %92 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %93 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    llvm.store %92, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %94 = ts.Variable(%92) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
    %95 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %96 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %97 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %98 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %99 = llvm.mlir.constant(1 : i64) : i64
    %100 = llvm.getelementptr %98[%99] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %101 = llvm.ptrtoint %100 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %102 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %103 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %104 = llvm.mlir.constant(1 : i64) : i64
    %105 = llvm.getelementptr %103[%104] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %106 = llvm.ptrtoint %105 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %107 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %108 = llvm.icmp "ult" %102, %107 : i64
    %109 = llvm.select %108, %102, %107 : i1, i64
    %110 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%96, %97, %109, %110) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%95, %94) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
    %111 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %112 = ts.Load(%95) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
    %113 = llvm.extractvalue %112[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %114 = ts.GetValueFromUnionOp %93 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %115 = llvm.mlir.constant(50 : i32) : i32
    %116 = llvm.zext %115 : i32 to i64
    %117 = zexti %115 : i32 to i64
    %118 = llvm.call @malloc(%117) : (i64) -> !llvm.ptr<i8>
    %119 = llvm.bitcast %118 : !llvm.ptr<i8> to !llvm.ptr<i8>
    %120 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
    %121 = llvm.mlir.constant(0 : i64) : i64
    %122 = llvm.getelementptr %120[%121, %121] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %123 = llvm.call @sprintf_s(%119, %115, %122, %113) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
    %124 = ts.Cast %114 : !ts.number to !ts.string
    %125 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
    %126 = llvm.mlir.constant(0 : i64) : i64
    %127 = llvm.getelementptr %125[%126, %126] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %128 = ts.Constant {value = " "} : !ts.string
    %129 = llvm.intr.stacksave : !llvm.ptr<i8>
    %130 = llvm.mlir.constant(1 : i64) : i64
    %131 = llvm.call @strlen(%24) : (!llvm.ptr<i8>) -> i64
    %132 = llvm.add %130, %131  : i64
    %133 = llvm.call @strlen(%127) : (!llvm.ptr<i8>) -> i64
    %134 = llvm.add %132, %133  : i64
    %135 = llvm.call @strlen(%119) : (!llvm.ptr<i8>) -> i64
    %136 = llvm.add %134, %135  : i64
    %137 = llvm.alloca %136 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
    %138 = llvm.call @strcpy(%137, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %139 = llvm.call @strcat(%138, %127) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %140 = llvm.call @strcat(%139, %119) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %141 = "ts.StringConcat"(%24, %128, %119) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
    %142 = llvm.call @puts(%141) : (!ts.string) -> i32
    llvm.intr.stackrestore %129
    ts.Print(%25, %124) : !ts.string, !ts.string
    llvm.br ^bb6
    br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
    %143 = llvm.call @puts(%28) : (!llvm.ptr<i8>) -> i32
    ts.Print(%29) : !ts.string
    llvm.return
    ts.ReturnInternal
  }
  func @main()
  ts.Func @main () -> ()  {
  }
  llvm.func @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x1b3ca893c50) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FuncOpConversion"
    ** Insert  : 'llvm.func'(0x1b3ca89d020)
    ** Erase   : 'func'(0x1b3ca893c50)
"`anonymous-namespace'::FuncOpConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x1b3ca89d020) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  llvm.func @strcat(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strcpy(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strlen(!llvm.ptr<i8>) -> i64
  llvm.func @sprintf_s(!llvm.ptr<i8>, i32, !llvm.ptr<i8>, ...) -> i32
  llvm.func @puts(!llvm.ptr<i8>) -> i32
  llvm.func @strcmp(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  llvm.func @llvm.memcpy.p0i8.p0i8.i64(!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1)
  llvm.mlir.global internal constant @s_9237349086447201248("number\00")
  llvm.mlir.global internal constant @s_13617892236937420068("b number: \00")
  llvm.mlir.global internal constant @s_6682479467004374669("done.\00")
  llvm.mlir.global internal constant @frmt_555404038213028357("%g\00")
  llvm.mlir.global internal constant @s_12638117931323064703(" \00")
  llvm.func @main() {
    %0 = llvm.mlir.constant(1 : i32) : i32
    %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %2 = llvm.mlir.constant(1 : i32) : i32
    %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %4 = llvm.mlir.constant(1 : i32) : i32
    %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %6 = llvm.mlir.constant(1 : i32) : i32
    %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %8 = llvm.mlir.constant(1 : i32) : i32
    %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %10 = llvm.mlir.constant(1 : i32) : i32
    %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
    %cst = constant 1.000000e+01 : f64
    %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %15 = llvm.mlir.constant(0 : i64) : i64
    %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %17 = ts.Constant {value = "number"} : !ts.string
    %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %19 = llvm.mlir.constant(0 : i64) : i64
    %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %21 = ts.Constant {value = "number"} : !ts.string
    %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
    %23 = llvm.mlir.constant(0 : i64) : i64
    %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %25 = ts.Constant {value = "b number: "} : !ts.string
    %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
    %27 = llvm.mlir.constant(0 : i64) : i64
    %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %29 = ts.Constant {value = "done."} : !ts.string
    %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
    %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %40 = llvm.mlir.constant(1 : i64) : i64
    %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %45 = llvm.mlir.constant(1 : i64) : i64
    %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %49 = llvm.icmp "ult" %43, %48 : i64
    %50 = llvm.select %49, %43, %48 : i1, i64
    %51 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
    %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
    %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
    %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %64 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
    %65 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
    llvm.store %63, %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %65, %31 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %66 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %67 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %68 = llvm.extractvalue %66[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %69 = ts.GetTypeInfoFromUnionOp %67 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
    %70 = llvm.mlir.constant(0 : i64) : i64
    %71 = llvm.ptrtoint %68 : !llvm.ptr<i8> to i64
    %72 = llvm.ptrtoint %20 : !llvm.ptr<i8> to i64
    %73 = llvm.icmp "ne" %71, %70 : i64
    %74 = llvm.icmp "ne" %72, %70 : i64
    %75 = llvm.zext %73 : i1 to i32
    %76 = zexti %73 : i1 to i32
    %77 = ts.Cast %73 : i1 to i32
    %78 = llvm.zext %74 : i1 to i32
    %79 = zexti %74 : i1 to i32
    %80 = ts.Cast %74 : i1 to i32
    %81 = llvm.and %77, %80  : i32
    %82 = llvm.mlir.constant(0 : i32) : i32
    %83 = llvm.icmp "ne" %81, %82 : i32
    llvm.cond_br %83, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %84 = llvm.mlir.constant(0 : i32) : i32
    %85 = llvm.call @strcmp(%68, %20) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
    %86 = llvm.icmp "eq" %85, %84 : i32
    llvm.br ^bb3(%86 : i1)
  ^bb2:  // pred: ^bb0
    %87 = llvm.icmp "eq" %71, %72 : i64
    llvm.br ^bb3(%87 : i1)
  ^bb3(%88: i1):  // 2 preds: ^bb1, ^bb2
    llvm.br ^bb4
  ^bb4:  // pred: ^bb3
    %89 = "ts.StringCompare"(%68, %20) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
    %90 = ts.LogicalBinary %69(34) %21 : !ts.string, !ts.string -> !ts.boolean
    %91 = ts.Cast %90 : !ts.boolean to i1
    llvm.cond_br %88, ^bb5, ^bb6
    cond_br %91, ^bb5, ^bb6
  ^bb5:  // 2 preds: ^bb4, ^bb4
    %92 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %93 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    llvm.store %92, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %94 = ts.Variable(%92) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
    %95 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %96 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %97 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %98 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %99 = llvm.mlir.constant(1 : i64) : i64
    %100 = llvm.getelementptr %98[%99] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %101 = llvm.ptrtoint %100 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %102 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %103 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %104 = llvm.mlir.constant(1 : i64) : i64
    %105 = llvm.getelementptr %103[%104] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %106 = llvm.ptrtoint %105 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %107 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %108 = llvm.icmp "ult" %102, %107 : i64
    %109 = llvm.select %108, %102, %107 : i1, i64
    %110 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%96, %97, %109, %110) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%95, %94) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
    %111 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %112 = ts.Load(%95) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
    %113 = llvm.extractvalue %112[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %114 = ts.GetValueFromUnionOp %93 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %115 = llvm.mlir.constant(50 : i32) : i32
    %116 = llvm.zext %115 : i32 to i64
    %117 = zexti %115 : i32 to i64
    %118 = llvm.call @malloc(%117) : (i64) -> !llvm.ptr<i8>
    %119 = llvm.bitcast %118 : !llvm.ptr<i8> to !llvm.ptr<i8>
    %120 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
    %121 = llvm.mlir.constant(0 : i64) : i64
    %122 = llvm.getelementptr %120[%121, %121] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %123 = llvm.call @sprintf_s(%119, %115, %122, %113) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
    %124 = ts.Cast %114 : !ts.number to !ts.string
    %125 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
    %126 = llvm.mlir.constant(0 : i64) : i64
    %127 = llvm.getelementptr %125[%126, %126] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %128 = ts.Constant {value = " "} : !ts.string
    %129 = llvm.intr.stacksave : !llvm.ptr<i8>
    %130 = llvm.mlir.constant(1 : i64) : i64
    %131 = llvm.call @strlen(%24) : (!llvm.ptr<i8>) -> i64
    %132 = llvm.add %130, %131  : i64
    %133 = llvm.call @strlen(%127) : (!llvm.ptr<i8>) -> i64
    %134 = llvm.add %132, %133  : i64
    %135 = llvm.call @strlen(%119) : (!llvm.ptr<i8>) -> i64
    %136 = llvm.add %134, %135  : i64
    %137 = llvm.alloca %136 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
    %138 = llvm.call @strcpy(%137, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %139 = llvm.call @strcat(%138, %127) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %140 = llvm.call @strcat(%139, %119) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %141 = "ts.StringConcat"(%24, %128, %119) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
    %142 = llvm.call @puts(%141) : (!ts.string) -> i32
    llvm.intr.stackrestore %129
    ts.Print(%25, %124) : !ts.string, !ts.string
    llvm.br ^bb6
    br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
    %143 = llvm.call @puts(%28) : (!llvm.ptr<i8>) -> i32
    ts.Print(%29) : !ts.string
    llvm.return
    ts.ReturnInternal
  }
  func @main()
  ts.Func @main () -> ()  {
  }
  llvm.func @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x1b3ca894d80) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FuncOpConversion"
    ** Insert  : 'llvm.func'(0x1b3ca89d2e0)
    ** Erase   : 'func'(0x1b3ca894d80)
"`anonymous-namespace'::FuncOpConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x1b3ca89d2e0) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  llvm.func @strcat(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strcpy(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strlen(!llvm.ptr<i8>) -> i64
  llvm.func @sprintf_s(!llvm.ptr<i8>, i32, !llvm.ptr<i8>, ...) -> i32
  llvm.func @puts(!llvm.ptr<i8>) -> i32
  llvm.func @strcmp(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  llvm.func @llvm.memcpy.p0i8.p0i8.i64(!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1)
  llvm.mlir.global internal constant @s_9237349086447201248("number\00")
  llvm.mlir.global internal constant @s_13617892236937420068("b number: \00")
  llvm.mlir.global internal constant @s_6682479467004374669("done.\00")
  llvm.mlir.global internal constant @frmt_555404038213028357("%g\00")
  llvm.mlir.global internal constant @s_12638117931323064703(" \00")
  llvm.func @main() {
    %0 = llvm.mlir.constant(1 : i32) : i32
    %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %2 = llvm.mlir.constant(1 : i32) : i32
    %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %4 = llvm.mlir.constant(1 : i32) : i32
    %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %6 = llvm.mlir.constant(1 : i32) : i32
    %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %8 = llvm.mlir.constant(1 : i32) : i32
    %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %10 = llvm.mlir.constant(1 : i32) : i32
    %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
    %cst = constant 1.000000e+01 : f64
    %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %15 = llvm.mlir.constant(0 : i64) : i64
    %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %17 = ts.Constant {value = "number"} : !ts.string
    %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %19 = llvm.mlir.constant(0 : i64) : i64
    %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %21 = ts.Constant {value = "number"} : !ts.string
    %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
    %23 = llvm.mlir.constant(0 : i64) : i64
    %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %25 = ts.Constant {value = "b number: "} : !ts.string
    %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
    %27 = llvm.mlir.constant(0 : i64) : i64
    %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %29 = ts.Constant {value = "done."} : !ts.string
    %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
    %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %40 = llvm.mlir.constant(1 : i64) : i64
    %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %45 = llvm.mlir.constant(1 : i64) : i64
    %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %49 = llvm.icmp "ult" %43, %48 : i64
    %50 = llvm.select %49, %43, %48 : i1, i64
    %51 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
    %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
    %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
    %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %64 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
    %65 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
    llvm.store %63, %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %65, %31 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %66 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %67 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %68 = llvm.extractvalue %66[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %69 = ts.GetTypeInfoFromUnionOp %67 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
    %70 = llvm.mlir.constant(0 : i64) : i64
    %71 = llvm.ptrtoint %68 : !llvm.ptr<i8> to i64
    %72 = llvm.ptrtoint %20 : !llvm.ptr<i8> to i64
    %73 = llvm.icmp "ne" %71, %70 : i64
    %74 = llvm.icmp "ne" %72, %70 : i64
    %75 = llvm.zext %73 : i1 to i32
    %76 = zexti %73 : i1 to i32
    %77 = ts.Cast %73 : i1 to i32
    %78 = llvm.zext %74 : i1 to i32
    %79 = zexti %74 : i1 to i32
    %80 = ts.Cast %74 : i1 to i32
    %81 = llvm.and %77, %80  : i32
    %82 = llvm.mlir.constant(0 : i32) : i32
    %83 = llvm.icmp "ne" %81, %82 : i32
    llvm.cond_br %83, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %84 = llvm.mlir.constant(0 : i32) : i32
    %85 = llvm.call @strcmp(%68, %20) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
    %86 = llvm.icmp "eq" %85, %84 : i32
    llvm.br ^bb3(%86 : i1)
  ^bb2:  // pred: ^bb0
    %87 = llvm.icmp "eq" %71, %72 : i64
    llvm.br ^bb3(%87 : i1)
  ^bb3(%88: i1):  // 2 preds: ^bb1, ^bb2
    llvm.br ^bb4
  ^bb4:  // pred: ^bb3
    %89 = "ts.StringCompare"(%68, %20) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
    %90 = ts.LogicalBinary %69(34) %21 : !ts.string, !ts.string -> !ts.boolean
    %91 = ts.Cast %90 : !ts.boolean to i1
    llvm.cond_br %88, ^bb5, ^bb6
    cond_br %91, ^bb5, ^bb6
  ^bb5:  // 2 preds: ^bb4, ^bb4
    %92 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %93 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    llvm.store %92, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %94 = ts.Variable(%92) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
    %95 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %96 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %97 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %98 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %99 = llvm.mlir.constant(1 : i64) : i64
    %100 = llvm.getelementptr %98[%99] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %101 = llvm.ptrtoint %100 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %102 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %103 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %104 = llvm.mlir.constant(1 : i64) : i64
    %105 = llvm.getelementptr %103[%104] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %106 = llvm.ptrtoint %105 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %107 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %108 = llvm.icmp "ult" %102, %107 : i64
    %109 = llvm.select %108, %102, %107 : i1, i64
    %110 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%96, %97, %109, %110) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%95, %94) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
    %111 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %112 = ts.Load(%95) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
    %113 = llvm.extractvalue %112[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %114 = ts.GetValueFromUnionOp %93 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %115 = llvm.mlir.constant(50 : i32) : i32
    %116 = llvm.zext %115 : i32 to i64
    %117 = zexti %115 : i32 to i64
    %118 = llvm.call @malloc(%117) : (i64) -> !llvm.ptr<i8>
    %119 = llvm.bitcast %118 : !llvm.ptr<i8> to !llvm.ptr<i8>
    %120 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
    %121 = llvm.mlir.constant(0 : i64) : i64
    %122 = llvm.getelementptr %120[%121, %121] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %123 = llvm.call @sprintf_s(%119, %115, %122, %113) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
    %124 = ts.Cast %114 : !ts.number to !ts.string
    %125 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
    %126 = llvm.mlir.constant(0 : i64) : i64
    %127 = llvm.getelementptr %125[%126, %126] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %128 = ts.Constant {value = " "} : !ts.string
    %129 = llvm.intr.stacksave : !llvm.ptr<i8>
    %130 = llvm.mlir.constant(1 : i64) : i64
    %131 = llvm.call @strlen(%24) : (!llvm.ptr<i8>) -> i64
    %132 = llvm.add %130, %131  : i64
    %133 = llvm.call @strlen(%127) : (!llvm.ptr<i8>) -> i64
    %134 = llvm.add %132, %133  : i64
    %135 = llvm.call @strlen(%119) : (!llvm.ptr<i8>) -> i64
    %136 = llvm.add %134, %135  : i64
    %137 = llvm.alloca %136 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
    %138 = llvm.call @strcpy(%137, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %139 = llvm.call @strcat(%138, %127) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %140 = llvm.call @strcat(%139, %119) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %141 = "ts.StringConcat"(%24, %128, %119) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
    %142 = llvm.call @puts(%141) : (!ts.string) -> i32
    llvm.intr.stackrestore %129
    ts.Print(%25, %124) : !ts.string, !ts.string
    llvm.br ^bb6
    br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
    %143 = llvm.call @puts(%28) : (!llvm.ptr<i8>) -> i32
    ts.Print(%29) : !ts.string
    llvm.return
    ts.ReturnInternal
  }
  func @main()
  ts.Func @main () -> ()  {
  }
  llvm.func @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x1b3ca8938e0) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FuncOpConversion"
    ** Insert  : 'llvm.func'(0x1b3ca89c680)
    ** Erase   : 'func'(0x1b3ca8938e0)
"`anonymous-namespace'::FuncOpConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x1b3ca89c680) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  llvm.func @strcat(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strcpy(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strlen(!llvm.ptr<i8>) -> i64
  llvm.func @sprintf_s(!llvm.ptr<i8>, i32, !llvm.ptr<i8>, ...) -> i32
  llvm.func @puts(!llvm.ptr<i8>) -> i32
  llvm.func @strcmp(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  llvm.func @llvm.memcpy.p0i8.p0i8.i64(!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1)
  llvm.mlir.global internal constant @s_9237349086447201248("number\00")
  llvm.mlir.global internal constant @s_13617892236937420068("b number: \00")
  llvm.mlir.global internal constant @s_6682479467004374669("done.\00")
  llvm.mlir.global internal constant @frmt_555404038213028357("%g\00")
  llvm.mlir.global internal constant @s_12638117931323064703(" \00")
  llvm.func @main() {
    %0 = llvm.mlir.constant(1 : i32) : i32
    %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %2 = llvm.mlir.constant(1 : i32) : i32
    %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %4 = llvm.mlir.constant(1 : i32) : i32
    %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %6 = llvm.mlir.constant(1 : i32) : i32
    %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %8 = llvm.mlir.constant(1 : i32) : i32
    %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %10 = llvm.mlir.constant(1 : i32) : i32
    %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
    %cst = constant 1.000000e+01 : f64
    %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %15 = llvm.mlir.constant(0 : i64) : i64
    %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %17 = ts.Constant {value = "number"} : !ts.string
    %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %19 = llvm.mlir.constant(0 : i64) : i64
    %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %21 = ts.Constant {value = "number"} : !ts.string
    %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
    %23 = llvm.mlir.constant(0 : i64) : i64
    %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %25 = ts.Constant {value = "b number: "} : !ts.string
    %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
    %27 = llvm.mlir.constant(0 : i64) : i64
    %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %29 = ts.Constant {value = "done."} : !ts.string
    %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
    %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %40 = llvm.mlir.constant(1 : i64) : i64
    %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %45 = llvm.mlir.constant(1 : i64) : i64
    %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %49 = llvm.icmp "ult" %43, %48 : i64
    %50 = llvm.select %49, %43, %48 : i1, i64
    %51 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
    %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
    %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
    %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %64 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
    %65 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
    llvm.store %63, %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %65, %31 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %66 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %67 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %68 = llvm.extractvalue %66[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %69 = ts.GetTypeInfoFromUnionOp %67 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
    %70 = llvm.mlir.constant(0 : i64) : i64
    %71 = llvm.ptrtoint %68 : !llvm.ptr<i8> to i64
    %72 = llvm.ptrtoint %20 : !llvm.ptr<i8> to i64
    %73 = llvm.icmp "ne" %71, %70 : i64
    %74 = llvm.icmp "ne" %72, %70 : i64
    %75 = llvm.zext %73 : i1 to i32
    %76 = zexti %73 : i1 to i32
    %77 = ts.Cast %73 : i1 to i32
    %78 = llvm.zext %74 : i1 to i32
    %79 = zexti %74 : i1 to i32
    %80 = ts.Cast %74 : i1 to i32
    %81 = llvm.and %77, %80  : i32
    %82 = llvm.mlir.constant(0 : i32) : i32
    %83 = llvm.icmp "ne" %81, %82 : i32
    llvm.cond_br %83, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %84 = llvm.mlir.constant(0 : i32) : i32
    %85 = llvm.call @strcmp(%68, %20) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
    %86 = llvm.icmp "eq" %85, %84 : i32
    llvm.br ^bb3(%86 : i1)
  ^bb2:  // pred: ^bb0
    %87 = llvm.icmp "eq" %71, %72 : i64
    llvm.br ^bb3(%87 : i1)
  ^bb3(%88: i1):  // 2 preds: ^bb1, ^bb2
    llvm.br ^bb4
  ^bb4:  // pred: ^bb3
    %89 = "ts.StringCompare"(%68, %20) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
    %90 = ts.LogicalBinary %69(34) %21 : !ts.string, !ts.string -> !ts.boolean
    %91 = ts.Cast %90 : !ts.boolean to i1
    llvm.cond_br %88, ^bb5, ^bb6
    cond_br %91, ^bb5, ^bb6
  ^bb5:  // 2 preds: ^bb4, ^bb4
    %92 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %93 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    llvm.store %92, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %94 = ts.Variable(%92) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
    %95 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %96 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %97 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %98 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %99 = llvm.mlir.constant(1 : i64) : i64
    %100 = llvm.getelementptr %98[%99] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %101 = llvm.ptrtoint %100 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %102 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %103 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %104 = llvm.mlir.constant(1 : i64) : i64
    %105 = llvm.getelementptr %103[%104] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %106 = llvm.ptrtoint %105 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %107 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %108 = llvm.icmp "ult" %102, %107 : i64
    %109 = llvm.select %108, %102, %107 : i1, i64
    %110 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%96, %97, %109, %110) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%95, %94) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
    %111 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %112 = ts.Load(%95) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
    %113 = llvm.extractvalue %112[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %114 = ts.GetValueFromUnionOp %93 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %115 = llvm.mlir.constant(50 : i32) : i32
    %116 = llvm.zext %115 : i32 to i64
    %117 = zexti %115 : i32 to i64
    %118 = llvm.call @malloc(%117) : (i64) -> !llvm.ptr<i8>
    %119 = llvm.bitcast %118 : !llvm.ptr<i8> to !llvm.ptr<i8>
    %120 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
    %121 = llvm.mlir.constant(0 : i64) : i64
    %122 = llvm.getelementptr %120[%121, %121] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %123 = llvm.call @sprintf_s(%119, %115, %122, %113) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
    %124 = ts.Cast %114 : !ts.number to !ts.string
    %125 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
    %126 = llvm.mlir.constant(0 : i64) : i64
    %127 = llvm.getelementptr %125[%126, %126] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %128 = ts.Constant {value = " "} : !ts.string
    %129 = llvm.intr.stacksave : !llvm.ptr<i8>
    %130 = llvm.mlir.constant(1 : i64) : i64
    %131 = llvm.call @strlen(%24) : (!llvm.ptr<i8>) -> i64
    %132 = llvm.add %130, %131  : i64
    %133 = llvm.call @strlen(%127) : (!llvm.ptr<i8>) -> i64
    %134 = llvm.add %132, %133  : i64
    %135 = llvm.call @strlen(%119) : (!llvm.ptr<i8>) -> i64
    %136 = llvm.add %134, %135  : i64
    %137 = llvm.alloca %136 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
    %138 = llvm.call @strcpy(%137, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %139 = llvm.call @strcat(%138, %127) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %140 = llvm.call @strcat(%139, %119) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %141 = "ts.StringConcat"(%24, %128, %119) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
    %142 = llvm.call @puts(%141) : (!ts.string) -> i32
    llvm.intr.stackrestore %129
    ts.Print(%25, %124) : !ts.string, !ts.string
    llvm.br ^bb6
    br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
    %143 = llvm.call @puts(%28) : (!llvm.ptr<i8>) -> i32
    ts.Print(%29) : !ts.string
    llvm.return
    ts.ReturnInternal
  }
  func @main()
  ts.Func @main () -> ()  {
  }
  llvm.func @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x1b3ca8932b0) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FuncOpConversion"
    ** Insert  : 'llvm.func'(0x1b3ca89b6b0)
    ** Erase   : 'func'(0x1b3ca8932b0)
"`anonymous-namespace'::FuncOpConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x1b3ca89b6b0) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  llvm.func @strcat(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strcpy(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strlen(!llvm.ptr<i8>) -> i64
  llvm.func @sprintf_s(!llvm.ptr<i8>, i32, !llvm.ptr<i8>, ...) -> i32
  llvm.func @puts(!llvm.ptr<i8>) -> i32
  llvm.func @strcmp(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  llvm.func @llvm.memcpy.p0i8.p0i8.i64(!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1)
  llvm.mlir.global internal constant @s_9237349086447201248("number\00")
  llvm.mlir.global internal constant @s_13617892236937420068("b number: \00")
  llvm.mlir.global internal constant @s_6682479467004374669("done.\00")
  llvm.mlir.global internal constant @frmt_555404038213028357("%g\00")
  llvm.mlir.global internal constant @s_12638117931323064703(" \00")
  llvm.func @main() {
    %0 = llvm.mlir.constant(1 : i32) : i32
    %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %2 = llvm.mlir.constant(1 : i32) : i32
    %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %4 = llvm.mlir.constant(1 : i32) : i32
    %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %6 = llvm.mlir.constant(1 : i32) : i32
    %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %8 = llvm.mlir.constant(1 : i32) : i32
    %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %10 = llvm.mlir.constant(1 : i32) : i32
    %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
    %cst = constant 1.000000e+01 : f64
    %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %15 = llvm.mlir.constant(0 : i64) : i64
    %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %17 = ts.Constant {value = "number"} : !ts.string
    %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %19 = llvm.mlir.constant(0 : i64) : i64
    %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %21 = ts.Constant {value = "number"} : !ts.string
    %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
    %23 = llvm.mlir.constant(0 : i64) : i64
    %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %25 = ts.Constant {value = "b number: "} : !ts.string
    %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
    %27 = llvm.mlir.constant(0 : i64) : i64
    %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %29 = ts.Constant {value = "done."} : !ts.string
    %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
    %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %40 = llvm.mlir.constant(1 : i64) : i64
    %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %45 = llvm.mlir.constant(1 : i64) : i64
    %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %49 = llvm.icmp "ult" %43, %48 : i64
    %50 = llvm.select %49, %43, %48 : i1, i64
    %51 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
    %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
    %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
    %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %64 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
    %65 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
    llvm.store %63, %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %65, %31 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %66 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %67 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %68 = llvm.extractvalue %66[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %69 = ts.GetTypeInfoFromUnionOp %67 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
    %70 = llvm.mlir.constant(0 : i64) : i64
    %71 = llvm.ptrtoint %68 : !llvm.ptr<i8> to i64
    %72 = llvm.ptrtoint %20 : !llvm.ptr<i8> to i64
    %73 = llvm.icmp "ne" %71, %70 : i64
    %74 = llvm.icmp "ne" %72, %70 : i64
    %75 = llvm.zext %73 : i1 to i32
    %76 = zexti %73 : i1 to i32
    %77 = ts.Cast %73 : i1 to i32
    %78 = llvm.zext %74 : i1 to i32
    %79 = zexti %74 : i1 to i32
    %80 = ts.Cast %74 : i1 to i32
    %81 = llvm.and %77, %80  : i32
    %82 = llvm.mlir.constant(0 : i32) : i32
    %83 = llvm.icmp "ne" %81, %82 : i32
    llvm.cond_br %83, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %84 = llvm.mlir.constant(0 : i32) : i32
    %85 = llvm.call @strcmp(%68, %20) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
    %86 = llvm.icmp "eq" %85, %84 : i32
    llvm.br ^bb3(%86 : i1)
  ^bb2:  // pred: ^bb0
    %87 = llvm.icmp "eq" %71, %72 : i64
    llvm.br ^bb3(%87 : i1)
  ^bb3(%88: i1):  // 2 preds: ^bb1, ^bb2
    llvm.br ^bb4
  ^bb4:  // pred: ^bb3
    %89 = "ts.StringCompare"(%68, %20) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
    %90 = ts.LogicalBinary %69(34) %21 : !ts.string, !ts.string -> !ts.boolean
    %91 = ts.Cast %90 : !ts.boolean to i1
    llvm.cond_br %88, ^bb5, ^bb6
    cond_br %91, ^bb5, ^bb6
  ^bb5:  // 2 preds: ^bb4, ^bb4
    %92 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %93 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    llvm.store %92, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %94 = ts.Variable(%92) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
    %95 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %96 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %97 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %98 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %99 = llvm.mlir.constant(1 : i64) : i64
    %100 = llvm.getelementptr %98[%99] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %101 = llvm.ptrtoint %100 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %102 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %103 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %104 = llvm.mlir.constant(1 : i64) : i64
    %105 = llvm.getelementptr %103[%104] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %106 = llvm.ptrtoint %105 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %107 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %108 = llvm.icmp "ult" %102, %107 : i64
    %109 = llvm.select %108, %102, %107 : i1, i64
    %110 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%96, %97, %109, %110) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%95, %94) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
    %111 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %112 = ts.Load(%95) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
    %113 = llvm.extractvalue %112[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %114 = ts.GetValueFromUnionOp %93 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %115 = llvm.mlir.constant(50 : i32) : i32
    %116 = llvm.zext %115 : i32 to i64
    %117 = zexti %115 : i32 to i64
    %118 = llvm.call @malloc(%117) : (i64) -> !llvm.ptr<i8>
    %119 = llvm.bitcast %118 : !llvm.ptr<i8> to !llvm.ptr<i8>
    %120 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
    %121 = llvm.mlir.constant(0 : i64) : i64
    %122 = llvm.getelementptr %120[%121, %121] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %123 = llvm.call @sprintf_s(%119, %115, %122, %113) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
    %124 = ts.Cast %114 : !ts.number to !ts.string
    %125 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
    %126 = llvm.mlir.constant(0 : i64) : i64
    %127 = llvm.getelementptr %125[%126, %126] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %128 = ts.Constant {value = " "} : !ts.string
    %129 = llvm.intr.stacksave : !llvm.ptr<i8>
    %130 = llvm.mlir.constant(1 : i64) : i64
    %131 = llvm.call @strlen(%24) : (!llvm.ptr<i8>) -> i64
    %132 = llvm.add %130, %131  : i64
    %133 = llvm.call @strlen(%127) : (!llvm.ptr<i8>) -> i64
    %134 = llvm.add %132, %133  : i64
    %135 = llvm.call @strlen(%119) : (!llvm.ptr<i8>) -> i64
    %136 = llvm.add %134, %135  : i64
    %137 = llvm.alloca %136 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
    %138 = llvm.call @strcpy(%137, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %139 = llvm.call @strcat(%138, %127) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %140 = llvm.call @strcat(%139, %119) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %141 = "ts.StringConcat"(%24, %128, %119) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
    %142 = llvm.call @puts(%141) : (!ts.string) -> i32
    llvm.intr.stackrestore %129
    ts.Print(%25, %124) : !ts.string, !ts.string
    llvm.br ^bb6
    br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
    %143 = llvm.call @puts(%28) : (!llvm.ptr<i8>) -> i32
    ts.Print(%29) : !ts.string
    llvm.return
    ts.ReturnInternal
  }
  func @main()
  ts.Func @main () -> ()  {
  }
  llvm.func @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x1b3ca894cd0) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FuncOpConversion"
    ** Insert  : 'llvm.func'(0x1b3ca89c100)
    ** Erase   : 'func'(0x1b3ca894cd0)
"`anonymous-namespace'::FuncOpConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x1b3ca89c100) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  llvm.func @strcat(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strcpy(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strlen(!llvm.ptr<i8>) -> i64
  llvm.func @sprintf_s(!llvm.ptr<i8>, i32, !llvm.ptr<i8>, ...) -> i32
  llvm.func @puts(!llvm.ptr<i8>) -> i32
  llvm.func @strcmp(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  llvm.func @llvm.memcpy.p0i8.p0i8.i64(!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1)
  llvm.mlir.global internal constant @s_9237349086447201248("number\00")
  llvm.mlir.global internal constant @s_13617892236937420068("b number: \00")
  llvm.mlir.global internal constant @s_6682479467004374669("done.\00")
  llvm.mlir.global internal constant @frmt_555404038213028357("%g\00")
  llvm.mlir.global internal constant @s_12638117931323064703(" \00")
  llvm.func @main() {
    %0 = llvm.mlir.constant(1 : i32) : i32
    %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %2 = llvm.mlir.constant(1 : i32) : i32
    %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %4 = llvm.mlir.constant(1 : i32) : i32
    %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %6 = llvm.mlir.constant(1 : i32) : i32
    %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %8 = llvm.mlir.constant(1 : i32) : i32
    %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %10 = llvm.mlir.constant(1 : i32) : i32
    %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
    %cst = constant 1.000000e+01 : f64
    %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %15 = llvm.mlir.constant(0 : i64) : i64
    %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %17 = ts.Constant {value = "number"} : !ts.string
    %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %19 = llvm.mlir.constant(0 : i64) : i64
    %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %21 = ts.Constant {value = "number"} : !ts.string
    %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
    %23 = llvm.mlir.constant(0 : i64) : i64
    %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %25 = ts.Constant {value = "b number: "} : !ts.string
    %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
    %27 = llvm.mlir.constant(0 : i64) : i64
    %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %29 = ts.Constant {value = "done."} : !ts.string
    %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
    %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %40 = llvm.mlir.constant(1 : i64) : i64
    %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %45 = llvm.mlir.constant(1 : i64) : i64
    %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %49 = llvm.icmp "ult" %43, %48 : i64
    %50 = llvm.select %49, %43, %48 : i1, i64
    %51 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
    %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
    %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
    %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %64 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
    %65 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
    llvm.store %63, %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %65, %31 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %66 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %67 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %68 = llvm.extractvalue %66[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %69 = ts.GetTypeInfoFromUnionOp %67 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
    %70 = llvm.mlir.constant(0 : i64) : i64
    %71 = llvm.ptrtoint %68 : !llvm.ptr<i8> to i64
    %72 = llvm.ptrtoint %20 : !llvm.ptr<i8> to i64
    %73 = llvm.icmp "ne" %71, %70 : i64
    %74 = llvm.icmp "ne" %72, %70 : i64
    %75 = llvm.zext %73 : i1 to i32
    %76 = zexti %73 : i1 to i32
    %77 = ts.Cast %73 : i1 to i32
    %78 = llvm.zext %74 : i1 to i32
    %79 = zexti %74 : i1 to i32
    %80 = ts.Cast %74 : i1 to i32
    %81 = llvm.and %77, %80  : i32
    %82 = llvm.mlir.constant(0 : i32) : i32
    %83 = llvm.icmp "ne" %81, %82 : i32
    llvm.cond_br %83, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %84 = llvm.mlir.constant(0 : i32) : i32
    %85 = llvm.call @strcmp(%68, %20) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
    %86 = llvm.icmp "eq" %85, %84 : i32
    llvm.br ^bb3(%86 : i1)
  ^bb2:  // pred: ^bb0
    %87 = llvm.icmp "eq" %71, %72 : i64
    llvm.br ^bb3(%87 : i1)
  ^bb3(%88: i1):  // 2 preds: ^bb1, ^bb2
    llvm.br ^bb4
  ^bb4:  // pred: ^bb3
    %89 = "ts.StringCompare"(%68, %20) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
    %90 = ts.LogicalBinary %69(34) %21 : !ts.string, !ts.string -> !ts.boolean
    %91 = ts.Cast %90 : !ts.boolean to i1
    llvm.cond_br %88, ^bb5, ^bb6
    cond_br %91, ^bb5, ^bb6
  ^bb5:  // 2 preds: ^bb4, ^bb4
    %92 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %93 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    llvm.store %92, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %94 = ts.Variable(%92) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
    %95 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %96 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %97 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %98 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %99 = llvm.mlir.constant(1 : i64) : i64
    %100 = llvm.getelementptr %98[%99] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %101 = llvm.ptrtoint %100 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %102 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %103 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %104 = llvm.mlir.constant(1 : i64) : i64
    %105 = llvm.getelementptr %103[%104] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %106 = llvm.ptrtoint %105 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %107 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %108 = llvm.icmp "ult" %102, %107 : i64
    %109 = llvm.select %108, %102, %107 : i1, i64
    %110 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%96, %97, %109, %110) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%95, %94) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
    %111 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %112 = ts.Load(%95) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
    %113 = llvm.extractvalue %112[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %114 = ts.GetValueFromUnionOp %93 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %115 = llvm.mlir.constant(50 : i32) : i32
    %116 = llvm.zext %115 : i32 to i64
    %117 = zexti %115 : i32 to i64
    %118 = llvm.call @malloc(%117) : (i64) -> !llvm.ptr<i8>
    %119 = llvm.bitcast %118 : !llvm.ptr<i8> to !llvm.ptr<i8>
    %120 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
    %121 = llvm.mlir.constant(0 : i64) : i64
    %122 = llvm.getelementptr %120[%121, %121] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %123 = llvm.call @sprintf_s(%119, %115, %122, %113) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
    %124 = ts.Cast %114 : !ts.number to !ts.string
    %125 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
    %126 = llvm.mlir.constant(0 : i64) : i64
    %127 = llvm.getelementptr %125[%126, %126] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %128 = ts.Constant {value = " "} : !ts.string
    %129 = llvm.intr.stacksave : !llvm.ptr<i8>
    %130 = llvm.mlir.constant(1 : i64) : i64
    %131 = llvm.call @strlen(%24) : (!llvm.ptr<i8>) -> i64
    %132 = llvm.add %130, %131  : i64
    %133 = llvm.call @strlen(%127) : (!llvm.ptr<i8>) -> i64
    %134 = llvm.add %132, %133  : i64
    %135 = llvm.call @strlen(%119) : (!llvm.ptr<i8>) -> i64
    %136 = llvm.add %134, %135  : i64
    %137 = llvm.alloca %136 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
    %138 = llvm.call @strcpy(%137, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %139 = llvm.call @strcat(%138, %127) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %140 = llvm.call @strcat(%139, %119) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %141 = "ts.StringConcat"(%24, %128, %119) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
    %142 = llvm.call @puts(%141) : (!ts.string) -> i32
    llvm.intr.stackrestore %129
    ts.Print(%25, %124) : !ts.string, !ts.string
    llvm.br ^bb6
    br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
    %143 = llvm.call @puts(%28) : (!llvm.ptr<i8>) -> i32
    ts.Print(%29) : !ts.string
    llvm.return
    ts.ReturnInternal
  }
  func @main()
  ts.Func @main () -> ()  {
  }
  llvm.func @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x1b3ca893360) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FuncOpConversion"
    ** Insert  : 'llvm.func'(0x1b3ca89b1e0)
    ** Erase   : 'func'(0x1b3ca893360)
"`anonymous-namespace'::FuncOpConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x1b3ca89b1e0) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  llvm.func @strcat(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strcpy(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strlen(!llvm.ptr<i8>) -> i64
  llvm.func @sprintf_s(!llvm.ptr<i8>, i32, !llvm.ptr<i8>, ...) -> i32
  llvm.func @puts(!llvm.ptr<i8>) -> i32
  llvm.func @strcmp(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  llvm.func @llvm.memcpy.p0i8.p0i8.i64(!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1)
  llvm.mlir.global internal constant @s_9237349086447201248("number\00")
  llvm.mlir.global internal constant @s_13617892236937420068("b number: \00")
  llvm.mlir.global internal constant @s_6682479467004374669("done.\00")
  llvm.mlir.global internal constant @frmt_555404038213028357("%g\00")
  llvm.mlir.global internal constant @s_12638117931323064703(" \00")
  llvm.func @main() {
    %0 = llvm.mlir.constant(1 : i32) : i32
    %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %2 = llvm.mlir.constant(1 : i32) : i32
    %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %4 = llvm.mlir.constant(1 : i32) : i32
    %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %6 = llvm.mlir.constant(1 : i32) : i32
    %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %8 = llvm.mlir.constant(1 : i32) : i32
    %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %10 = llvm.mlir.constant(1 : i32) : i32
    %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
    %cst = constant 1.000000e+01 : f64
    %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %15 = llvm.mlir.constant(0 : i64) : i64
    %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %17 = ts.Constant {value = "number"} : !ts.string
    %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %19 = llvm.mlir.constant(0 : i64) : i64
    %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %21 = ts.Constant {value = "number"} : !ts.string
    %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
    %23 = llvm.mlir.constant(0 : i64) : i64
    %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %25 = ts.Constant {value = "b number: "} : !ts.string
    %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
    %27 = llvm.mlir.constant(0 : i64) : i64
    %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %29 = ts.Constant {value = "done."} : !ts.string
    %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
    %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %40 = llvm.mlir.constant(1 : i64) : i64
    %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %45 = llvm.mlir.constant(1 : i64) : i64
    %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %49 = llvm.icmp "ult" %43, %48 : i64
    %50 = llvm.select %49, %43, %48 : i1, i64
    %51 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
    %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
    %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
    %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %64 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
    %65 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
    llvm.store %63, %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %65, %31 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %66 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %67 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %68 = llvm.extractvalue %66[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %69 = ts.GetTypeInfoFromUnionOp %67 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
    %70 = llvm.mlir.constant(0 : i64) : i64
    %71 = llvm.ptrtoint %68 : !llvm.ptr<i8> to i64
    %72 = llvm.ptrtoint %20 : !llvm.ptr<i8> to i64
    %73 = llvm.icmp "ne" %71, %70 : i64
    %74 = llvm.icmp "ne" %72, %70 : i64
    %75 = llvm.zext %73 : i1 to i32
    %76 = zexti %73 : i1 to i32
    %77 = ts.Cast %73 : i1 to i32
    %78 = llvm.zext %74 : i1 to i32
    %79 = zexti %74 : i1 to i32
    %80 = ts.Cast %74 : i1 to i32
    %81 = llvm.and %77, %80  : i32
    %82 = llvm.mlir.constant(0 : i32) : i32
    %83 = llvm.icmp "ne" %81, %82 : i32
    llvm.cond_br %83, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %84 = llvm.mlir.constant(0 : i32) : i32
    %85 = llvm.call @strcmp(%68, %20) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
    %86 = llvm.icmp "eq" %85, %84 : i32
    llvm.br ^bb3(%86 : i1)
  ^bb2:  // pred: ^bb0
    %87 = llvm.icmp "eq" %71, %72 : i64
    llvm.br ^bb3(%87 : i1)
  ^bb3(%88: i1):  // 2 preds: ^bb1, ^bb2
    llvm.br ^bb4
  ^bb4:  // pred: ^bb3
    %89 = "ts.StringCompare"(%68, %20) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
    %90 = ts.LogicalBinary %69(34) %21 : !ts.string, !ts.string -> !ts.boolean
    %91 = ts.Cast %90 : !ts.boolean to i1
    llvm.cond_br %88, ^bb5, ^bb6
    cond_br %91, ^bb5, ^bb6
  ^bb5:  // 2 preds: ^bb4, ^bb4
    %92 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %93 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    llvm.store %92, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %94 = ts.Variable(%92) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
    %95 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %96 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %97 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %98 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %99 = llvm.mlir.constant(1 : i64) : i64
    %100 = llvm.getelementptr %98[%99] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %101 = llvm.ptrtoint %100 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %102 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %103 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %104 = llvm.mlir.constant(1 : i64) : i64
    %105 = llvm.getelementptr %103[%104] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %106 = llvm.ptrtoint %105 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %107 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %108 = llvm.icmp "ult" %102, %107 : i64
    %109 = llvm.select %108, %102, %107 : i1, i64
    %110 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%96, %97, %109, %110) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%95, %94) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
    %111 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %112 = ts.Load(%95) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
    %113 = llvm.extractvalue %112[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %114 = ts.GetValueFromUnionOp %93 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %115 = llvm.mlir.constant(50 : i32) : i32
    %116 = llvm.zext %115 : i32 to i64
    %117 = zexti %115 : i32 to i64
    %118 = llvm.call @malloc(%117) : (i64) -> !llvm.ptr<i8>
    %119 = llvm.bitcast %118 : !llvm.ptr<i8> to !llvm.ptr<i8>
    %120 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
    %121 = llvm.mlir.constant(0 : i64) : i64
    %122 = llvm.getelementptr %120[%121, %121] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %123 = llvm.call @sprintf_s(%119, %115, %122, %113) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
    %124 = ts.Cast %114 : !ts.number to !ts.string
    %125 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
    %126 = llvm.mlir.constant(0 : i64) : i64
    %127 = llvm.getelementptr %125[%126, %126] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %128 = ts.Constant {value = " "} : !ts.string
    %129 = llvm.intr.stacksave : !llvm.ptr<i8>
    %130 = llvm.mlir.constant(1 : i64) : i64
    %131 = llvm.call @strlen(%24) : (!llvm.ptr<i8>) -> i64
    %132 = llvm.add %130, %131  : i64
    %133 = llvm.call @strlen(%127) : (!llvm.ptr<i8>) -> i64
    %134 = llvm.add %132, %133  : i64
    %135 = llvm.call @strlen(%119) : (!llvm.ptr<i8>) -> i64
    %136 = llvm.add %134, %135  : i64
    %137 = llvm.alloca %136 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
    %138 = llvm.call @strcpy(%137, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %139 = llvm.call @strcat(%138, %127) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %140 = llvm.call @strcat(%139, %119) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %141 = "ts.StringConcat"(%24, %128, %119) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
    %142 = llvm.call @puts(%141) : (!ts.string) -> i32
    llvm.intr.stackrestore %129
    ts.Print(%25, %124) : !ts.string, !ts.string
    llvm.br ^bb6
    br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
    %143 = llvm.call @puts(%28) : (!llvm.ptr<i8>) -> i32
    ts.Print(%29) : !ts.string
    llvm.return
    ts.ReturnInternal
  }
  func @main()
  ts.Func @main () -> ()  {
  }
  llvm.func @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x1b3ca8950f0) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FuncOpConversion"
    ** Insert  : 'llvm.func'(0x1b3ca89c9f0)
    ** Erase   : 'func'(0x1b3ca8950f0)
"`anonymous-namespace'::FuncOpConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x1b3ca89c9f0) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  llvm.func @strcat(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strcpy(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strlen(!llvm.ptr<i8>) -> i64
  llvm.func @sprintf_s(!llvm.ptr<i8>, i32, !llvm.ptr<i8>, ...) -> i32
  llvm.func @puts(!llvm.ptr<i8>) -> i32
  llvm.func @strcmp(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  llvm.func @llvm.memcpy.p0i8.p0i8.i64(!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1)
  llvm.mlir.global internal constant @s_9237349086447201248("number\00")
  llvm.mlir.global internal constant @s_13617892236937420068("b number: \00")
  llvm.mlir.global internal constant @s_6682479467004374669("done.\00")
  llvm.mlir.global internal constant @frmt_555404038213028357("%g\00")
  llvm.mlir.global internal constant @s_12638117931323064703(" \00")
  llvm.func @main() {
    %0 = llvm.mlir.constant(1 : i32) : i32
    %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %2 = llvm.mlir.constant(1 : i32) : i32
    %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %4 = llvm.mlir.constant(1 : i32) : i32
    %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %6 = llvm.mlir.constant(1 : i32) : i32
    %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %8 = llvm.mlir.constant(1 : i32) : i32
    %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %10 = llvm.mlir.constant(1 : i32) : i32
    %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
    %cst = constant 1.000000e+01 : f64
    %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %15 = llvm.mlir.constant(0 : i64) : i64
    %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %17 = ts.Constant {value = "number"} : !ts.string
    %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %19 = llvm.mlir.constant(0 : i64) : i64
    %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %21 = ts.Constant {value = "number"} : !ts.string
    %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
    %23 = llvm.mlir.constant(0 : i64) : i64
    %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %25 = ts.Constant {value = "b number: "} : !ts.string
    %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
    %27 = llvm.mlir.constant(0 : i64) : i64
    %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %29 = ts.Constant {value = "done."} : !ts.string
    %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
    %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %40 = llvm.mlir.constant(1 : i64) : i64
    %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %45 = llvm.mlir.constant(1 : i64) : i64
    %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %49 = llvm.icmp "ult" %43, %48 : i64
    %50 = llvm.select %49, %43, %48 : i1, i64
    %51 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
    %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
    %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
    %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %64 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
    %65 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
    llvm.store %63, %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %65, %31 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %66 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %67 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %68 = llvm.extractvalue %66[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %69 = ts.GetTypeInfoFromUnionOp %67 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
    %70 = llvm.mlir.constant(0 : i64) : i64
    %71 = llvm.ptrtoint %68 : !llvm.ptr<i8> to i64
    %72 = llvm.ptrtoint %20 : !llvm.ptr<i8> to i64
    %73 = llvm.icmp "ne" %71, %70 : i64
    %74 = llvm.icmp "ne" %72, %70 : i64
    %75 = llvm.zext %73 : i1 to i32
    %76 = zexti %73 : i1 to i32
    %77 = ts.Cast %73 : i1 to i32
    %78 = llvm.zext %74 : i1 to i32
    %79 = zexti %74 : i1 to i32
    %80 = ts.Cast %74 : i1 to i32
    %81 = llvm.and %77, %80  : i32
    %82 = llvm.mlir.constant(0 : i32) : i32
    %83 = llvm.icmp "ne" %81, %82 : i32
    llvm.cond_br %83, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %84 = llvm.mlir.constant(0 : i32) : i32
    %85 = llvm.call @strcmp(%68, %20) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
    %86 = llvm.icmp "eq" %85, %84 : i32
    llvm.br ^bb3(%86 : i1)
  ^bb2:  // pred: ^bb0
    %87 = llvm.icmp "eq" %71, %72 : i64
    llvm.br ^bb3(%87 : i1)
  ^bb3(%88: i1):  // 2 preds: ^bb1, ^bb2
    llvm.br ^bb4
  ^bb4:  // pred: ^bb3
    %89 = "ts.StringCompare"(%68, %20) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
    %90 = ts.LogicalBinary %69(34) %21 : !ts.string, !ts.string -> !ts.boolean
    %91 = ts.Cast %90 : !ts.boolean to i1
    llvm.cond_br %88, ^bb5, ^bb6
    cond_br %91, ^bb5, ^bb6
  ^bb5:  // 2 preds: ^bb4, ^bb4
    %92 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %93 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    llvm.store %92, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %94 = ts.Variable(%92) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
    %95 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %96 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %97 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %98 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %99 = llvm.mlir.constant(1 : i64) : i64
    %100 = llvm.getelementptr %98[%99] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %101 = llvm.ptrtoint %100 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %102 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %103 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %104 = llvm.mlir.constant(1 : i64) : i64
    %105 = llvm.getelementptr %103[%104] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %106 = llvm.ptrtoint %105 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %107 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %108 = llvm.icmp "ult" %102, %107 : i64
    %109 = llvm.select %108, %102, %107 : i1, i64
    %110 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%96, %97, %109, %110) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%95, %94) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
    %111 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %112 = ts.Load(%95) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
    %113 = llvm.extractvalue %112[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %114 = ts.GetValueFromUnionOp %93 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %115 = llvm.mlir.constant(50 : i32) : i32
    %116 = llvm.zext %115 : i32 to i64
    %117 = zexti %115 : i32 to i64
    %118 = llvm.call @malloc(%117) : (i64) -> !llvm.ptr<i8>
    %119 = llvm.bitcast %118 : !llvm.ptr<i8> to !llvm.ptr<i8>
    %120 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
    %121 = llvm.mlir.constant(0 : i64) : i64
    %122 = llvm.getelementptr %120[%121, %121] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %123 = llvm.call @sprintf_s(%119, %115, %122, %113) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
    %124 = ts.Cast %114 : !ts.number to !ts.string
    %125 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
    %126 = llvm.mlir.constant(0 : i64) : i64
    %127 = llvm.getelementptr %125[%126, %126] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %128 = ts.Constant {value = " "} : !ts.string
    %129 = llvm.intr.stacksave : !llvm.ptr<i8>
    %130 = llvm.mlir.constant(1 : i64) : i64
    %131 = llvm.call @strlen(%24) : (!llvm.ptr<i8>) -> i64
    %132 = llvm.add %130, %131  : i64
    %133 = llvm.call @strlen(%127) : (!llvm.ptr<i8>) -> i64
    %134 = llvm.add %132, %133  : i64
    %135 = llvm.call @strlen(%119) : (!llvm.ptr<i8>) -> i64
    %136 = llvm.add %134, %135  : i64
    %137 = llvm.alloca %136 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
    %138 = llvm.call @strcpy(%137, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %139 = llvm.call @strcat(%138, %127) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %140 = llvm.call @strcat(%139, %119) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %141 = "ts.StringConcat"(%24, %128, %119) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
    %142 = llvm.call @puts(%141) : (!ts.string) -> i32
    llvm.intr.stackrestore %129
    ts.Print(%25, %124) : !ts.string, !ts.string
    llvm.br ^bb6
    br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
    %143 = llvm.call @puts(%28) : (!llvm.ptr<i8>) -> i32
    ts.Print(%29) : !ts.string
    llvm.return
    ts.ReturnInternal
  }
  func @main()
  ts.Func @main () -> ()  {
  }
  llvm.func @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x1b3ca8929c0) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FuncOpConversion"
    ** Insert  : 'llvm.func'(0x1b3ca89bfa0)
    ** Erase   : 'func'(0x1b3ca8929c0)
"`anonymous-namespace'::FuncOpConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x1b3ca89bfa0) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  llvm.func @strcat(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strcpy(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strlen(!llvm.ptr<i8>) -> i64
  llvm.func @sprintf_s(!llvm.ptr<i8>, i32, !llvm.ptr<i8>, ...) -> i32
  llvm.func @puts(!llvm.ptr<i8>) -> i32
  llvm.func @strcmp(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  llvm.func @llvm.memcpy.p0i8.p0i8.i64(!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1)
  llvm.mlir.global internal constant @s_9237349086447201248("number\00")
  llvm.mlir.global internal constant @s_13617892236937420068("b number: \00")
  llvm.mlir.global internal constant @s_6682479467004374669("done.\00")
  llvm.mlir.global internal constant @frmt_555404038213028357("%g\00")
  llvm.mlir.global internal constant @s_12638117931323064703(" \00")
  llvm.func @main() {
    %0 = llvm.mlir.constant(1 : i32) : i32
    %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %2 = llvm.mlir.constant(1 : i32) : i32
    %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %4 = llvm.mlir.constant(1 : i32) : i32
    %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %6 = llvm.mlir.constant(1 : i32) : i32
    %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %8 = llvm.mlir.constant(1 : i32) : i32
    %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %10 = llvm.mlir.constant(1 : i32) : i32
    %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
    %cst = constant 1.000000e+01 : f64
    %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %15 = llvm.mlir.constant(0 : i64) : i64
    %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %17 = ts.Constant {value = "number"} : !ts.string
    %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %19 = llvm.mlir.constant(0 : i64) : i64
    %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %21 = ts.Constant {value = "number"} : !ts.string
    %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
    %23 = llvm.mlir.constant(0 : i64) : i64
    %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %25 = ts.Constant {value = "b number: "} : !ts.string
    %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
    %27 = llvm.mlir.constant(0 : i64) : i64
    %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %29 = ts.Constant {value = "done."} : !ts.string
    %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
    %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %40 = llvm.mlir.constant(1 : i64) : i64
    %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %45 = llvm.mlir.constant(1 : i64) : i64
    %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %49 = llvm.icmp "ult" %43, %48 : i64
    %50 = llvm.select %49, %43, %48 : i1, i64
    %51 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
    %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
    %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
    %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %64 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
    %65 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
    llvm.store %63, %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %65, %31 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %66 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %67 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %68 = llvm.extractvalue %66[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %69 = ts.GetTypeInfoFromUnionOp %67 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
    %70 = llvm.mlir.constant(0 : i64) : i64
    %71 = llvm.ptrtoint %68 : !llvm.ptr<i8> to i64
    %72 = llvm.ptrtoint %20 : !llvm.ptr<i8> to i64
    %73 = llvm.icmp "ne" %71, %70 : i64
    %74 = llvm.icmp "ne" %72, %70 : i64
    %75 = llvm.zext %73 : i1 to i32
    %76 = zexti %73 : i1 to i32
    %77 = ts.Cast %73 : i1 to i32
    %78 = llvm.zext %74 : i1 to i32
    %79 = zexti %74 : i1 to i32
    %80 = ts.Cast %74 : i1 to i32
    %81 = llvm.and %77, %80  : i32
    %82 = llvm.mlir.constant(0 : i32) : i32
    %83 = llvm.icmp "ne" %81, %82 : i32
    llvm.cond_br %83, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %84 = llvm.mlir.constant(0 : i32) : i32
    %85 = llvm.call @strcmp(%68, %20) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
    %86 = llvm.icmp "eq" %85, %84 : i32
    llvm.br ^bb3(%86 : i1)
  ^bb2:  // pred: ^bb0
    %87 = llvm.icmp "eq" %71, %72 : i64
    llvm.br ^bb3(%87 : i1)
  ^bb3(%88: i1):  // 2 preds: ^bb1, ^bb2
    llvm.br ^bb4
  ^bb4:  // pred: ^bb3
    %89 = "ts.StringCompare"(%68, %20) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
    %90 = ts.LogicalBinary %69(34) %21 : !ts.string, !ts.string -> !ts.boolean
    %91 = ts.Cast %90 : !ts.boolean to i1
    llvm.cond_br %88, ^bb5, ^bb6
    cond_br %91, ^bb5, ^bb6
  ^bb5:  // 2 preds: ^bb4, ^bb4
    %92 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %93 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    llvm.store %92, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %94 = ts.Variable(%92) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
    %95 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %96 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %97 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %98 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %99 = llvm.mlir.constant(1 : i64) : i64
    %100 = llvm.getelementptr %98[%99] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %101 = llvm.ptrtoint %100 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %102 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %103 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %104 = llvm.mlir.constant(1 : i64) : i64
    %105 = llvm.getelementptr %103[%104] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %106 = llvm.ptrtoint %105 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %107 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %108 = llvm.icmp "ult" %102, %107 : i64
    %109 = llvm.select %108, %102, %107 : i1, i64
    %110 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%96, %97, %109, %110) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%95, %94) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
    %111 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %112 = ts.Load(%95) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
    %113 = llvm.extractvalue %112[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %114 = ts.GetValueFromUnionOp %93 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %115 = llvm.mlir.constant(50 : i32) : i32
    %116 = llvm.zext %115 : i32 to i64
    %117 = zexti %115 : i32 to i64
    %118 = llvm.call @malloc(%117) : (i64) -> !llvm.ptr<i8>
    %119 = llvm.bitcast %118 : !llvm.ptr<i8> to !llvm.ptr<i8>
    %120 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
    %121 = llvm.mlir.constant(0 : i64) : i64
    %122 = llvm.getelementptr %120[%121, %121] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %123 = llvm.call @sprintf_s(%119, %115, %122, %113) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
    %124 = ts.Cast %114 : !ts.number to !ts.string
    %125 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
    %126 = llvm.mlir.constant(0 : i64) : i64
    %127 = llvm.getelementptr %125[%126, %126] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %128 = ts.Constant {value = " "} : !ts.string
    %129 = llvm.intr.stacksave : !llvm.ptr<i8>
    %130 = llvm.mlir.constant(1 : i64) : i64
    %131 = llvm.call @strlen(%24) : (!llvm.ptr<i8>) -> i64
    %132 = llvm.add %130, %131  : i64
    %133 = llvm.call @strlen(%127) : (!llvm.ptr<i8>) -> i64
    %134 = llvm.add %132, %133  : i64
    %135 = llvm.call @strlen(%119) : (!llvm.ptr<i8>) -> i64
    %136 = llvm.add %134, %135  : i64
    %137 = llvm.alloca %136 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
    %138 = llvm.call @strcpy(%137, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %139 = llvm.call @strcat(%138, %127) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %140 = llvm.call @strcat(%139, %119) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %141 = "ts.StringConcat"(%24, %128, %119) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
    %142 = llvm.call @puts(%141) : (!ts.string) -> i32
    llvm.intr.stackrestore %129
    ts.Print(%25, %124) : !ts.string, !ts.string
    llvm.br ^bb6
    br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
    %143 = llvm.call @puts(%28) : (!llvm.ptr<i8>) -> i32
    ts.Print(%29) : !ts.string
    llvm.return
    ts.ReturnInternal
  }
  func @main()
  ts.Func @main () -> ()  {
  }
  llvm.func @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x1b3ca894ee0) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FuncOpConversion"
    ** Insert  : 'llvm.func'(0x1b3ca89caa0)
    ** Erase   : 'func'(0x1b3ca894ee0)
"`anonymous-namespace'::FuncOpConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x1b3ca89caa0) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  llvm.func @strcat(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strcpy(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strlen(!llvm.ptr<i8>) -> i64
  llvm.func @sprintf_s(!llvm.ptr<i8>, i32, !llvm.ptr<i8>, ...) -> i32
  llvm.func @puts(!llvm.ptr<i8>) -> i32
  llvm.func @strcmp(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  llvm.func @llvm.memcpy.p0i8.p0i8.i64(!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1)
  llvm.mlir.global internal constant @s_9237349086447201248("number\00")
  llvm.mlir.global internal constant @s_13617892236937420068("b number: \00")
  llvm.mlir.global internal constant @s_6682479467004374669("done.\00")
  llvm.mlir.global internal constant @frmt_555404038213028357("%g\00")
  llvm.mlir.global internal constant @s_12638117931323064703(" \00")
  llvm.func @main() {
    %0 = llvm.mlir.constant(1 : i32) : i32
    %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %2 = llvm.mlir.constant(1 : i32) : i32
    %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %4 = llvm.mlir.constant(1 : i32) : i32
    %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %6 = llvm.mlir.constant(1 : i32) : i32
    %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %8 = llvm.mlir.constant(1 : i32) : i32
    %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %10 = llvm.mlir.constant(1 : i32) : i32
    %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
    %cst = constant 1.000000e+01 : f64
    %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %15 = llvm.mlir.constant(0 : i64) : i64
    %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %17 = ts.Constant {value = "number"} : !ts.string
    %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %19 = llvm.mlir.constant(0 : i64) : i64
    %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %21 = ts.Constant {value = "number"} : !ts.string
    %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
    %23 = llvm.mlir.constant(0 : i64) : i64
    %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %25 = ts.Constant {value = "b number: "} : !ts.string
    %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
    %27 = llvm.mlir.constant(0 : i64) : i64
    %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %29 = ts.Constant {value = "done."} : !ts.string
    %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
    %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %40 = llvm.mlir.constant(1 : i64) : i64
    %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %45 = llvm.mlir.constant(1 : i64) : i64
    %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %49 = llvm.icmp "ult" %43, %48 : i64
    %50 = llvm.select %49, %43, %48 : i1, i64
    %51 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
    %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
    %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
    %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %64 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
    %65 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
    llvm.store %63, %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %65, %31 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %66 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %67 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %68 = llvm.extractvalue %66[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %69 = ts.GetTypeInfoFromUnionOp %67 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
    %70 = llvm.mlir.constant(0 : i64) : i64
    %71 = llvm.ptrtoint %68 : !llvm.ptr<i8> to i64
    %72 = llvm.ptrtoint %20 : !llvm.ptr<i8> to i64
    %73 = llvm.icmp "ne" %71, %70 : i64
    %74 = llvm.icmp "ne" %72, %70 : i64
    %75 = llvm.zext %73 : i1 to i32
    %76 = zexti %73 : i1 to i32
    %77 = ts.Cast %73 : i1 to i32
    %78 = llvm.zext %74 : i1 to i32
    %79 = zexti %74 : i1 to i32
    %80 = ts.Cast %74 : i1 to i32
    %81 = llvm.and %77, %80  : i32
    %82 = llvm.mlir.constant(0 : i32) : i32
    %83 = llvm.icmp "ne" %81, %82 : i32
    llvm.cond_br %83, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %84 = llvm.mlir.constant(0 : i32) : i32
    %85 = llvm.call @strcmp(%68, %20) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
    %86 = llvm.icmp "eq" %85, %84 : i32
    llvm.br ^bb3(%86 : i1)
  ^bb2:  // pred: ^bb0
    %87 = llvm.icmp "eq" %71, %72 : i64
    llvm.br ^bb3(%87 : i1)
  ^bb3(%88: i1):  // 2 preds: ^bb1, ^bb2
    llvm.br ^bb4
  ^bb4:  // pred: ^bb3
    %89 = "ts.StringCompare"(%68, %20) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
    %90 = ts.LogicalBinary %69(34) %21 : !ts.string, !ts.string -> !ts.boolean
    %91 = ts.Cast %90 : !ts.boolean to i1
    llvm.cond_br %88, ^bb5, ^bb6
    cond_br %91, ^bb5, ^bb6
  ^bb5:  // 2 preds: ^bb4, ^bb4
    %92 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %93 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    llvm.store %92, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %94 = ts.Variable(%92) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
    %95 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %96 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %97 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %98 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %99 = llvm.mlir.constant(1 : i64) : i64
    %100 = llvm.getelementptr %98[%99] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %101 = llvm.ptrtoint %100 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %102 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %103 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %104 = llvm.mlir.constant(1 : i64) : i64
    %105 = llvm.getelementptr %103[%104] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %106 = llvm.ptrtoint %105 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %107 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %108 = llvm.icmp "ult" %102, %107 : i64
    %109 = llvm.select %108, %102, %107 : i1, i64
    %110 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%96, %97, %109, %110) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%95, %94) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
    %111 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %112 = ts.Load(%95) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
    %113 = llvm.extractvalue %112[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %114 = ts.GetValueFromUnionOp %93 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %115 = llvm.mlir.constant(50 : i32) : i32
    %116 = llvm.zext %115 : i32 to i64
    %117 = zexti %115 : i32 to i64
    %118 = llvm.call @malloc(%117) : (i64) -> !llvm.ptr<i8>
    %119 = llvm.bitcast %118 : !llvm.ptr<i8> to !llvm.ptr<i8>
    %120 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
    %121 = llvm.mlir.constant(0 : i64) : i64
    %122 = llvm.getelementptr %120[%121, %121] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %123 = llvm.call @sprintf_s(%119, %115, %122, %113) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
    %124 = ts.Cast %114 : !ts.number to !ts.string
    %125 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
    %126 = llvm.mlir.constant(0 : i64) : i64
    %127 = llvm.getelementptr %125[%126, %126] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %128 = ts.Constant {value = " "} : !ts.string
    %129 = llvm.intr.stacksave : !llvm.ptr<i8>
    %130 = llvm.mlir.constant(1 : i64) : i64
    %131 = llvm.call @strlen(%24) : (!llvm.ptr<i8>) -> i64
    %132 = llvm.add %130, %131  : i64
    %133 = llvm.call @strlen(%127) : (!llvm.ptr<i8>) -> i64
    %134 = llvm.add %132, %133  : i64
    %135 = llvm.call @strlen(%119) : (!llvm.ptr<i8>) -> i64
    %136 = llvm.add %134, %135  : i64
    %137 = llvm.alloca %136 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
    %138 = llvm.call @strcpy(%137, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %139 = llvm.call @strcat(%138, %127) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %140 = llvm.call @strcat(%139, %119) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %141 = "ts.StringConcat"(%24, %128, %119) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
    %142 = llvm.call @puts(%141) : (!ts.string) -> i32
    llvm.intr.stackrestore %129
    ts.Print(%25, %124) : !ts.string, !ts.string
    llvm.br ^bb6
    br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
    %143 = llvm.call @puts(%28) : (!llvm.ptr<i8>) -> i32
    ts.Print(%29) : !ts.string
    llvm.return
    ts.ReturnInternal
  }
  func @main()
  ts.Func @main () -> ()  {
  }
  llvm.func @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x1b3ca8925a0) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FuncOpConversion"
    ** Insert  : 'llvm.func'(0x1b3ca89b290)
    ** Erase   : 'func'(0x1b3ca8925a0)
"`anonymous-namespace'::FuncOpConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x1b3ca89b290) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  llvm.func @strcat(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strcpy(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strlen(!llvm.ptr<i8>) -> i64
  llvm.func @sprintf_s(!llvm.ptr<i8>, i32, !llvm.ptr<i8>, ...) -> i32
  llvm.func @puts(!llvm.ptr<i8>) -> i32
  llvm.func @strcmp(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  llvm.func @llvm.memcpy.p0i8.p0i8.i64(!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1)
  llvm.mlir.global internal constant @s_9237349086447201248("number\00")
  llvm.mlir.global internal constant @s_13617892236937420068("b number: \00")
  llvm.mlir.global internal constant @s_6682479467004374669("done.\00")
  llvm.mlir.global internal constant @frmt_555404038213028357("%g\00")
  llvm.mlir.global internal constant @s_12638117931323064703(" \00")
  llvm.func @main() {
    %0 = llvm.mlir.constant(1 : i32) : i32
    %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %2 = llvm.mlir.constant(1 : i32) : i32
    %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %4 = llvm.mlir.constant(1 : i32) : i32
    %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %6 = llvm.mlir.constant(1 : i32) : i32
    %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %8 = llvm.mlir.constant(1 : i32) : i32
    %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %10 = llvm.mlir.constant(1 : i32) : i32
    %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
    %cst = constant 1.000000e+01 : f64
    %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %15 = llvm.mlir.constant(0 : i64) : i64
    %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %17 = ts.Constant {value = "number"} : !ts.string
    %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %19 = llvm.mlir.constant(0 : i64) : i64
    %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %21 = ts.Constant {value = "number"} : !ts.string
    %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
    %23 = llvm.mlir.constant(0 : i64) : i64
    %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %25 = ts.Constant {value = "b number: "} : !ts.string
    %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
    %27 = llvm.mlir.constant(0 : i64) : i64
    %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %29 = ts.Constant {value = "done."} : !ts.string
    %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
    %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %40 = llvm.mlir.constant(1 : i64) : i64
    %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %45 = llvm.mlir.constant(1 : i64) : i64
    %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %49 = llvm.icmp "ult" %43, %48 : i64
    %50 = llvm.select %49, %43, %48 : i1, i64
    %51 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
    %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
    %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
    %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %64 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
    %65 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
    llvm.store %63, %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %65, %31 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %66 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %67 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %68 = llvm.extractvalue %66[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %69 = ts.GetTypeInfoFromUnionOp %67 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
    %70 = llvm.mlir.constant(0 : i64) : i64
    %71 = llvm.ptrtoint %68 : !llvm.ptr<i8> to i64
    %72 = llvm.ptrtoint %20 : !llvm.ptr<i8> to i64
    %73 = llvm.icmp "ne" %71, %70 : i64
    %74 = llvm.icmp "ne" %72, %70 : i64
    %75 = llvm.zext %73 : i1 to i32
    %76 = zexti %73 : i1 to i32
    %77 = ts.Cast %73 : i1 to i32
    %78 = llvm.zext %74 : i1 to i32
    %79 = zexti %74 : i1 to i32
    %80 = ts.Cast %74 : i1 to i32
    %81 = llvm.and %77, %80  : i32
    %82 = llvm.mlir.constant(0 : i32) : i32
    %83 = llvm.icmp "ne" %81, %82 : i32
    llvm.cond_br %83, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %84 = llvm.mlir.constant(0 : i32) : i32
    %85 = llvm.call @strcmp(%68, %20) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
    %86 = llvm.icmp "eq" %85, %84 : i32
    llvm.br ^bb3(%86 : i1)
  ^bb2:  // pred: ^bb0
    %87 = llvm.icmp "eq" %71, %72 : i64
    llvm.br ^bb3(%87 : i1)
  ^bb3(%88: i1):  // 2 preds: ^bb1, ^bb2
    llvm.br ^bb4
  ^bb4:  // pred: ^bb3
    %89 = "ts.StringCompare"(%68, %20) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
    %90 = ts.LogicalBinary %69(34) %21 : !ts.string, !ts.string -> !ts.boolean
    %91 = ts.Cast %90 : !ts.boolean to i1
    llvm.cond_br %88, ^bb5, ^bb6
    cond_br %91, ^bb5, ^bb6
  ^bb5:  // 2 preds: ^bb4, ^bb4
    %92 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %93 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    llvm.store %92, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %94 = ts.Variable(%92) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
    %95 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %96 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %97 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %98 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %99 = llvm.mlir.constant(1 : i64) : i64
    %100 = llvm.getelementptr %98[%99] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %101 = llvm.ptrtoint %100 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %102 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %103 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %104 = llvm.mlir.constant(1 : i64) : i64
    %105 = llvm.getelementptr %103[%104] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %106 = llvm.ptrtoint %105 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %107 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %108 = llvm.icmp "ult" %102, %107 : i64
    %109 = llvm.select %108, %102, %107 : i1, i64
    %110 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%96, %97, %109, %110) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%95, %94) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
    %111 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %112 = ts.Load(%95) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
    %113 = llvm.extractvalue %112[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %114 = ts.GetValueFromUnionOp %93 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %115 = llvm.mlir.constant(50 : i32) : i32
    %116 = llvm.zext %115 : i32 to i64
    %117 = zexti %115 : i32 to i64
    %118 = llvm.call @malloc(%117) : (i64) -> !llvm.ptr<i8>
    %119 = llvm.bitcast %118 : !llvm.ptr<i8> to !llvm.ptr<i8>
    %120 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
    %121 = llvm.mlir.constant(0 : i64) : i64
    %122 = llvm.getelementptr %120[%121, %121] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %123 = llvm.call @sprintf_s(%119, %115, %122, %113) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
    %124 = ts.Cast %114 : !ts.number to !ts.string
    %125 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
    %126 = llvm.mlir.constant(0 : i64) : i64
    %127 = llvm.getelementptr %125[%126, %126] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %128 = ts.Constant {value = " "} : !ts.string
    %129 = llvm.intr.stacksave : !llvm.ptr<i8>
    %130 = llvm.mlir.constant(1 : i64) : i64
    %131 = llvm.call @strlen(%24) : (!llvm.ptr<i8>) -> i64
    %132 = llvm.add %130, %131  : i64
    %133 = llvm.call @strlen(%127) : (!llvm.ptr<i8>) -> i64
    %134 = llvm.add %132, %133  : i64
    %135 = llvm.call @strlen(%119) : (!llvm.ptr<i8>) -> i64
    %136 = llvm.add %134, %135  : i64
    %137 = llvm.alloca %136 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
    %138 = llvm.call @strcpy(%137, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %139 = llvm.call @strcat(%138, %127) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %140 = llvm.call @strcat(%139, %119) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %141 = "ts.StringConcat"(%24, %128, %119) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
    %142 = llvm.call @puts(%141) : (!ts.string) -> i32
    llvm.intr.stackrestore %129
    ts.Print(%25, %124) : !ts.string, !ts.string
    llvm.br ^bb6
    br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
    %143 = llvm.call @puts(%28) : (!llvm.ptr<i8>) -> i32
    ts.Print(%29) : !ts.string
    llvm.return
    ts.ReturnInternal
  }
  func @main()
  ts.Func @main () -> ()  {
  }
  llvm.func @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x1b3ca892650) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FuncOpConversion"
    ** Insert  : 'llvm.func'(0x1b3ca89ab00)
    ** Erase   : 'func'(0x1b3ca892650)
"`anonymous-namespace'::FuncOpConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x1b3ca89ab00) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  llvm.func @strcat(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strcpy(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strlen(!llvm.ptr<i8>) -> i64
  llvm.func @sprintf_s(!llvm.ptr<i8>, i32, !llvm.ptr<i8>, ...) -> i32
  llvm.func @puts(!llvm.ptr<i8>) -> i32
  llvm.func @strcmp(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  llvm.func @llvm.memcpy.p0i8.p0i8.i64(!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1)
  llvm.mlir.global internal constant @s_9237349086447201248("number\00")
  llvm.mlir.global internal constant @s_13617892236937420068("b number: \00")
  llvm.mlir.global internal constant @s_6682479467004374669("done.\00")
  llvm.mlir.global internal constant @frmt_555404038213028357("%g\00")
  llvm.mlir.global internal constant @s_12638117931323064703(" \00")
  llvm.func @main() {
    %0 = llvm.mlir.constant(1 : i32) : i32
    %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %2 = llvm.mlir.constant(1 : i32) : i32
    %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %4 = llvm.mlir.constant(1 : i32) : i32
    %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %6 = llvm.mlir.constant(1 : i32) : i32
    %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %8 = llvm.mlir.constant(1 : i32) : i32
    %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %10 = llvm.mlir.constant(1 : i32) : i32
    %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
    %cst = constant 1.000000e+01 : f64
    %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %15 = llvm.mlir.constant(0 : i64) : i64
    %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %17 = ts.Constant {value = "number"} : !ts.string
    %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %19 = llvm.mlir.constant(0 : i64) : i64
    %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %21 = ts.Constant {value = "number"} : !ts.string
    %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
    %23 = llvm.mlir.constant(0 : i64) : i64
    %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %25 = ts.Constant {value = "b number: "} : !ts.string
    %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
    %27 = llvm.mlir.constant(0 : i64) : i64
    %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %29 = ts.Constant {value = "done."} : !ts.string
    %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
    %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %40 = llvm.mlir.constant(1 : i64) : i64
    %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %45 = llvm.mlir.constant(1 : i64) : i64
    %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %49 = llvm.icmp "ult" %43, %48 : i64
    %50 = llvm.select %49, %43, %48 : i1, i64
    %51 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
    %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
    %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
    %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %64 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
    %65 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
    llvm.store %63, %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %65, %31 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %66 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %67 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %68 = llvm.extractvalue %66[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %69 = ts.GetTypeInfoFromUnionOp %67 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
    %70 = llvm.mlir.constant(0 : i64) : i64
    %71 = llvm.ptrtoint %68 : !llvm.ptr<i8> to i64
    %72 = llvm.ptrtoint %20 : !llvm.ptr<i8> to i64
    %73 = llvm.icmp "ne" %71, %70 : i64
    %74 = llvm.icmp "ne" %72, %70 : i64
    %75 = llvm.zext %73 : i1 to i32
    %76 = zexti %73 : i1 to i32
    %77 = ts.Cast %73 : i1 to i32
    %78 = llvm.zext %74 : i1 to i32
    %79 = zexti %74 : i1 to i32
    %80 = ts.Cast %74 : i1 to i32
    %81 = llvm.and %77, %80  : i32
    %82 = llvm.mlir.constant(0 : i32) : i32
    %83 = llvm.icmp "ne" %81, %82 : i32
    llvm.cond_br %83, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %84 = llvm.mlir.constant(0 : i32) : i32
    %85 = llvm.call @strcmp(%68, %20) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
    %86 = llvm.icmp "eq" %85, %84 : i32
    llvm.br ^bb3(%86 : i1)
  ^bb2:  // pred: ^bb0
    %87 = llvm.icmp "eq" %71, %72 : i64
    llvm.br ^bb3(%87 : i1)
  ^bb3(%88: i1):  // 2 preds: ^bb1, ^bb2
    llvm.br ^bb4
  ^bb4:  // pred: ^bb3
    %89 = "ts.StringCompare"(%68, %20) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
    %90 = ts.LogicalBinary %69(34) %21 : !ts.string, !ts.string -> !ts.boolean
    %91 = ts.Cast %90 : !ts.boolean to i1
    llvm.cond_br %88, ^bb5, ^bb6
    cond_br %91, ^bb5, ^bb6
  ^bb5:  // 2 preds: ^bb4, ^bb4
    %92 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %93 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    llvm.store %92, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %94 = ts.Variable(%92) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
    %95 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %96 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %97 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %98 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %99 = llvm.mlir.constant(1 : i64) : i64
    %100 = llvm.getelementptr %98[%99] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %101 = llvm.ptrtoint %100 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %102 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %103 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %104 = llvm.mlir.constant(1 : i64) : i64
    %105 = llvm.getelementptr %103[%104] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %106 = llvm.ptrtoint %105 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %107 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %108 = llvm.icmp "ult" %102, %107 : i64
    %109 = llvm.select %108, %102, %107 : i1, i64
    %110 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%96, %97, %109, %110) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%95, %94) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
    %111 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %112 = ts.Load(%95) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
    %113 = llvm.extractvalue %112[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %114 = ts.GetValueFromUnionOp %93 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %115 = llvm.mlir.constant(50 : i32) : i32
    %116 = llvm.zext %115 : i32 to i64
    %117 = zexti %115 : i32 to i64
    %118 = llvm.call @malloc(%117) : (i64) -> !llvm.ptr<i8>
    %119 = llvm.bitcast %118 : !llvm.ptr<i8> to !llvm.ptr<i8>
    %120 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
    %121 = llvm.mlir.constant(0 : i64) : i64
    %122 = llvm.getelementptr %120[%121, %121] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %123 = llvm.call @sprintf_s(%119, %115, %122, %113) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
    %124 = ts.Cast %114 : !ts.number to !ts.string
    %125 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
    %126 = llvm.mlir.constant(0 : i64) : i64
    %127 = llvm.getelementptr %125[%126, %126] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %128 = ts.Constant {value = " "} : !ts.string
    %129 = llvm.intr.stacksave : !llvm.ptr<i8>
    %130 = llvm.mlir.constant(1 : i64) : i64
    %131 = llvm.call @strlen(%24) : (!llvm.ptr<i8>) -> i64
    %132 = llvm.add %130, %131  : i64
    %133 = llvm.call @strlen(%127) : (!llvm.ptr<i8>) -> i64
    %134 = llvm.add %132, %133  : i64
    %135 = llvm.call @strlen(%119) : (!llvm.ptr<i8>) -> i64
    %136 = llvm.add %134, %135  : i64
    %137 = llvm.alloca %136 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
    %138 = llvm.call @strcpy(%137, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %139 = llvm.call @strcat(%138, %127) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %140 = llvm.call @strcat(%139, %119) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %141 = "ts.StringConcat"(%24, %128, %119) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
    %142 = llvm.call @puts(%141) : (!ts.string) -> i32
    llvm.intr.stackrestore %129
    ts.Print(%25, %124) : !ts.string, !ts.string
    llvm.br ^bb6
    br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
    %143 = llvm.call @puts(%28) : (!llvm.ptr<i8>) -> i32
    ts.Print(%29) : !ts.string
    llvm.return
    ts.ReturnInternal
  }
  func @main()
  ts.Func @main () -> ()  {
  }
  llvm.func @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x1b3ca892700) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FuncOpConversion"
    ** Insert  : 'llvm.func'(0x1b3ca89b810)
    ** Erase   : 'func'(0x1b3ca892700)
"`anonymous-namespace'::FuncOpConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x1b3ca89b810) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  llvm.func @strcat(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strcpy(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strlen(!llvm.ptr<i8>) -> i64
  llvm.func @sprintf_s(!llvm.ptr<i8>, i32, !llvm.ptr<i8>, ...) -> i32
  llvm.func @puts(!llvm.ptr<i8>) -> i32
  llvm.func @strcmp(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  llvm.func @llvm.memcpy.p0i8.p0i8.i64(!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1)
  llvm.mlir.global internal constant @s_9237349086447201248("number\00")
  llvm.mlir.global internal constant @s_13617892236937420068("b number: \00")
  llvm.mlir.global internal constant @s_6682479467004374669("done.\00")
  llvm.mlir.global internal constant @frmt_555404038213028357("%g\00")
  llvm.mlir.global internal constant @s_12638117931323064703(" \00")
  llvm.func @main() {
    %0 = llvm.mlir.constant(1 : i32) : i32
    %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %2 = llvm.mlir.constant(1 : i32) : i32
    %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %4 = llvm.mlir.constant(1 : i32) : i32
    %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %6 = llvm.mlir.constant(1 : i32) : i32
    %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %8 = llvm.mlir.constant(1 : i32) : i32
    %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %10 = llvm.mlir.constant(1 : i32) : i32
    %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
    %cst = constant 1.000000e+01 : f64
    %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %15 = llvm.mlir.constant(0 : i64) : i64
    %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %17 = ts.Constant {value = "number"} : !ts.string
    %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %19 = llvm.mlir.constant(0 : i64) : i64
    %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %21 = ts.Constant {value = "number"} : !ts.string
    %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
    %23 = llvm.mlir.constant(0 : i64) : i64
    %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %25 = ts.Constant {value = "b number: "} : !ts.string
    %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
    %27 = llvm.mlir.constant(0 : i64) : i64
    %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %29 = ts.Constant {value = "done."} : !ts.string
    %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
    %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %40 = llvm.mlir.constant(1 : i64) : i64
    %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %45 = llvm.mlir.constant(1 : i64) : i64
    %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %49 = llvm.icmp "ult" %43, %48 : i64
    %50 = llvm.select %49, %43, %48 : i1, i64
    %51 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
    %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
    %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
    %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %64 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
    %65 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
    llvm.store %63, %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %65, %31 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %66 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %67 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %68 = llvm.extractvalue %66[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %69 = ts.GetTypeInfoFromUnionOp %67 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
    %70 = llvm.mlir.constant(0 : i64) : i64
    %71 = llvm.ptrtoint %68 : !llvm.ptr<i8> to i64
    %72 = llvm.ptrtoint %20 : !llvm.ptr<i8> to i64
    %73 = llvm.icmp "ne" %71, %70 : i64
    %74 = llvm.icmp "ne" %72, %70 : i64
    %75 = llvm.zext %73 : i1 to i32
    %76 = zexti %73 : i1 to i32
    %77 = ts.Cast %73 : i1 to i32
    %78 = llvm.zext %74 : i1 to i32
    %79 = zexti %74 : i1 to i32
    %80 = ts.Cast %74 : i1 to i32
    %81 = llvm.and %77, %80  : i32
    %82 = llvm.mlir.constant(0 : i32) : i32
    %83 = llvm.icmp "ne" %81, %82 : i32
    llvm.cond_br %83, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %84 = llvm.mlir.constant(0 : i32) : i32
    %85 = llvm.call @strcmp(%68, %20) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
    %86 = llvm.icmp "eq" %85, %84 : i32
    llvm.br ^bb3(%86 : i1)
  ^bb2:  // pred: ^bb0
    %87 = llvm.icmp "eq" %71, %72 : i64
    llvm.br ^bb3(%87 : i1)
  ^bb3(%88: i1):  // 2 preds: ^bb1, ^bb2
    llvm.br ^bb4
  ^bb4:  // pred: ^bb3
    %89 = "ts.StringCompare"(%68, %20) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
    %90 = ts.LogicalBinary %69(34) %21 : !ts.string, !ts.string -> !ts.boolean
    %91 = ts.Cast %90 : !ts.boolean to i1
    llvm.cond_br %88, ^bb5, ^bb6
    cond_br %91, ^bb5, ^bb6
  ^bb5:  // 2 preds: ^bb4, ^bb4
    %92 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %93 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    llvm.store %92, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %94 = ts.Variable(%92) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
    %95 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %96 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %97 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %98 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %99 = llvm.mlir.constant(1 : i64) : i64
    %100 = llvm.getelementptr %98[%99] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %101 = llvm.ptrtoint %100 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %102 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %103 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %104 = llvm.mlir.constant(1 : i64) : i64
    %105 = llvm.getelementptr %103[%104] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %106 = llvm.ptrtoint %105 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %107 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %108 = llvm.icmp "ult" %102, %107 : i64
    %109 = llvm.select %108, %102, %107 : i1, i64
    %110 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%96, %97, %109, %110) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%95, %94) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
    %111 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %112 = ts.Load(%95) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
    %113 = llvm.extractvalue %112[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %114 = ts.GetValueFromUnionOp %93 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %115 = llvm.mlir.constant(50 : i32) : i32
    %116 = llvm.zext %115 : i32 to i64
    %117 = zexti %115 : i32 to i64
    %118 = llvm.call @malloc(%117) : (i64) -> !llvm.ptr<i8>
    %119 = llvm.bitcast %118 : !llvm.ptr<i8> to !llvm.ptr<i8>
    %120 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
    %121 = llvm.mlir.constant(0 : i64) : i64
    %122 = llvm.getelementptr %120[%121, %121] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %123 = llvm.call @sprintf_s(%119, %115, %122, %113) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
    %124 = ts.Cast %114 : !ts.number to !ts.string
    %125 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
    %126 = llvm.mlir.constant(0 : i64) : i64
    %127 = llvm.getelementptr %125[%126, %126] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %128 = ts.Constant {value = " "} : !ts.string
    %129 = llvm.intr.stacksave : !llvm.ptr<i8>
    %130 = llvm.mlir.constant(1 : i64) : i64
    %131 = llvm.call @strlen(%24) : (!llvm.ptr<i8>) -> i64
    %132 = llvm.add %130, %131  : i64
    %133 = llvm.call @strlen(%127) : (!llvm.ptr<i8>) -> i64
    %134 = llvm.add %132, %133  : i64
    %135 = llvm.call @strlen(%119) : (!llvm.ptr<i8>) -> i64
    %136 = llvm.add %134, %135  : i64
    %137 = llvm.alloca %136 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
    %138 = llvm.call @strcpy(%137, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %139 = llvm.call @strcat(%138, %127) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %140 = llvm.call @strcat(%139, %119) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %141 = "ts.StringConcat"(%24, %128, %119) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
    %142 = llvm.call @puts(%141) : (!ts.string) -> i32
    llvm.intr.stackrestore %129
    ts.Print(%25, %124) : !ts.string, !ts.string
    llvm.br ^bb6
    br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
    %143 = llvm.call @puts(%28) : (!llvm.ptr<i8>) -> i32
    ts.Print(%29) : !ts.string
    llvm.return
    ts.ReturnInternal
  }
  func @main()
  ts.Func @main () -> ()  {
  }
  llvm.func @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x1b3ca892860) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FuncOpConversion"
    ** Insert  : 'llvm.func'(0x1b3ca89c1b0)
    ** Erase   : 'func'(0x1b3ca892860)
"`anonymous-namespace'::FuncOpConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x1b3ca89c1b0) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  llvm.func @strcat(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strcpy(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strlen(!llvm.ptr<i8>) -> i64
  llvm.func @sprintf_s(!llvm.ptr<i8>, i32, !llvm.ptr<i8>, ...) -> i32
  llvm.func @puts(!llvm.ptr<i8>) -> i32
  llvm.func @strcmp(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  llvm.func @llvm.memcpy.p0i8.p0i8.i64(!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1)
  llvm.mlir.global internal constant @s_9237349086447201248("number\00")
  llvm.mlir.global internal constant @s_13617892236937420068("b number: \00")
  llvm.mlir.global internal constant @s_6682479467004374669("done.\00")
  llvm.mlir.global internal constant @frmt_555404038213028357("%g\00")
  llvm.mlir.global internal constant @s_12638117931323064703(" \00")
  llvm.func @main() {
    %0 = llvm.mlir.constant(1 : i32) : i32
    %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %2 = llvm.mlir.constant(1 : i32) : i32
    %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %4 = llvm.mlir.constant(1 : i32) : i32
    %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %6 = llvm.mlir.constant(1 : i32) : i32
    %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %8 = llvm.mlir.constant(1 : i32) : i32
    %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %10 = llvm.mlir.constant(1 : i32) : i32
    %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
    %cst = constant 1.000000e+01 : f64
    %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %15 = llvm.mlir.constant(0 : i64) : i64
    %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %17 = ts.Constant {value = "number"} : !ts.string
    %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %19 = llvm.mlir.constant(0 : i64) : i64
    %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %21 = ts.Constant {value = "number"} : !ts.string
    %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
    %23 = llvm.mlir.constant(0 : i64) : i64
    %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %25 = ts.Constant {value = "b number: "} : !ts.string
    %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
    %27 = llvm.mlir.constant(0 : i64) : i64
    %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %29 = ts.Constant {value = "done."} : !ts.string
    %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
    %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %40 = llvm.mlir.constant(1 : i64) : i64
    %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %45 = llvm.mlir.constant(1 : i64) : i64
    %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %49 = llvm.icmp "ult" %43, %48 : i64
    %50 = llvm.select %49, %43, %48 : i1, i64
    %51 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
    %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
    %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
    %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %64 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
    %65 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
    llvm.store %63, %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %65, %31 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %66 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %67 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %68 = llvm.extractvalue %66[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %69 = ts.GetTypeInfoFromUnionOp %67 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
    %70 = llvm.mlir.constant(0 : i64) : i64
    %71 = llvm.ptrtoint %68 : !llvm.ptr<i8> to i64
    %72 = llvm.ptrtoint %20 : !llvm.ptr<i8> to i64
    %73 = llvm.icmp "ne" %71, %70 : i64
    %74 = llvm.icmp "ne" %72, %70 : i64
    %75 = llvm.zext %73 : i1 to i32
    %76 = zexti %73 : i1 to i32
    %77 = ts.Cast %73 : i1 to i32
    %78 = llvm.zext %74 : i1 to i32
    %79 = zexti %74 : i1 to i32
    %80 = ts.Cast %74 : i1 to i32
    %81 = llvm.and %77, %80  : i32
    %82 = llvm.mlir.constant(0 : i32) : i32
    %83 = llvm.icmp "ne" %81, %82 : i32
    llvm.cond_br %83, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %84 = llvm.mlir.constant(0 : i32) : i32
    %85 = llvm.call @strcmp(%68, %20) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
    %86 = llvm.icmp "eq" %85, %84 : i32
    llvm.br ^bb3(%86 : i1)
  ^bb2:  // pred: ^bb0
    %87 = llvm.icmp "eq" %71, %72 : i64
    llvm.br ^bb3(%87 : i1)
  ^bb3(%88: i1):  // 2 preds: ^bb1, ^bb2
    llvm.br ^bb4
  ^bb4:  // pred: ^bb3
    %89 = "ts.StringCompare"(%68, %20) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
    %90 = ts.LogicalBinary %69(34) %21 : !ts.string, !ts.string -> !ts.boolean
    %91 = ts.Cast %90 : !ts.boolean to i1
    llvm.cond_br %88, ^bb5, ^bb6
    cond_br %91, ^bb5, ^bb6
  ^bb5:  // 2 preds: ^bb4, ^bb4
    %92 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %93 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    llvm.store %92, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %94 = ts.Variable(%92) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
    %95 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %96 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %97 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %98 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %99 = llvm.mlir.constant(1 : i64) : i64
    %100 = llvm.getelementptr %98[%99] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %101 = llvm.ptrtoint %100 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %102 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %103 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %104 = llvm.mlir.constant(1 : i64) : i64
    %105 = llvm.getelementptr %103[%104] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %106 = llvm.ptrtoint %105 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %107 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %108 = llvm.icmp "ult" %102, %107 : i64
    %109 = llvm.select %108, %102, %107 : i1, i64
    %110 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%96, %97, %109, %110) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%95, %94) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
    %111 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %112 = ts.Load(%95) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
    %113 = llvm.extractvalue %112[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %114 = ts.GetValueFromUnionOp %93 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %115 = llvm.mlir.constant(50 : i32) : i32
    %116 = llvm.zext %115 : i32 to i64
    %117 = zexti %115 : i32 to i64
    %118 = llvm.call @malloc(%117) : (i64) -> !llvm.ptr<i8>
    %119 = llvm.bitcast %118 : !llvm.ptr<i8> to !llvm.ptr<i8>
    %120 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
    %121 = llvm.mlir.constant(0 : i64) : i64
    %122 = llvm.getelementptr %120[%121, %121] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %123 = llvm.call @sprintf_s(%119, %115, %122, %113) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
    %124 = ts.Cast %114 : !ts.number to !ts.string
    %125 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
    %126 = llvm.mlir.constant(0 : i64) : i64
    %127 = llvm.getelementptr %125[%126, %126] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %128 = ts.Constant {value = " "} : !ts.string
    %129 = llvm.intr.stacksave : !llvm.ptr<i8>
    %130 = llvm.mlir.constant(1 : i64) : i64
    %131 = llvm.call @strlen(%24) : (!llvm.ptr<i8>) -> i64
    %132 = llvm.add %130, %131  : i64
    %133 = llvm.call @strlen(%127) : (!llvm.ptr<i8>) -> i64
    %134 = llvm.add %132, %133  : i64
    %135 = llvm.call @strlen(%119) : (!llvm.ptr<i8>) -> i64
    %136 = llvm.add %134, %135  : i64
    %137 = llvm.alloca %136 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
    %138 = llvm.call @strcpy(%137, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %139 = llvm.call @strcat(%138, %127) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %140 = llvm.call @strcat(%139, %119) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %141 = "ts.StringConcat"(%24, %128, %119) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
    %142 = llvm.call @puts(%141) : (!ts.string) -> i32
    llvm.intr.stackrestore %129
    ts.Print(%25, %124) : !ts.string, !ts.string
    llvm.br ^bb6
    br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
    %143 = llvm.call @puts(%28) : (!llvm.ptr<i8>) -> i32
    ts.Print(%29) : !ts.string
    llvm.return
    ts.ReturnInternal
  }
  func @main()
  ts.Func @main () -> ()  {
  }
  llvm.func @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  llvm.func @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x1b3ca892a70) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FuncOpConversion"
    ** Insert  : 'llvm.func'(0x1b3ca89cc00)
    ** Erase   : 'func'(0x1b3ca892a70)
"`anonymous-namespace'::FuncOpConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x1b3ca89cc00) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  llvm.func @strcat(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strcpy(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strlen(!llvm.ptr<i8>) -> i64
  llvm.func @sprintf_s(!llvm.ptr<i8>, i32, !llvm.ptr<i8>, ...) -> i32
  llvm.func @puts(!llvm.ptr<i8>) -> i32
  llvm.func @strcmp(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  llvm.func @llvm.memcpy.p0i8.p0i8.i64(!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1)
  llvm.mlir.global internal constant @s_9237349086447201248("number\00")
  llvm.mlir.global internal constant @s_13617892236937420068("b number: \00")
  llvm.mlir.global internal constant @s_6682479467004374669("done.\00")
  llvm.mlir.global internal constant @frmt_555404038213028357("%g\00")
  llvm.mlir.global internal constant @s_12638117931323064703(" \00")
  llvm.func @main() {
    %0 = llvm.mlir.constant(1 : i32) : i32
    %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %2 = llvm.mlir.constant(1 : i32) : i32
    %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %4 = llvm.mlir.constant(1 : i32) : i32
    %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %6 = llvm.mlir.constant(1 : i32) : i32
    %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %8 = llvm.mlir.constant(1 : i32) : i32
    %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %10 = llvm.mlir.constant(1 : i32) : i32
    %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
    %cst = constant 1.000000e+01 : f64
    %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %15 = llvm.mlir.constant(0 : i64) : i64
    %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %17 = ts.Constant {value = "number"} : !ts.string
    %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %19 = llvm.mlir.constant(0 : i64) : i64
    %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %21 = ts.Constant {value = "number"} : !ts.string
    %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
    %23 = llvm.mlir.constant(0 : i64) : i64
    %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %25 = ts.Constant {value = "b number: "} : !ts.string
    %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
    %27 = llvm.mlir.constant(0 : i64) : i64
    %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %29 = ts.Constant {value = "done."} : !ts.string
    %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
    %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %40 = llvm.mlir.constant(1 : i64) : i64
    %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %45 = llvm.mlir.constant(1 : i64) : i64
    %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %49 = llvm.icmp "ult" %43, %48 : i64
    %50 = llvm.select %49, %43, %48 : i1, i64
    %51 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
    %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
    %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
    %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %64 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
    %65 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
    llvm.store %63, %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %65, %31 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %66 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %67 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %68 = llvm.extractvalue %66[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %69 = ts.GetTypeInfoFromUnionOp %67 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
    %70 = llvm.mlir.constant(0 : i64) : i64
    %71 = llvm.ptrtoint %68 : !llvm.ptr<i8> to i64
    %72 = llvm.ptrtoint %20 : !llvm.ptr<i8> to i64
    %73 = llvm.icmp "ne" %71, %70 : i64
    %74 = llvm.icmp "ne" %72, %70 : i64
    %75 = llvm.zext %73 : i1 to i32
    %76 = zexti %73 : i1 to i32
    %77 = ts.Cast %73 : i1 to i32
    %78 = llvm.zext %74 : i1 to i32
    %79 = zexti %74 : i1 to i32
    %80 = ts.Cast %74 : i1 to i32
    %81 = llvm.and %77, %80  : i32
    %82 = llvm.mlir.constant(0 : i32) : i32
    %83 = llvm.icmp "ne" %81, %82 : i32
    llvm.cond_br %83, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %84 = llvm.mlir.constant(0 : i32) : i32
    %85 = llvm.call @strcmp(%68, %20) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
    %86 = llvm.icmp "eq" %85, %84 : i32
    llvm.br ^bb3(%86 : i1)
  ^bb2:  // pred: ^bb0
    %87 = llvm.icmp "eq" %71, %72 : i64
    llvm.br ^bb3(%87 : i1)
  ^bb3(%88: i1):  // 2 preds: ^bb1, ^bb2
    llvm.br ^bb4
  ^bb4:  // pred: ^bb3
    %89 = "ts.StringCompare"(%68, %20) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
    %90 = ts.LogicalBinary %69(34) %21 : !ts.string, !ts.string -> !ts.boolean
    %91 = ts.Cast %90 : !ts.boolean to i1
    llvm.cond_br %88, ^bb5, ^bb6
    cond_br %91, ^bb5, ^bb6
  ^bb5:  // 2 preds: ^bb4, ^bb4
    %92 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %93 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    llvm.store %92, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %94 = ts.Variable(%92) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
    %95 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %96 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %97 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %98 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %99 = llvm.mlir.constant(1 : i64) : i64
    %100 = llvm.getelementptr %98[%99] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %101 = llvm.ptrtoint %100 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %102 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %103 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %104 = llvm.mlir.constant(1 : i64) : i64
    %105 = llvm.getelementptr %103[%104] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %106 = llvm.ptrtoint %105 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %107 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %108 = llvm.icmp "ult" %102, %107 : i64
    %109 = llvm.select %108, %102, %107 : i1, i64
    %110 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%96, %97, %109, %110) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%95, %94) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
    %111 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %112 = ts.Load(%95) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
    %113 = llvm.extractvalue %112[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %114 = ts.GetValueFromUnionOp %93 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %115 = llvm.mlir.constant(50 : i32) : i32
    %116 = llvm.zext %115 : i32 to i64
    %117 = zexti %115 : i32 to i64
    %118 = llvm.call @malloc(%117) : (i64) -> !llvm.ptr<i8>
    %119 = llvm.bitcast %118 : !llvm.ptr<i8> to !llvm.ptr<i8>
    %120 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
    %121 = llvm.mlir.constant(0 : i64) : i64
    %122 = llvm.getelementptr %120[%121, %121] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %123 = llvm.call @sprintf_s(%119, %115, %122, %113) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
    %124 = ts.Cast %114 : !ts.number to !ts.string
    %125 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
    %126 = llvm.mlir.constant(0 : i64) : i64
    %127 = llvm.getelementptr %125[%126, %126] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %128 = ts.Constant {value = " "} : !ts.string
    %129 = llvm.intr.stacksave : !llvm.ptr<i8>
    %130 = llvm.mlir.constant(1 : i64) : i64
    %131 = llvm.call @strlen(%24) : (!llvm.ptr<i8>) -> i64
    %132 = llvm.add %130, %131  : i64
    %133 = llvm.call @strlen(%127) : (!llvm.ptr<i8>) -> i64
    %134 = llvm.add %132, %133  : i64
    %135 = llvm.call @strlen(%119) : (!llvm.ptr<i8>) -> i64
    %136 = llvm.add %134, %135  : i64
    %137 = llvm.alloca %136 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
    %138 = llvm.call @strcpy(%137, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %139 = llvm.call @strcat(%138, %127) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %140 = llvm.call @strcat(%139, %119) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %141 = "ts.StringConcat"(%24, %128, %119) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
    %142 = llvm.call @puts(%141) : (!ts.string) -> i32
    llvm.intr.stackrestore %129
    ts.Print(%25, %124) : !ts.string, !ts.string
    llvm.br ^bb6
    br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
    %143 = llvm.call @puts(%28) : (!llvm.ptr<i8>) -> i32
    ts.Print(%29) : !ts.string
    llvm.return
    ts.ReturnInternal
  }
  func @main()
  ts.Func @main () -> ()  {
  }
  llvm.func @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  llvm.func @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x1b3ca894490) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FuncOpConversion"
    ** Insert  : 'llvm.func'(0x1b3ca89cd60)
    ** Erase   : 'func'(0x1b3ca894490)
"`anonymous-namespace'::FuncOpConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x1b3ca89cd60) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  llvm.func @strcat(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strcpy(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strlen(!llvm.ptr<i8>) -> i64
  llvm.func @sprintf_s(!llvm.ptr<i8>, i32, !llvm.ptr<i8>, ...) -> i32
  llvm.func @puts(!llvm.ptr<i8>) -> i32
  llvm.func @strcmp(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  llvm.func @llvm.memcpy.p0i8.p0i8.i64(!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1)
  llvm.mlir.global internal constant @s_9237349086447201248("number\00")
  llvm.mlir.global internal constant @s_13617892236937420068("b number: \00")
  llvm.mlir.global internal constant @s_6682479467004374669("done.\00")
  llvm.mlir.global internal constant @frmt_555404038213028357("%g\00")
  llvm.mlir.global internal constant @s_12638117931323064703(" \00")
  llvm.func @main() {
    %0 = llvm.mlir.constant(1 : i32) : i32
    %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %2 = llvm.mlir.constant(1 : i32) : i32
    %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %4 = llvm.mlir.constant(1 : i32) : i32
    %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %6 = llvm.mlir.constant(1 : i32) : i32
    %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %8 = llvm.mlir.constant(1 : i32) : i32
    %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %10 = llvm.mlir.constant(1 : i32) : i32
    %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
    %cst = constant 1.000000e+01 : f64
    %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %15 = llvm.mlir.constant(0 : i64) : i64
    %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %17 = ts.Constant {value = "number"} : !ts.string
    %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %19 = llvm.mlir.constant(0 : i64) : i64
    %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %21 = ts.Constant {value = "number"} : !ts.string
    %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
    %23 = llvm.mlir.constant(0 : i64) : i64
    %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %25 = ts.Constant {value = "b number: "} : !ts.string
    %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
    %27 = llvm.mlir.constant(0 : i64) : i64
    %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %29 = ts.Constant {value = "done."} : !ts.string
    %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
    %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %40 = llvm.mlir.constant(1 : i64) : i64
    %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %45 = llvm.mlir.constant(1 : i64) : i64
    %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %49 = llvm.icmp "ult" %43, %48 : i64
    %50 = llvm.select %49, %43, %48 : i1, i64
    %51 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
    %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
    %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
    %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %64 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
    %65 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
    llvm.store %63, %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %65, %31 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
    %66 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %67 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    %68 = llvm.extractvalue %66[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %69 = ts.GetTypeInfoFromUnionOp %67 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
    %70 = llvm.mlir.constant(0 : i64) : i64
    %71 = llvm.ptrtoint %68 : !llvm.ptr<i8> to i64
    %72 = llvm.ptrtoint %20 : !llvm.ptr<i8> to i64
    %73 = llvm.icmp "ne" %71, %70 : i64
    %74 = llvm.icmp "ne" %72, %70 : i64
    %75 = llvm.zext %73 : i1 to i32
    %76 = zexti %73 : i1 to i32
    %77 = ts.Cast %73 : i1 to i32
    %78 = llvm.zext %74 : i1 to i32
    %79 = zexti %74 : i1 to i32
    %80 = ts.Cast %74 : i1 to i32
    %81 = llvm.and %77, %80  : i32
    %82 = llvm.mlir.constant(0 : i32) : i32
    %83 = llvm.icmp "ne" %81, %82 : i32
    llvm.cond_br %83, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %84 = llvm.mlir.constant(0 : i32) : i32
    %85 = llvm.call @strcmp(%68, %20) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
    %86 = llvm.icmp "eq" %85, %84 : i32
    llvm.br ^bb3(%86 : i1)
  ^bb2:  // pred: ^bb0
    %87 = llvm.icmp "eq" %71, %72 : i64
    llvm.br ^bb3(%87 : i1)
  ^bb3(%88: i1):  // 2 preds: ^bb1, ^bb2
    llvm.br ^bb4
  ^bb4:  // pred: ^bb3
    %89 = "ts.StringCompare"(%68, %20) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
    %90 = ts.LogicalBinary %69(34) %21 : !ts.string, !ts.string -> !ts.boolean
    %91 = ts.Cast %90 : !ts.boolean to i1
    llvm.cond_br %88, ^bb5, ^bb6
    cond_br %91, ^bb5, ^bb6
  ^bb5:  // 2 preds: ^bb4, ^bb4
    %92 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %93 = ts.Load(%31) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
    llvm.store %92, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %94 = ts.Variable(%92) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
    %95 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %96 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %97 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %98 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %99 = llvm.mlir.constant(1 : i64) : i64
    %100 = llvm.getelementptr %98[%99] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %101 = llvm.ptrtoint %100 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %102 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %103 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %104 = llvm.mlir.constant(1 : i64) : i64
    %105 = llvm.getelementptr %103[%104] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %106 = llvm.ptrtoint %105 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %107 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %108 = llvm.icmp "ult" %102, %107 : i64
    %109 = llvm.select %108, %102, %107 : i1, i64
    %110 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%96, %97, %109, %110) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%95, %94) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
    %111 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %112 = ts.Load(%95) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
    %113 = llvm.extractvalue %112[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %114 = ts.GetValueFromUnionOp %93 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
    %115 = llvm.mlir.constant(50 : i32) : i32
    %116 = llvm.zext %115 : i32 to i64
    %117 = zexti %115 : i32 to i64
    %118 = llvm.call @malloc(%117) : (i64) -> !llvm.ptr<i8>
    %119 = llvm.bitcast %118 : !llvm.ptr<i8> to !llvm.ptr<i8>
    %120 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
    %121 = llvm.mlir.constant(0 : i64) : i64
    %122 = llvm.getelementptr %120[%121, %121] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %123 = llvm.call @sprintf_s(%119, %115, %122, %113) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
    %124 = ts.Cast %114 : !ts.number to !ts.string
    %125 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
    %126 = llvm.mlir.constant(0 : i64) : i64
    %127 = llvm.getelementptr %125[%126, %126] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %128 = ts.Constant {value = " "} : !ts.string
    %129 = llvm.intr.stacksave : !llvm.ptr<i8>
    %130 = llvm.mlir.constant(1 : i64) : i64
    %131 = llvm.call @strlen(%24) : (!llvm.ptr<i8>) -> i64
    %132 = llvm.add %130, %131  : i64
    %133 = llvm.call @strlen(%127) : (!llvm.ptr<i8>) -> i64
    %134 = llvm.add %132, %133  : i64
    %135 = llvm.call @strlen(%119) : (!llvm.ptr<i8>) -> i64
    %136 = llvm.add %134, %135  : i64
    %137 = llvm.alloca %136 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
    %138 = llvm.call @strcpy(%137, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %139 = llvm.call @strcat(%138, %127) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %140 = llvm.call @strcat(%139, %119) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %141 = "ts.StringConcat"(%24, %128, %119) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
    %142 = llvm.call @puts(%141) : (!ts.string) -> i32
    llvm.intr.stackrestore %129
    ts.Print(%25, %124) : !ts.string, !ts.string
    llvm.br ^bb6
    br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
    %143 = llvm.call @puts(%28) : (!llvm.ptr<i8>) -> i32
    ts.Print(%29) : !ts.string
    llvm.return
    ts.ReturnInternal
  }
  func @main()
  ts.Func @main () -> ()  {
  }
  llvm.func @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  llvm.func @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x1b3ca894330) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x1b3ca892b20) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

!! SourceMaterialization: loc:[ loc("c:\\temp\\1.ts":5:9) ] result: [ !ts.number ]

!! SourceMaterialization value: [ %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64 ]
** Insert  : 'ts.DialectCast'(0x1b3ca7b21c0)

//===-------------------------------------------===//
Legalizing operation : 'ts.DialectCast'(0x1b3ca7b21c0) {
  %14 = "ts.DialectCast"(%12) : (f64) -> !ts.number

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.DialectCast -> ()' {
Trying to match "`anonymous-namespace'::DialectCastOpLowering"
    ** Replace : 'ts.DialectCast'(0x1b3ca7b21c0)
"`anonymous-namespace'::DialectCastOpLowering" result 1
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %13 = ts.DialectCast %12 : f64 to !ts.number
  %14 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %15 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %16 = llvm.mlir.constant(0 : i64) : i64
  %17 = llvm.getelementptr %15[%16, %16] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %18 = ts.Constant {value = "number"} : !ts.string
  %19 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %20 = llvm.mlir.constant(0 : i64) : i64
  %21 = llvm.getelementptr %19[%20, %20] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %22 = ts.Constant {value = "number"} : !ts.string
  %23 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %24 = llvm.mlir.constant(0 : i64) : i64
  %25 = llvm.getelementptr %23[%24, %24] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %26 = ts.Constant {value = "b number: "} : !ts.string
  %27 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %28 = llvm.mlir.constant(0 : i64) : i64
  %29 = llvm.getelementptr %27[%28, %28] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %30 = ts.Constant {value = "done."} : !ts.string
  %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %32 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %33 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %34 = llvm.insertvalue %18, %33[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %35 = llvm.insertvalue %14, %34[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %35, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %36 = ts.Variable(%35) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %37 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %38 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %39 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %40 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %41 = llvm.mlir.constant(1 : i64) : i64
  %42 = llvm.getelementptr %40[%41] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %43 = llvm.ptrtoint %42 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %44 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %45 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %46 = llvm.mlir.constant(1 : i64) : i64
  %47 = llvm.getelementptr %45[%46] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %48 = llvm.ptrtoint %47 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %49 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %50 = llvm.icmp "ult" %44, %49 : i64
  %51 = llvm.select %50, %44, %49 : i1, i64
  %52 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%38, %39, %51, %52) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%37, %36) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %53 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %54 = ts.Load(%37) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %55 = ts.CreateUnionInstance %14, %18 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %53, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %55, %31 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %56 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %57 = ts.Load(%31) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %58 = llvm.extractvalue %56[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %59 = ts.GetValueFromUnionOp %56 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %60 = llvm.extractvalue %56[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %61 = ts.GetTypeInfoFromUnionOp %56 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %62 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %63 = llvm.insertvalue %61, %62[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %64 = llvm.insertvalue %59, %63[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %65 = ts.CreateUnionInstance %59, %61 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
  %66 = ts.Cast %57 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  llvm.store %64, %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %66, %32 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %67 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %68 = ts.Load(%32) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %69 = llvm.extractvalue %67[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %70 = ts.GetTypeInfoFromUnionOp %68 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %71 = llvm.mlir.constant(0 : i64) : i64
  %72 = llvm.ptrtoint %69 : !llvm.ptr<i8> to i64
  %73 = llvm.ptrtoint %21 : !llvm.ptr<i8> to i64
  %74 = llvm.icmp "ne" %72, %71 : i64
  %75 = llvm.icmp "ne" %73, %71 : i64
  %76 = llvm.zext %74 : i1 to i32
  %77 = zexti %74 : i1 to i32
  %78 = ts.Cast %74 : i1 to i32
  %79 = llvm.zext %75 : i1 to i32
  %80 = zexti %75 : i1 to i32
  %81 = ts.Cast %75 : i1 to i32
  %82 = llvm.and %78, %81  : i32
  %83 = llvm.mlir.constant(0 : i32) : i32
  %84 = llvm.icmp "ne" %82, %83 : i32
  llvm.cond_br %84, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %85 = llvm.mlir.constant(0 : i32) : i32
  %86 = llvm.call @strcmp(%69, %21) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %87 = llvm.icmp "eq" %86, %85 : i32
  llvm.br ^bb3(%87 : i1)
^bb2:  // pred: ^bb0
  %88 = llvm.icmp "eq" %72, %73 : i64
  llvm.br ^bb3(%88 : i1)
^bb3(%89: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %90 = "ts.StringCompare"(%69, %21) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %91 = ts.LogicalBinary %70(34) %22 : !ts.string, !ts.string -> !ts.boolean
  %92 = ts.Cast %91 : !ts.boolean to i1
  llvm.cond_br %89, ^bb5, ^bb6
  cond_br %92, ^bb5, ^bb6
^bb5:  // 2 preds: ^bb4, ^bb4
  %93 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %94 = ts.Load(%32) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  llvm.store %93, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %95 = ts.Variable(%93) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %96 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %97 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %98 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %99 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %100 = llvm.mlir.constant(1 : i64) : i64
  %101 = llvm.getelementptr %99[%100] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %102 = llvm.ptrtoint %101 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %103 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %104 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %105 = llvm.mlir.constant(1 : i64) : i64
  %106 = llvm.getelementptr %104[%105] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %107 = llvm.ptrtoint %106 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %108 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %109 = llvm.icmp "ult" %103, %108 : i64
  %110 = llvm.select %109, %103, %108 : i1, i64
  %111 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%97, %98, %110, %111) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%96, %95) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %112 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %113 = ts.Load(%96) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
  %114 = llvm.extractvalue %113[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %115 = ts.GetValueFromUnionOp %94 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %116 = llvm.mlir.constant(50 : i32) : i32
  %117 = llvm.zext %116 : i32 to i64
  %118 = zexti %116 : i32 to i64
  %119 = llvm.call @malloc(%118) : (i64) -> !llvm.ptr<i8>
  %120 = llvm.bitcast %119 : !llvm.ptr<i8> to !llvm.ptr<i8>
  %121 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
  %122 = llvm.mlir.constant(0 : i64) : i64
  %123 = llvm.getelementptr %121[%122, %122] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %124 = llvm.call @sprintf_s(%120, %116, %123, %114) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
  %125 = ts.Cast %115 : !ts.number to !ts.string
  %126 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
  %127 = llvm.mlir.constant(0 : i64) : i64
  %128 = llvm.getelementptr %126[%127, %127] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %129 = ts.Constant {value = " "} : !ts.string
  %130 = llvm.intr.stacksave : !llvm.ptr<i8>
  %131 = llvm.mlir.constant(1 : i64) : i64
  %132 = llvm.call @strlen(%25) : (!llvm.ptr<i8>) -> i64
  %133 = llvm.add %131, %132  : i64
  %134 = llvm.call @strlen(%128) : (!llvm.ptr<i8>) -> i64
  %135 = llvm.add %133, %134  : i64
  %136 = llvm.call @strlen(%120) : (!llvm.ptr<i8>) -> i64
  %137 = llvm.add %135, %136  : i64
  %138 = llvm.alloca %137 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
  %139 = llvm.call @strcpy(%138, %25) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  %140 = llvm.call @strcat(%139, %128) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  %141 = llvm.call @strcat(%140, %120) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  %142 = "ts.StringConcat"(%25, %129, %120) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
  %143 = llvm.call @puts(%142) : (!ts.string) -> i32
  llvm.intr.stackrestore %130
  ts.Print(%26, %125) : !ts.string, !ts.string
  llvm.br ^bb6
  br ^bb6
^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
  %144 = llvm.call @puts(%29) : (!llvm.ptr<i8>) -> i32
  ts.Print(%30) : !ts.string
  llvm.return
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

!! SourceMaterialization: loc:[ loc("c:\\temp\\1.ts":5:5) ] result: [ !ts.string ]

!! SourceMaterialization value: [ %17 = llvm.getelementptr %15[%16, %16] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8> ]
** Insert  : 'ts.DialectCast'(0x1b3ca7b27c0)

//===-------------------------------------------===//
Legalizing operation : 'ts.DialectCast'(0x1b3ca7b27c0) {
  %19 = "ts.DialectCast"(%18) : (!llvm.ptr<i8>) -> !ts.string

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.DialectCast -> ()' {
Trying to match "`anonymous-namespace'::DialectCastOpLowering"
    ** Replace : 'ts.DialectCast'(0x1b3ca7b27c0)
"`anonymous-namespace'::DialectCastOpLowering" result 1
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %13 = ts.DialectCast %12 : f64 to !ts.number
  %14 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %15 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %16 = llvm.mlir.constant(0 : i64) : i64
  %17 = llvm.getelementptr %15[%16, %16] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %18 = ts.DialectCast %17 : !llvm.ptr<i8> to !ts.string
  %19 = ts.Constant {value = "number"} : !ts.string
  %20 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %21 = llvm.mlir.constant(0 : i64) : i64
  %22 = llvm.getelementptr %20[%21, %21] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %23 = ts.Constant {value = "number"} : !ts.string
  %24 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %25 = llvm.mlir.constant(0 : i64) : i64
  %26 = llvm.getelementptr %24[%25, %25] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %27 = ts.Constant {value = "b number: "} : !ts.string
  %28 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %29 = llvm.mlir.constant(0 : i64) : i64
  %30 = llvm.getelementptr %28[%29, %29] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %31 = ts.Constant {value = "done."} : !ts.string
  %32 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %33 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %34 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %35 = llvm.insertvalue %19, %34[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %36 = llvm.insertvalue %14, %35[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %36, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %37 = ts.Variable(%36) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %38 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %39 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %40 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %41 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %42 = llvm.mlir.constant(1 : i64) : i64
  %43 = llvm.getelementptr %41[%42] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %44 = llvm.ptrtoint %43 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %45 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %46 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %47 = llvm.mlir.constant(1 : i64) : i64
  %48 = llvm.getelementptr %46[%47] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %49 = llvm.ptrtoint %48 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %50 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %51 = llvm.icmp "ult" %45, %50 : i64
  %52 = llvm.select %51, %45, %50 : i1, i64
  %53 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%39, %40, %52, %53) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%38, %37) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %54 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %55 = ts.Load(%38) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %56 = ts.CreateUnionInstance %14, %19 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %54, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %56, %32 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %57 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %58 = ts.Load(%32) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %59 = llvm.extractvalue %57[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.GetValueFromUnionOp %57 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %61 = llvm.extractvalue %57[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %62 = ts.GetTypeInfoFromUnionOp %57 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %63 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %64 = llvm.insertvalue %62, %63[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %65 = llvm.insertvalue %60, %64[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %66 = ts.CreateUnionInstance %60, %62 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
  %67 = ts.Cast %58 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  llvm.store %65, %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %67, %33 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %68 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %69 = ts.Load(%33) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %70 = llvm.extractvalue %68[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %71 = ts.GetTypeInfoFromUnionOp %69 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %72 = llvm.mlir.constant(0 : i64) : i64
  %73 = llvm.ptrtoint %70 : !llvm.ptr<i8> to i64
  %74 = llvm.ptrtoint %22 : !llvm.ptr<i8> to i64
  %75 = llvm.icmp "ne" %73, %72 : i64
  %76 = llvm.icmp "ne" %74, %72 : i64
  %77 = llvm.zext %75 : i1 to i32
  %78 = zexti %75 : i1 to i32
  %79 = ts.Cast %75 : i1 to i32
  %80 = llvm.zext %76 : i1 to i32
  %81 = zexti %76 : i1 to i32
  %82 = ts.Cast %76 : i1 to i32
  %83 = llvm.and %79, %82  : i32
  %84 = llvm.mlir.constant(0 : i32) : i32
  %85 = llvm.icmp "ne" %83, %84 : i32
  llvm.cond_br %85, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %86 = llvm.mlir.constant(0 : i32) : i32
  %87 = llvm.call @strcmp(%70, %22) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %88 = llvm.icmp "eq" %87, %86 : i32
  llvm.br ^bb3(%88 : i1)
^bb2:  // pred: ^bb0
  %89 = llvm.icmp "eq" %73, %74 : i64
  llvm.br ^bb3(%89 : i1)
^bb3(%90: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %91 = "ts.StringCompare"(%70, %22) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %92 = ts.LogicalBinary %71(34) %23 : !ts.string, !ts.string -> !ts.boolean
  %93 = ts.Cast %92 : !ts.boolean to i1
  llvm.cond_br %90, ^bb5, ^bb6
  cond_br %93, ^bb5, ^bb6
^bb5:  // 2 preds: ^bb4, ^bb4
  %94 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %95 = ts.Load(%33) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  llvm.store %94, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %96 = ts.Variable(%94) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %97 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %98 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %99 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %100 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %101 = llvm.mlir.constant(1 : i64) : i64
  %102 = llvm.getelementptr %100[%101] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %103 = llvm.ptrtoint %102 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %104 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %105 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %106 = llvm.mlir.constant(1 : i64) : i64
  %107 = llvm.getelementptr %105[%106] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %108 = llvm.ptrtoint %107 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %109 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %110 = llvm.icmp "ult" %104, %109 : i64
  %111 = llvm.select %110, %104, %109 : i1, i64
  %112 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%98, %99, %111, %112) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%97, %96) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %113 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %114 = ts.Load(%97) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
  %115 = llvm.extractvalue %114[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %116 = ts.GetValueFromUnionOp %95 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %117 = llvm.mlir.constant(50 : i32) : i32
  %118 = llvm.zext %117 : i32 to i64
  %119 = zexti %117 : i32 to i64
  %120 = llvm.call @malloc(%119) : (i64) -> !llvm.ptr<i8>
  %121 = llvm.bitcast %120 : !llvm.ptr<i8> to !llvm.ptr<i8>
  %122 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
  %123 = llvm.mlir.constant(0 : i64) : i64
  %124 = llvm.getelementptr %122[%123, %123] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %125 = llvm.call @sprintf_s(%121, %117, %124, %115) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
  %126 = ts.Cast %116 : !ts.number to !ts.string
  %127 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
  %128 = llvm.mlir.constant(0 : i64) : i64
  %129 = llvm.getelementptr %127[%128, %128] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %130 = ts.Constant {value = " "} : !ts.string
  %131 = llvm.intr.stacksave : !llvm.ptr<i8>
  %132 = llvm.mlir.constant(1 : i64) : i64
  %133 = llvm.call @strlen(%26) : (!llvm.ptr<i8>) -> i64
  %134 = llvm.add %132, %133  : i64
  %135 = llvm.call @strlen(%129) : (!llvm.ptr<i8>) -> i64
  %136 = llvm.add %134, %135  : i64
  %137 = llvm.call @strlen(%121) : (!llvm.ptr<i8>) -> i64
  %138 = llvm.add %136, %137  : i64
  %139 = llvm.alloca %138 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
  %140 = llvm.call @strcpy(%139, %26) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  %141 = llvm.call @strcat(%140, %129) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  %142 = llvm.call @strcat(%141, %121) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  %143 = "ts.StringConcat"(%26, %130, %121) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
  %144 = llvm.call @puts(%143) : (!ts.string) -> i32
  llvm.intr.stackrestore %131
  ts.Print(%27, %126) : !ts.string, !ts.string
  llvm.br ^bb6
  br ^bb6
^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
  %145 = llvm.call @puts(%30) : (!llvm.ptr<i8>) -> i32
  ts.Print(%31) : !ts.string
  llvm.return
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

!! SourceMaterialization: loc:[ loc("c:\\temp\\1.ts":7:5) ] result: [ !ts.string ]

!! SourceMaterialization value: [ %61 = llvm.extractvalue %57[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)> ]
** Insert  : 'ts.DialectCast'(0x1b3ca7b4380)

//===-------------------------------------------===//
Legalizing operation : 'ts.DialectCast'(0x1b3ca7b4380) {
  %63 = "ts.DialectCast"(%62) : (!llvm.ptr<i8>) -> !ts.string

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.DialectCast -> ()' {
Trying to match "`anonymous-namespace'::DialectCastOpLowering"
    ** Replace : 'ts.DialectCast'(0x1b3ca7b4380)
"`anonymous-namespace'::DialectCastOpLowering" result 1
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %13 = ts.DialectCast %12 : f64 to !ts.number
  %14 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %15 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %16 = llvm.mlir.constant(0 : i64) : i64
  %17 = llvm.getelementptr %15[%16, %16] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %18 = ts.DialectCast %17 : !llvm.ptr<i8> to !ts.string
  %19 = ts.Constant {value = "number"} : !ts.string
  %20 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %21 = llvm.mlir.constant(0 : i64) : i64
  %22 = llvm.getelementptr %20[%21, %21] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %23 = ts.Constant {value = "number"} : !ts.string
  %24 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %25 = llvm.mlir.constant(0 : i64) : i64
  %26 = llvm.getelementptr %24[%25, %25] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %27 = ts.Constant {value = "b number: "} : !ts.string
  %28 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %29 = llvm.mlir.constant(0 : i64) : i64
  %30 = llvm.getelementptr %28[%29, %29] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %31 = ts.Constant {value = "done."} : !ts.string
  %32 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %33 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %34 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %35 = llvm.insertvalue %19, %34[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %36 = llvm.insertvalue %14, %35[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %36, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %37 = ts.Variable(%36) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %38 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %39 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %40 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %41 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %42 = llvm.mlir.constant(1 : i64) : i64
  %43 = llvm.getelementptr %41[%42] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %44 = llvm.ptrtoint %43 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %45 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %46 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %47 = llvm.mlir.constant(1 : i64) : i64
  %48 = llvm.getelementptr %46[%47] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %49 = llvm.ptrtoint %48 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %50 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %51 = llvm.icmp "ult" %45, %50 : i64
  %52 = llvm.select %51, %45, %50 : i1, i64
  %53 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%39, %40, %52, %53) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%38, %37) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %54 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %55 = ts.Load(%38) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %56 = ts.CreateUnionInstance %14, %19 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %54, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %56, %32 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %57 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %58 = ts.Load(%32) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %59 = llvm.extractvalue %57[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.GetValueFromUnionOp %57 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %61 = llvm.extractvalue %57[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %62 = ts.DialectCast %61 : !llvm.ptr<i8> to !ts.string
  %63 = ts.GetTypeInfoFromUnionOp %57 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %64 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %65 = llvm.insertvalue %63, %64[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %66 = llvm.insertvalue %60, %65[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %67 = ts.CreateUnionInstance %60, %63 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
  %68 = ts.Cast %58 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  llvm.store %66, %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %68, %33 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %69 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %70 = ts.Load(%33) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %71 = llvm.extractvalue %69[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %72 = ts.GetTypeInfoFromUnionOp %70 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %73 = llvm.mlir.constant(0 : i64) : i64
  %74 = llvm.ptrtoint %71 : !llvm.ptr<i8> to i64
  %75 = llvm.ptrtoint %22 : !llvm.ptr<i8> to i64
  %76 = llvm.icmp "ne" %74, %73 : i64
  %77 = llvm.icmp "ne" %75, %73 : i64
  %78 = llvm.zext %76 : i1 to i32
  %79 = zexti %76 : i1 to i32
  %80 = ts.Cast %76 : i1 to i32
  %81 = llvm.zext %77 : i1 to i32
  %82 = zexti %77 : i1 to i32
  %83 = ts.Cast %77 : i1 to i32
  %84 = llvm.and %80, %83  : i32
  %85 = llvm.mlir.constant(0 : i32) : i32
  %86 = llvm.icmp "ne" %84, %85 : i32
  llvm.cond_br %86, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %87 = llvm.mlir.constant(0 : i32) : i32
  %88 = llvm.call @strcmp(%71, %22) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %89 = llvm.icmp "eq" %88, %87 : i32
  llvm.br ^bb3(%89 : i1)
^bb2:  // pred: ^bb0
  %90 = llvm.icmp "eq" %74, %75 : i64
  llvm.br ^bb3(%90 : i1)
^bb3(%91: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %92 = "ts.StringCompare"(%71, %22) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %93 = ts.LogicalBinary %72(34) %23 : !ts.string, !ts.string -> !ts.boolean
  %94 = ts.Cast %93 : !ts.boolean to i1
  llvm.cond_br %91, ^bb5, ^bb6
  cond_br %94, ^bb5, ^bb6
^bb5:  // 2 preds: ^bb4, ^bb4
  %95 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %96 = ts.Load(%33) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  llvm.store %95, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %97 = ts.Variable(%95) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %98 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %99 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %100 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %101 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %102 = llvm.mlir.constant(1 : i64) : i64
  %103 = llvm.getelementptr %101[%102] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %104 = llvm.ptrtoint %103 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %105 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %106 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %107 = llvm.mlir.constant(1 : i64) : i64
  %108 = llvm.getelementptr %106[%107] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %109 = llvm.ptrtoint %108 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %110 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %111 = llvm.icmp "ult" %105, %110 : i64
  %112 = llvm.select %111, %105, %110 : i1, i64
  %113 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%99, %100, %112, %113) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%98, %97) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %114 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %115 = ts.Load(%98) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
  %116 = llvm.extractvalue %115[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %117 = ts.GetValueFromUnionOp %96 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %118 = llvm.mlir.constant(50 : i32) : i32
  %119 = llvm.zext %118 : i32 to i64
  %120 = zexti %118 : i32 to i64
  %121 = llvm.call @malloc(%120) : (i64) -> !llvm.ptr<i8>
  %122 = llvm.bitcast %121 : !llvm.ptr<i8> to !llvm.ptr<i8>
  %123 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
  %124 = llvm.mlir.constant(0 : i64) : i64
  %125 = llvm.getelementptr %123[%124, %124] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %126 = llvm.call @sprintf_s(%122, %118, %125, %116) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
  %127 = ts.Cast %117 : !ts.number to !ts.string
  %128 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
  %129 = llvm.mlir.constant(0 : i64) : i64
  %130 = llvm.getelementptr %128[%129, %129] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %131 = ts.Constant {value = " "} : !ts.string
  %132 = llvm.intr.stacksave : !llvm.ptr<i8>
  %133 = llvm.mlir.constant(1 : i64) : i64
  %134 = llvm.call @strlen(%26) : (!llvm.ptr<i8>) -> i64
  %135 = llvm.add %133, %134  : i64
  %136 = llvm.call @strlen(%130) : (!llvm.ptr<i8>) -> i64
  %137 = llvm.add %135, %136  : i64
  %138 = llvm.call @strlen(%122) : (!llvm.ptr<i8>) -> i64
  %139 = llvm.add %137, %138  : i64
  %140 = llvm.alloca %139 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
  %141 = llvm.call @strcpy(%140, %26) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  %142 = llvm.call @strcat(%141, %130) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  %143 = llvm.call @strcat(%142, %122) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  %144 = "ts.StringConcat"(%26, %131, %122) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
  %145 = llvm.call @puts(%144) : (!ts.string) -> i32
  llvm.intr.stackrestore %132
  ts.Print(%27, %127) : !ts.string, !ts.string
  llvm.br ^bb6
  br ^bb6
^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
  %146 = llvm.call @puts(%30) : (!llvm.ptr<i8>) -> i32
  ts.Print(%31) : !ts.string
  llvm.return
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

!! SourceMaterialization: loc:[ loc("c:\\temp\\1.ts":11:2) ] result: [ !ts.string ]

!! SourceMaterialization value: [ %140 = llvm.alloca %139 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8> ]
** Insert  : 'ts.DialectCast'(0x1b3ca7b2700)

//===-------------------------------------------===//
Legalizing operation : 'ts.DialectCast'(0x1b3ca7b2700) {
  %145 = "ts.DialectCast"(%141) : (!llvm.ptr<i8>) -> !ts.string

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.DialectCast -> ()' {
Trying to match "`anonymous-namespace'::DialectCastOpLowering"
    ** Replace : 'ts.DialectCast'(0x1b3ca7b2700)
"`anonymous-namespace'::DialectCastOpLowering" result 1
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %13 = ts.DialectCast %12 : f64 to !ts.number
  %14 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %15 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %16 = llvm.mlir.constant(0 : i64) : i64
  %17 = llvm.getelementptr %15[%16, %16] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %18 = ts.DialectCast %17 : !llvm.ptr<i8> to !ts.string
  %19 = ts.Constant {value = "number"} : !ts.string
  %20 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %21 = llvm.mlir.constant(0 : i64) : i64
  %22 = llvm.getelementptr %20[%21, %21] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %23 = ts.Constant {value = "number"} : !ts.string
  %24 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %25 = llvm.mlir.constant(0 : i64) : i64
  %26 = llvm.getelementptr %24[%25, %25] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %27 = ts.Constant {value = "b number: "} : !ts.string
  %28 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %29 = llvm.mlir.constant(0 : i64) : i64
  %30 = llvm.getelementptr %28[%29, %29] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %31 = ts.Constant {value = "done."} : !ts.string
  %32 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %33 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %34 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %35 = llvm.insertvalue %19, %34[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %36 = llvm.insertvalue %14, %35[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %36, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %37 = ts.Variable(%36) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %38 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %39 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %40 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %41 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %42 = llvm.mlir.constant(1 : i64) : i64
  %43 = llvm.getelementptr %41[%42] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %44 = llvm.ptrtoint %43 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %45 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %46 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %47 = llvm.mlir.constant(1 : i64) : i64
  %48 = llvm.getelementptr %46[%47] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %49 = llvm.ptrtoint %48 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %50 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %51 = llvm.icmp "ult" %45, %50 : i64
  %52 = llvm.select %51, %45, %50 : i1, i64
  %53 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%39, %40, %52, %53) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%38, %37) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %54 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %55 = ts.Load(%38) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %56 = ts.CreateUnionInstance %14, %19 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %54, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %56, %32 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %57 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %58 = ts.Load(%32) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %59 = llvm.extractvalue %57[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.GetValueFromUnionOp %57 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %61 = llvm.extractvalue %57[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %62 = ts.DialectCast %61 : !llvm.ptr<i8> to !ts.string
  %63 = ts.GetTypeInfoFromUnionOp %57 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %64 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %65 = llvm.insertvalue %63, %64[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %66 = llvm.insertvalue %60, %65[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %67 = ts.CreateUnionInstance %60, %63 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.boolean,!ts.number,!ts.string>
  %68 = ts.Cast %58 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.boolean,!ts.number,!ts.string>
  llvm.store %66, %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %68, %33 : !ts.union<!ts.boolean,!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>>
  %69 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %70 = ts.Load(%33) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  %71 = llvm.extractvalue %69[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %72 = ts.GetTypeInfoFromUnionOp %70 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.string
  %73 = llvm.mlir.constant(0 : i64) : i64
  %74 = llvm.ptrtoint %71 : !llvm.ptr<i8> to i64
  %75 = llvm.ptrtoint %22 : !llvm.ptr<i8> to i64
  %76 = llvm.icmp "ne" %74, %73 : i64
  %77 = llvm.icmp "ne" %75, %73 : i64
  %78 = llvm.zext %76 : i1 to i32
  %79 = zexti %76 : i1 to i32
  %80 = ts.Cast %76 : i1 to i32
  %81 = llvm.zext %77 : i1 to i32
  %82 = zexti %77 : i1 to i32
  %83 = ts.Cast %77 : i1 to i32
  %84 = llvm.and %80, %83  : i32
  %85 = llvm.mlir.constant(0 : i32) : i32
  %86 = llvm.icmp "ne" %84, %85 : i32
  llvm.cond_br %86, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %87 = llvm.mlir.constant(0 : i32) : i32
  %88 = llvm.call @strcmp(%71, %22) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %89 = llvm.icmp "eq" %88, %87 : i32
  llvm.br ^bb3(%89 : i1)
^bb2:  // pred: ^bb0
  %90 = llvm.icmp "eq" %74, %75 : i64
  llvm.br ^bb3(%90 : i1)
^bb3(%91: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %92 = "ts.StringCompare"(%71, %22) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %93 = ts.LogicalBinary %72(34) %23 : !ts.string, !ts.string -> !ts.boolean
  %94 = ts.Cast %93 : !ts.boolean to i1
  llvm.cond_br %91, ^bb5, ^bb6
  cond_br %94, ^bb5, ^bb6
^bb5:  // 2 preds: ^bb4, ^bb4
  %95 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %96 = ts.Load(%33) : !ts.ref<!ts.union<!ts.boolean,!ts.number,!ts.string>> -> !ts.union<!ts.boolean,!ts.number,!ts.string>
  llvm.store %95, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %97 = ts.Variable(%95) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %98 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %99 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %100 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %101 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %102 = llvm.mlir.constant(1 : i64) : i64
  %103 = llvm.getelementptr %101[%102] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %104 = llvm.ptrtoint %103 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %105 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %106 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %107 = llvm.mlir.constant(1 : i64) : i64
  %108 = llvm.getelementptr %106[%107] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %109 = llvm.ptrtoint %108 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %110 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %111 = llvm.icmp "ult" %105, %110 : i64
  %112 = llvm.select %111, %105, %110 : i1, i64
  %113 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%99, %100, %112, %113) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%98, %97) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %114 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %115 = ts.Load(%98) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
  %116 = llvm.extractvalue %115[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %117 = ts.GetValueFromUnionOp %96 : !ts.union<!ts.boolean,!ts.number,!ts.string> to !ts.number
  %118 = llvm.mlir.constant(50 : i32) : i32
  %119 = llvm.zext %118 : i32 to i64
  %120 = zexti %118 : i32 to i64
  %121 = llvm.call @malloc(%120) : (i64) -> !llvm.ptr<i8>
  %122 = llvm.bitcast %121 : !llvm.ptr<i8> to !llvm.ptr<i8>
  %123 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
  %124 = llvm.mlir.constant(0 : i64) : i64
  %125 = llvm.getelementptr %123[%124, %124] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %126 = llvm.call @sprintf_s(%122, %118, %125, %116) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
  %127 = ts.Cast %117 : !ts.number to !ts.string
  %128 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
  %129 = llvm.mlir.constant(0 : i64) : i64
  %130 = llvm.getelementptr %128[%129, %129] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %131 = ts.Constant {value = " "} : !ts.string
  %132 = llvm.intr.stacksave : !llvm.ptr<i8>
  %133 = llvm.mlir.constant(1 : i64) : i64
  %134 = llvm.call @strlen(%26) : (!llvm.ptr<i8>) -> i64
  %135 = llvm.add %133, %134  : i64
  %136 = llvm.call @strlen(%130) : (!llvm.ptr<i8>) -> i64
  %137 = llvm.add %135, %136  : i64
  %138 = llvm.call @strlen(%122) : (!llvm.ptr<i8>) -> i64
  %139 = llvm.add %137, %138  : i64
  %140 = llvm.alloca %139 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
  %141 = llvm.call @strcpy(%140, %26) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  %142 = llvm.call @strcat(%141, %130) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  %143 = llvm.call @strcat(%142, %122) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  %144 = ts.DialectCast %140 : !llvm.ptr<i8> to !ts.string
  %145 = "ts.StringConcat"(%26, %131, %122) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
  %146 = llvm.call @puts(%145) : (!ts.string) -> i32
  llvm.intr.stackrestore %132
  ts.Print(%27, %127) : !ts.string, !ts.string
  llvm.br ^bb6
  br ^bb6
^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
  %147 = llvm.call @puts(%30) : (!llvm.ptr<i8>) -> i32
  ts.Print(%31) : !ts.string
  llvm.return
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'module'(0x1b3ca8948b0) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x1b3ca89bad0) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x1b3ca89c890) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x1b3ca89af20) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x1b3ca89ae70) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x1b3ca89bce0) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x1b3ca89ac60) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x1b3ca89b130) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.global'(0x1b3ca89c520) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.global'(0x1b3ca89ce10) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.global'(0x1b3ca89c730) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.global'(0x1b3ca89cb50) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.global'(0x1b3ca89b340) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x1b3ca89d390) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x1b3ca85b5c0) {
  %0 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.alloca'(0x1b3ca7b0480) {
  %1 = "llvm.alloca"(%0) : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x1b3ca85c100) {
  %2 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.alloca'(0x1b3ca7b0240) {
  %3 = "llvm.alloca"(%2) : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x1b3ca85bc00) {
  %4 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.alloca'(0x1b3ca7afdc0) {
  %5 = "llvm.alloca"(%4) : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x1b3ca85bac0) {
  %6 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.alloca'(0x1b3ca7b1c80) {
  %7 = "llvm.alloca"(%6) : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x1b3ca85d1e0) {
  %8 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.alloca'(0x1b3ca7b0d80) {
  %9 = "llvm.alloca"(%8) : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x1b3ca85c060) {
  %10 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.alloca'(0x1b3ca7b15c0) {
  %11 = "llvm.alloca"(%10) : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x1b3ca85cec0) {
  %12 = "llvm.mlir.constant"() {value = 1.000000e+01 : f64} : () -> f64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.addressof'(0x1b3ca85c6a0) {
  %13 = "llvm.mlir.addressof"() {global_name = @s_9237349086447201248} : () -> !llvm.ptr<array<7 x i8>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x1b3ca85b840) {
  %14 = "llvm.mlir.constant"() {value = 0 : i64} : () -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x1b3ca712830) {
  %15 = "llvm.getelementptr"(%13, %14, %14) : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.addressof'(0x1b3ca85bb60) {
  %16 = "llvm.mlir.addressof"() {global_name = @s_9237349086447201248} : () -> !llvm.ptr<array<7 x i8>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x1b3ca85b200) {
  %17 = "llvm.mlir.constant"() {value = 0 : i64} : () -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x1b3ca71e230) {
  %18 = "llvm.getelementptr"(%16, %17, %17) : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.addressof'(0x1b3ca85bca0) {
  %19 = "llvm.mlir.addressof"() {global_name = @s_13617892236937420068} : () -> !llvm.ptr<array<11 x i8>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x1b3ca85ba20) {
  %20 = "llvm.mlir.constant"() {value = 0 : i64} : () -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x1b3ca71c930) {
  %21 = "llvm.getelementptr"(%19, %20, %20) : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.addressof'(0x1b3ca85c880) {
  %22 = "llvm.mlir.addressof"() {global_name = @s_6682479467004374669} : () -> !llvm.ptr<array<6 x i8>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x1b3ca85ca60) {
  %23 = "llvm.mlir.constant"() {value = 0 : i64} : () -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x1b3ca71df30) {
  %24 = "llvm.getelementptr"(%22, %23, %23) : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.undef'(0x1b3ca85bde0) {
  %25 = "llvm.mlir.undef"() : () -> !llvm.struct<(ptr<i8>, f64)>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.insertvalue'(0x1b3ca8d8a00) {
  %26 = "llvm.insertvalue"(%25, %15) {position = [0 : i32]} : (!llvm.struct<(ptr<i8>, f64)>, !llvm.ptr<i8>) -> !llvm.struct<(ptr<i8>, f64)>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.insertvalue'(0x1b3ca8d9aa0) {
  %27 = "llvm.insertvalue"(%26, %12) {position = [1 : i32]} : (!llvm.struct<(ptr<i8>, f64)>, f64) -> !llvm.struct<(ptr<i8>, f64)>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.store'(0x1b3ca7fd950) {
  "llvm.store"(%27, %7) : (!llvm.struct<(ptr<i8>, f64)>, !llvm.ptr<struct<(ptr<i8>, f64)>>) -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.bitcast'(0x1b3ca7b0e40) {
  %28 = "llvm.bitcast"(%5) : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>) -> !llvm.ptr<i8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.bitcast'(0x1b3ca7b1e00) {
  %29 = "llvm.bitcast"(%7) : (!llvm.ptr<struct<(ptr<i8>, f64)>>) -> !llvm.ptr<i8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.null'(0x1b3ca85b3e0) {
  %30 = "llvm.mlir.null"() : () -> !llvm.ptr<struct<(ptr<i8>, f64)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x1b3ca85c2e0) {
  %31 = "llvm.mlir.constant"() {value = 1 : i64} : () -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x1b3ca8d6d20) {
  %32 = "llvm.getelementptr"(%30, %31) : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.ptrtoint'(0x1b3ca7b1680) {
  %33 = "llvm.ptrtoint"(%32) : (!llvm.ptr<struct<(ptr<i8>, f64)>>) -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.null'(0x1b3ca85cce0) {
  %34 = "llvm.mlir.null"() : () -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x1b3ca85be80) {
  %35 = "llvm.mlir.constant"() {value = 1 : i64} : () -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x1b3ca8d6fc0) {
  %36 = "llvm.getelementptr"(%34, %35) : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.ptrtoint'(0x1b3ca7af280) {
  %37 = "llvm.ptrtoint"(%36) : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>) -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.icmp'(0x1b3ca8d9fe0) {
  %38 = "llvm.icmp"(%33, %37) {predicate = 6 : i64} : (i64, i64) -> i1

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.select'(0x1b3ca71e430) {
  %39 = "llvm.select"(%38, %33, %37) : (i1, i64, i64) -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x1b3ca85cf60) {
  %40 = "llvm.mlir.constant"() {value = false} : () -> i1

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.call'(0x1b3ca7d3df0) {
  "llvm.call"(%28, %29, %39, %40) {callee = @llvm.memcpy.p0i8.p0i8.i64} : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.load'(0x1b3ca7b1080) {
  %41 = "llvm.load"(%5) : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>) -> !llvm.struct<(ptr<i8>, ptr<i8>)>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.store'(0x1b3ca7fa960) {
  "llvm.store"(%41, %11) : (!llvm.struct<(ptr<i8>, ptr<i8>)>, !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>) -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.load'(0x1b3ca7b2040) {
  %42 = "llvm.load"(%11) : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>) -> !llvm.struct<(ptr<i8>, ptr<i8>)>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.extractvalue'(0x1b3ca7b1500) {
  %43 = "llvm.extractvalue"(%42) {position = [1 : i32]} : (!llvm.struct<(ptr<i8>, ptr<i8>)>) -> !llvm.ptr<i8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.extractvalue'(0x1b3ca7b1740) {
  %44 = "llvm.extractvalue"(%42) {position = [0 : i32]} : (!llvm.struct<(ptr<i8>, ptr<i8>)>) -> !llvm.ptr<i8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.undef'(0x1b3ca85b980) {
  %45 = "llvm.mlir.undef"() : () -> !llvm.struct<(ptr<i8>, ptr<i8>)>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.insertvalue'(0x1b3ca8d7180) {
  %46 = "llvm.insertvalue"(%45, %44) {position = [0 : i32]} : (!llvm.struct<(ptr<i8>, ptr<i8>)>, !llvm.ptr<i8>) -> !llvm.struct<(ptr<i8>, ptr<i8>)>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.insertvalue'(0x1b3ca8d8ca0) {
  %47 = "llvm.insertvalue"(%46, %43) {position = [1 : i32]} : (!llvm.struct<(ptr<i8>, ptr<i8>)>, !llvm.ptr<i8>) -> !llvm.struct<(ptr<i8>, ptr<i8>)>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.store'(0x1b3ca7fb320) {
  "llvm.store"(%47, %9) : (!llvm.struct<(ptr<i8>, ptr<i8>)>, !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>) -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.load'(0x1b3ca7b0b40) {
  %48 = "llvm.load"(%9) : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>) -> !llvm.struct<(ptr<i8>, ptr<i8>)>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.extractvalue'(0x1b3ca7af100) {
  %49 = "llvm.extractvalue"(%48) {position = [0 : i32]} : (!llvm.struct<(ptr<i8>, ptr<i8>)>) -> !llvm.ptr<i8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x1b3ca85d5a0) {
  %50 = "llvm.mlir.constant"() {value = 0 : i64} : () -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.ptrtoint'(0x1b3ca7af580) {
  %51 = "llvm.ptrtoint"(%49) : (!llvm.ptr<i8>) -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.ptrtoint'(0x1b3ca7b0cc0) {
  %52 = "llvm.ptrtoint"(%18) : (!llvm.ptr<i8>) -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.icmp'(0x1b3ca8d8f40) {
  %53 = "llvm.icmp"(%51, %50) {predicate = 1 : i64} : (i64, i64) -> i1

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.icmp'(0x1b3ca8d9100) {
  %54 = "llvm.icmp"(%52, %50) {predicate = 1 : i64} : (i64, i64) -> i1

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.zext'(0x1b3ca7af700) {
  %55 = "llvm.zext"(%53) : (i1) -> i32

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.zext'(0x1b3ca7b03c0) {
  %56 = "llvm.zext"(%54) : (i1) -> i32

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.and'(0x1b3ca8d9560) {
  %57 = "llvm.and"(%55, %56) : (i32, i32) -> i32

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x1b3ca85cd80) {
  %58 = "llvm.mlir.constant"() {value = 0 : i32} : () -> i32

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.icmp'(0x1b3ca8d9640) {
  %59 = "llvm.icmp"(%57, %58) {predicate = 1 : i64} : (i32, i32) -> i1

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.cond_br'(0x1b3ca8354d0) {
  "llvm.cond_br"(%59)[^bb1, ^bb2] {operand_segment_sizes = dense<[1, 0, 0]> : vector<3xi32>} : (i1) -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.icmp'(0x1b3ca8da6e0) {
  %63 = "llvm.icmp"(%51, %52) {predicate = 0 : i64} : (i64, i64) -> i1

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.br'(0x1b3ca7fdaf0) {
  "llvm.br"(%63)[^bb3] : (i1) -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.br'(0x1b3ca89cf70) {
  "llvm.br"()[^bb4] : () -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.cond_br'(0x1b3ca833400) {
  "llvm.cond_br"(%64)[^bb5, ^bb6] {operand_segment_sizes = dense<[1, 0, 0]> : vector<3xi32>} : (i1) -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.call'(0x1b3ca7af880) {
  %105 = "llvm.call"(%24) {callee = @puts} : (!llvm.ptr<i8>) -> i32

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.return'(0x1b3ca977240) {
  "llvm.return"() : () -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.load'(0x1b3ca7b0180) {
  %65 = "llvm.load"(%9) : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>) -> !llvm.struct<(ptr<i8>, ptr<i8>)>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.store'(0x1b3ca7fcec0) {
  "llvm.store"(%65, %3) : (!llvm.struct<(ptr<i8>, ptr<i8>)>, !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>) -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.bitcast'(0x1b3ca7b1140) {
  %66 = "llvm.bitcast"(%1) : (!llvm.ptr<struct<(ptr<i8>, f64)>>) -> !llvm.ptr<i8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.bitcast'(0x1b3ca7b42c0) {
  %67 = "llvm.bitcast"(%3) : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>) -> !llvm.ptr<i8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.null'(0x1b3ca85ce20) {
  %68 = "llvm.mlir.null"() : () -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x1b3ca85c4c0) {
  %69 = "llvm.mlir.constant"() {value = 1 : i64} : () -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x1b3ca8dafa0) {
  %70 = "llvm.getelementptr"(%68, %69) : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.ptrtoint'(0x1b3ca7b4a40) {
  %71 = "llvm.ptrtoint"(%70) : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>) -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.null'(0x1b3ca85db40) {
  %72 = "llvm.mlir.null"() : () -> !llvm.ptr<struct<(ptr<i8>, f64)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x1b3ca85e220) {
  %73 = "llvm.mlir.constant"() {value = 1 : i64} : () -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x1b3ca8dbb00) {
  %74 = "llvm.getelementptr"(%72, %73) : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.ptrtoint'(0x1b3ca7b3cc0) {
  %75 = "llvm.ptrtoint"(%74) : (!llvm.ptr<struct<(ptr<i8>, f64)>>) -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.icmp'(0x1b3ca8da520) {
  %76 = "llvm.icmp"(%71, %75) {predicate = 6 : i64} : (i64, i64) -> i1

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.select'(0x1b3ca71e530) {
  %77 = "llvm.select"(%76, %71, %75) : (i1, i64, i64) -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x1b3ca85c380) {
  %78 = "llvm.mlir.constant"() {value = false} : () -> i1

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.call'(0x1b3ca7d4780) {
  "llvm.call"(%66, %67, %77, %78) {callee = @llvm.memcpy.p0i8.p0i8.i64} : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.load'(0x1b3ca7b3540) {
  %79 = "llvm.load"(%1) : (!llvm.ptr<struct<(ptr<i8>, f64)>>) -> !llvm.struct<(ptr<i8>, f64)>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.extractvalue'(0x1b3ca7b00c0) {
  %80 = "llvm.extractvalue"(%79) {position = [1 : i32]} : (!llvm.struct<(ptr<i8>, f64)>) -> f64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x1b3ca85fda0) {
  %81 = "llvm.mlir.constant"() {value = 50 : i32} : () -> i32

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.zext'(0x1b3ca7b2580) {
  %82 = "llvm.zext"(%81) : (i32) -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.call'(0x1b3ca7b5040) {
  %83 = "llvm.call"(%82) {callee = @malloc} : (i64) -> !llvm.ptr<i8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.bitcast'(0x1b3ca7b4680) {
  %84 = "llvm.bitcast"(%83) : (!llvm.ptr<i8>) -> !llvm.ptr<i8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.addressof'(0x1b3ca85dc80) {
  %85 = "llvm.mlir.addressof"() {global_name = @frmt_555404038213028357} : () -> !llvm.ptr<array<3 x i8>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x1b3ca85ff80) {
  %86 = "llvm.mlir.constant"() {value = 0 : i64} : () -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x1b3ca71e630) {
  %87 = "llvm.getelementptr"(%85, %86, %86) : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.call'(0x1b3ca791110) {
  %88 = "llvm.call"(%84, %81, %87, %80) {callee = @sprintf_s} : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.addressof'(0x1b3ca85e860) {
  %89 = "llvm.mlir.addressof"() {global_name = @s_12638117931323064703} : () -> !llvm.ptr<array<2 x i8>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x1b3ca85e360) {
  %90 = "llvm.mlir.constant"() {value = 0 : i64} : () -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x1b3ca71e930) {
  %91 = "llvm.getelementptr"(%89, %90, %90) : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.intr.stacksave'(0x1b3ca85eae0) {
  %92 = "llvm.intr.stacksave"() : () -> !llvm.ptr<i8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x1b3ca85e400) {
  %93 = "llvm.mlir.constant"() {value = 1 : i64} : () -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.call'(0x1b3ca7b3600) {
  %94 = "llvm.call"(%21) {callee = @strlen} : (!llvm.ptr<i8>) -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.add'(0x1b3ca8dab40) {
  %95 = "llvm.add"(%93, %94) : (i64, i64) -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.call'(0x1b3ca7b2100) {
  %96 = "llvm.call"(%91) {callee = @strlen} : (!llvm.ptr<i8>) -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.add'(0x1b3ca8db4e0) {
  %97 = "llvm.add"(%95, %96) : (i64, i64) -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.call'(0x1b3ca7b36c0) {
  %98 = "llvm.call"(%84) {callee = @strlen} : (!llvm.ptr<i8>) -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.add'(0x1b3ca8dad00) {
  %99 = "llvm.add"(%97, %98) : (i64, i64) -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.alloca'(0x1b3ca7b4140) {
  %100 = "llvm.alloca"(%99) {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.call'(0x1b3ca8dac20) {
  %101 = "llvm.call"(%100, %21) {callee = @strcpy} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.call'(0x1b3ca8dade0) {
  %102 = "llvm.call"(%101, %91) {callee = @strcat} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.call'(0x1b3ca8daec0) {
  %103 = "llvm.call"(%102, %84) {callee = @strcat} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.call'(0x1b3ca7b2940) {
  %104 = "llvm.call"(%100) {callee = @puts} : (!llvm.ptr<i8>) -> i32

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.intr.stackrestore'(0x1b3ca89c7e0) {
  "llvm.intr.stackrestore"(%92) : (!llvm.ptr<i8>) -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.br'(0x1b3ca89b970) {
  "llvm.br"()[^bb6] : () -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x1b3ca85d780) {
  %60 = "llvm.mlir.constant"() {value = 0 : i32} : () -> i32

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.call'(0x1b3ca8da440) {
  %61 = "llvm.call"(%49, %18) {callee = @strcmp} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.icmp'(0x1b3ca8da8a0) {
  %62 = "llvm.icmp"(%61, %60) {predicate = 0 : i64} : (i32, i32) -> i1

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.br'(0x1b3ca7fd6e0) {
  "llvm.br"(%62)[^bb3] : (i1) -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x1b3ca89b600) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x1b3ca89d230) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x1b3ca89c940) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x1b3ca89afd0) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x1b3ca89c5d0) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x1b3ca89be40) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x1b3ca89d020) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x1b3ca89d2e0) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x1b3ca89c680) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x1b3ca89b6b0) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x1b3ca89c100) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x1b3ca89b1e0) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x1b3ca89c9f0) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x1b3ca89bfa0) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x1b3ca89caa0) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x1b3ca89b290) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x1b3ca89ab00) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x1b3ca89b810) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x1b3ca89c1b0) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x1b3ca89cc00) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x1b3ca89cd60) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x1b3ca894330) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x1b3ca892b20) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

!! AFTER DUMP: 
module @"c:\\temp\\1.ts"  {
  llvm.func @strcat(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strcpy(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strlen(!llvm.ptr<i8>) -> i64
  llvm.func @sprintf_s(!llvm.ptr<i8>, i32, !llvm.ptr<i8>, ...) -> i32
  llvm.func @puts(!llvm.ptr<i8>) -> i32
  llvm.func @strcmp(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  llvm.func @llvm.memcpy.p0i8.p0i8.i64(!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1)
  llvm.mlir.global internal constant @s_9237349086447201248("number\00")
  llvm.mlir.global internal constant @s_13617892236937420068("b number: \00")
  llvm.mlir.global internal constant @s_6682479467004374669("done.\00")
  llvm.mlir.global internal constant @frmt_555404038213028357("%g\00")
  llvm.mlir.global internal constant @s_12638117931323064703(" \00")
  llvm.func @main() {
    %0 = llvm.mlir.constant(1 : i32) : i32
    %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %2 = llvm.mlir.constant(1 : i32) : i32
    %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %4 = llvm.mlir.constant(1 : i32) : i32
    %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %6 = llvm.mlir.constant(1 : i32) : i32
    %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %8 = llvm.mlir.constant(1 : i32) : i32
    %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %10 = llvm.mlir.constant(1 : i32) : i32
    %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
    %13 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %14 = llvm.mlir.constant(0 : i64) : i64
    %15 = llvm.getelementptr %13[%14, %14] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %16 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %17 = llvm.mlir.constant(0 : i64) : i64
    %18 = llvm.getelementptr %16[%17, %17] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %19 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
    %20 = llvm.mlir.constant(0 : i64) : i64
    %21 = llvm.getelementptr %19[%20, %20] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %22 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
    %23 = llvm.mlir.constant(0 : i64) : i64
    %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %25 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
    %26 = llvm.insertvalue %15, %25[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %27 = llvm.insertvalue %12, %26[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    llvm.store %27, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %28 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %29 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %30 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %31 = llvm.mlir.constant(1 : i64) : i64
    %32 = llvm.getelementptr %30[%31] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %33 = llvm.ptrtoint %32 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %34 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %35 = llvm.mlir.constant(1 : i64) : i64
    %36 = llvm.getelementptr %34[%35] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %37 = llvm.ptrtoint %36 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %38 = llvm.icmp "ult" %33, %37 : i64
    %39 = llvm.select %38, %33, %37 : i1, i64
    %40 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%28, %29, %39, %40) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    %41 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    llvm.store %41, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %42 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %43 = llvm.extractvalue %42[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %44 = llvm.extractvalue %42[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %45 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %46 = llvm.insertvalue %44, %45[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %47 = llvm.insertvalue %43, %46[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    llvm.store %47, %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %48 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %49 = llvm.extractvalue %48[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %50 = llvm.mlir.constant(0 : i64) : i64
    %51 = llvm.ptrtoint %49 : !llvm.ptr<i8> to i64
    %52 = llvm.ptrtoint %18 : !llvm.ptr<i8> to i64
    %53 = llvm.icmp "ne" %51, %50 : i64
    %54 = llvm.icmp "ne" %52, %50 : i64
    %55 = llvm.zext %53 : i1 to i32
    %56 = llvm.zext %54 : i1 to i32
    %57 = llvm.and %55, %56  : i32
    %58 = llvm.mlir.constant(0 : i32) : i32
    %59 = llvm.icmp "ne" %57, %58 : i32
    llvm.cond_br %59, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %60 = llvm.mlir.constant(0 : i32) : i32
    %61 = llvm.call @strcmp(%49, %18) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
    %62 = llvm.icmp "eq" %61, %60 : i32
    llvm.br ^bb3(%62 : i1)
  ^bb2:  // pred: ^bb0
    %63 = llvm.icmp "eq" %51, %52 : i64
    llvm.br ^bb3(%63 : i1)
  ^bb3(%64: i1):  // 2 preds: ^bb1, ^bb2
    llvm.br ^bb4
  ^bb4:  // pred: ^bb3
    llvm.cond_br %64, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    %65 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    llvm.store %65, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %66 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %67 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %68 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %69 = llvm.mlir.constant(1 : i64) : i64
    %70 = llvm.getelementptr %68[%69] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %71 = llvm.ptrtoint %70 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %72 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %73 = llvm.mlir.constant(1 : i64) : i64
    %74 = llvm.getelementptr %72[%73] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %75 = llvm.ptrtoint %74 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %76 = llvm.icmp "ult" %71, %75 : i64
    %77 = llvm.select %76, %71, %75 : i1, i64
    %78 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%66, %67, %77, %78) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    %79 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %80 = llvm.extractvalue %79[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %81 = llvm.mlir.constant(50 : i32) : i32
    %82 = llvm.zext %81 : i32 to i64
    %83 = llvm.call @malloc(%82) : (i64) -> !llvm.ptr<i8>
    %84 = llvm.bitcast %83 : !llvm.ptr<i8> to !llvm.ptr<i8>
    %85 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
    %86 = llvm.mlir.constant(0 : i64) : i64
    %87 = llvm.getelementptr %85[%86, %86] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %88 = llvm.call @sprintf_s(%84, %81, %87, %80) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
    %89 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
    %90 = llvm.mlir.constant(0 : i64) : i64
    %91 = llvm.getelementptr %89[%90, %90] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %92 = llvm.intr.stacksave : !llvm.ptr<i8>
    %93 = llvm.mlir.constant(1 : i64) : i64
    %94 = llvm.call @strlen(%21) : (!llvm.ptr<i8>) -> i64
    %95 = llvm.add %93, %94  : i64
    %96 = llvm.call @strlen(%91) : (!llvm.ptr<i8>) -> i64
    %97 = llvm.add %95, %96  : i64
    %98 = llvm.call @strlen(%84) : (!llvm.ptr<i8>) -> i64
    %99 = llvm.add %97, %98  : i64
    %100 = llvm.alloca %99 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
    %101 = llvm.call @strcpy(%100, %21) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %102 = llvm.call @strcat(%101, %91) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %103 = llvm.call @strcat(%102, %84) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %104 = llvm.call @puts(%100) : (!llvm.ptr<i8>) -> i32
    llvm.intr.stackrestore %92
    llvm.br ^bb6
  ^bb6:  // 2 preds: ^bb4, ^bb5
    %105 = llvm.call @puts(%24) : (!llvm.ptr<i8>) -> i32
    llvm.return
  }
  llvm.func @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>) attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64 attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>) attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>) attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>) attributes {sym_visibility = "private"}
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}
** Insert  : 'llvm.func'(0x1b3ca89b3f0)
** Insert  : 'llvm.call'(0x1b3ca978560)
module @"c:\\temp\\1.ts"  {
  llvm.func @GC_init()
  llvm.func @strcat(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strcpy(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strlen(!llvm.ptr<i8>) -> i64
  llvm.func @sprintf_s(!llvm.ptr<i8>, i32, !llvm.ptr<i8>, ...) -> i32
  llvm.func @puts(!llvm.ptr<i8>) -> i32
  llvm.func @strcmp(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  llvm.func @llvm.memcpy.p0i8.p0i8.i64(!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1)
  llvm.mlir.global internal constant @s_9237349086447201248("number\00")
  llvm.mlir.global internal constant @s_13617892236937420068("b number: \00")
  llvm.mlir.global internal constant @s_6682479467004374669("done.\00")
  llvm.mlir.global internal constant @frmt_555404038213028357("%g\00")
  llvm.mlir.global internal constant @s_12638117931323064703(" \00")
  llvm.func @main() {
    llvm.call @GC_init() : () -> ()
    %0 = llvm.mlir.constant(1 : i32) : i32
    %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %2 = llvm.mlir.constant(1 : i32) : i32
    %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %4 = llvm.mlir.constant(1 : i32) : i32
    %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %6 = llvm.mlir.constant(1 : i32) : i32
    %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %8 = llvm.mlir.constant(1 : i32) : i32
    %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %10 = llvm.mlir.constant(1 : i32) : i32
    %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
    %13 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %14 = llvm.mlir.constant(0 : i64) : i64
    %15 = llvm.getelementptr %13[%14, %14] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %16 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %17 = llvm.mlir.constant(0 : i64) : i64
    %18 = llvm.getelementptr %16[%17, %17] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %19 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
    %20 = llvm.mlir.constant(0 : i64) : i64
    %21 = llvm.getelementptr %19[%20, %20] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %22 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
    %23 = llvm.mlir.constant(0 : i64) : i64
    %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %25 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
    %26 = llvm.insertvalue %15, %25[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %27 = llvm.insertvalue %12, %26[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    llvm.store %27, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %28 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %29 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %30 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %31 = llvm.mlir.constant(1 : i64) : i64
    %32 = llvm.getelementptr %30[%31] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %33 = llvm.ptrtoint %32 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %34 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %35 = llvm.mlir.constant(1 : i64) : i64
    %36 = llvm.getelementptr %34[%35] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %37 = llvm.ptrtoint %36 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %38 = llvm.icmp "ult" %33, %37 : i64
    %39 = llvm.select %38, %33, %37 : i1, i64
    %40 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%28, %29, %39, %40) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    %41 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    llvm.store %41, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %42 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %43 = llvm.extractvalue %42[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %44 = llvm.extractvalue %42[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %45 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %46 = llvm.insertvalue %44, %45[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %47 = llvm.insertvalue %43, %46[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    llvm.store %47, %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %48 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %49 = llvm.extractvalue %48[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %50 = llvm.mlir.constant(0 : i64) : i64
    %51 = llvm.ptrtoint %49 : !llvm.ptr<i8> to i64
    %52 = llvm.ptrtoint %18 : !llvm.ptr<i8> to i64
    %53 = llvm.icmp "ne" %51, %50 : i64
    %54 = llvm.icmp "ne" %52, %50 : i64
    %55 = llvm.zext %53 : i1 to i32
    %56 = llvm.zext %54 : i1 to i32
    %57 = llvm.and %55, %56  : i32
    %58 = llvm.mlir.constant(0 : i32) : i32
    %59 = llvm.icmp "ne" %57, %58 : i32
    llvm.cond_br %59, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %60 = llvm.mlir.constant(0 : i32) : i32
    %61 = llvm.call @strcmp(%49, %18) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
    %62 = llvm.icmp "eq" %61, %60 : i32
    llvm.br ^bb3(%62 : i1)
  ^bb2:  // pred: ^bb0
    %63 = llvm.icmp "eq" %51, %52 : i64
    llvm.br ^bb3(%63 : i1)
  ^bb3(%64: i1):  // 2 preds: ^bb1, ^bb2
    llvm.br ^bb4
  ^bb4:  // pred: ^bb3
    llvm.cond_br %64, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    %65 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    llvm.store %65, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %66 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %67 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %68 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %69 = llvm.mlir.constant(1 : i64) : i64
    %70 = llvm.getelementptr %68[%69] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %71 = llvm.ptrtoint %70 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %72 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %73 = llvm.mlir.constant(1 : i64) : i64
    %74 = llvm.getelementptr %72[%73] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %75 = llvm.ptrtoint %74 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %76 = llvm.icmp "ult" %71, %75 : i64
    %77 = llvm.select %76, %71, %75 : i1, i64
    %78 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%66, %67, %77, %78) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    %79 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %80 = llvm.extractvalue %79[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %81 = llvm.mlir.constant(50 : i32) : i32
    %82 = llvm.zext %81 : i32 to i64
    %83 = llvm.call @GC_malloc(%82) : (i64) -> !llvm.ptr<i8>
    %84 = llvm.bitcast %83 : !llvm.ptr<i8> to !llvm.ptr<i8>
    %85 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
    %86 = llvm.mlir.constant(0 : i64) : i64
    %87 = llvm.getelementptr %85[%86, %86] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %88 = llvm.call @sprintf_s(%84, %81, %87, %80) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
    %89 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
    %90 = llvm.mlir.constant(0 : i64) : i64
    %91 = llvm.getelementptr %89[%90, %90] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %92 = llvm.intr.stacksave : !llvm.ptr<i8>
    %93 = llvm.mlir.constant(1 : i64) : i64
    %94 = llvm.call @strlen(%21) : (!llvm.ptr<i8>) -> i64
    %95 = llvm.add %93, %94  : i64
    %96 = llvm.call @strlen(%91) : (!llvm.ptr<i8>) -> i64
    %97 = llvm.add %95, %96  : i64
    %98 = llvm.call @strlen(%84) : (!llvm.ptr<i8>) -> i64
    %99 = llvm.add %97, %98  : i64
    %100 = llvm.alloca %99 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
    %101 = llvm.call @strcpy(%100, %21) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %102 = llvm.call @strcat(%101, %91) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %103 = llvm.call @strcat(%102, %84) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %104 = llvm.call @puts(%100) : (!llvm.ptr<i8>) -> i32
    llvm.intr.stackrestore %92
    llvm.br ^bb6
  ^bb6:  // 2 preds: ^bb4, ^bb5
    %105 = llvm.call @puts(%24) : (!llvm.ptr<i8>) -> i32
    llvm.return
  }
  llvm.func @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>) attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64 attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>) attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>) attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>) attributes {sym_visibility = "private"}
  llvm.func @GC_malloc(i64) -> !llvm.ptr<i8>
  llvm.func @GC_free(!llvm.ptr<i8>)
}
