Args: tsc.exe --emit=mlir-llvm c:\temp\1.ts -debug 
Load new dialect in Context 
Load new dialect in Context ts
Load new dialect in Context std
Load new dialect in Context math
Load new dialect in Context llvm
Load new dialect in Context async

!! discovering 'ret type' & 'captured vars' for : main

!! variable = a type: !ts.union<!ts.number,!ts.string> op: %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>

!! variable = b type: !ts.union<!ts.string,!ts.number,!ts.boolean> op: %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>

!! variable: a type: !ts.ref<!ts.union<!ts.number,!ts.string>>

!! Dest type: !ts.union<!ts.number,!ts.string>

!! variable: b type: !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>

!! variable: a type: !ts.ref<!ts.union<!ts.number,!ts.string>>

!! Dest type: !ts.union<!ts.string,!ts.number,!ts.boolean>

!! variable: b type: !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>

!! variable: b type: !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>

!! variable = b type: !ts.number op: %13 = ts.Cast %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number

!! variable = a type: !ts.union<!ts.number,!ts.string> op: %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>

!! variable = b type: !ts.union<!ts.string,!ts.number,!ts.boolean> op: %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>

!! variable: a type: !ts.ref<!ts.union<!ts.number,!ts.string>>

!! Dest type: !ts.union<!ts.number,!ts.string>

!! variable: b type: !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>

!! variable: a type: !ts.ref<!ts.union<!ts.number,!ts.string>>

!! Dest type: !ts.union<!ts.string,!ts.number,!ts.boolean>

!! variable: b type: !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>

!! variable: b type: !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>

!! variable = b type: !ts.number op: %13 = ts.Cast %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number

!! reg. func: main type:() -> ()

!! reg. func: main num inputs:0

!! variable = a type: !ts.union<!ts.number,!ts.string> op: %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>

!! variable = b type: !ts.union<!ts.string,!ts.number,!ts.boolean> op: %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>

!! variable: a type: !ts.ref<!ts.union<!ts.number,!ts.string>>

!! Dest type: !ts.union<!ts.number,!ts.string>

!! variable: b type: !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>

!! variable: a type: !ts.ref<!ts.union<!ts.number,!ts.string>>

!! Dest type: !ts.union<!ts.string,!ts.number,!ts.boolean>

!! variable: b type: !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>

!! variable: b type: !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>

!! variable = b type: !ts.number op: %13 = ts.Cast %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number

!! re-process. func: main type:() -> ()

!! re-process. func: main num inputs:0
Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %6 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %7 = ts.Cast %6 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %7, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %8 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %9 = "ts.TypeOf"(%8) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %10 = ts.Constant {value = "number"} : !ts.string
  %11 = ts.LogicalBinary %9(34) %10 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%11) ( {
    %14 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %15 = ts.Cast %14 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %16 = ts.UnresolvedSymbolRef {identifier = @print} : none
    %17 = ts.Constant {value = "b number: "} : !ts.string
    %18 = ts.Cast %15 : !ts.number to !ts.string
    ts.Print(%17, %18) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %12 = ts.UnresolvedSymbolRef {identifier = @print} : none
  %13 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%13) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %13 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %14 = ts.Cast %13 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %15 = ts.UnresolvedSymbolRef {identifier = @print} : none
    %16 = ts.Constant {value = "b number: "} : !ts.string
    %17 = ts.Cast %14 : !ts.number to !ts.string
    ts.Print(%16, %17) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.UnresolvedSymbolRef {identifier = @print} : none
  %12 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%12) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %13 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %14 = ts.Cast %13 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %15 = ts.UnresolvedSymbolRef {identifier = @print} : none
    %16 = ts.Constant {value = "b number: "} : !ts.string
    %17 = ts.Cast %14 : !ts.number to !ts.string
    ts.Print(%16, %17) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.UnresolvedSymbolRef {identifier = @print} : none
  %12 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%12) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %13 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %14 = ts.Cast %13 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %15 = ts.UnresolvedSymbolRef {identifier = @print} : none
    %16 = ts.Constant {value = "b number: "} : !ts.string
    %17 = ts.Cast %14 : !ts.number to !ts.string
    ts.Print(%16, %17) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.UnresolvedSymbolRef {identifier = @print} : none
  %12 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%12) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnusedResults"
"`anonymous-namespace'::RemoveUnusedResults" result 0
Trying to match "`anonymous-namespace'::RemoveStaticCondition"
"`anonymous-namespace'::RemoveStaticCondition" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %13 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %14 = ts.Cast %13 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %15 = ts.UnresolvedSymbolRef {identifier = @print} : none
    %16 = ts.Constant {value = "b number: "} : !ts.string
    %17 = ts.Cast %14 : !ts.number to !ts.string
    ts.Print(%16, %17) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.UnresolvedSymbolRef {identifier = @print} : none
  %12 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%12) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %13 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %14 = ts.GetValueFromUnionOp %13 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %15 = ts.UnresolvedSymbolRef {identifier = @print} : none
    %16 = ts.Constant {value = "b number: "} : !ts.string
    %17 = ts.Cast %14 : !ts.number to !ts.string
    ts.Print(%16, %17) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.UnresolvedSymbolRef {identifier = @print} : none
  %12 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%12) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %13 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %14 = ts.GetValueFromUnionOp %13 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %15 = ts.Constant {value = "b number: "} : !ts.string
    %16 = ts.Cast %14 : !ts.number to !ts.string
    ts.Print(%15, %16) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.UnresolvedSymbolRef {identifier = @print} : none
  %12 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%12) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnusedResults"
"`anonymous-namespace'::RemoveUnusedResults" result 0
Trying to match "`anonymous-namespace'::RemoveStaticCondition"
"`anonymous-namespace'::RemoveStaticCondition" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnusedResults"
"`anonymous-namespace'::RemoveUnusedResults" result 0
Trying to match "`anonymous-namespace'::RemoveStaticCondition"
"`anonymous-namespace'::RemoveStaticCondition" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnusedResults"
"`anonymous-namespace'::RemoveUnusedResults" result 0
Trying to match "`anonymous-namespace'::RemoveStaticCondition"
"`anonymous-namespace'::RemoveStaticCondition" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnusedResults"
"`anonymous-namespace'::RemoveUnusedResults" result 0
Trying to match "`anonymous-namespace'::RemoveStaticCondition"
"`anonymous-namespace'::RemoveStaticCondition" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnusedResults"
"`anonymous-namespace'::RemoveUnusedResults" result 0
Trying to match "`anonymous-namespace'::RemoveStaticCondition"
"`anonymous-namespace'::RemoveStaticCondition" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnusedResults"
"`anonymous-namespace'::RemoveUnusedResults" result 0
Trying to match "`anonymous-namespace'::RemoveStaticCondition"
"`anonymous-namespace'::RemoveStaticCondition" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnusedResults"
"`anonymous-namespace'::RemoveUnusedResults" result 0
Trying to match "`anonymous-namespace'::RemoveStaticCondition"
"`anonymous-namespace'::RemoveStaticCondition" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnusedResults"
"`anonymous-namespace'::RemoveUnusedResults" result 0
Trying to match "`anonymous-namespace'::RemoveStaticCondition"
"`anonymous-namespace'::RemoveStaticCondition" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::RemoveUnusedResults"
"`anonymous-namespace'::RemoveUnusedResults" result 0
Trying to match "`anonymous-namespace'::RemoveStaticCondition"
"`anonymous-namespace'::RemoveStaticCondition" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
}


The pattern rewrite doesn't converge after scanning 10 times

//===-------------------------------------------===//
Legalizing operation : 'ts.Func'(0x278e950b810) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Entry'(0x278e95f0500) {
  "ts.Entry"() : () -> ()

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.Entry -> ()' {
Trying to match "`anonymous-namespace'::EntryOpLowering"
    ** Insert  : 'ts.ReturnInternal'(0x278e95f0ce0)
    ** Erase   : 'ts.Entry'(0x278e95f0500)
"`anonymous-namespace'::EntryOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'ts.ReturnInternal'(0x278e95f0ce0) {
      "ts.ReturnInternal"() : () -> ()

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = "ts.TypeOf"(%7) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%10) ( {
    %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %14 = ts.Constant {value = "b number: "} : !ts.string
    %15 = ts.Cast %13 : !ts.number to !ts.string
    ts.Print(%14, %15) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %11 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%11) : !ts.string
  "ts.Exit"() : () -> ()
^bb1:  // no predecessors
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Variable'(0x278e94cf2c0) {
  %0 = "ts.Variable"() {captured = false} : () -> !ts.ref<!ts.union<!ts.number,!ts.string>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Variable'(0x278e94ce780) {
  %1 = "ts.Variable"() {captured = false} : () -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Constant'(0x278e94ce820) {
  %2 = "ts.Constant"() {value = 1.000000e+01 : f64} : () -> !ts.number

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.TypeOf'(0x278e942ffc0) {
  %3 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.TypeOf -> ()' {
Trying to match "`anonymous-namespace'::TypeOfOpLowering"
    ** Insert  : 'ts.Constant'(0x278e94d3500)
    ** Replace : 'ts.TypeOf'(0x278e942ffc0)
"`anonymous-namespace'::TypeOfOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'ts.Constant'(0x278e94d3500) {
      %3 = "ts.Constant"() {value = "number"} : () -> !ts.string

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %5 = ts.CreateUnionInstance %2, %4 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %5, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %6 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %7 = ts.Cast %6 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %7, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %8 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %9 = "ts.TypeOf"(%8) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %10 = ts.Constant {value = "number"} : !ts.string
  %11 = ts.LogicalBinary %9(34) %10 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%11) ( {
    %13 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %14 = ts.GetValueFromUnionOp %13 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %15 = ts.Constant {value = "b number: "} : !ts.string
    %16 = ts.Cast %14 : !ts.number to !ts.string
    ts.Print(%15, %16) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %12 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%12) : !ts.string
  "ts.Exit"() : () -> ()
^bb1:  // no predecessors
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.CreateUnionInstance'(0x278e9553b00) {
  %5 = "ts.CreateUnionInstance"(%2, %4) : (!ts.number, !ts.string) -> !ts.union<!ts.number,!ts.string>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Store'(0x278e9478880) {
  "ts.Store"(%5, %0) : (!ts.union<!ts.number,!ts.string>, !ts.ref<!ts.union<!ts.number,!ts.string>>) -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Load'(0x278e942f240) {
  %6 = "ts.Load"(%0) : (!ts.ref<!ts.union<!ts.number,!ts.string>>) -> !ts.union<!ts.number,!ts.string>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Cast'(0x278e942e400) {
  %7 = "ts.Cast"(%6) : (!ts.union<!ts.number,!ts.string>) -> !ts.union<!ts.string,!ts.number,!ts.boolean>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Store'(0x278e9475550) {
  "ts.Store"(%7, %1) : (!ts.union<!ts.string,!ts.number,!ts.boolean>, !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>) -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Load'(0x278e942e940) {
  %8 = "ts.Load"(%1) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>) -> !ts.union<!ts.string,!ts.number,!ts.boolean>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.TypeOf'(0x278e942fe40) {
  %9 = "ts.TypeOf"(%8) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.TypeOf -> ()' {
Trying to match "`anonymous-namespace'::TypeOfOpLowering"
    ** Insert  : 'ts.GetTypeInfoFromUnionOp'(0x278e9430440)
    ** Replace : 'ts.TypeOf'(0x278e942fe40)
"`anonymous-namespace'::TypeOfOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'ts.GetTypeInfoFromUnionOp'(0x278e9430440) {
      %9 = "ts.GetTypeInfoFromUnionOp"(%8) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %5 = ts.CreateUnionInstance %2, %4 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %5, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %6 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %7 = ts.Cast %6 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %7, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %8 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %9 = ts.GetTypeInfoFromUnionOp %8 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %10 = "ts.TypeOf"(%8) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %11 = ts.Constant {value = "number"} : !ts.string
  %12 = ts.LogicalBinary %10(34) %11 : !ts.string, !ts.string -> !ts.boolean
  "ts.If"(%12) ( {
    %14 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %15 = ts.GetValueFromUnionOp %14 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %16 = ts.Constant {value = "b number: "} : !ts.string
    %17 = ts.Cast %15 : !ts.number to !ts.string
    ts.Print(%16, %17) : !ts.string, !ts.string
    "ts.Result"() : () -> ()
  },  {
  }) : (!ts.boolean) -> ()
  %13 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%13) : !ts.string
  "ts.Exit"() : () -> ()
^bb1:  // no predecessors
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Constant'(0x278e94ced20) {
  %11 = "ts.Constant"() {value = "number"} : () -> !ts.string

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.LogicalBinary'(0x278e954ff80) {
  %12 = "ts.LogicalBinary"(%10, %11) {opCode = 34 : i32} : (!ts.string, !ts.string) -> !ts.boolean

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.If'(0x278e9396920) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.If -> ()' {
Trying to match "`anonymous-namespace'::IfOpLowering"
    ** Insert  : 'std.br'(0x278e950ec50)
    ** Erase   : 'ts.Result'(0x278e95ef030)
    ** Insert  : 'ts.Cast'(0x278e942eac0)
    ** Insert  : 'std.cond_br'(0x278e94b0a70)
    ** Replace : 'ts.If'(0x278e9396920)
"`anonymous-namespace'::IfOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'std.br'(0x278e950ec50) {
      "std.br"()[^bb2] : () -> ()

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'ts.Cast'(0x278e942eac0) {
      %13 = "ts.Cast"(%12) : (!ts.boolean) -> i1

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'std.cond_br'(0x278e94b0a70) {
      "std.cond_br"(%13)[^bb1, ^bb2] {operand_segment_sizes = dense<[1, 0, 0]> : vector<3xi32>} : (i1) -> ()

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %5 = ts.CreateUnionInstance %2, %4 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %5, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %6 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %7 = ts.Cast %6 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %7, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %8 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %9 = ts.GetTypeInfoFromUnionOp %8 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %10 = "ts.TypeOf"(%8) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %11 = ts.Constant {value = "number"} : !ts.string
  %12 = ts.LogicalBinary %10(34) %11 : !ts.string, !ts.string -> !ts.boolean
  %13 = ts.Cast %12 : !ts.boolean to i1
  cond_br %13, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %14 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %15 = ts.GetValueFromUnionOp %14 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %16 = ts.Constant {value = "b number: "} : !ts.string
  %17 = ts.Cast %15 : !ts.number to !ts.string
  ts.Print(%16, %17) : !ts.string, !ts.string
  "ts.Result"() : () -> ()
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  "ts.If"(%12) ( {
  },  {
  }) : (!ts.boolean) -> ()
  %18 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%18) : !ts.string
  "ts.Exit"() : () -> ()
^bb3:  // no predecessors
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Load'(0x278e9430140) {
  %14 = "ts.Load"(%1) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>) -> !ts.union<!ts.string,!ts.number,!ts.boolean>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.GetValueFromUnionOp'(0x278e9430380) {
  %15 = "ts.GetValueFromUnionOp"(%14) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.number

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Constant'(0x278e94cedc0) {
  %16 = "ts.Constant"() {value = "b number: "} : () -> !ts.string

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Cast'(0x278e942e4c0) {
  %17 = "ts.Cast"(%15) : (!ts.number) -> !ts.string

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Print'(0x278e9475fe0) {
  "ts.Print"(%16, %17) : (!ts.string, !ts.string) -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Result'(0x278e95ef030) {
  "ts.Result"() : () -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Constant'(0x278e94cee60) {
  %18 = "ts.Constant"() {value = "done."} : () -> !ts.string

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Print'(0x278e950abb0) {
  "ts.Print"(%18) : (!ts.string) -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Exit'(0x278e95ef0c0) {
  "ts.Exit"() : () -> ()

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.Exit -> ()' {
Trying to match "`anonymous-namespace'::ExitOpLowering"
    ** Insert  : 'std.br'(0x278e950e620)
    ** Erase   : 'ts.Exit'(0x278e95ef0c0)
"`anonymous-namespace'::ExitOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'std.br'(0x278e950e620) {
      "std.br"()[^bb3] : () -> ()

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  "ts.Entry"() : () -> ()
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = "ts.TypeOf"(%2) : (!ts.number) -> !ts.string
  %5 = ts.CreateUnionInstance %2, %4 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %5, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %6 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %7 = ts.Cast %6 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %7, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %8 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %9 = ts.GetTypeInfoFromUnionOp %8 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %10 = "ts.TypeOf"(%8) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string
  %11 = ts.Constant {value = "number"} : !ts.string
  %12 = ts.LogicalBinary %10(34) %11 : !ts.string, !ts.string -> !ts.boolean
  %13 = ts.Cast %12 : !ts.boolean to i1
  cond_br %13, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %14 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %15 = ts.GetValueFromUnionOp %14 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %16 = ts.Constant {value = "b number: "} : !ts.string
  %17 = ts.Cast %15 : !ts.number to !ts.string
  ts.Print(%16, %17) : !ts.string, !ts.string
  "ts.Result"() : () -> ()
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  "ts.If"(%12) ( {
  },  {
  }) : (!ts.boolean) -> ()
  %18 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%18) : !ts.string
  br ^bb3
  "ts.Exit"() : () -> ()
^bb3:  // pred: ^bb2
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

!! Processing function: 
main

!! AFTER FUNC DUMP: 
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  br ^bb3
^bb3:  // pred: ^bb2
  ts.ReturnInternal
}
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  br ^bb3
^bb3:  // pred: ^bb2
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  br ^bb3
^bb3:  // pred: ^bb2
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  br ^bb3
^bb3:  // pred: ^bb2
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  br ^bb3
^bb3:  // pred: ^bb2
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::SimplifyConstCondBranchPred"
"`anonymous-namespace'::SimplifyConstCondBranchPred" result 0
Trying to match "`anonymous-namespace'::SimplifyPassThroughCondBranch"
"`anonymous-namespace'::SimplifyPassThroughCondBranch" result 0
Trying to match "`anonymous-namespace'::SimplifyCondBranchIdenticalSuccessors"
"`anonymous-namespace'::SimplifyCondBranchIdenticalSuccessors" result 0
Trying to match "`anonymous-namespace'::SimplifyCondBranchFromCondBranchOnSameCondition"
"`anonymous-namespace'::SimplifyCondBranchFromCondBranchOnSameCondition" result 0
Trying to match "`anonymous-namespace'::CondBranchTruthPropagation"
"`anonymous-namespace'::CondBranchTruthPropagation" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  br ^bb3
^bb3:  // pred: ^bb2
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  br ^bb3
^bb3:  // pred: ^bb2
  ts.ReturnInternal
}


Trying to match ""
"" result 0
Trying to match ""
"" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::SimplifyConstCondBranchPred"
"`anonymous-namespace'::SimplifyConstCondBranchPred" result 0
Trying to match "`anonymous-namespace'::SimplifyPassThroughCondBranch"
"`anonymous-namespace'::SimplifyPassThroughCondBranch" result 0
Trying to match "`anonymous-namespace'::SimplifyCondBranchIdenticalSuccessors"
"`anonymous-namespace'::SimplifyCondBranchIdenticalSuccessors" result 0
Trying to match "`anonymous-namespace'::SimplifyCondBranchFromCondBranchOnSameCondition"
"`anonymous-namespace'::SimplifyCondBranchFromCondBranchOnSameCondition" result 0
Trying to match "`anonymous-namespace'::CondBranchTruthPropagation"
"`anonymous-namespace'::CondBranchTruthPropagation" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match ""
"" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::SimplifyConstCondBranchPred"
"`anonymous-namespace'::SimplifyConstCondBranchPred" result 0
Trying to match "`anonymous-namespace'::SimplifyPassThroughCondBranch"
"`anonymous-namespace'::SimplifyPassThroughCondBranch" result 0
Trying to match "`anonymous-namespace'::SimplifyCondBranchIdenticalSuccessors"
"`anonymous-namespace'::SimplifyCondBranchIdenticalSuccessors" result 0
Trying to match "`anonymous-namespace'::SimplifyCondBranchFromCondBranchOnSameCondition"
"`anonymous-namespace'::SimplifyCondBranchFromCondBranchOnSameCondition" result 0
Trying to match "`anonymous-namespace'::CondBranchTruthPropagation"
"`anonymous-namespace'::CondBranchTruthPropagation" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match ""
"" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::SimplifyConstCondBranchPred"
"`anonymous-namespace'::SimplifyConstCondBranchPred" result 0
Trying to match "`anonymous-namespace'::SimplifyPassThroughCondBranch"
"`anonymous-namespace'::SimplifyPassThroughCondBranch" result 0
Trying to match "`anonymous-namespace'::SimplifyCondBranchIdenticalSuccessors"
"`anonymous-namespace'::SimplifyCondBranchIdenticalSuccessors" result 0
Trying to match "`anonymous-namespace'::SimplifyCondBranchFromCondBranchOnSameCondition"
"`anonymous-namespace'::SimplifyCondBranchFromCondBranchOnSameCondition" result 0
Trying to match "`anonymous-namespace'::CondBranchTruthPropagation"
"`anonymous-namespace'::CondBranchTruthPropagation" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match ""
"" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::SimplifyConstCondBranchPred"
"`anonymous-namespace'::SimplifyConstCondBranchPred" result 0
Trying to match "`anonymous-namespace'::SimplifyPassThroughCondBranch"
"`anonymous-namespace'::SimplifyPassThroughCondBranch" result 0
Trying to match "`anonymous-namespace'::SimplifyCondBranchIdenticalSuccessors"
"`anonymous-namespace'::SimplifyCondBranchIdenticalSuccessors" result 0
Trying to match "`anonymous-namespace'::SimplifyCondBranchFromCondBranchOnSameCondition"
"`anonymous-namespace'::SimplifyCondBranchFromCondBranchOnSameCondition" result 0
Trying to match "`anonymous-namespace'::CondBranchTruthPropagation"
"`anonymous-namespace'::CondBranchTruthPropagation" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match ""
"" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::SimplifyConstCondBranchPred"
"`anonymous-namespace'::SimplifyConstCondBranchPred" result 0
Trying to match "`anonymous-namespace'::SimplifyPassThroughCondBranch"
"`anonymous-namespace'::SimplifyPassThroughCondBranch" result 0
Trying to match "`anonymous-namespace'::SimplifyCondBranchIdenticalSuccessors"
"`anonymous-namespace'::SimplifyCondBranchIdenticalSuccessors" result 0
Trying to match "`anonymous-namespace'::SimplifyCondBranchFromCondBranchOnSameCondition"
"`anonymous-namespace'::SimplifyCondBranchFromCondBranchOnSameCondition" result 0
Trying to match "`anonymous-namespace'::CondBranchTruthPropagation"
"`anonymous-namespace'::CondBranchTruthPropagation" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match ""
"" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::SimplifyConstCondBranchPred"
"`anonymous-namespace'::SimplifyConstCondBranchPred" result 0
Trying to match "`anonymous-namespace'::SimplifyPassThroughCondBranch"
"`anonymous-namespace'::SimplifyPassThroughCondBranch" result 0
Trying to match "`anonymous-namespace'::SimplifyCondBranchIdenticalSuccessors"
"`anonymous-namespace'::SimplifyCondBranchIdenticalSuccessors" result 0
Trying to match "`anonymous-namespace'::SimplifyCondBranchFromCondBranchOnSameCondition"
"`anonymous-namespace'::SimplifyCondBranchFromCondBranchOnSameCondition" result 0
Trying to match "`anonymous-namespace'::CondBranchTruthPropagation"
"`anonymous-namespace'::CondBranchTruthPropagation" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match ""
"" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::SimplifyConstCondBranchPred"
"`anonymous-namespace'::SimplifyConstCondBranchPred" result 0
Trying to match "`anonymous-namespace'::SimplifyPassThroughCondBranch"
"`anonymous-namespace'::SimplifyPassThroughCondBranch" result 0
Trying to match "`anonymous-namespace'::SimplifyCondBranchIdenticalSuccessors"
"`anonymous-namespace'::SimplifyCondBranchIdenticalSuccessors" result 0
Trying to match "`anonymous-namespace'::SimplifyCondBranchFromCondBranchOnSameCondition"
"`anonymous-namespace'::SimplifyCondBranchFromCondBranchOnSameCondition" result 0
Trying to match "`anonymous-namespace'::CondBranchTruthPropagation"
"`anonymous-namespace'::CondBranchTruthPropagation" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match ""
"" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::SimplifyConstCondBranchPred"
"`anonymous-namespace'::SimplifyConstCondBranchPred" result 0
Trying to match "`anonymous-namespace'::SimplifyPassThroughCondBranch"
"`anonymous-namespace'::SimplifyPassThroughCondBranch" result 0
Trying to match "`anonymous-namespace'::SimplifyCondBranchIdenticalSuccessors"
"`anonymous-namespace'::SimplifyCondBranchIdenticalSuccessors" result 0
Trying to match "`anonymous-namespace'::SimplifyCondBranchFromCondBranchOnSameCondition"
"`anonymous-namespace'::SimplifyCondBranchFromCondBranchOnSameCondition" result 0
Trying to match "`anonymous-namespace'::CondBranchTruthPropagation"
"`anonymous-namespace'::CondBranchTruthPropagation" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match ""
"" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::SimplifyConstCondBranchPred"
"`anonymous-namespace'::SimplifyConstCondBranchPred" result 0
Trying to match "`anonymous-namespace'::SimplifyPassThroughCondBranch"
"`anonymous-namespace'::SimplifyPassThroughCondBranch" result 0
Trying to match "`anonymous-namespace'::SimplifyCondBranchIdenticalSuccessors"
"`anonymous-namespace'::SimplifyCondBranchIdenticalSuccessors" result 0
Trying to match "`anonymous-namespace'::SimplifyCondBranchFromCondBranchOnSameCondition"
"`anonymous-namespace'::SimplifyCondBranchFromCondBranchOnSameCondition" result 0
Trying to match "`anonymous-namespace'::CondBranchTruthPropagation"
"`anonymous-namespace'::CondBranchTruthPropagation" result 0
Trying to match "`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>"
"`anonymous-namespace'::RemoveUnused<class mlir::typescript::LoadOp>" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match "`anonymous-namespace'::NormalizeCast"
"`anonymous-namespace'::NormalizeCast" result 1
// *** IR Dump After Pattern Application ***
ts.Func @main () -> ()  {
  %0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %1 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.CreateUnionInstance %2, %3 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %4, %0 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %5 = ts.Load(%0) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %6 = ts.Cast %5 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %6, %1 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %8 = ts.GetTypeInfoFromUnionOp %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.LogicalBinary %8(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %11 = ts.Cast %10 : !ts.boolean to i1
  cond_br %11, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %12 = ts.Load(%1) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %13 = ts.GetValueFromUnionOp %12 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %14 = ts.Constant {value = "b number: "} : !ts.string
  %15 = ts.Cast %13 : !ts.number to !ts.string
  ts.Print(%14, %15) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  %16 = ts.Constant {value = "done."} : !ts.string
  ts.Print(%16) : !ts.string
  ts.ReturnInternal
}


Trying to match ""
"" result 0
The pattern rewrite doesn't converge after scanning 10 times

Insert const at: 
%0 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>

const to insert: 
%2 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
** Insert  : 'ts.Constant'(0x278e94d38c0)

const to insert: 
%3 = ts.Constant {value = "number"} : !ts.string
** Insert  : 'ts.Constant'(0x278e94ce820)

const to insert: 
%9 = ts.Constant {value = "number"} : !ts.string
** Insert  : 'ts.Constant'(0x278e94d49a0)

const to insert: 
%14 = ts.Constant {value = "b number: "} : !ts.string
** Insert  : 'ts.Constant'(0x278e94cebe0)

const to insert: 
%16 = ts.Constant {value = "done."} : !ts.string
** Insert  : 'ts.Constant'(0x278e94cec80)

!! AFTER CONST RELOC FUNC DUMP: 
ts.Func @main () -> ()  {
  %0 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %1 = ts.Constant {value = "number"} : !ts.string
  %2 = ts.Constant {value = "number"} : !ts.string
  %3 = ts.Constant {value = "b number: "} : !ts.string
  %4 = ts.Constant {value = "done."} : !ts.string
  %5 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %6 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %7 = ts.CreateUnionInstance %0, %1 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %7, %5 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %8 = ts.Load(%5) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %9 = ts.Cast %8 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %9, %6 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %10 = ts.Load(%6) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %11 = ts.GetTypeInfoFromUnionOp %10 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %12 = ts.LogicalBinary %11(34) %2 : !ts.string, !ts.string -> !ts.boolean
  %13 = ts.Cast %12 : !ts.boolean to i1
  cond_br %13, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %14 = ts.Load(%6) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %15 = ts.GetValueFromUnionOp %14 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %16 = ts.Cast %15 : !ts.number to !ts.string
  ts.Print(%3, %16) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%4) : !ts.string
  ts.ReturnInternal
}
Outlined 0 functions built from async.execute operations

//===-------------------------------------------===//
Legalizing operation : 'module'(0x278e950a6e0) {
  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Func'(0x278e950b810) {
  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Constant'(0x278e94d38c0) {
  %0 = "ts.Constant"() {value = 1.000000e+01 : f64} : () -> !ts.number

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Constant'(0x278e94ce820) {
  %1 = "ts.Constant"() {value = "number"} : () -> !ts.string

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Constant'(0x278e94d49a0) {
  %2 = "ts.Constant"() {value = "number"} : () -> !ts.string

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Constant'(0x278e94cebe0) {
  %3 = "ts.Constant"() {value = "b number: "} : () -> !ts.string

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Constant'(0x278e94cec80) {
  %4 = "ts.Constant"() {value = "done."} : () -> !ts.string

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Variable'(0x278e94cf2c0) {
  %5 = "ts.Variable"() {captured = false} : () -> !ts.ref<!ts.union<!ts.number,!ts.string>>

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Variable'(0x278e94ce780) {
  %6 = "ts.Variable"() {captured = false} : () -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.CreateUnionInstance'(0x278e9553b00) {
  %7 = "ts.CreateUnionInstance"(%0, %1) : (!ts.number, !ts.string) -> !ts.union<!ts.number,!ts.string>

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Store'(0x278e9478880) {
  "ts.Store"(%7, %5) : (!ts.union<!ts.number,!ts.string>, !ts.ref<!ts.union<!ts.number,!ts.string>>) -> ()

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Load'(0x278e942f240) {
  %8 = "ts.Load"(%5) : (!ts.ref<!ts.union<!ts.number,!ts.string>>) -> !ts.union<!ts.number,!ts.string>

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Cast'(0x278e942e400) {
  %9 = "ts.Cast"(%8) : (!ts.union<!ts.number,!ts.string>) -> !ts.union<!ts.string,!ts.number,!ts.boolean>

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Store'(0x278e9475550) {
  "ts.Store"(%9, %6) : (!ts.union<!ts.string,!ts.number,!ts.boolean>, !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>) -> ()

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Load'(0x278e942e940) {
  %10 = "ts.Load"(%6) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>) -> !ts.union<!ts.string,!ts.number,!ts.boolean>

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.GetTypeInfoFromUnionOp'(0x278e9430440) {
  %11 = "ts.GetTypeInfoFromUnionOp"(%10) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.LogicalBinary'(0x278e954ff80) {
  %12 = "ts.LogicalBinary"(%11, %2) {opCode = 34 : i32} : (!ts.string, !ts.string) -> !ts.boolean

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Cast'(0x278e942eac0) {
  %13 = "ts.Cast"(%12) : (!ts.boolean) -> i1

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'std.cond_br'(0x278e94b0a70) {
  "std.cond_br"(%13)[^bb1, ^bb2] {operand_segment_sizes = dense<[1, 0, 0]> : vector<3xi32>} : (i1) -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Print'(0x278e950abb0) {
  "ts.Print"(%4) : (!ts.string) -> ()

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.ReturnInternal'(0x278e95f0ce0) {
  "ts.ReturnInternal"() : () -> ()

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Load'(0x278e9430140) {
  %14 = "ts.Load"(%6) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>) -> !ts.union<!ts.string,!ts.number,!ts.boolean>

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.GetValueFromUnionOp'(0x278e9430380) {
  %15 = "ts.GetValueFromUnionOp"(%14) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.number

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Cast'(0x278e942e4c0) {
  %16 = "ts.Cast"(%15) : (!ts.number) -> !ts.string

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Print'(0x278e9475fe0) {
  "ts.Print"(%3, %16) : (!ts.string, !ts.string) -> ()

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'std.br'(0x278e950ec50) {
  "std.br"()[^bb2] : () -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'module'(0x278e950a6e0) {
  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Func'(0x278e950b810) {
  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Constant'(0x278e94d38c0) {
  %0 = "ts.Constant"() {value = 1.000000e+01 : f64} : () -> !ts.number

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Constant'(0x278e94ce820) {
  %1 = "ts.Constant"() {value = "number"} : () -> !ts.string

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Constant'(0x278e94d49a0) {
  %2 = "ts.Constant"() {value = "number"} : () -> !ts.string

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Constant'(0x278e94cebe0) {
  %3 = "ts.Constant"() {value = "b number: "} : () -> !ts.string

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Constant'(0x278e94cec80) {
  %4 = "ts.Constant"() {value = "done."} : () -> !ts.string

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Variable'(0x278e94cf2c0) {
  %5 = "ts.Variable"() {captured = false} : () -> !ts.ref<!ts.union<!ts.number,!ts.string>>

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Variable'(0x278e94ce780) {
  %6 = "ts.Variable"() {captured = false} : () -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.CreateUnionInstance'(0x278e9553b00) {
  %7 = "ts.CreateUnionInstance"(%0, %1) : (!ts.number, !ts.string) -> !ts.union<!ts.number,!ts.string>

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Store'(0x278e9478880) {
  "ts.Store"(%7, %5) : (!ts.union<!ts.number,!ts.string>, !ts.ref<!ts.union<!ts.number,!ts.string>>) -> ()

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Load'(0x278e942f240) {
  %8 = "ts.Load"(%5) : (!ts.ref<!ts.union<!ts.number,!ts.string>>) -> !ts.union<!ts.number,!ts.string>

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Cast'(0x278e942e400) {
  %9 = "ts.Cast"(%8) : (!ts.union<!ts.number,!ts.string>) -> !ts.union<!ts.string,!ts.number,!ts.boolean>

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Store'(0x278e9475550) {
  "ts.Store"(%9, %6) : (!ts.union<!ts.string,!ts.number,!ts.boolean>, !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>) -> ()

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Load'(0x278e942e940) {
  %10 = "ts.Load"(%6) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>) -> !ts.union<!ts.string,!ts.number,!ts.boolean>

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.GetTypeInfoFromUnionOp'(0x278e9430440) {
  %11 = "ts.GetTypeInfoFromUnionOp"(%10) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.LogicalBinary'(0x278e954ff80) {
  %12 = "ts.LogicalBinary"(%11, %2) {opCode = 34 : i32} : (!ts.string, !ts.string) -> !ts.boolean

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Cast'(0x278e942eac0) {
  %13 = "ts.Cast"(%12) : (!ts.boolean) -> i1

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'std.cond_br'(0x278e94b0a70) {
  "std.cond_br"(%13)[^bb1, ^bb2] {operand_segment_sizes = dense<[1, 0, 0]> : vector<3xi32>} : (i1) -> ()

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Print'(0x278e950abb0) {
  "ts.Print"(%4) : (!ts.string) -> ()

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.ReturnInternal'(0x278e95f0ce0) {
  "ts.ReturnInternal"() : () -> ()

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Load'(0x278e9430140) {
  %14 = "ts.Load"(%6) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>) -> !ts.union<!ts.string,!ts.number,!ts.boolean>

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.GetValueFromUnionOp'(0x278e9430380) {
  %15 = "ts.GetValueFromUnionOp"(%14) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.number

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Cast'(0x278e942e4c0) {
  %16 = "ts.Cast"(%15) : (!ts.number) -> !ts.string

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Print'(0x278e9475fe0) {
  "ts.Print"(%3, %16) : (!ts.string, !ts.string) -> ()

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'std.br'(0x278e950ec50) {
  "std.br"()[^bb2] : () -> ()

  * Fold {
  } -> FAILURE : unable to fold
} -> FAILURE : no matched legalization pattern
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x278e950caa0) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x278e950ccb0) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x278e950bc30) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FunctionLikeSignatureConversion"
"`anonymous-namespace'::FunctionLikeSignatureConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'func'(0x278e950bc30) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  ts.Func @main () -> ()  {
    %0 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %1 = ts.Constant {value = "number"} : !ts.string
    %2 = ts.Constant {value = "number"} : !ts.string
    %3 = ts.Constant {value = "b number: "} : !ts.string
    %4 = ts.Constant {value = "done."} : !ts.string
    %5 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %6 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %7 = ts.CreateUnionInstance %0, %1 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    ts.Store %7, %5 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %8 = ts.Load(%5) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %9 = ts.Cast %8 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
    ts.Store %9, %6 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %10 = ts.Load(%6) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %11 = ts.GetTypeInfoFromUnionOp %10 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
    %12 = ts.LogicalBinary %11(34) %2 : !ts.string, !ts.string -> !ts.boolean
    %13 = ts.Cast %12 : !ts.boolean to i1
    cond_br %13, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %14 = ts.Load(%6) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %15 = ts.GetValueFromUnionOp %14 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %16 = ts.Cast %15 : !ts.number to !ts.string
    ts.Print(%3, %16) : !ts.string, !ts.string
    br ^bb2
  ^bb2:  // 2 preds: ^bb0, ^bb1
    ts.Print(%4) : !ts.string
    ts.ReturnInternal
  }
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !async.group
  func private @mlirAsyncRuntimeEmplaceToken(!async.token)
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetTokenError(!async.token)
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeIsTokenError(!async.token) -> i1
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsGroupError(!async.group) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!async.token)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!async.group)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!async.token, !async.group) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!async.token, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!async.group, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x278e950b130) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x278e950bce0) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FunctionLikeSignatureConversion"
"`anonymous-namespace'::FunctionLikeSignatureConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'func'(0x278e950bce0) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  ts.Func @main () -> ()  {
    %0 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %1 = ts.Constant {value = "number"} : !ts.string
    %2 = ts.Constant {value = "number"} : !ts.string
    %3 = ts.Constant {value = "b number: "} : !ts.string
    %4 = ts.Constant {value = "done."} : !ts.string
    %5 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %6 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %7 = ts.CreateUnionInstance %0, %1 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    ts.Store %7, %5 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %8 = ts.Load(%5) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %9 = ts.Cast %8 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
    ts.Store %9, %6 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %10 = ts.Load(%6) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %11 = ts.GetTypeInfoFromUnionOp %10 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
    %12 = ts.LogicalBinary %11(34) %2 : !ts.string, !ts.string -> !ts.boolean
    %13 = ts.Cast %12 : !ts.boolean to i1
    cond_br %13, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %14 = ts.Load(%6) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %15 = ts.GetValueFromUnionOp %14 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %16 = ts.Cast %15 : !ts.number to !ts.string
    ts.Print(%3, %16) : !ts.string, !ts.string
    br ^bb2
  ^bb2:  // 2 preds: ^bb0, ^bb1
    ts.Print(%4) : !ts.string
    ts.ReturnInternal
  }
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeEmplaceToken(!async.token)
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetTokenError(!async.token)
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeIsTokenError(!async.token) -> i1
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsGroupError(!async.group) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!async.token)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!async.group)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!async.token, !async.group) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!async.token, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!async.group, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x278e950cec0) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FunctionLikeSignatureConversion"
"`anonymous-namespace'::FunctionLikeSignatureConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'func'(0x278e950cec0) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  ts.Func @main () -> ()  {
    %0 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %1 = ts.Constant {value = "number"} : !ts.string
    %2 = ts.Constant {value = "number"} : !ts.string
    %3 = ts.Constant {value = "b number: "} : !ts.string
    %4 = ts.Constant {value = "done."} : !ts.string
    %5 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %6 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %7 = ts.CreateUnionInstance %0, %1 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    ts.Store %7, %5 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %8 = ts.Load(%5) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %9 = ts.Cast %8 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
    ts.Store %9, %6 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %10 = ts.Load(%6) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %11 = ts.GetTypeInfoFromUnionOp %10 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
    %12 = ts.LogicalBinary %11(34) %2 : !ts.string, !ts.string -> !ts.boolean
    %13 = ts.Cast %12 : !ts.boolean to i1
    cond_br %13, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %14 = ts.Load(%6) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %15 = ts.GetValueFromUnionOp %14 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %16 = ts.Cast %15 : !ts.number to !ts.string
    ts.Print(%3, %16) : !ts.string, !ts.string
    br ^bb2
  ^bb2:  // 2 preds: ^bb0, ^bb1
    ts.Print(%4) : !ts.string
    ts.ReturnInternal
  }
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetTokenError(!async.token)
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeIsTokenError(!async.token) -> i1
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsGroupError(!async.group) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!async.token)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!async.group)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!async.token, !async.group) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!async.token, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!async.group, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x278e950a630) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x278e950be40) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FunctionLikeSignatureConversion"
"`anonymous-namespace'::FunctionLikeSignatureConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'func'(0x278e950be40) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  ts.Func @main () -> ()  {
    %0 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %1 = ts.Constant {value = "number"} : !ts.string
    %2 = ts.Constant {value = "number"} : !ts.string
    %3 = ts.Constant {value = "b number: "} : !ts.string
    %4 = ts.Constant {value = "done."} : !ts.string
    %5 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %6 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %7 = ts.CreateUnionInstance %0, %1 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    ts.Store %7, %5 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %8 = ts.Load(%5) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %9 = ts.Cast %8 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
    ts.Store %9, %6 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %10 = ts.Load(%6) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %11 = ts.GetTypeInfoFromUnionOp %10 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
    %12 = ts.LogicalBinary %11(34) %2 : !ts.string, !ts.string -> !ts.boolean
    %13 = ts.Cast %12 : !ts.boolean to i1
    cond_br %13, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %14 = ts.Load(%6) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %15 = ts.GetValueFromUnionOp %14 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %16 = ts.Cast %15 : !ts.number to !ts.string
    ts.Print(%3, %16) : !ts.string, !ts.string
    br ^bb2
  ^bb2:  // 2 preds: ^bb0, ^bb1
    ts.Print(%4) : !ts.string
    ts.ReturnInternal
  }
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeIsTokenError(!async.token) -> i1
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsGroupError(!async.group) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!async.token)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!async.group)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!async.token, !async.group) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!async.token, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!async.group, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x278e950bef0) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x278e950c100) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FunctionLikeSignatureConversion"
"`anonymous-namespace'::FunctionLikeSignatureConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'func'(0x278e950c100) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  ts.Func @main () -> ()  {
    %0 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %1 = ts.Constant {value = "number"} : !ts.string
    %2 = ts.Constant {value = "number"} : !ts.string
    %3 = ts.Constant {value = "b number: "} : !ts.string
    %4 = ts.Constant {value = "done."} : !ts.string
    %5 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %6 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %7 = ts.CreateUnionInstance %0, %1 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    ts.Store %7, %5 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %8 = ts.Load(%5) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %9 = ts.Cast %8 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
    ts.Store %9, %6 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %10 = ts.Load(%6) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %11 = ts.GetTypeInfoFromUnionOp %10 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
    %12 = ts.LogicalBinary %11(34) %2 : !ts.string, !ts.string -> !ts.boolean
    %13 = ts.Cast %12 : !ts.boolean to i1
    cond_br %13, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %14 = ts.Load(%6) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %15 = ts.GetValueFromUnionOp %14 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %16 = ts.Cast %15 : !ts.number to !ts.string
    ts.Print(%3, %16) : !ts.string, !ts.string
    br ^bb2
  ^bb2:  // 2 preds: ^bb0, ^bb1
    ts.Print(%4) : !ts.string
    ts.ReturnInternal
  }
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsGroupError(!async.group) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!async.token)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!async.group)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!async.token, !async.group) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!async.token, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!async.group, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x278e950ae70) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x278e950afd0) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FunctionLikeSignatureConversion"
"`anonymous-namespace'::FunctionLikeSignatureConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'func'(0x278e950afd0) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  ts.Func @main () -> ()  {
    %0 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %1 = ts.Constant {value = "number"} : !ts.string
    %2 = ts.Constant {value = "number"} : !ts.string
    %3 = ts.Constant {value = "b number: "} : !ts.string
    %4 = ts.Constant {value = "done."} : !ts.string
    %5 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %6 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %7 = ts.CreateUnionInstance %0, %1 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    ts.Store %7, %5 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %8 = ts.Load(%5) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %9 = ts.Cast %8 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
    ts.Store %9, %6 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %10 = ts.Load(%6) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %11 = ts.GetTypeInfoFromUnionOp %10 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
    %12 = ts.LogicalBinary %11(34) %2 : !ts.string, !ts.string -> !ts.boolean
    %13 = ts.Cast %12 : !ts.boolean to i1
    cond_br %13, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %14 = ts.Load(%6) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %15 = ts.GetValueFromUnionOp %14 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %16 = ts.Cast %15 : !ts.number to !ts.string
    ts.Print(%3, %16) : !ts.string, !ts.string
    br ^bb2
  ^bb2:  // 2 preds: ^bb0, ^bb1
    ts.Print(%4) : !ts.string
    ts.ReturnInternal
  }
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!async.token)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!async.group)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!async.token, !async.group) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!async.token, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!async.group, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x278e950b080) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FunctionLikeSignatureConversion"
"`anonymous-namespace'::FunctionLikeSignatureConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'func'(0x278e950b080) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  ts.Func @main () -> ()  {
    %0 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %1 = ts.Constant {value = "number"} : !ts.string
    %2 = ts.Constant {value = "number"} : !ts.string
    %3 = ts.Constant {value = "b number: "} : !ts.string
    %4 = ts.Constant {value = "done."} : !ts.string
    %5 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %6 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %7 = ts.CreateUnionInstance %0, %1 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    ts.Store %7, %5 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %8 = ts.Load(%5) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %9 = ts.Cast %8 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
    ts.Store %9, %6 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %10 = ts.Load(%6) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %11 = ts.GetTypeInfoFromUnionOp %10 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
    %12 = ts.LogicalBinary %11(34) %2 : !ts.string, !ts.string -> !ts.boolean
    %13 = ts.Cast %12 : !ts.boolean to i1
    cond_br %13, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %14 = ts.Load(%6) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %15 = ts.GetValueFromUnionOp %14 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %16 = ts.Cast %15 : !ts.number to !ts.string
    ts.Print(%3, %16) : !ts.string, !ts.string
    br ^bb2
  ^bb2:  // 2 preds: ^bb0, ^bb1
    ts.Print(%4) : !ts.string
    ts.ReturnInternal
  }
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!async.group)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!async.token, !async.group) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!async.token, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!async.group, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x278e950b1e0) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x278e950a790) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FunctionLikeSignatureConversion"
"`anonymous-namespace'::FunctionLikeSignatureConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'func'(0x278e950a790) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  ts.Func @main () -> ()  {
    %0 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %1 = ts.Constant {value = "number"} : !ts.string
    %2 = ts.Constant {value = "number"} : !ts.string
    %3 = ts.Constant {value = "b number: "} : !ts.string
    %4 = ts.Constant {value = "done."} : !ts.string
    %5 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %6 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %7 = ts.CreateUnionInstance %0, %1 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    ts.Store %7, %5 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %8 = ts.Load(%5) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %9 = ts.Cast %8 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
    ts.Store %9, %6 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %10 = ts.Load(%6) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %11 = ts.GetTypeInfoFromUnionOp %10 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
    %12 = ts.LogicalBinary %11(34) %2 : !ts.string, !ts.string -> !ts.boolean
    %13 = ts.Cast %12 : !ts.boolean to i1
    cond_br %13, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %14 = ts.Load(%6) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %15 = ts.GetValueFromUnionOp %14 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %16 = ts.Cast %15 : !ts.number to !ts.string
    ts.Print(%3, %16) : !ts.string, !ts.string
    br ^bb2
  ^bb2:  // 2 preds: ^bb0, ^bb1
    ts.Print(%4) : !ts.string
    ts.ReturnInternal
  }
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!async.token, !async.group) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!async.token, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!async.group, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x278e950cd60) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x278e950b4a0) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x278e950c1b0) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FunctionLikeSignatureConversion"
"`anonymous-namespace'::FunctionLikeSignatureConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'func'(0x278e950c1b0) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  ts.Func @main () -> ()  {
    %0 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %1 = ts.Constant {value = "number"} : !ts.string
    %2 = ts.Constant {value = "number"} : !ts.string
    %3 = ts.Constant {value = "b number: "} : !ts.string
    %4 = ts.Constant {value = "done."} : !ts.string
    %5 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %6 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %7 = ts.CreateUnionInstance %0, %1 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    ts.Store %7, %5 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %8 = ts.Load(%5) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %9 = ts.Cast %8 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
    ts.Store %9, %6 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %10 = ts.Load(%6) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %11 = ts.GetTypeInfoFromUnionOp %10 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
    %12 = ts.LogicalBinary %11(34) %2 : !ts.string, !ts.string -> !ts.boolean
    %13 = ts.Cast %12 : !ts.boolean to i1
    cond_br %13, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %14 = ts.Load(%6) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %15 = ts.GetValueFromUnionOp %14 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %16 = ts.Cast %15 : !ts.number to !ts.string
    ts.Print(%3, %16) : !ts.string, !ts.string
    br ^bb2
  ^bb2:  // 2 preds: ^bb0, ^bb1
    ts.Print(%4) : !ts.string
    ts.ReturnInternal
  }
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!async.token, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!async.group, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x278e950c5d0) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FunctionLikeSignatureConversion"
"`anonymous-namespace'::FunctionLikeSignatureConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'func'(0x278e950c5d0) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  ts.Func @main () -> ()  {
    %0 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %1 = ts.Constant {value = "number"} : !ts.string
    %2 = ts.Constant {value = "number"} : !ts.string
    %3 = ts.Constant {value = "b number: "} : !ts.string
    %4 = ts.Constant {value = "done."} : !ts.string
    %5 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %6 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %7 = ts.CreateUnionInstance %0, %1 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    ts.Store %7, %5 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %8 = ts.Load(%5) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %9 = ts.Cast %8 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
    ts.Store %9, %6 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %10 = ts.Load(%6) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %11 = ts.GetTypeInfoFromUnionOp %10 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
    %12 = ts.LogicalBinary %11(34) %2 : !ts.string, !ts.string -> !ts.boolean
    %13 = ts.Cast %12 : !ts.boolean to i1
    cond_br %13, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %14 = ts.Load(%6) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %15 = ts.GetValueFromUnionOp %14 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %16 = ts.Cast %15 : !ts.number to !ts.string
    ts.Print(%3, %16) : !ts.string, !ts.string
    br ^bb2
  ^bb2:  // 2 preds: ^bb0, ^bb1
    ts.Print(%4) : !ts.string
    ts.ReturnInternal
  }
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!async.group, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x278e950c940) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x278e950a840) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FunctionLikeSignatureConversion"
"`anonymous-namespace'::FunctionLikeSignatureConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'func'(0x278e950a840) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  ts.Func @main () -> ()  {
    %0 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %1 = ts.Constant {value = "number"} : !ts.string
    %2 = ts.Constant {value = "number"} : !ts.string
    %3 = ts.Constant {value = "b number: "} : !ts.string
    %4 = ts.Constant {value = "done."} : !ts.string
    %5 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %6 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %7 = ts.CreateUnionInstance %0, %1 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    ts.Store %7, %5 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %8 = ts.Load(%5) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %9 = ts.Cast %8 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
    ts.Store %9, %6 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %10 = ts.Load(%6) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %11 = ts.GetTypeInfoFromUnionOp %10 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
    %12 = ts.LogicalBinary %11(34) %2 : !ts.string, !ts.string -> !ts.boolean
    %13 = ts.Cast %12 : !ts.boolean to i1
    cond_br %13, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %14 = ts.Load(%6) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %15 = ts.GetValueFromUnionOp %14 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %16 = ts.Cast %15 : !ts.number to !ts.string
    ts.Print(%3, %16) : !ts.string, !ts.string
    br ^bb2
  ^bb2:  // 2 preds: ^bb0, ^bb1
    ts.Print(%4) : !ts.string
    ts.ReturnInternal
  }
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x278e950b550) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x278e950c9f0) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

!! BEFORE DUMP: 
module @"c:\\temp\\1.ts"  {
  ts.Func @main () -> ()  {
    %0 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %1 = ts.Constant {value = "number"} : !ts.string
    %2 = ts.Constant {value = "number"} : !ts.string
    %3 = ts.Constant {value = "b number: "} : !ts.string
    %4 = ts.Constant {value = "done."} : !ts.string
    %5 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %6 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %7 = ts.CreateUnionInstance %0, %1 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    ts.Store %7, %5 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %8 = ts.Load(%5) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %9 = ts.Cast %8 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
    ts.Store %9, %6 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %10 = ts.Load(%6) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %11 = ts.GetTypeInfoFromUnionOp %10 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
    %12 = ts.LogicalBinary %11(34) %2 : !ts.string, !ts.string -> !ts.boolean
    %13 = ts.Cast %12 : !ts.boolean to i1
    cond_br %13, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %14 = ts.Load(%6) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %15 = ts.GetValueFromUnionOp %14 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %16 = ts.Cast %15 : !ts.number to !ts.string
    ts.Print(%3, %16) : !ts.string, !ts.string
    br ^bb2
  ^bb2:  // 2 preds: ^bb0, ^bb1
    ts.Print(%4) : !ts.string
    ts.ReturnInternal
  }
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}
Ignoring pattern 'unrealized_conversion_cast' because it is impossible to match or cannot lead to legal IR (by cost model)

//===-------------------------------------------===//
Legalizing operation : 'module'(0x278e950a6e0) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Func'(0x278e950b810) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.Func -> ()' {
Trying to match "`anonymous-namespace'::FuncOpLowering"
    ** Insert  : 'func'(0x278e9513480)
    ** Erase   : 'ts.Func'(0x278e950b810)
"`anonymous-namespace'::FuncOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'func'(0x278e9513480) {
      * Fold {
      } -> FAILURE : unable to fold

      * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FuncOpConversion"
        ** Insert  : 'llvm.func'(0x278e9513110)
        ** Erase   : 'func'(0x278e9513480)
"`anonymous-namespace'::FuncOpConversion" result 1

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.func'(0x278e9513110) {
        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//
      } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  llvm.func @main() {
    %0 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %1 = ts.Constant {value = "number"} : !ts.string
    %2 = ts.Constant {value = "number"} : !ts.string
    %3 = ts.Constant {value = "b number: "} : !ts.string
    %4 = ts.Constant {value = "done."} : !ts.string
    %5 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %6 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %7 = ts.CreateUnionInstance %0, %1 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    ts.Store %7, %5 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %8 = ts.Load(%5) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %9 = ts.Cast %8 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
    ts.Store %9, %6 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %10 = ts.Load(%6) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %11 = ts.GetTypeInfoFromUnionOp %10 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
    %12 = ts.LogicalBinary %11(34) %2 : !ts.string, !ts.string -> !ts.boolean
    %13 = ts.Cast %12 : !ts.boolean to i1
    cond_br %13, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %14 = ts.Load(%6) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %15 = ts.GetValueFromUnionOp %14 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %16 = ts.Cast %15 : !ts.number to !ts.string
    ts.Print(%3, %16) : !ts.string, !ts.string
    br ^bb2
  ^bb2:  // 2 preds: ^bb0, ^bb1
    ts.Print(%4) : !ts.string
    ts.ReturnInternal
  }
  func @main()
  ts.Func @main () -> ()  {
  }
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


    } -> SUCCESS
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  llvm.func @main() {
    %0 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %1 = ts.Constant {value = "number"} : !ts.string
    %2 = ts.Constant {value = "number"} : !ts.string
    %3 = ts.Constant {value = "b number: "} : !ts.string
    %4 = ts.Constant {value = "done."} : !ts.string
    %5 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %6 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %7 = ts.CreateUnionInstance %0, %1 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    ts.Store %7, %5 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %8 = ts.Load(%5) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %9 = ts.Cast %8 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
    ts.Store %9, %6 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %10 = ts.Load(%6) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %11 = ts.GetTypeInfoFromUnionOp %10 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
    %12 = ts.LogicalBinary %11(34) %2 : !ts.string, !ts.string -> !ts.boolean
    %13 = ts.Cast %12 : !ts.boolean to i1
    cond_br %13, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %14 = ts.Load(%6) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %15 = ts.GetValueFromUnionOp %14 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %16 = ts.Cast %15 : !ts.number to !ts.string
    ts.Print(%3, %16) : !ts.string, !ts.string
    br ^bb2
  ^bb2:  // 2 preds: ^bb0, ^bb1
    ts.Print(%4) : !ts.string
    ts.ReturnInternal
  }
  func @main()
  ts.Func @main () -> ()  {
  }
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Constant'(0x278e94d38c0) {
  %0 = "ts.Constant"() {value = 1.000000e+01 : f64} : () -> !ts.number

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.Constant -> ()' {
Trying to match "`anonymous-namespace'::ConstantOpLowering"
    ** Insert  : 'std.constant'(0x278e94d3f00)
    ** Replace : 'ts.Constant'(0x278e94d38c0)
"`anonymous-namespace'::ConstantOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'std.constant'(0x278e94d3f00) {
      %0 = "std.constant"() {value = 1.000000e+01 : f64} : () -> f64

      * Fold {
      } -> FAILURE : unable to fold

      * Pattern : 'std.constant -> ()' {
Trying to match "`anonymous-namespace'::ConstantOpLowering"
        ** Insert  : 'llvm.mlir.constant'(0x278e94d4ae0)
        ** Replace : 'std.constant'(0x278e94d3f00)
"`anonymous-namespace'::ConstantOpLowering" result 1

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.mlir.constant'(0x278e94d4ae0) {
          %0 = "llvm.mlir.constant"() {value = 1.000000e+01 : f64} : () -> f64

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//
      } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %1 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %2 = ts.Constant {value = "number"} : !ts.string
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.Constant {value = "b number: "} : !ts.string
  %5 = ts.Constant {value = "done."} : !ts.string
  %6 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %7 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %8 = ts.CreateUnionInstance %1, %2 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %8, %6 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %9 = ts.Load(%6) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %10 = ts.Cast %9 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %10, %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %11 = ts.Load(%7) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %12 = ts.GetTypeInfoFromUnionOp %11 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %13 = ts.LogicalBinary %12(34) %3 : !ts.string, !ts.string -> !ts.boolean
  %14 = ts.Cast %13 : !ts.boolean to i1
  cond_br %14, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %15 = ts.Load(%7) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %16 = ts.GetValueFromUnionOp %15 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %17 = ts.Cast %16 : !ts.number to !ts.string
  ts.Print(%4, %17) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%5) : !ts.string
  ts.ReturnInternal
}


    } -> SUCCESS
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %1 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %2 = ts.Constant {value = "number"} : !ts.string
  %3 = ts.Constant {value = "number"} : !ts.string
  %4 = ts.Constant {value = "b number: "} : !ts.string
  %5 = ts.Constant {value = "done."} : !ts.string
  %6 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %7 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %8 = ts.CreateUnionInstance %1, %2 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %8, %6 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %9 = ts.Load(%6) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %10 = ts.Cast %9 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %10, %7 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %11 = ts.Load(%7) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %12 = ts.GetTypeInfoFromUnionOp %11 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %13 = ts.LogicalBinary %12(34) %3 : !ts.string, !ts.string -> !ts.boolean
  %14 = ts.Cast %13 : !ts.boolean to i1
  cond_br %14, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %15 = ts.Load(%7) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %16 = ts.GetValueFromUnionOp %15 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %17 = ts.Cast %16 : !ts.number to !ts.string
  ts.Print(%4, %17) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%5) : !ts.string
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Constant'(0x278e94ce820) {
  %3 = "ts.Constant"() {value = "number"} : () -> !ts.string

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.Constant -> ()' {
Trying to match "`anonymous-namespace'::ConstantOpLowering"
    ** Insert  : 'llvm.mlir.global'(0x278e9512a30)
    ** Insert  : 'llvm.mlir.addressof'(0x278e94d3640)
    ** Insert  : 'llvm.mlir.constant'(0x278e94d58a0)
    ** Insert  : 'llvm.getelementptr'(0x278e9396930)
    ** Replace : 'ts.Constant'(0x278e94ce820)
"`anonymous-namespace'::ConstantOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.mlir.global'(0x278e9512a30) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.mlir.addressof'(0x278e94d3640) {
      %3 = "llvm.mlir.addressof"() {global_name = @s_9237349086447201248} : () -> !llvm.ptr<array<7 x i8>>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.mlir.constant'(0x278e94d58a0) {
      %4 = "llvm.mlir.constant"() {value = 0 : i64} : () -> i64

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.getelementptr'(0x278e9396930) {
      %5 = "llvm.getelementptr"(%3, %4, %4) : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %1 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %2 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %3 = llvm.mlir.constant(0 : i64) : i64
  %4 = llvm.getelementptr %2[%3, %3] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %5 = ts.Constant {value = "number"} : !ts.string
  %6 = ts.Constant {value = "number"} : !ts.string
  %7 = ts.Constant {value = "b number: "} : !ts.string
  %8 = ts.Constant {value = "done."} : !ts.string
  %9 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %10 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %11 = ts.CreateUnionInstance %1, %5 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %11, %9 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %12 = ts.Load(%9) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %13 = ts.Cast %12 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %13, %10 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %14 = ts.Load(%10) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %15 = ts.GetTypeInfoFromUnionOp %14 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %16 = ts.LogicalBinary %15(34) %6 : !ts.string, !ts.string -> !ts.boolean
  %17 = ts.Cast %16 : !ts.boolean to i1
  cond_br %17, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %18 = ts.Load(%10) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %19 = ts.GetValueFromUnionOp %18 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %20 = ts.Cast %19 : !ts.number to !ts.string
  ts.Print(%7, %20) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%8) : !ts.string
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Constant'(0x278e94d49a0) {
  %7 = "ts.Constant"() {value = "number"} : () -> !ts.string

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.Constant -> ()' {
Trying to match "`anonymous-namespace'::ConstantOpLowering"
    ** Insert  : 'llvm.mlir.addressof'(0x278e94d51c0)
    ** Insert  : 'llvm.mlir.constant'(0x278e94d3820)
    ** Insert  : 'llvm.getelementptr'(0x278e9391d30)
    ** Replace : 'ts.Constant'(0x278e94d49a0)
"`anonymous-namespace'::ConstantOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.mlir.addressof'(0x278e94d51c0) {
      %7 = "llvm.mlir.addressof"() {global_name = @s_9237349086447201248} : () -> !llvm.ptr<array<7 x i8>>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.mlir.constant'(0x278e94d3820) {
      %8 = "llvm.mlir.constant"() {value = 0 : i64} : () -> i64

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.getelementptr'(0x278e9391d30) {
      %9 = "llvm.getelementptr"(%7, %8, %8) : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %1 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %2 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %3 = llvm.mlir.constant(0 : i64) : i64
  %4 = llvm.getelementptr %2[%3, %3] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %5 = ts.Constant {value = "number"} : !ts.string
  %6 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %7 = llvm.mlir.constant(0 : i64) : i64
  %8 = llvm.getelementptr %6[%7, %7] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = ts.Constant {value = "b number: "} : !ts.string
  %11 = ts.Constant {value = "done."} : !ts.string
  %12 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %13 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %14 = ts.CreateUnionInstance %1, %5 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %14, %12 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %15 = ts.Load(%12) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %16 = ts.Cast %15 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %16, %13 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %17 = ts.Load(%13) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %18 = ts.GetTypeInfoFromUnionOp %17 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %19 = ts.LogicalBinary %18(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %20 = ts.Cast %19 : !ts.boolean to i1
  cond_br %20, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %21 = ts.Load(%13) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %22 = ts.GetValueFromUnionOp %21 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %23 = ts.Cast %22 : !ts.number to !ts.string
  ts.Print(%10, %23) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%11) : !ts.string
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Constant'(0x278e94cebe0) {
  %11 = "ts.Constant"() {value = "b number: "} : () -> !ts.string

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.Constant -> ()' {
Trying to match "`anonymous-namespace'::ConstantOpLowering"
    ** Insert  : 'llvm.mlir.global'(0x278e95135e0)
    ** Insert  : 'llvm.mlir.addressof'(0x278e94d4720)
    ** Insert  : 'llvm.mlir.constant'(0x278e94d56c0)
    ** Insert  : 'llvm.getelementptr'(0x278e9390830)
    ** Replace : 'ts.Constant'(0x278e94cebe0)
"`anonymous-namespace'::ConstantOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.mlir.global'(0x278e95135e0) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.mlir.addressof'(0x278e94d4720) {
      %11 = "llvm.mlir.addressof"() {global_name = @s_13617892236937420068} : () -> !llvm.ptr<array<11 x i8>>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.mlir.constant'(0x278e94d56c0) {
      %12 = "llvm.mlir.constant"() {value = 0 : i64} : () -> i64

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.getelementptr'(0x278e9390830) {
      %13 = "llvm.getelementptr"(%11, %12, %12) : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %1 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %2 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %3 = llvm.mlir.constant(0 : i64) : i64
  %4 = llvm.getelementptr %2[%3, %3] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %5 = ts.Constant {value = "number"} : !ts.string
  %6 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %7 = llvm.mlir.constant(0 : i64) : i64
  %8 = llvm.getelementptr %6[%7, %7] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %11 = llvm.mlir.constant(0 : i64) : i64
  %12 = llvm.getelementptr %10[%11, %11] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %13 = ts.Constant {value = "b number: "} : !ts.string
  %14 = ts.Constant {value = "done."} : !ts.string
  %15 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %16 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %17 = ts.CreateUnionInstance %1, %5 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %17, %15 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %18 = ts.Load(%15) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %19 = ts.Cast %18 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %19, %16 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %20 = ts.Load(%16) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %21 = ts.GetTypeInfoFromUnionOp %20 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %22 = ts.LogicalBinary %21(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %23 = ts.Cast %22 : !ts.boolean to i1
  cond_br %23, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %24 = ts.Load(%16) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %25 = ts.GetValueFromUnionOp %24 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %26 = ts.Cast %25 : !ts.number to !ts.string
  ts.Print(%13, %26) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%14) : !ts.string
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Constant'(0x278e94cec80) {
  %15 = "ts.Constant"() {value = "done."} : () -> !ts.string

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.Constant -> ()' {
Trying to match "`anonymous-namespace'::ConstantOpLowering"
    ** Insert  : 'llvm.mlir.global'(0x278e95154d0)
    ** Insert  : 'llvm.mlir.addressof'(0x278e94d4fe0)
    ** Insert  : 'llvm.mlir.constant'(0x278e94d33c0)
    ** Insert  : 'llvm.getelementptr'(0x278e9393730)
    ** Replace : 'ts.Constant'(0x278e94cec80)
"`anonymous-namespace'::ConstantOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.mlir.global'(0x278e95154d0) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.mlir.addressof'(0x278e94d4fe0) {
      %15 = "llvm.mlir.addressof"() {global_name = @s_6682479467004374669} : () -> !llvm.ptr<array<6 x i8>>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.mlir.constant'(0x278e94d33c0) {
      %16 = "llvm.mlir.constant"() {value = 0 : i64} : () -> i64

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.getelementptr'(0x278e9393730) {
      %17 = "llvm.getelementptr"(%15, %16, %16) : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %1 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %2 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %3 = llvm.mlir.constant(0 : i64) : i64
  %4 = llvm.getelementptr %2[%3, %3] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %5 = ts.Constant {value = "number"} : !ts.string
  %6 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %7 = llvm.mlir.constant(0 : i64) : i64
  %8 = llvm.getelementptr %6[%7, %7] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %11 = llvm.mlir.constant(0 : i64) : i64
  %12 = llvm.getelementptr %10[%11, %11] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %13 = ts.Constant {value = "b number: "} : !ts.string
  %14 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "done."} : !ts.string
  %18 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %19 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %20 = ts.CreateUnionInstance %1, %5 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %20, %18 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %21 = ts.Load(%18) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %22 = ts.Cast %21 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %22, %19 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %23 = ts.Load(%19) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %24 = ts.GetTypeInfoFromUnionOp %23 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %25 = ts.LogicalBinary %24(34) %9 : !ts.string, !ts.string -> !ts.boolean
  %26 = ts.Cast %25 : !ts.boolean to i1
  cond_br %26, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %27 = ts.Load(%19) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %28 = ts.GetValueFromUnionOp %27 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %29 = ts.Cast %28 : !ts.number to !ts.string
  ts.Print(%13, %29) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%17) : !ts.string
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Variable'(0x278e94cf2c0) {
  %19 = "ts.Variable"() {captured = false} : () -> !ts.ref<!ts.union<!ts.number,!ts.string>>

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.Variable -> ()' {
Trying to match "`anonymous-namespace'::VariableOpLowering"

!! variable allocation: !ts.union<!ts.number,!ts.string> is captured: 0
    ** Insert  : 'llvm.mlir.constant'(0x278e94d4cc0)
    ** Insert  : 'llvm.alloca'(0x278e94305c0)
    ** Replace : 'ts.Variable'(0x278e94cf2c0)
"`anonymous-namespace'::VariableOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.mlir.constant'(0x278e94d4cc0) {
      %0 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.alloca'(0x278e94305c0) {
      %1 = "llvm.alloca"(%0) : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %2 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %3 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %4 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %5 = llvm.mlir.constant(0 : i64) : i64
  %6 = llvm.getelementptr %4[%5, %5] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %7 = ts.Constant {value = "number"} : !ts.string
  %8 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %9 = llvm.mlir.constant(0 : i64) : i64
  %10 = llvm.getelementptr %8[%9, %9] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %11 = ts.Constant {value = "number"} : !ts.string
  %12 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %13 = llvm.mlir.constant(0 : i64) : i64
  %14 = llvm.getelementptr %12[%13, %13] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %15 = ts.Constant {value = "b number: "} : !ts.string
  %16 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %17 = llvm.mlir.constant(0 : i64) : i64
  %18 = llvm.getelementptr %16[%17, %17] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %19 = ts.Constant {value = "done."} : !ts.string
  %20 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %21 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %22 = ts.CreateUnionInstance %3, %7 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %22, %20 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %23 = ts.Load(%20) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %24 = ts.Cast %23 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %24, %21 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %25 = ts.Load(%21) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %26 = ts.GetTypeInfoFromUnionOp %25 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %27 = ts.LogicalBinary %26(34) %11 : !ts.string, !ts.string -> !ts.boolean
  %28 = ts.Cast %27 : !ts.boolean to i1
  cond_br %28, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %29 = ts.Load(%21) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %30 = ts.GetValueFromUnionOp %29 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %31 = ts.Cast %30 : !ts.number to !ts.string
  ts.Print(%15, %31) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%19) : !ts.string
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Variable'(0x278e94ce780) {
  %22 = "ts.Variable"() {captured = false} : () -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.Variable -> ()' {
Trying to match "`anonymous-namespace'::VariableOpLowering"

!! variable allocation: !ts.union<!ts.string,!ts.number,!ts.boolean> is captured: 0
    ** Insert  : 'llvm.mlir.constant'(0x278e94d4680)
    ** Insert  : 'llvm.alloca'(0x278e94308c0)
    ** Replace : 'ts.Variable'(0x278e94ce780)
"`anonymous-namespace'::VariableOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.mlir.constant'(0x278e94d4680) {
      %0 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.alloca'(0x278e94308c0) {
      %1 = "llvm.alloca"(%0) : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %4 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %5 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %6 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %7 = llvm.mlir.constant(0 : i64) : i64
  %8 = llvm.getelementptr %6[%7, %7] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %9 = ts.Constant {value = "number"} : !ts.string
  %10 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %11 = llvm.mlir.constant(0 : i64) : i64
  %12 = llvm.getelementptr %10[%11, %11] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %13 = ts.Constant {value = "number"} : !ts.string
  %14 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "b number: "} : !ts.string
  %18 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "done."} : !ts.string
  %22 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %23 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %24 = ts.CreateUnionInstance %5, %9 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %24, %22 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %25 = ts.Load(%22) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %26 = ts.Cast %25 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %26, %23 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %27 = ts.Load(%23) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %28 = ts.GetTypeInfoFromUnionOp %27 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %29 = ts.LogicalBinary %28(34) %13 : !ts.string, !ts.string -> !ts.boolean
  %30 = ts.Cast %29 : !ts.boolean to i1
  cond_br %30, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %31 = ts.Load(%23) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %32 = ts.GetValueFromUnionOp %31 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %33 = ts.Cast %32 : !ts.number to !ts.string
  ts.Print(%17, %33) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%21) : !ts.string
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.CreateUnionInstance'(0x278e9553b00) {
  %25 = "ts.CreateUnionInstance"(%6, %10) : (!ts.number, !ts.string) -> !ts.union<!ts.number,!ts.string>

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.CreateUnionInstance -> ()' {
Trying to match "`anonymous-namespace'::CreateUnionInstanceOpLowering"
    ** Insert  : 'llvm.mlir.undef'(0x278e94d3460)
    ** Insert  : 'llvm.insertvalue'(0x278e95471c0)
    ** Insert  : 'llvm.insertvalue'(0x278e9546040)
    ** Insert  : 'ts.Variable'(0x278e942e640)
    ** Insert  : 'ts.Variable'(0x278e94d5080)
    ** Insert  : 'ts.MemoryCopy'(0x278e94756f0)
    ** Insert  : 'ts.Load'(0x278e942f6c0)
    ** Replace : 'ts.CreateUnionInstance'(0x278e9553b00)
"`anonymous-namespace'::CreateUnionInstanceOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.mlir.undef'(0x278e94d3460) {
      %25 = "llvm.mlir.undef"() : () -> !llvm.struct<(ptr<i8>, f64)>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.insertvalue'(0x278e95471c0) {
      %26 = "llvm.insertvalue"(%25, %10) {position = [0 : i32]} : (!llvm.struct<(ptr<i8>, f64)>, !ts.string) -> !llvm.struct<(ptr<i8>, f64)>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.insertvalue'(0x278e9546040) {
      %27 = "llvm.insertvalue"(%26, %6) {position = [1 : i32]} : (!llvm.struct<(ptr<i8>, f64)>, !ts.number) -> !llvm.struct<(ptr<i8>, f64)>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'ts.Variable'(0x278e942e640) {
      %28 = "ts.Variable"(%27) {captured = false} : (!llvm.struct<(ptr<i8>, f64)>) -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>

      * Fold {
      } -> FAILURE : unable to fold

      * Pattern : 'ts.Variable -> ()' {
Trying to match "`anonymous-namespace'::VariableOpLowering"

!! variable allocation: !llvm.struct<(ptr<i8>, f64)> is captured: 0
        ** Insert  : 'llvm.mlir.constant'(0x278e94d5580)
        ** Insert  : 'llvm.alloca'(0x278e942ff00)
        ** Insert  : 'llvm.store'(0x278e9476800)
        ** Replace : 'ts.Variable'(0x278e942e640)
"`anonymous-namespace'::VariableOpLowering" result 1

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.mlir.constant'(0x278e94d5580) {
          %0 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.alloca'(0x278e942ff00) {
          %1 = "llvm.alloca"(%0) : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.store'(0x278e9476800) {
          "llvm.store"(%29, %1) : (!llvm.struct<(ptr<i8>, f64)>, !llvm.ptr<struct<(ptr<i8>, f64)>>) -> ()

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//
      } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %7 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %8 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %9 = llvm.mlir.constant(0 : i64) : i64
  %10 = llvm.getelementptr %8[%9, %9] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %11 = ts.Constant {value = "number"} : !ts.string
  %12 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %13 = llvm.mlir.constant(0 : i64) : i64
  %14 = llvm.getelementptr %12[%13, %13] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %15 = ts.Constant {value = "number"} : !ts.string
  %16 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %17 = llvm.mlir.constant(0 : i64) : i64
  %18 = llvm.getelementptr %16[%17, %17] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %19 = ts.Constant {value = "b number: "} : !ts.string
  %20 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %21 = llvm.mlir.constant(0 : i64) : i64
  %22 = llvm.getelementptr %20[%21, %21] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %23 = ts.Constant {value = "done."} : !ts.string
  %24 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %25 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %26 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %27 = llvm.insertvalue %11, %26[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %28 = llvm.insertvalue %7, %27[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %28, %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %29 = ts.Variable(%28) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  "ts.MemoryCopy"(%30, %29) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %31 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %32 = ts.CreateUnionInstance %7, %11 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %32, %24 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %33 = ts.Load(%24) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %34 = ts.Cast %33 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %34, %25 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %35 = ts.Load(%25) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %36 = ts.GetTypeInfoFromUnionOp %35 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %37 = ts.LogicalBinary %36(34) %15 : !ts.string, !ts.string -> !ts.boolean
  %38 = ts.Cast %37 : !ts.boolean to i1
  cond_br %38, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %39 = ts.Load(%25) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %40 = ts.GetValueFromUnionOp %39 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %41 = ts.Cast %40 : !ts.number to !ts.string
  ts.Print(%19, %41) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%23) : !ts.string
  ts.ReturnInternal
}


    } -> SUCCESS
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'ts.Variable'(0x278e94d5080) {
      %31 = "ts.Variable"() {captured = false} : () -> !ts.ref<!ts.union<!ts.number,!ts.string>>

      * Fold {
      } -> FAILURE : unable to fold

      * Pattern : 'ts.Variable -> ()' {
Trying to match "`anonymous-namespace'::VariableOpLowering"

!! variable allocation: !ts.union<!ts.number,!ts.string> is captured: 0
        ** Insert  : 'llvm.mlir.constant'(0x278e94d5260)
        ** Insert  : 'llvm.alloca'(0x278e942f300)
        ** Replace : 'ts.Variable'(0x278e94d5080)
"`anonymous-namespace'::VariableOpLowering" result 1

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.mlir.constant'(0x278e94d5260) {
          %0 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.alloca'(0x278e942f300) {
          %1 = "llvm.alloca"(%0) : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//
      } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %9 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %10 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %11 = llvm.mlir.constant(0 : i64) : i64
  %12 = llvm.getelementptr %10[%11, %11] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %13 = ts.Constant {value = "number"} : !ts.string
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "b number: "} : !ts.string
  %22 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "done."} : !ts.string
  %26 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %27 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %28 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %29 = llvm.insertvalue %13, %28[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %30 = llvm.insertvalue %9, %29[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %30, %3 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %31 = ts.Variable(%30) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %32 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  "ts.MemoryCopy"(%32, %31) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %33 = ts.Load(%32) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %34 = ts.CreateUnionInstance %9, %13 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %34, %26 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %35 = ts.Load(%26) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %36 = ts.Cast %35 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %36, %27 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %37 = ts.Load(%27) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %38 = ts.GetTypeInfoFromUnionOp %37 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %39 = ts.LogicalBinary %38(34) %17 : !ts.string, !ts.string -> !ts.boolean
  %40 = ts.Cast %39 : !ts.boolean to i1
  cond_br %40, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %41 = ts.Load(%27) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %42 = ts.GetValueFromUnionOp %41 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %43 = ts.Cast %42 : !ts.number to !ts.string
  ts.Print(%21, %43) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%25) : !ts.string
  ts.ReturnInternal
}


    } -> SUCCESS
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'ts.MemoryCopy'(0x278e94756f0) {
      "ts.MemoryCopy"(%33, %32) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()

      * Fold {
      } -> FAILURE : unable to fold

      * Pattern : 'ts.MemoryCopy -> ()' {
Trying to match "`anonymous-namespace'::MemoryCopyOpLowering"
        ** Insert  : 'llvm.func'(0x278e9515370)
        ** Insert  : 'llvm.bitcast'(0x278e9430ec0)
        ** Insert  : 'llvm.bitcast'(0x278e942f180)
        ** Insert  : 'ts.SizeOf'(0x278e94d3780)
        ** Insert  : 'ts.SizeOf'(0x278e94d5620)
        ** Insert  : 'llvm.icmp'(0x278e95446e0)
        ** Insert  : 'llvm.select'(0x278e9392430)
        ** Insert  : 'llvm.mlir.constant'(0x278e94d5760)
        ** Insert  : 'llvm.call'(0x278e9457880)
        ** Erase   : 'ts.MemoryCopy'(0x278e94756f0)
"`anonymous-namespace'::MemoryCopyOpLowering" result 1

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.func'(0x278e9515370) {
        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.bitcast'(0x278e9430ec0) {
          %34 = "llvm.bitcast"(%1) : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>) -> !llvm.ptr<i8>

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.bitcast'(0x278e942f180) {
          %35 = "llvm.bitcast"(%3) : (!llvm.ptr<struct<(ptr<i8>, f64)>>) -> !llvm.ptr<i8>

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'ts.SizeOf'(0x278e94d3780) {
          %36 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64

          * Fold {
          } -> FAILURE : unable to fold

          * Pattern : 'ts.SizeOf -> ()' {
Trying to match "`anonymous-namespace'::SizeOfOpLowering"
            ** Insert  : 'llvm.mlir.null'(0x278e94d4360)

!! size of - storage type: [!llvm.struct<(ptr<i8>, f64)>] llvm storage type: [!llvm.struct<(ptr<i8>, f64)>] llvm ptr: [!llvm.ptr<struct<(ptr<i8>, f64)>>] value: [%35 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>]
            ** Insert  : 'llvm.mlir.constant'(0x278e94d4d60)
            ** Insert  : 'llvm.getelementptr'(0x278e9545f60)
            ** Insert  : 'llvm.ptrtoint'(0x278e942e700)
            ** Replace : 'ts.SizeOf'(0x278e94d3780)
"`anonymous-namespace'::SizeOfOpLowering" result 1

            //===-------------------------------------------===//
            Legalizing operation : 'llvm.mlir.null'(0x278e94d4360) {
              %36 = "llvm.mlir.null"() : () -> !llvm.ptr<struct<(ptr<i8>, f64)>>

            } -> SUCCESS : operation marked legal by the target
            //===-------------------------------------------===//

            //===-------------------------------------------===//
            Legalizing operation : 'llvm.mlir.constant'(0x278e94d4d60) {
              %37 = "llvm.mlir.constant"() {value = 1 : i64} : () -> i64

            } -> SUCCESS : operation marked legal by the target
            //===-------------------------------------------===//

            //===-------------------------------------------===//
            Legalizing operation : 'llvm.getelementptr'(0x278e9545f60) {
              %38 = "llvm.getelementptr"(%36, %37) : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>

            } -> SUCCESS : operation marked legal by the target
            //===-------------------------------------------===//

            //===-------------------------------------------===//
            Legalizing operation : 'llvm.ptrtoint'(0x278e942e700) {
              %39 = "llvm.ptrtoint"(%38) : (!llvm.ptr<struct<(ptr<i8>, f64)>>) -> i64

            } -> SUCCESS : operation marked legal by the target
            //===-------------------------------------------===//
          } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %9 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %10 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %11 = llvm.mlir.constant(0 : i64) : i64
  %12 = llvm.getelementptr %10[%11, %11] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %13 = ts.Constant {value = "number"} : !ts.string
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "b number: "} : !ts.string
  %22 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "done."} : !ts.string
  %26 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %27 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %28 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %29 = llvm.insertvalue %13, %28[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %30 = llvm.insertvalue %9, %29[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %30, %3 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %31 = ts.Variable(%30) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %32 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %33 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %34 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %35 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %36 = llvm.mlir.constant(1 : i64) : i64
  %37 = llvm.getelementptr %35[%36] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %38 = llvm.ptrtoint %37 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %39 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %40 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %41 = llvm.icmp "ult" %39, %40 : i64
  %42 = llvm.select %41, %39, %40 : i1, i64
  %43 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%33, %34, %42, %43) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%32, %31) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %44 = ts.Load(%32) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %45 = ts.CreateUnionInstance %9, %13 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %45, %26 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %46 = ts.Load(%26) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %47 = ts.Cast %46 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %47, %27 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %48 = ts.Load(%27) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %49 = ts.GetTypeInfoFromUnionOp %48 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %50 = ts.LogicalBinary %49(34) %17 : !ts.string, !ts.string -> !ts.boolean
  %51 = ts.Cast %50 : !ts.boolean to i1
  cond_br %51, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %52 = ts.Load(%27) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %53 = ts.GetValueFromUnionOp %52 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %54 = ts.Cast %53 : !ts.number to !ts.string
  ts.Print(%21, %54) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%25) : !ts.string
  ts.ReturnInternal
}


        } -> SUCCESS
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'ts.SizeOf'(0x278e94d5620) {
          %41 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64

          * Fold {
          } -> FAILURE : unable to fold

          * Pattern : 'ts.SizeOf -> ()' {
Trying to match "`anonymous-namespace'::SizeOfOpLowering"
            ** Insert  : 'llvm.mlir.null'(0x278e94d3140)

!! size of - storage type: [!llvm.struct<(ptr<i8>, ptr<i8>)>] llvm storage type: [!llvm.struct<(ptr<i8>, ptr<i8>)>] llvm ptr: [!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>] value: [%40 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>]
            ** Insert  : 'llvm.mlir.constant'(0x278e94d4400)
            ** Insert  : 'llvm.getelementptr'(0x278e9545780)
            ** Insert  : 'llvm.ptrtoint'(0x278e942edc0)
            ** Replace : 'ts.SizeOf'(0x278e94d5620)
"`anonymous-namespace'::SizeOfOpLowering" result 1

            //===-------------------------------------------===//
            Legalizing operation : 'llvm.mlir.null'(0x278e94d3140) {
              %41 = "llvm.mlir.null"() : () -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>

            } -> SUCCESS : operation marked legal by the target
            //===-------------------------------------------===//

            //===-------------------------------------------===//
            Legalizing operation : 'llvm.mlir.constant'(0x278e94d4400) {
              %42 = "llvm.mlir.constant"() {value = 1 : i64} : () -> i64

            } -> SUCCESS : operation marked legal by the target
            //===-------------------------------------------===//

            //===-------------------------------------------===//
            Legalizing operation : 'llvm.getelementptr'(0x278e9545780) {
              %43 = "llvm.getelementptr"(%41, %42) : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>

            } -> SUCCESS : operation marked legal by the target
            //===-------------------------------------------===//

            //===-------------------------------------------===//
            Legalizing operation : 'llvm.ptrtoint'(0x278e942edc0) {
              %44 = "llvm.ptrtoint"(%43) : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>) -> i64

            } -> SUCCESS : operation marked legal by the target
            //===-------------------------------------------===//
          } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %9 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %10 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %11 = llvm.mlir.constant(0 : i64) : i64
  %12 = llvm.getelementptr %10[%11, %11] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %13 = ts.Constant {value = "number"} : !ts.string
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "b number: "} : !ts.string
  %22 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "done."} : !ts.string
  %26 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %27 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %28 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %29 = llvm.insertvalue %13, %28[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %30 = llvm.insertvalue %9, %29[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %30, %3 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %31 = ts.Variable(%30) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %32 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %33 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %34 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %35 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %36 = llvm.mlir.constant(1 : i64) : i64
  %37 = llvm.getelementptr %35[%36] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %38 = llvm.ptrtoint %37 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %39 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %40 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %41 = llvm.mlir.constant(1 : i64) : i64
  %42 = llvm.getelementptr %40[%41] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %43 = llvm.ptrtoint %42 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %44 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %45 = llvm.icmp "ult" %39, %44 : i64
  %46 = llvm.select %45, %39, %44 : i1, i64
  %47 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%33, %34, %46, %47) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%32, %31) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %48 = ts.Load(%32) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %49 = ts.CreateUnionInstance %9, %13 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %49, %26 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %50 = ts.Load(%26) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %51 = ts.Cast %50 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %51, %27 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %52 = ts.Load(%27) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %53 = ts.GetTypeInfoFromUnionOp %52 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %54 = ts.LogicalBinary %53(34) %17 : !ts.string, !ts.string -> !ts.boolean
  %55 = ts.Cast %54 : !ts.boolean to i1
  cond_br %55, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %56 = ts.Load(%27) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %57 = ts.GetValueFromUnionOp %56 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %58 = ts.Cast %57 : !ts.number to !ts.string
  ts.Print(%21, %58) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%25) : !ts.string
  ts.ReturnInternal
}


        } -> SUCCESS
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.icmp'(0x278e95446e0) {
          %46 = "llvm.icmp"(%40, %45) {predicate = 6 : i64} : (i64, i64) -> i1

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.select'(0x278e9392430) {
          %47 = "llvm.select"(%46, %40, %45) : (i1, i64, i64) -> i64

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.mlir.constant'(0x278e94d5760) {
          %48 = "llvm.mlir.constant"() {value = false} : () -> i1

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.call'(0x278e9457880) {
          "llvm.call"(%34, %35, %47, %48) {callee = @llvm.memcpy.p0i8.p0i8.i64} : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//
      } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %9 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %10 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %11 = llvm.mlir.constant(0 : i64) : i64
  %12 = llvm.getelementptr %10[%11, %11] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %13 = ts.Constant {value = "number"} : !ts.string
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "b number: "} : !ts.string
  %22 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "done."} : !ts.string
  %26 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %27 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %28 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %29 = llvm.insertvalue %13, %28[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %30 = llvm.insertvalue %9, %29[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %30, %3 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %31 = ts.Variable(%30) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %32 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %33 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %34 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %35 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %36 = llvm.mlir.constant(1 : i64) : i64
  %37 = llvm.getelementptr %35[%36] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %38 = llvm.ptrtoint %37 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %39 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %40 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %41 = llvm.mlir.constant(1 : i64) : i64
  %42 = llvm.getelementptr %40[%41] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %43 = llvm.ptrtoint %42 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %44 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %45 = llvm.icmp "ult" %39, %44 : i64
  %46 = llvm.select %45, %39, %44 : i1, i64
  %47 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%33, %34, %46, %47) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%32, %31) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %48 = ts.Load(%32) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %49 = ts.CreateUnionInstance %9, %13 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %49, %26 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %50 = ts.Load(%26) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %51 = ts.Cast %50 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %51, %27 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %52 = ts.Load(%27) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %53 = ts.GetTypeInfoFromUnionOp %52 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %54 = ts.LogicalBinary %53(34) %17 : !ts.string, !ts.string -> !ts.boolean
  %55 = ts.Cast %54 : !ts.boolean to i1
  cond_br %55, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %56 = ts.Load(%27) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %57 = ts.GetValueFromUnionOp %56 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %58 = ts.Cast %57 : !ts.number to !ts.string
  ts.Print(%21, %58) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%25) : !ts.string
  ts.ReturnInternal
}


    } -> SUCCESS
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'ts.Load'(0x278e942f6c0) {
      %49 = "ts.Load"(%33) : (!ts.ref<!ts.union<!ts.number,!ts.string>>) -> !ts.union<!ts.number,!ts.string>

      * Fold {
      } -> FAILURE : unable to fold

      * Pattern : 'ts.Load -> ()' {
Trying to match "`anonymous-namespace'::LoadOpLowering"
        ** Insert  : 'llvm.load'(0x278e942eb80)
        ** Replace : 'ts.Load'(0x278e942f6c0)
"`anonymous-namespace'::LoadOpLowering" result 1

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.load'(0x278e942eb80) {
          %49 = "llvm.load"(%1) : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>) -> !llvm.struct<(ptr<i8>, ptr<i8>)>

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//
      } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %9 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %10 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %11 = llvm.mlir.constant(0 : i64) : i64
  %12 = llvm.getelementptr %10[%11, %11] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %13 = ts.Constant {value = "number"} : !ts.string
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "b number: "} : !ts.string
  %22 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "done."} : !ts.string
  %26 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %27 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %28 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %29 = llvm.insertvalue %13, %28[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %30 = llvm.insertvalue %9, %29[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %30, %3 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %31 = ts.Variable(%30) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %32 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %33 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %34 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %35 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %36 = llvm.mlir.constant(1 : i64) : i64
  %37 = llvm.getelementptr %35[%36] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %38 = llvm.ptrtoint %37 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %39 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %40 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %41 = llvm.mlir.constant(1 : i64) : i64
  %42 = llvm.getelementptr %40[%41] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %43 = llvm.ptrtoint %42 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %44 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %45 = llvm.icmp "ult" %39, %44 : i64
  %46 = llvm.select %45, %39, %44 : i1, i64
  %47 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%33, %34, %46, %47) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%32, %31) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %48 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %49 = ts.Load(%32) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %50 = ts.CreateUnionInstance %9, %13 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %50, %26 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %51 = ts.Load(%26) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %52 = ts.Cast %51 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %52, %27 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %53 = ts.Load(%27) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %54 = ts.GetTypeInfoFromUnionOp %53 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %55 = ts.LogicalBinary %54(34) %17 : !ts.string, !ts.string -> !ts.boolean
  %56 = ts.Cast %55 : !ts.boolean to i1
  cond_br %56, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %57 = ts.Load(%27) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %58 = ts.GetValueFromUnionOp %57 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %59 = ts.Cast %58 : !ts.number to !ts.string
  ts.Print(%21, %59) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%25) : !ts.string
  ts.ReturnInternal
}


    } -> SUCCESS
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %9 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %10 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %11 = llvm.mlir.constant(0 : i64) : i64
  %12 = llvm.getelementptr %10[%11, %11] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %13 = ts.Constant {value = "number"} : !ts.string
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "b number: "} : !ts.string
  %22 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "done."} : !ts.string
  %26 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %27 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %28 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %29 = llvm.insertvalue %13, %28[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %30 = llvm.insertvalue %9, %29[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %30, %3 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %31 = ts.Variable(%30) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %32 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %33 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %34 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %35 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %36 = llvm.mlir.constant(1 : i64) : i64
  %37 = llvm.getelementptr %35[%36] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %38 = llvm.ptrtoint %37 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %39 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %40 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %41 = llvm.mlir.constant(1 : i64) : i64
  %42 = llvm.getelementptr %40[%41] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %43 = llvm.ptrtoint %42 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %44 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %45 = llvm.icmp "ult" %39, %44 : i64
  %46 = llvm.select %45, %39, %44 : i1, i64
  %47 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%33, %34, %46, %47) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%32, %31) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %48 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %49 = ts.Load(%32) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %50 = ts.CreateUnionInstance %9, %13 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  ts.Store %50, %26 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %51 = ts.Load(%26) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %52 = ts.Cast %51 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %52, %27 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %53 = ts.Load(%27) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %54 = ts.GetTypeInfoFromUnionOp %53 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %55 = ts.LogicalBinary %54(34) %17 : !ts.string, !ts.string -> !ts.boolean
  %56 = ts.Cast %55 : !ts.boolean to i1
  cond_br %56, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %57 = ts.Load(%27) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %58 = ts.GetValueFromUnionOp %57 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %59 = ts.Cast %58 : !ts.number to !ts.string
  ts.Print(%21, %59) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%25) : !ts.string
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Store'(0x278e9478880) {
  "ts.Store"(%51, %27) : (!ts.union<!ts.number,!ts.string>, !ts.ref<!ts.union<!ts.number,!ts.string>>) -> ()

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.Store -> ()' {
Trying to match "`anonymous-namespace'::StoreOpLowering"
    ** Insert  : 'llvm.store'(0x278e9476180)
    ** Replace : 'ts.Store'(0x278e9478880)
"`anonymous-namespace'::StoreOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.store'(0x278e9476180) {
      "llvm.store"(%49, %7) : (!llvm.struct<(ptr<i8>, ptr<i8>)>, !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>) -> ()

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %9 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %10 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %11 = llvm.mlir.constant(0 : i64) : i64
  %12 = llvm.getelementptr %10[%11, %11] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %13 = ts.Constant {value = "number"} : !ts.string
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "b number: "} : !ts.string
  %22 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "done."} : !ts.string
  %26 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %27 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %28 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %29 = llvm.insertvalue %13, %28[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %30 = llvm.insertvalue %9, %29[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %30, %3 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %31 = ts.Variable(%30) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %32 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %33 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %34 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %35 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %36 = llvm.mlir.constant(1 : i64) : i64
  %37 = llvm.getelementptr %35[%36] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %38 = llvm.ptrtoint %37 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %39 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %40 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %41 = llvm.mlir.constant(1 : i64) : i64
  %42 = llvm.getelementptr %40[%41] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %43 = llvm.ptrtoint %42 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %44 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %45 = llvm.icmp "ult" %39, %44 : i64
  %46 = llvm.select %45, %39, %44 : i1, i64
  %47 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%33, %34, %46, %47) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%32, %31) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %48 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %49 = ts.Load(%32) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %50 = ts.CreateUnionInstance %9, %13 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %48, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %50, %26 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %51 = ts.Load(%26) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %52 = ts.Cast %51 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %52, %27 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %53 = ts.Load(%27) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %54 = ts.GetTypeInfoFromUnionOp %53 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %55 = ts.LogicalBinary %54(34) %17 : !ts.string, !ts.string -> !ts.boolean
  %56 = ts.Cast %55 : !ts.boolean to i1
  cond_br %56, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %57 = ts.Load(%27) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %58 = ts.GetValueFromUnionOp %57 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %59 = ts.Cast %58 : !ts.number to !ts.string
  ts.Print(%21, %59) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%25) : !ts.string
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Load'(0x278e942f240) {
  %52 = "ts.Load"(%27) : (!ts.ref<!ts.union<!ts.number,!ts.string>>) -> !ts.union<!ts.number,!ts.string>

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.Load -> ()' {
Trying to match "`anonymous-namespace'::LoadOpLowering"
    ** Insert  : 'llvm.load'(0x278e942fc00)
    ** Replace : 'ts.Load'(0x278e942f240)
"`anonymous-namespace'::LoadOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.load'(0x278e942fc00) {
      %52 = "llvm.load"(%7) : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>) -> !llvm.struct<(ptr<i8>, ptr<i8>)>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %9 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %10 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %11 = llvm.mlir.constant(0 : i64) : i64
  %12 = llvm.getelementptr %10[%11, %11] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %13 = ts.Constant {value = "number"} : !ts.string
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "b number: "} : !ts.string
  %22 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "done."} : !ts.string
  %26 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %27 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %28 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %29 = llvm.insertvalue %13, %28[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %30 = llvm.insertvalue %9, %29[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %30, %3 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %31 = ts.Variable(%30) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %32 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %33 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %34 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %35 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %36 = llvm.mlir.constant(1 : i64) : i64
  %37 = llvm.getelementptr %35[%36] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %38 = llvm.ptrtoint %37 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %39 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %40 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %41 = llvm.mlir.constant(1 : i64) : i64
  %42 = llvm.getelementptr %40[%41] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %43 = llvm.ptrtoint %42 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %44 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %45 = llvm.icmp "ult" %39, %44 : i64
  %46 = llvm.select %45, %39, %44 : i1, i64
  %47 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%33, %34, %46, %47) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%32, %31) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %48 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %49 = ts.Load(%32) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %50 = ts.CreateUnionInstance %9, %13 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %48, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %50, %26 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %51 = llvm.load %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %52 = ts.Load(%26) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %53 = ts.Cast %52 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %53, %27 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %54 = ts.Load(%27) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %55 = ts.GetTypeInfoFromUnionOp %54 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %56 = ts.LogicalBinary %55(34) %17 : !ts.string, !ts.string -> !ts.boolean
  %57 = ts.Cast %56 : !ts.boolean to i1
  cond_br %57, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %58 = ts.Load(%27) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %59 = ts.GetValueFromUnionOp %58 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %60 = ts.Cast %59 : !ts.number to !ts.string
  ts.Print(%21, %60) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%25) : !ts.string
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Cast'(0x278e942e400) {
  %54 = "ts.Cast"(%53) : (!ts.union<!ts.number,!ts.string>) -> !ts.union<!ts.string,!ts.number,!ts.boolean>

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.Cast -> ()' {
Trying to match "`anonymous-namespace'::CastOpLowering"
    ** Insert  : 'ts.GetValueFromUnionOp'(0x278e942ed00)
    ** Insert  : 'ts.GetTypeInfoFromUnionOp'(0x278e9430500)
    ** Insert  : 'ts.CreateUnionInstance'(0x278e95469e0)
    ** Replace : 'ts.Cast'(0x278e942e400)
"`anonymous-namespace'::CastOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'ts.GetValueFromUnionOp'(0x278e942ed00) {
      %54 = "ts.GetValueFromUnionOp"(%52) : (!llvm.struct<(ptr<i8>, ptr<i8>)>) -> !llvm.ptr<i8>

      * Fold {
      } -> FAILURE : unable to fold

      * Pattern : 'ts.GetValueFromUnionOp -> ()' {
Trying to match "`anonymous-namespace'::GetValueFromUnionOpLowering"
        ** Insert  : 'llvm.extractvalue'(0x278e9430740)
        ** Replace : 'ts.GetValueFromUnionOp'(0x278e942ed00)
"`anonymous-namespace'::GetValueFromUnionOpLowering" result 1

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.extractvalue'(0x278e9430740) {
          %54 = "llvm.extractvalue"(%52) {position = [1 : i32]} : (!llvm.struct<(ptr<i8>, ptr<i8>)>) -> !llvm.ptr<i8>

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//
      } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %9 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %10 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %11 = llvm.mlir.constant(0 : i64) : i64
  %12 = llvm.getelementptr %10[%11, %11] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %13 = ts.Constant {value = "number"} : !ts.string
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "b number: "} : !ts.string
  %22 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "done."} : !ts.string
  %26 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %27 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %28 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %29 = llvm.insertvalue %13, %28[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %30 = llvm.insertvalue %9, %29[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %30, %3 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %31 = ts.Variable(%30) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %32 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %33 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %34 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %35 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %36 = llvm.mlir.constant(1 : i64) : i64
  %37 = llvm.getelementptr %35[%36] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %38 = llvm.ptrtoint %37 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %39 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %40 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %41 = llvm.mlir.constant(1 : i64) : i64
  %42 = llvm.getelementptr %40[%41] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %43 = llvm.ptrtoint %42 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %44 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %45 = llvm.icmp "ult" %39, %44 : i64
  %46 = llvm.select %45, %39, %44 : i1, i64
  %47 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%33, %34, %46, %47) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%32, %31) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %48 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %49 = ts.Load(%32) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %50 = ts.CreateUnionInstance %9, %13 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %48, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %50, %26 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %51 = llvm.load %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %52 = ts.Load(%26) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %53 = llvm.extractvalue %51[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %54 = ts.GetValueFromUnionOp %51 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %55 = ts.GetTypeInfoFromUnionOp %51 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %56 = ts.CreateUnionInstance %54, %55 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
  %57 = ts.Cast %52 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %57, %27 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %58 = ts.Load(%27) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %59 = ts.GetTypeInfoFromUnionOp %58 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %60 = ts.LogicalBinary %59(34) %17 : !ts.string, !ts.string -> !ts.boolean
  %61 = ts.Cast %60 : !ts.boolean to i1
  cond_br %61, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %62 = ts.Load(%27) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %63 = ts.GetValueFromUnionOp %62 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %64 = ts.Cast %63 : !ts.number to !ts.string
  ts.Print(%21, %64) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%25) : !ts.string
  ts.ReturnInternal
}


    } -> SUCCESS
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'ts.GetTypeInfoFromUnionOp'(0x278e9430500) {
      %56 = "ts.GetTypeInfoFromUnionOp"(%52) : (!llvm.struct<(ptr<i8>, ptr<i8>)>) -> !ts.string

      * Fold {
      } -> FAILURE : unable to fold

      * Pattern : 'ts.GetTypeInfoFromUnionOp -> ()' {
Trying to match "`anonymous-namespace'::GetTypeInfoFromUnionOpLowering"
        ** Insert  : 'llvm.extractvalue'(0x278e942ee80)
        ** Replace : 'ts.GetTypeInfoFromUnionOp'(0x278e9430500)
"`anonymous-namespace'::GetTypeInfoFromUnionOpLowering" result 1

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.extractvalue'(0x278e942ee80) {
          %56 = "llvm.extractvalue"(%52) {position = [0 : i32]} : (!llvm.struct<(ptr<i8>, ptr<i8>)>) -> !llvm.ptr<i8>

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//
      } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %9 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %10 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %11 = llvm.mlir.constant(0 : i64) : i64
  %12 = llvm.getelementptr %10[%11, %11] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %13 = ts.Constant {value = "number"} : !ts.string
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "b number: "} : !ts.string
  %22 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "done."} : !ts.string
  %26 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %27 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %28 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %29 = llvm.insertvalue %13, %28[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %30 = llvm.insertvalue %9, %29[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %30, %3 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %31 = ts.Variable(%30) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %32 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %33 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %34 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %35 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %36 = llvm.mlir.constant(1 : i64) : i64
  %37 = llvm.getelementptr %35[%36] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %38 = llvm.ptrtoint %37 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %39 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %40 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %41 = llvm.mlir.constant(1 : i64) : i64
  %42 = llvm.getelementptr %40[%41] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %43 = llvm.ptrtoint %42 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %44 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %45 = llvm.icmp "ult" %39, %44 : i64
  %46 = llvm.select %45, %39, %44 : i1, i64
  %47 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%33, %34, %46, %47) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%32, %31) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %48 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %49 = ts.Load(%32) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %50 = ts.CreateUnionInstance %9, %13 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %48, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %50, %26 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %51 = llvm.load %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %52 = ts.Load(%26) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %53 = llvm.extractvalue %51[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %54 = ts.GetValueFromUnionOp %51 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %55 = llvm.extractvalue %51[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %56 = ts.GetTypeInfoFromUnionOp %51 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %57 = ts.CreateUnionInstance %54, %56 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
  %58 = ts.Cast %52 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %58, %27 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %59 = ts.Load(%27) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %60 = ts.GetTypeInfoFromUnionOp %59 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %61 = ts.LogicalBinary %60(34) %17 : !ts.string, !ts.string -> !ts.boolean
  %62 = ts.Cast %61 : !ts.boolean to i1
  cond_br %62, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %63 = ts.Load(%27) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %64 = ts.GetValueFromUnionOp %63 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %65 = ts.Cast %64 : !ts.number to !ts.string
  ts.Print(%21, %65) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%25) : !ts.string
  ts.ReturnInternal
}


    } -> SUCCESS
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'ts.CreateUnionInstance'(0x278e95469e0) {
      %58 = "ts.CreateUnionInstance"(%55, %57) : (!llvm.ptr<i8>, !ts.string) -> !ts.union<!ts.string,!ts.number,!ts.boolean>

      * Fold {
      } -> FAILURE : unable to fold

      * Pattern : 'ts.CreateUnionInstance -> ()' {
Trying to match "`anonymous-namespace'::CreateUnionInstanceOpLowering"
        ** Insert  : 'llvm.mlir.undef'(0x278e94d47c0)
        ** Insert  : 'llvm.insertvalue'(0x278e9547540)
        ** Insert  : 'llvm.insertvalue'(0x278e9544520)
        ** Insert  : 'ts.Variable'(0x278e942f480)
        ** Insert  : 'ts.Variable'(0x278e94d3500)
        ** Insert  : 'ts.MemoryCopy'(0x278e9475d70)
        ** Insert  : 'ts.Load'(0x278e942fb40)
        ** Replace : 'ts.CreateUnionInstance'(0x278e95469e0)
"`anonymous-namespace'::CreateUnionInstanceOpLowering" result 1

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.mlir.undef'(0x278e94d47c0) {
          %58 = "llvm.mlir.undef"() : () -> !llvm.struct<(ptr<i8>, ptr<i8>)>

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.insertvalue'(0x278e9547540) {
          %59 = "llvm.insertvalue"(%58, %57) {position = [0 : i32]} : (!llvm.struct<(ptr<i8>, ptr<i8>)>, !ts.string) -> !llvm.struct<(ptr<i8>, ptr<i8>)>

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.insertvalue'(0x278e9544520) {
          %60 = "llvm.insertvalue"(%59, %55) {position = [1 : i32]} : (!llvm.struct<(ptr<i8>, ptr<i8>)>, !llvm.ptr<i8>) -> !llvm.struct<(ptr<i8>, ptr<i8>)>

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'ts.Variable'(0x278e942f480) {
          %61 = "ts.Variable"(%60) {captured = false} : (!llvm.struct<(ptr<i8>, ptr<i8>)>) -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>

          * Fold {
          } -> FAILURE : unable to fold

          * Pattern : 'ts.Variable -> ()' {
Trying to match "`anonymous-namespace'::VariableOpLowering"

!! variable allocation: !llvm.struct<(ptr<i8>, ptr<i8>)> is captured: 0
            ** Insert  : 'llvm.mlir.constant'(0x278e94d4040)
            ** Insert  : 'llvm.alloca'(0x278e942ef40)
            ** Insert  : 'llvm.store'(0x278e94757c0)
            ** Replace : 'ts.Variable'(0x278e942f480)
"`anonymous-namespace'::VariableOpLowering" result 1

            //===-------------------------------------------===//
            Legalizing operation : 'llvm.mlir.constant'(0x278e94d4040) {
              %0 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32

            } -> SUCCESS : operation marked legal by the target
            //===-------------------------------------------===//

            //===-------------------------------------------===//
            Legalizing operation : 'llvm.alloca'(0x278e942ef40) {
              %1 = "llvm.alloca"(%0) : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>

            } -> SUCCESS : operation marked legal by the target
            //===-------------------------------------------===//

            //===-------------------------------------------===//
            Legalizing operation : 'llvm.store'(0x278e94757c0) {
              "llvm.store"(%62, %1) : (!llvm.struct<(ptr<i8>, ptr<i8>)>, !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>) -> ()

            } -> SUCCESS : operation marked legal by the target
            //===-------------------------------------------===//
          } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %10 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %11 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %12 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %13 = llvm.mlir.constant(0 : i64) : i64
  %14 = llvm.getelementptr %12[%13, %13] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %15 = ts.Constant {value = "number"} : !ts.string
  %16 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %17 = llvm.mlir.constant(0 : i64) : i64
  %18 = llvm.getelementptr %16[%17, %17] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %19 = ts.Constant {value = "number"} : !ts.string
  %20 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %21 = llvm.mlir.constant(0 : i64) : i64
  %22 = llvm.getelementptr %20[%21, %21] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %23 = ts.Constant {value = "b number: "} : !ts.string
  %24 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %25 = llvm.mlir.constant(0 : i64) : i64
  %26 = llvm.getelementptr %24[%25, %25] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %27 = ts.Constant {value = "done."} : !ts.string
  %28 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %29 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %30 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %31 = llvm.insertvalue %15, %30[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %32 = llvm.insertvalue %11, %31[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %32, %5 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %33 = ts.Variable(%32) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %34 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %35 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %36 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %37 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %38 = llvm.mlir.constant(1 : i64) : i64
  %39 = llvm.getelementptr %37[%38] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %40 = llvm.ptrtoint %39 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %41 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %42 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %43 = llvm.mlir.constant(1 : i64) : i64
  %44 = llvm.getelementptr %42[%43] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %45 = llvm.ptrtoint %44 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %46 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %47 = llvm.icmp "ult" %41, %46 : i64
  %48 = llvm.select %47, %41, %46 : i1, i64
  %49 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%35, %36, %48, %49) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%34, %33) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %50 = llvm.load %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %51 = ts.Load(%34) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %52 = ts.CreateUnionInstance %11, %15 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %50, %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %52, %28 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %53 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %54 = ts.Load(%28) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %55 = llvm.extractvalue %53[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %56 = ts.GetValueFromUnionOp %53 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %57 = llvm.extractvalue %53[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = ts.GetTypeInfoFromUnionOp %53 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %59 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = llvm.insertvalue %58, %59[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %61 = llvm.insertvalue %56, %60[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  llvm.store %61, %1 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %62 = ts.Variable(%61) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %63 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  "ts.MemoryCopy"(%63, %62) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %64 = ts.Load(%63) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %65 = ts.CreateUnionInstance %56, %58 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
  %66 = ts.Cast %54 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %66, %29 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %67 = ts.Load(%29) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %68 = ts.GetTypeInfoFromUnionOp %67 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %69 = ts.LogicalBinary %68(34) %19 : !ts.string, !ts.string -> !ts.boolean
  %70 = ts.Cast %69 : !ts.boolean to i1
  cond_br %70, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %71 = ts.Load(%29) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %72 = ts.GetValueFromUnionOp %71 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %73 = ts.Cast %72 : !ts.number to !ts.string
  ts.Print(%23, %73) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%27) : !ts.string
  ts.ReturnInternal
}


        } -> SUCCESS
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'ts.Variable'(0x278e94d3500) {
          %64 = "ts.Variable"() {captured = false} : () -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>

          * Fold {
          } -> FAILURE : unable to fold

          * Pattern : 'ts.Variable -> ()' {
Trying to match "`anonymous-namespace'::VariableOpLowering"

!! variable allocation: !ts.union<!ts.string,!ts.number,!ts.boolean> is captured: 0
            ** Insert  : 'llvm.mlir.constant'(0x278e94d35a0)
            ** Insert  : 'llvm.alloca'(0x278e942f900)
            ** Replace : 'ts.Variable'(0x278e94d3500)
"`anonymous-namespace'::VariableOpLowering" result 1

            //===-------------------------------------------===//
            Legalizing operation : 'llvm.mlir.constant'(0x278e94d35a0) {
              %0 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32

            } -> SUCCESS : operation marked legal by the target
            //===-------------------------------------------===//

            //===-------------------------------------------===//
            Legalizing operation : 'llvm.alloca'(0x278e942f900) {
              %1 = "llvm.alloca"(%0) : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>

            } -> SUCCESS : operation marked legal by the target
            //===-------------------------------------------===//
          } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "number"} : !ts.string
  %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "b number: "} : !ts.string
  %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %27 = llvm.mlir.constant(0 : i64) : i64
  %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %29 = ts.Constant {value = "done."} : !ts.string
  %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %40 = llvm.mlir.constant(1 : i64) : i64
  %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %45 = llvm.mlir.constant(1 : i64) : i64
  %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %49 = llvm.icmp "ult" %43, %48 : i64
  %50 = llvm.select %49, %43, %48 : i1, i64
  %51 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  llvm.store %63, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %64 = ts.Variable(%63) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %65 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  "ts.MemoryCopy"(%65, %64) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %66 = ts.Load(%65) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %67 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
  %68 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %68, %31 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %69 = ts.Load(%31) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %70 = ts.GetTypeInfoFromUnionOp %69 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %71 = ts.LogicalBinary %70(34) %21 : !ts.string, !ts.string -> !ts.boolean
  %72 = ts.Cast %71 : !ts.boolean to i1
  cond_br %72, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %73 = ts.Load(%31) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %74 = ts.GetValueFromUnionOp %73 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %75 = ts.Cast %74 : !ts.number to !ts.string
  ts.Print(%25, %75) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%29) : !ts.string
  ts.ReturnInternal
}


        } -> SUCCESS
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'ts.MemoryCopy'(0x278e9475d70) {
          "ts.MemoryCopy"(%66, %65) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()

          * Fold {
          } -> FAILURE : unable to fold

          * Pattern : 'ts.MemoryCopy -> ()' {
Trying to match "`anonymous-namespace'::MemoryCopyOpLowering"
            ** Insert  : 'llvm.bitcast'(0x278e942f600)
            ** Insert  : 'llvm.bitcast'(0x278e942f780)
            ** Insert  : 'ts.SizeOf'(0x278e94d3960)
            ** Insert  : 'ts.SizeOf'(0x278e94d45e0)
            ** Insert  : 'llvm.icmp'(0x278e95464a0)
            ** Insert  : 'llvm.select'(0x278e9391530)
            ** Insert  : 'llvm.mlir.constant'(0x278e94d3a00)
            ** Insert  : 'llvm.call'(0x278e9458dc0)
            ** Erase   : 'ts.MemoryCopy'(0x278e9475d70)
"`anonymous-namespace'::MemoryCopyOpLowering" result 1

            //===-------------------------------------------===//
            Legalizing operation : 'llvm.bitcast'(0x278e942f600) {
              %67 = "llvm.bitcast"(%1) : (!llvm.ptr<struct<(ptr<i8>, i1)>>) -> !llvm.ptr<i8>

            } -> SUCCESS : operation marked legal by the target
            //===-------------------------------------------===//

            //===-------------------------------------------===//
            Legalizing operation : 'llvm.bitcast'(0x278e942f780) {
              %68 = "llvm.bitcast"(%3) : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>) -> !llvm.ptr<i8>

            } -> SUCCESS : operation marked legal by the target
            //===-------------------------------------------===//

            //===-------------------------------------------===//
            Legalizing operation : 'ts.SizeOf'(0x278e94d3960) {
              %69 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64

              * Fold {
              } -> FAILURE : unable to fold

              * Pattern : 'ts.SizeOf -> ()' {
Trying to match "`anonymous-namespace'::SizeOfOpLowering"
                ** Insert  : 'llvm.mlir.null'(0x278e94d3b40)

!! size of - storage type: [!llvm.struct<(ptr<i8>, ptr<i8>)>] llvm storage type: [!llvm.struct<(ptr<i8>, ptr<i8>)>] llvm ptr: [!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>] value: [%68 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>]
                ** Insert  : 'llvm.mlir.constant'(0x278e94d3be0)
                ** Insert  : 'llvm.getelementptr'(0x278e9544600)
                ** Insert  : 'llvm.ptrtoint'(0x278e9430680)
                ** Replace : 'ts.SizeOf'(0x278e94d3960)
"`anonymous-namespace'::SizeOfOpLowering" result 1

                //===-------------------------------------------===//
                Legalizing operation : 'llvm.mlir.null'(0x278e94d3b40) {
                  %69 = "llvm.mlir.null"() : () -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>

                } -> SUCCESS : operation marked legal by the target
                //===-------------------------------------------===//

                //===-------------------------------------------===//
                Legalizing operation : 'llvm.mlir.constant'(0x278e94d3be0) {
                  %70 = "llvm.mlir.constant"() {value = 1 : i64} : () -> i64

                } -> SUCCESS : operation marked legal by the target
                //===-------------------------------------------===//

                //===-------------------------------------------===//
                Legalizing operation : 'llvm.getelementptr'(0x278e9544600) {
                  %71 = "llvm.getelementptr"(%69, %70) : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>

                } -> SUCCESS : operation marked legal by the target
                //===-------------------------------------------===//

                //===-------------------------------------------===//
                Legalizing operation : 'llvm.ptrtoint'(0x278e9430680) {
                  %72 = "llvm.ptrtoint"(%71) : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>) -> i64

                } -> SUCCESS : operation marked legal by the target
                //===-------------------------------------------===//
              } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "number"} : !ts.string
  %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "b number: "} : !ts.string
  %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %27 = llvm.mlir.constant(0 : i64) : i64
  %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %29 = ts.Constant {value = "done."} : !ts.string
  %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %40 = llvm.mlir.constant(1 : i64) : i64
  %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %45 = llvm.mlir.constant(1 : i64) : i64
  %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %49 = llvm.icmp "ult" %43, %48 : i64
  %50 = llvm.select %49, %43, %48 : i1, i64
  %51 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  llvm.store %63, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %64 = ts.Variable(%63) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %65 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %66 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %67 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %68 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %69 = llvm.mlir.constant(1 : i64) : i64
  %70 = llvm.getelementptr %68[%69] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %71 = llvm.ptrtoint %70 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %72 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %73 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %74 = llvm.icmp "ult" %72, %73 : i64
  %75 = llvm.select %74, %72, %73 : i1, i64
  %76 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%66, %67, %75, %76) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%65, %64) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %77 = ts.Load(%65) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %78 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
  %79 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %79, %31 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %80 = ts.Load(%31) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %81 = ts.GetTypeInfoFromUnionOp %80 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %82 = ts.LogicalBinary %81(34) %21 : !ts.string, !ts.string -> !ts.boolean
  %83 = ts.Cast %82 : !ts.boolean to i1
  cond_br %83, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %84 = ts.Load(%31) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %85 = ts.GetValueFromUnionOp %84 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %86 = ts.Cast %85 : !ts.number to !ts.string
  ts.Print(%25, %86) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%29) : !ts.string
  ts.ReturnInternal
}


            } -> SUCCESS
            //===-------------------------------------------===//

            //===-------------------------------------------===//
            Legalizing operation : 'ts.SizeOf'(0x278e94d45e0) {
              %74 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64

              * Fold {
              } -> FAILURE : unable to fold

              * Pattern : 'ts.SizeOf -> ()' {
Trying to match "`anonymous-namespace'::SizeOfOpLowering"
                ** Insert  : 'llvm.mlir.null'(0x278e94d3c80)

!! size of - storage type: [!llvm.struct<(ptr<i8>, i1)>] llvm storage type: [!llvm.struct<(ptr<i8>, i1)>] llvm ptr: [!llvm.ptr<struct<(ptr<i8>, i1)>>] value: [%73 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>]
                ** Insert  : 'llvm.mlir.constant'(0x278e94d3d20)
                ** Insert  : 'llvm.getelementptr'(0x278e95447c0)
                ** Insert  : 'llvm.ptrtoint'(0x278e9430f80)
                ** Replace : 'ts.SizeOf'(0x278e94d45e0)
"`anonymous-namespace'::SizeOfOpLowering" result 1

                //===-------------------------------------------===//
                Legalizing operation : 'llvm.mlir.null'(0x278e94d3c80) {
                  %74 = "llvm.mlir.null"() : () -> !llvm.ptr<struct<(ptr<i8>, i1)>>

                } -> SUCCESS : operation marked legal by the target
                //===-------------------------------------------===//

                //===-------------------------------------------===//
                Legalizing operation : 'llvm.mlir.constant'(0x278e94d3d20) {
                  %75 = "llvm.mlir.constant"() {value = 1 : i64} : () -> i64

                } -> SUCCESS : operation marked legal by the target
                //===-------------------------------------------===//

                //===-------------------------------------------===//
                Legalizing operation : 'llvm.getelementptr'(0x278e95447c0) {
                  %76 = "llvm.getelementptr"(%74, %75) : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>

                } -> SUCCESS : operation marked legal by the target
                //===-------------------------------------------===//

                //===-------------------------------------------===//
                Legalizing operation : 'llvm.ptrtoint'(0x278e9430f80) {
                  %77 = "llvm.ptrtoint"(%76) : (!llvm.ptr<struct<(ptr<i8>, i1)>>) -> i64

                } -> SUCCESS : operation marked legal by the target
                //===-------------------------------------------===//
              } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "number"} : !ts.string
  %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "b number: "} : !ts.string
  %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %27 = llvm.mlir.constant(0 : i64) : i64
  %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %29 = ts.Constant {value = "done."} : !ts.string
  %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %40 = llvm.mlir.constant(1 : i64) : i64
  %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %45 = llvm.mlir.constant(1 : i64) : i64
  %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %49 = llvm.icmp "ult" %43, %48 : i64
  %50 = llvm.select %49, %43, %48 : i1, i64
  %51 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  llvm.store %63, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %64 = ts.Variable(%63) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %65 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %66 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %67 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %68 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %69 = llvm.mlir.constant(1 : i64) : i64
  %70 = llvm.getelementptr %68[%69] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %71 = llvm.ptrtoint %70 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %72 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %73 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %74 = llvm.mlir.constant(1 : i64) : i64
  %75 = llvm.getelementptr %73[%74] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %76 = llvm.ptrtoint %75 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %77 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %78 = llvm.icmp "ult" %72, %77 : i64
  %79 = llvm.select %78, %72, %77 : i1, i64
  %80 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%66, %67, %79, %80) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%65, %64) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %81 = ts.Load(%65) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %82 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
  %83 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %83, %31 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %84 = ts.Load(%31) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %85 = ts.GetTypeInfoFromUnionOp %84 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %86 = ts.LogicalBinary %85(34) %21 : !ts.string, !ts.string -> !ts.boolean
  %87 = ts.Cast %86 : !ts.boolean to i1
  cond_br %87, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %88 = ts.Load(%31) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %89 = ts.GetValueFromUnionOp %88 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %90 = ts.Cast %89 : !ts.number to !ts.string
  ts.Print(%25, %90) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%29) : !ts.string
  ts.ReturnInternal
}


            } -> SUCCESS
            //===-------------------------------------------===//

            //===-------------------------------------------===//
            Legalizing operation : 'llvm.icmp'(0x278e95464a0) {
              %79 = "llvm.icmp"(%73, %78) {predicate = 6 : i64} : (i64, i64) -> i1

            } -> SUCCESS : operation marked legal by the target
            //===-------------------------------------------===//

            //===-------------------------------------------===//
            Legalizing operation : 'llvm.select'(0x278e9391530) {
              %80 = "llvm.select"(%79, %73, %78) : (i1, i64, i64) -> i64

            } -> SUCCESS : operation marked legal by the target
            //===-------------------------------------------===//

            //===-------------------------------------------===//
            Legalizing operation : 'llvm.mlir.constant'(0x278e94d3a00) {
              %81 = "llvm.mlir.constant"() {value = false} : () -> i1

            } -> SUCCESS : operation marked legal by the target
            //===-------------------------------------------===//

            //===-------------------------------------------===//
            Legalizing operation : 'llvm.call'(0x278e9458dc0) {
              "llvm.call"(%67, %68, %80, %81) {callee = @llvm.memcpy.p0i8.p0i8.i64} : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()

            } -> SUCCESS : operation marked legal by the target
            //===-------------------------------------------===//
          } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "number"} : !ts.string
  %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "b number: "} : !ts.string
  %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %27 = llvm.mlir.constant(0 : i64) : i64
  %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %29 = ts.Constant {value = "done."} : !ts.string
  %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %40 = llvm.mlir.constant(1 : i64) : i64
  %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %45 = llvm.mlir.constant(1 : i64) : i64
  %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %49 = llvm.icmp "ult" %43, %48 : i64
  %50 = llvm.select %49, %43, %48 : i1, i64
  %51 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  llvm.store %63, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %64 = ts.Variable(%63) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %65 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %66 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %67 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %68 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %69 = llvm.mlir.constant(1 : i64) : i64
  %70 = llvm.getelementptr %68[%69] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %71 = llvm.ptrtoint %70 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %72 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %73 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %74 = llvm.mlir.constant(1 : i64) : i64
  %75 = llvm.getelementptr %73[%74] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %76 = llvm.ptrtoint %75 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %77 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %78 = llvm.icmp "ult" %72, %77 : i64
  %79 = llvm.select %78, %72, %77 : i1, i64
  %80 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%66, %67, %79, %80) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%65, %64) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %81 = ts.Load(%65) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %82 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
  %83 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %83, %31 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %84 = ts.Load(%31) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %85 = ts.GetTypeInfoFromUnionOp %84 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %86 = ts.LogicalBinary %85(34) %21 : !ts.string, !ts.string -> !ts.boolean
  %87 = ts.Cast %86 : !ts.boolean to i1
  cond_br %87, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %88 = ts.Load(%31) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %89 = ts.GetValueFromUnionOp %88 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %90 = ts.Cast %89 : !ts.number to !ts.string
  ts.Print(%25, %90) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%29) : !ts.string
  ts.ReturnInternal
}


        } -> SUCCESS
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'ts.Load'(0x278e942fb40) {
          %82 = "ts.Load"(%66) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>) -> !ts.union<!ts.string,!ts.number,!ts.boolean>

          * Fold {
          } -> FAILURE : unable to fold

          * Pattern : 'ts.Load -> ()' {
Trying to match "`anonymous-namespace'::LoadOpLowering"
            ** Insert  : 'llvm.load'(0x278e9431040)
            ** Replace : 'ts.Load'(0x278e942fb40)
"`anonymous-namespace'::LoadOpLowering" result 1

            //===-------------------------------------------===//
            Legalizing operation : 'llvm.load'(0x278e9431040) {
              %82 = "llvm.load"(%1) : (!llvm.ptr<struct<(ptr<i8>, i1)>>) -> !llvm.struct<(ptr<i8>, i1)>

            } -> SUCCESS : operation marked legal by the target
            //===-------------------------------------------===//
          } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "number"} : !ts.string
  %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "b number: "} : !ts.string
  %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %27 = llvm.mlir.constant(0 : i64) : i64
  %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %29 = ts.Constant {value = "done."} : !ts.string
  %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %40 = llvm.mlir.constant(1 : i64) : i64
  %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %45 = llvm.mlir.constant(1 : i64) : i64
  %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %49 = llvm.icmp "ult" %43, %48 : i64
  %50 = llvm.select %49, %43, %48 : i1, i64
  %51 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  llvm.store %63, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %64 = ts.Variable(%63) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %65 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %66 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %67 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %68 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %69 = llvm.mlir.constant(1 : i64) : i64
  %70 = llvm.getelementptr %68[%69] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %71 = llvm.ptrtoint %70 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %72 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %73 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %74 = llvm.mlir.constant(1 : i64) : i64
  %75 = llvm.getelementptr %73[%74] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %76 = llvm.ptrtoint %75 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %77 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %78 = llvm.icmp "ult" %72, %77 : i64
  %79 = llvm.select %78, %72, %77 : i1, i64
  %80 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%66, %67, %79, %80) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%65, %64) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %81 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %82 = ts.Load(%65) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %83 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
  %84 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %84, %31 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %85 = ts.Load(%31) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %86 = ts.GetTypeInfoFromUnionOp %85 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %87 = ts.LogicalBinary %86(34) %21 : !ts.string, !ts.string -> !ts.boolean
  %88 = ts.Cast %87 : !ts.boolean to i1
  cond_br %88, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %89 = ts.Load(%31) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %90 = ts.GetValueFromUnionOp %89 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %91 = ts.Cast %90 : !ts.number to !ts.string
  ts.Print(%25, %91) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%29) : !ts.string
  ts.ReturnInternal
}


        } -> SUCCESS
        //===-------------------------------------------===//
      } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "number"} : !ts.string
  %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "b number: "} : !ts.string
  %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %27 = llvm.mlir.constant(0 : i64) : i64
  %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %29 = ts.Constant {value = "done."} : !ts.string
  %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %40 = llvm.mlir.constant(1 : i64) : i64
  %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %45 = llvm.mlir.constant(1 : i64) : i64
  %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %49 = llvm.icmp "ult" %43, %48 : i64
  %50 = llvm.select %49, %43, %48 : i1, i64
  %51 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  llvm.store %63, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %64 = ts.Variable(%63) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %65 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %66 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %67 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %68 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %69 = llvm.mlir.constant(1 : i64) : i64
  %70 = llvm.getelementptr %68[%69] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %71 = llvm.ptrtoint %70 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %72 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %73 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %74 = llvm.mlir.constant(1 : i64) : i64
  %75 = llvm.getelementptr %73[%74] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %76 = llvm.ptrtoint %75 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %77 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %78 = llvm.icmp "ult" %72, %77 : i64
  %79 = llvm.select %78, %72, %77 : i1, i64
  %80 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%66, %67, %79, %80) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%65, %64) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %81 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %82 = ts.Load(%65) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %83 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
  %84 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %84, %31 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %85 = ts.Load(%31) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %86 = ts.GetTypeInfoFromUnionOp %85 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %87 = ts.LogicalBinary %86(34) %21 : !ts.string, !ts.string -> !ts.boolean
  %88 = ts.Cast %87 : !ts.boolean to i1
  cond_br %88, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %89 = ts.Load(%31) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %90 = ts.GetValueFromUnionOp %89 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %91 = ts.Cast %90 : !ts.number to !ts.string
  ts.Print(%25, %91) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%29) : !ts.string
  ts.ReturnInternal
}


    } -> SUCCESS
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "number"} : !ts.string
  %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "b number: "} : !ts.string
  %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %27 = llvm.mlir.constant(0 : i64) : i64
  %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %29 = ts.Constant {value = "done."} : !ts.string
  %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %40 = llvm.mlir.constant(1 : i64) : i64
  %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %45 = llvm.mlir.constant(1 : i64) : i64
  %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %49 = llvm.icmp "ult" %43, %48 : i64
  %50 = llvm.select %49, %43, %48 : i1, i64
  %51 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  llvm.store %63, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %64 = ts.Variable(%63) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %65 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %66 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %67 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %68 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %69 = llvm.mlir.constant(1 : i64) : i64
  %70 = llvm.getelementptr %68[%69] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %71 = llvm.ptrtoint %70 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %72 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %73 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %74 = llvm.mlir.constant(1 : i64) : i64
  %75 = llvm.getelementptr %73[%74] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %76 = llvm.ptrtoint %75 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %77 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %78 = llvm.icmp "ult" %72, %77 : i64
  %79 = llvm.select %78, %72, %77 : i1, i64
  %80 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%66, %67, %79, %80) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%65, %64) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %81 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %82 = ts.Load(%65) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %83 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
  %84 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  ts.Store %84, %31 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %85 = ts.Load(%31) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %86 = ts.GetTypeInfoFromUnionOp %85 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %87 = ts.LogicalBinary %86(34) %21 : !ts.string, !ts.string -> !ts.boolean
  %88 = ts.Cast %87 : !ts.boolean to i1
  cond_br %88, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %89 = ts.Load(%31) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %90 = ts.GetValueFromUnionOp %89 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %91 = ts.Cast %90 : !ts.number to !ts.string
  ts.Print(%25, %91) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%29) : !ts.string
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Store'(0x278e9475550) {
  "ts.Store"(%85, %32) : (!ts.union<!ts.string,!ts.number,!ts.boolean>, !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>) -> ()

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.Store -> ()' {
Trying to match "`anonymous-namespace'::StoreOpLowering"
    ** Insert  : 'llvm.store'(0x278e94763f0)
    ** Replace : 'ts.Store'(0x278e9475550)
"`anonymous-namespace'::StoreOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.store'(0x278e94763f0) {
      "llvm.store"(%82, %9) : (!llvm.struct<(ptr<i8>, i1)>, !llvm.ptr<struct<(ptr<i8>, i1)>>) -> ()

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "number"} : !ts.string
  %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "b number: "} : !ts.string
  %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %27 = llvm.mlir.constant(0 : i64) : i64
  %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %29 = ts.Constant {value = "done."} : !ts.string
  %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %40 = llvm.mlir.constant(1 : i64) : i64
  %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %45 = llvm.mlir.constant(1 : i64) : i64
  %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %49 = llvm.icmp "ult" %43, %48 : i64
  %50 = llvm.select %49, %43, %48 : i1, i64
  %51 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  llvm.store %63, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %64 = ts.Variable(%63) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %65 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %66 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %67 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %68 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %69 = llvm.mlir.constant(1 : i64) : i64
  %70 = llvm.getelementptr %68[%69] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %71 = llvm.ptrtoint %70 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %72 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %73 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %74 = llvm.mlir.constant(1 : i64) : i64
  %75 = llvm.getelementptr %73[%74] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %76 = llvm.ptrtoint %75 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %77 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %78 = llvm.icmp "ult" %72, %77 : i64
  %79 = llvm.select %78, %72, %77 : i1, i64
  %80 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%66, %67, %79, %80) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%65, %64) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %81 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %82 = ts.Load(%65) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %83 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
  %84 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  llvm.store %81, %9 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  ts.Store %84, %31 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %85 = ts.Load(%31) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %86 = ts.GetTypeInfoFromUnionOp %85 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %87 = ts.LogicalBinary %86(34) %21 : !ts.string, !ts.string -> !ts.boolean
  %88 = ts.Cast %87 : !ts.boolean to i1
  cond_br %88, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %89 = ts.Load(%31) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %90 = ts.GetValueFromUnionOp %89 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %91 = ts.Cast %90 : !ts.number to !ts.string
  ts.Print(%25, %91) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%29) : !ts.string
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Load'(0x278e942e940) {
  %86 = "ts.Load"(%32) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>) -> !ts.union<!ts.string,!ts.number,!ts.boolean>

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.Load -> ()' {
Trying to match "`anonymous-namespace'::LoadOpLowering"
    ** Insert  : 'llvm.load'(0x278e9430080)
    ** Replace : 'ts.Load'(0x278e942e940)
"`anonymous-namespace'::LoadOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.load'(0x278e9430080) {
      %86 = "llvm.load"(%9) : (!llvm.ptr<struct<(ptr<i8>, i1)>>) -> !llvm.struct<(ptr<i8>, i1)>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "number"} : !ts.string
  %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "b number: "} : !ts.string
  %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %27 = llvm.mlir.constant(0 : i64) : i64
  %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %29 = ts.Constant {value = "done."} : !ts.string
  %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %40 = llvm.mlir.constant(1 : i64) : i64
  %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %45 = llvm.mlir.constant(1 : i64) : i64
  %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %49 = llvm.icmp "ult" %43, %48 : i64
  %50 = llvm.select %49, %43, %48 : i1, i64
  %51 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  llvm.store %63, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %64 = ts.Variable(%63) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %65 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %66 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %67 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %68 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %69 = llvm.mlir.constant(1 : i64) : i64
  %70 = llvm.getelementptr %68[%69] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %71 = llvm.ptrtoint %70 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %72 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %73 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %74 = llvm.mlir.constant(1 : i64) : i64
  %75 = llvm.getelementptr %73[%74] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %76 = llvm.ptrtoint %75 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %77 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %78 = llvm.icmp "ult" %72, %77 : i64
  %79 = llvm.select %78, %72, %77 : i1, i64
  %80 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%66, %67, %79, %80) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%65, %64) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %81 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %82 = ts.Load(%65) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %83 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
  %84 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  llvm.store %81, %9 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  ts.Store %84, %31 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %85 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %86 = ts.Load(%31) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %87 = ts.GetTypeInfoFromUnionOp %86 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %88 = ts.LogicalBinary %87(34) %21 : !ts.string, !ts.string -> !ts.boolean
  %89 = ts.Cast %88 : !ts.boolean to i1
  cond_br %89, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %90 = ts.Load(%31) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %91 = ts.GetValueFromUnionOp %90 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %92 = ts.Cast %91 : !ts.number to !ts.string
  ts.Print(%25, %92) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%29) : !ts.string
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.GetTypeInfoFromUnionOp'(0x278e9430440) {
  %88 = "ts.GetTypeInfoFromUnionOp"(%87) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.string

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.GetTypeInfoFromUnionOp -> ()' {
Trying to match "`anonymous-namespace'::GetTypeInfoFromUnionOpLowering"
    ** Insert  : 'llvm.extractvalue'(0x278e942e580)
    ** Replace : 'ts.GetTypeInfoFromUnionOp'(0x278e9430440)
"`anonymous-namespace'::GetTypeInfoFromUnionOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.extractvalue'(0x278e942e580) {
      %88 = "llvm.extractvalue"(%86) {position = [0 : i32]} : (!llvm.struct<(ptr<i8>, i1)>) -> !llvm.ptr<i8>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "number"} : !ts.string
  %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "b number: "} : !ts.string
  %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %27 = llvm.mlir.constant(0 : i64) : i64
  %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %29 = ts.Constant {value = "done."} : !ts.string
  %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %40 = llvm.mlir.constant(1 : i64) : i64
  %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %45 = llvm.mlir.constant(1 : i64) : i64
  %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %49 = llvm.icmp "ult" %43, %48 : i64
  %50 = llvm.select %49, %43, %48 : i1, i64
  %51 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  llvm.store %63, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %64 = ts.Variable(%63) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %65 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %66 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %67 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %68 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %69 = llvm.mlir.constant(1 : i64) : i64
  %70 = llvm.getelementptr %68[%69] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %71 = llvm.ptrtoint %70 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %72 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %73 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %74 = llvm.mlir.constant(1 : i64) : i64
  %75 = llvm.getelementptr %73[%74] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %76 = llvm.ptrtoint %75 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %77 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %78 = llvm.icmp "ult" %72, %77 : i64
  %79 = llvm.select %78, %72, %77 : i1, i64
  %80 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%66, %67, %79, %80) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%65, %64) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %81 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %82 = ts.Load(%65) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %83 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
  %84 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  llvm.store %81, %9 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  ts.Store %84, %31 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %85 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %86 = ts.Load(%31) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %87 = llvm.extractvalue %85[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
  %88 = ts.GetTypeInfoFromUnionOp %86 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %89 = ts.LogicalBinary %88(34) %21 : !ts.string, !ts.string -> !ts.boolean
  %90 = ts.Cast %89 : !ts.boolean to i1
  cond_br %90, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %91 = ts.Load(%31) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %92 = ts.GetValueFromUnionOp %91 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %93 = ts.Cast %92 : !ts.number to !ts.string
  ts.Print(%25, %93) : !ts.string, !ts.string
  br ^bb2
^bb2:  // 2 preds: ^bb0, ^bb1
  ts.Print(%29) : !ts.string
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.LogicalBinary'(0x278e954ff80) {
  %90 = "ts.LogicalBinary"(%89, %22) {opCode = 34 : i32} : (!ts.string, !ts.string) -> !ts.boolean

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.LogicalBinary -> ()' {
Trying to match "`anonymous-namespace'::LogicalBinaryOpLowering"
    ** Insert  : 'ts.StringCompare'(0x278e9547620)
    ** Replace : 'ts.LogicalBinary'(0x278e954ff80)
"`anonymous-namespace'::LogicalBinaryOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'ts.StringCompare'(0x278e9547620) {
      %90 = "ts.StringCompare"(%88, %21) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean

      * Fold {
      } -> FAILURE : unable to fold

      * Pattern : 'ts.StringCompare -> ()' {
Trying to match "`anonymous-namespace'::StringCompareOpLowering"
        ** Insert  : 'llvm.func'(0x278e9514ea0)
        ** Insert  : 'llvm.mlir.constant'(0x278e94d3dc0)
        ** Insert  : 'llvm.ptrtoint'(0x278e9430800)
        ** Insert  : 'llvm.ptrtoint'(0x278e942e1c0)
        ** Insert  : 'llvm.icmp'(0x278e9547000)
        ** Insert  : 'llvm.icmp'(0x278e95448a0)
        ** Insert  : 'ts.Cast'(0x278e9430980)
        ** Insert  : 'ts.Cast'(0x278e9430d40)
        ** Insert  : 'llvm.and'(0x278e9544b40)
        ** Insert  : 'llvm.mlir.constant'(0x278e94d4540)
        ** Insert  : 'llvm.icmp'(0x278e9546200)
        ** Insert  : 'llvm.mlir.constant'(0x278e94d4860)
        ** Insert  : 'llvm.call'(0x278e9545080)
        ** Insert  : 'llvm.icmp'(0x278e95456a0)
        ** Insert  : 'llvm.icmp'(0x278e9545e80)
        ** Insert  : 'llvm.br'(0x278e95131c0)
        ** Insert  : 'llvm.br'(0x278e94771c0)
        ** Insert  : 'llvm.br'(0x278e9475a30)
        ** Insert  : 'llvm.cond_br'(0x278e94afc60)
        ** Replace : 'ts.StringCompare'(0x278e9547620)
"`anonymous-namespace'::StringCompareOpLowering" result 1

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.func'(0x278e9514ea0) {
        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.mlir.constant'(0x278e94d3dc0) {
          %90 = "llvm.mlir.constant"() {value = 0 : i64} : () -> i64

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.ptrtoint'(0x278e9430800) {
          %91 = "llvm.ptrtoint"(%88) : (!llvm.ptr<i8>) -> i64

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.ptrtoint'(0x278e942e1c0) {
          %92 = "llvm.ptrtoint"(%21) : (!llvm.ptr<i8>) -> i64

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.icmp'(0x278e9547000) {
          %93 = "llvm.icmp"(%91, %90) {predicate = 1 : i64} : (i64, i64) -> i1

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.icmp'(0x278e95448a0) {
          %94 = "llvm.icmp"(%92, %90) {predicate = 1 : i64} : (i64, i64) -> i1

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'ts.Cast'(0x278e9430980) {
          %95 = "ts.Cast"(%93) : (i1) -> i32

          * Fold {
          } -> FAILURE : unable to fold

          * Pattern : 'ts.Cast -> ()' {
Trying to match "`anonymous-namespace'::CastOpLowering"
            ** Insert  : 'std.zexti'(0x278e942f840)
            ** Replace : 'ts.Cast'(0x278e9430980)
"`anonymous-namespace'::CastOpLowering" result 1

            //===-------------------------------------------===//
            Legalizing operation : 'std.zexti'(0x278e942f840) {
              %95 = "std.zexti"(%93) : (i1) -> i32

              * Fold {
              } -> FAILURE : unable to fold

              * Pattern : 'std.zexti -> ()' {
Trying to match "mlir::VectorConvertToLLVMPattern<class mlir::ZeroExtendIOp,class mlir::LLVM::ZExtOp>"
                ** Insert  : 'llvm.zext'(0x278e942e7c0)
                ** Replace : 'std.zexti'(0x278e942f840)
"mlir::VectorConvertToLLVMPattern<class mlir::ZeroExtendIOp,class mlir::LLVM::ZExtOp>" result 1

                //===-------------------------------------------===//
                Legalizing operation : 'llvm.zext'(0x278e942e7c0) {
                  %95 = "llvm.zext"(%93) : (i1) -> i32

                } -> SUCCESS : operation marked legal by the target
                //===-------------------------------------------===//
              } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "number"} : !ts.string
  %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "b number: "} : !ts.string
  %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %27 = llvm.mlir.constant(0 : i64) : i64
  %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %29 = ts.Constant {value = "done."} : !ts.string
  %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %40 = llvm.mlir.constant(1 : i64) : i64
  %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %45 = llvm.mlir.constant(1 : i64) : i64
  %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %49 = llvm.icmp "ult" %43, %48 : i64
  %50 = llvm.select %49, %43, %48 : i1, i64
  %51 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  llvm.store %63, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %64 = ts.Variable(%63) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %65 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %66 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %67 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %68 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %69 = llvm.mlir.constant(1 : i64) : i64
  %70 = llvm.getelementptr %68[%69] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %71 = llvm.ptrtoint %70 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %72 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %73 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %74 = llvm.mlir.constant(1 : i64) : i64
  %75 = llvm.getelementptr %73[%74] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %76 = llvm.ptrtoint %75 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %77 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %78 = llvm.icmp "ult" %72, %77 : i64
  %79 = llvm.select %78, %72, %77 : i1, i64
  %80 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%66, %67, %79, %80) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%65, %64) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %81 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %82 = ts.Load(%65) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %83 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
  %84 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  llvm.store %81, %9 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  ts.Store %84, %31 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %85 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %86 = ts.Load(%31) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %87 = llvm.extractvalue %85[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
  %88 = ts.GetTypeInfoFromUnionOp %86 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %89 = llvm.mlir.constant(0 : i64) : i64
  %90 = llvm.ptrtoint %87 : !llvm.ptr<i8> to i64
  %91 = llvm.ptrtoint %20 : !llvm.ptr<i8> to i64
  %92 = llvm.icmp "ne" %90, %89 : i64
  %93 = llvm.icmp "ne" %91, %89 : i64
  %94 = llvm.zext %92 : i1 to i32
  %95 = zexti %92 : i1 to i32
  %96 = ts.Cast %92 : i1 to i32
  %97 = ts.Cast %93 : i1 to i32
  %98 = llvm.and %96, %97  : i32
  %99 = llvm.mlir.constant(0 : i32) : i32
  %100 = llvm.icmp "ne" %98, %99 : i32
  llvm.cond_br %100, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %101 = llvm.mlir.constant(0 : i32) : i32
  %102 = llvm.call @strcmp(%87, %20) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %103 = llvm.icmp "eq" %102, %101 : i32
  llvm.br ^bb3(%103 : i1)
^bb2:  // pred: ^bb0
  %104 = llvm.icmp "eq" %90, %91 : i64
  llvm.br ^bb3(%104 : i1)
^bb3(%105: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %106 = "ts.StringCompare"(%87, %20) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %107 = ts.LogicalBinary %88(34) %21 : !ts.string, !ts.string -> !ts.boolean
  %108 = ts.Cast %107 : !ts.boolean to i1
  cond_br %108, ^bb5, ^bb6
^bb5:  // pred: ^bb4
  %109 = ts.Load(%31) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %110 = ts.GetValueFromUnionOp %109 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %111 = ts.Cast %110 : !ts.number to !ts.string
  ts.Print(%25, %111) : !ts.string, !ts.string
  br ^bb6
^bb6:  // 2 preds: ^bb4, ^bb5
  ts.Print(%29) : !ts.string
  ts.ReturnInternal
}


            } -> SUCCESS
            //===-------------------------------------------===//
          } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "number"} : !ts.string
  %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "b number: "} : !ts.string
  %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %27 = llvm.mlir.constant(0 : i64) : i64
  %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %29 = ts.Constant {value = "done."} : !ts.string
  %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %40 = llvm.mlir.constant(1 : i64) : i64
  %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %45 = llvm.mlir.constant(1 : i64) : i64
  %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %49 = llvm.icmp "ult" %43, %48 : i64
  %50 = llvm.select %49, %43, %48 : i1, i64
  %51 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  llvm.store %63, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %64 = ts.Variable(%63) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %65 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %66 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %67 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %68 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %69 = llvm.mlir.constant(1 : i64) : i64
  %70 = llvm.getelementptr %68[%69] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %71 = llvm.ptrtoint %70 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %72 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %73 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %74 = llvm.mlir.constant(1 : i64) : i64
  %75 = llvm.getelementptr %73[%74] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %76 = llvm.ptrtoint %75 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %77 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %78 = llvm.icmp "ult" %72, %77 : i64
  %79 = llvm.select %78, %72, %77 : i1, i64
  %80 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%66, %67, %79, %80) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%65, %64) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %81 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %82 = ts.Load(%65) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %83 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
  %84 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  llvm.store %81, %9 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  ts.Store %84, %31 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %85 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %86 = ts.Load(%31) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %87 = llvm.extractvalue %85[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
  %88 = ts.GetTypeInfoFromUnionOp %86 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %89 = llvm.mlir.constant(0 : i64) : i64
  %90 = llvm.ptrtoint %87 : !llvm.ptr<i8> to i64
  %91 = llvm.ptrtoint %20 : !llvm.ptr<i8> to i64
  %92 = llvm.icmp "ne" %90, %89 : i64
  %93 = llvm.icmp "ne" %91, %89 : i64
  %94 = llvm.zext %92 : i1 to i32
  %95 = zexti %92 : i1 to i32
  %96 = ts.Cast %92 : i1 to i32
  %97 = ts.Cast %93 : i1 to i32
  %98 = llvm.and %96, %97  : i32
  %99 = llvm.mlir.constant(0 : i32) : i32
  %100 = llvm.icmp "ne" %98, %99 : i32
  llvm.cond_br %100, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %101 = llvm.mlir.constant(0 : i32) : i32
  %102 = llvm.call @strcmp(%87, %20) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %103 = llvm.icmp "eq" %102, %101 : i32
  llvm.br ^bb3(%103 : i1)
^bb2:  // pred: ^bb0
  %104 = llvm.icmp "eq" %90, %91 : i64
  llvm.br ^bb3(%104 : i1)
^bb3(%105: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %106 = "ts.StringCompare"(%87, %20) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %107 = ts.LogicalBinary %88(34) %21 : !ts.string, !ts.string -> !ts.boolean
  %108 = ts.Cast %107 : !ts.boolean to i1
  cond_br %108, ^bb5, ^bb6
^bb5:  // pred: ^bb4
  %109 = ts.Load(%31) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %110 = ts.GetValueFromUnionOp %109 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %111 = ts.Cast %110 : !ts.number to !ts.string
  ts.Print(%25, %111) : !ts.string, !ts.string
  br ^bb6
^bb6:  // 2 preds: ^bb4, ^bb5
  ts.Print(%29) : !ts.string
  ts.ReturnInternal
}


        } -> SUCCESS
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'ts.Cast'(0x278e9430d40) {
          %98 = "ts.Cast"(%94) : (i1) -> i32

          * Fold {
          } -> FAILURE : unable to fold

          * Pattern : 'ts.Cast -> ()' {
Trying to match "`anonymous-namespace'::CastOpLowering"
            ** Insert  : 'std.zexti'(0x278e942f9c0)
            ** Replace : 'ts.Cast'(0x278e9430d40)
"`anonymous-namespace'::CastOpLowering" result 1

            //===-------------------------------------------===//
            Legalizing operation : 'std.zexti'(0x278e942f9c0) {
              %98 = "std.zexti"(%94) : (i1) -> i32

              * Fold {
              } -> FAILURE : unable to fold

              * Pattern : 'std.zexti -> ()' {
Trying to match "mlir::VectorConvertToLLVMPattern<class mlir::ZeroExtendIOp,class mlir::LLVM::ZExtOp>"
                ** Insert  : 'llvm.zext'(0x278e942f000)
                ** Replace : 'std.zexti'(0x278e942f9c0)
"mlir::VectorConvertToLLVMPattern<class mlir::ZeroExtendIOp,class mlir::LLVM::ZExtOp>" result 1

                //===-------------------------------------------===//
                Legalizing operation : 'llvm.zext'(0x278e942f000) {
                  %98 = "llvm.zext"(%94) : (i1) -> i32

                } -> SUCCESS : operation marked legal by the target
                //===-------------------------------------------===//
              } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "number"} : !ts.string
  %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "b number: "} : !ts.string
  %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %27 = llvm.mlir.constant(0 : i64) : i64
  %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %29 = ts.Constant {value = "done."} : !ts.string
  %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %40 = llvm.mlir.constant(1 : i64) : i64
  %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %45 = llvm.mlir.constant(1 : i64) : i64
  %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %49 = llvm.icmp "ult" %43, %48 : i64
  %50 = llvm.select %49, %43, %48 : i1, i64
  %51 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  llvm.store %63, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %64 = ts.Variable(%63) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %65 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %66 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %67 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %68 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %69 = llvm.mlir.constant(1 : i64) : i64
  %70 = llvm.getelementptr %68[%69] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %71 = llvm.ptrtoint %70 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %72 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %73 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %74 = llvm.mlir.constant(1 : i64) : i64
  %75 = llvm.getelementptr %73[%74] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %76 = llvm.ptrtoint %75 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %77 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %78 = llvm.icmp "ult" %72, %77 : i64
  %79 = llvm.select %78, %72, %77 : i1, i64
  %80 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%66, %67, %79, %80) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%65, %64) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %81 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %82 = ts.Load(%65) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %83 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
  %84 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  llvm.store %81, %9 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  ts.Store %84, %31 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %85 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %86 = ts.Load(%31) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %87 = llvm.extractvalue %85[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
  %88 = ts.GetTypeInfoFromUnionOp %86 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %89 = llvm.mlir.constant(0 : i64) : i64
  %90 = llvm.ptrtoint %87 : !llvm.ptr<i8> to i64
  %91 = llvm.ptrtoint %20 : !llvm.ptr<i8> to i64
  %92 = llvm.icmp "ne" %90, %89 : i64
  %93 = llvm.icmp "ne" %91, %89 : i64
  %94 = llvm.zext %92 : i1 to i32
  %95 = zexti %92 : i1 to i32
  %96 = ts.Cast %92 : i1 to i32
  %97 = llvm.zext %93 : i1 to i32
  %98 = zexti %93 : i1 to i32
  %99 = ts.Cast %93 : i1 to i32
  %100 = llvm.and %96, %99  : i32
  %101 = llvm.mlir.constant(0 : i32) : i32
  %102 = llvm.icmp "ne" %100, %101 : i32
  llvm.cond_br %102, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %103 = llvm.mlir.constant(0 : i32) : i32
  %104 = llvm.call @strcmp(%87, %20) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %105 = llvm.icmp "eq" %104, %103 : i32
  llvm.br ^bb3(%105 : i1)
^bb2:  // pred: ^bb0
  %106 = llvm.icmp "eq" %90, %91 : i64
  llvm.br ^bb3(%106 : i1)
^bb3(%107: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %108 = "ts.StringCompare"(%87, %20) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %109 = ts.LogicalBinary %88(34) %21 : !ts.string, !ts.string -> !ts.boolean
  %110 = ts.Cast %109 : !ts.boolean to i1
  cond_br %110, ^bb5, ^bb6
^bb5:  // pred: ^bb4
  %111 = ts.Load(%31) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %112 = ts.GetValueFromUnionOp %111 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %113 = ts.Cast %112 : !ts.number to !ts.string
  ts.Print(%25, %113) : !ts.string, !ts.string
  br ^bb6
^bb6:  // 2 preds: ^bb4, ^bb5
  ts.Print(%29) : !ts.string
  ts.ReturnInternal
}


            } -> SUCCESS
            //===-------------------------------------------===//
          } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "number"} : !ts.string
  %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "b number: "} : !ts.string
  %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %27 = llvm.mlir.constant(0 : i64) : i64
  %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %29 = ts.Constant {value = "done."} : !ts.string
  %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %40 = llvm.mlir.constant(1 : i64) : i64
  %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %45 = llvm.mlir.constant(1 : i64) : i64
  %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %49 = llvm.icmp "ult" %43, %48 : i64
  %50 = llvm.select %49, %43, %48 : i1, i64
  %51 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  llvm.store %63, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %64 = ts.Variable(%63) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %65 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %66 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %67 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %68 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %69 = llvm.mlir.constant(1 : i64) : i64
  %70 = llvm.getelementptr %68[%69] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %71 = llvm.ptrtoint %70 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %72 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %73 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %74 = llvm.mlir.constant(1 : i64) : i64
  %75 = llvm.getelementptr %73[%74] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %76 = llvm.ptrtoint %75 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %77 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %78 = llvm.icmp "ult" %72, %77 : i64
  %79 = llvm.select %78, %72, %77 : i1, i64
  %80 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%66, %67, %79, %80) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%65, %64) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %81 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %82 = ts.Load(%65) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %83 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
  %84 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  llvm.store %81, %9 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  ts.Store %84, %31 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %85 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %86 = ts.Load(%31) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %87 = llvm.extractvalue %85[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
  %88 = ts.GetTypeInfoFromUnionOp %86 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %89 = llvm.mlir.constant(0 : i64) : i64
  %90 = llvm.ptrtoint %87 : !llvm.ptr<i8> to i64
  %91 = llvm.ptrtoint %20 : !llvm.ptr<i8> to i64
  %92 = llvm.icmp "ne" %90, %89 : i64
  %93 = llvm.icmp "ne" %91, %89 : i64
  %94 = llvm.zext %92 : i1 to i32
  %95 = zexti %92 : i1 to i32
  %96 = ts.Cast %92 : i1 to i32
  %97 = llvm.zext %93 : i1 to i32
  %98 = zexti %93 : i1 to i32
  %99 = ts.Cast %93 : i1 to i32
  %100 = llvm.and %96, %99  : i32
  %101 = llvm.mlir.constant(0 : i32) : i32
  %102 = llvm.icmp "ne" %100, %101 : i32
  llvm.cond_br %102, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %103 = llvm.mlir.constant(0 : i32) : i32
  %104 = llvm.call @strcmp(%87, %20) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %105 = llvm.icmp "eq" %104, %103 : i32
  llvm.br ^bb3(%105 : i1)
^bb2:  // pred: ^bb0
  %106 = llvm.icmp "eq" %90, %91 : i64
  llvm.br ^bb3(%106 : i1)
^bb3(%107: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %108 = "ts.StringCompare"(%87, %20) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %109 = ts.LogicalBinary %88(34) %21 : !ts.string, !ts.string -> !ts.boolean
  %110 = ts.Cast %109 : !ts.boolean to i1
  cond_br %110, ^bb5, ^bb6
^bb5:  // pred: ^bb4
  %111 = ts.Load(%31) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %112 = ts.GetValueFromUnionOp %111 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %113 = ts.Cast %112 : !ts.number to !ts.string
  ts.Print(%25, %113) : !ts.string, !ts.string
  br ^bb6
^bb6:  // 2 preds: ^bb4, ^bb5
  ts.Print(%29) : !ts.string
  ts.ReturnInternal
}


        } -> SUCCESS
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.and'(0x278e9544b40) {
          %101 = "llvm.and"(%97, %100) : (i32, i32) -> i32

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.mlir.constant'(0x278e94d4540) {
          %102 = "llvm.mlir.constant"() {value = 0 : i32} : () -> i32

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.icmp'(0x278e9546200) {
          %103 = "llvm.icmp"(%101, %102) {predicate = 1 : i64} : (i32, i32) -> i1

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.mlir.constant'(0x278e94d4860) {
          %104 = "llvm.mlir.constant"() {value = 0 : i32} : () -> i32

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.call'(0x278e9545080) {
          %105 = "llvm.call"(%88, %21) {callee = @strcmp} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.icmp'(0x278e95456a0) {
          %106 = "llvm.icmp"(%105, %104) {predicate = 0 : i64} : (i32, i32) -> i1

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.icmp'(0x278e9545e80) {
          %107 = "llvm.icmp"(%91, %92) {predicate = 0 : i64} : (i64, i64) -> i1

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.br'(0x278e95131c0) {
          "llvm.br"()[^bb4] : () -> ()

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.br'(0x278e94771c0) {
          "llvm.br"(%106)[^bb3] : (i1) -> ()

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.br'(0x278e9475a30) {
          "llvm.br"(%107)[^bb3] : (i1) -> ()

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.cond_br'(0x278e94afc60) {
          "llvm.cond_br"(%103)[^bb1, ^bb2] {operand_segment_sizes = dense<[1, 0, 0]> : vector<3xi32>} : (i1) -> ()

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//
      } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "number"} : !ts.string
  %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "b number: "} : !ts.string
  %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %27 = llvm.mlir.constant(0 : i64) : i64
  %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %29 = ts.Constant {value = "done."} : !ts.string
  %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %40 = llvm.mlir.constant(1 : i64) : i64
  %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %45 = llvm.mlir.constant(1 : i64) : i64
  %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %49 = llvm.icmp "ult" %43, %48 : i64
  %50 = llvm.select %49, %43, %48 : i1, i64
  %51 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  llvm.store %63, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %64 = ts.Variable(%63) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %65 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %66 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %67 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %68 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %69 = llvm.mlir.constant(1 : i64) : i64
  %70 = llvm.getelementptr %68[%69] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %71 = llvm.ptrtoint %70 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %72 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %73 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %74 = llvm.mlir.constant(1 : i64) : i64
  %75 = llvm.getelementptr %73[%74] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %76 = llvm.ptrtoint %75 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %77 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %78 = llvm.icmp "ult" %72, %77 : i64
  %79 = llvm.select %78, %72, %77 : i1, i64
  %80 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%66, %67, %79, %80) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%65, %64) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %81 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %82 = ts.Load(%65) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %83 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
  %84 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  llvm.store %81, %9 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  ts.Store %84, %31 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %85 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %86 = ts.Load(%31) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %87 = llvm.extractvalue %85[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
  %88 = ts.GetTypeInfoFromUnionOp %86 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %89 = llvm.mlir.constant(0 : i64) : i64
  %90 = llvm.ptrtoint %87 : !llvm.ptr<i8> to i64
  %91 = llvm.ptrtoint %20 : !llvm.ptr<i8> to i64
  %92 = llvm.icmp "ne" %90, %89 : i64
  %93 = llvm.icmp "ne" %91, %89 : i64
  %94 = llvm.zext %92 : i1 to i32
  %95 = zexti %92 : i1 to i32
  %96 = ts.Cast %92 : i1 to i32
  %97 = llvm.zext %93 : i1 to i32
  %98 = zexti %93 : i1 to i32
  %99 = ts.Cast %93 : i1 to i32
  %100 = llvm.and %96, %99  : i32
  %101 = llvm.mlir.constant(0 : i32) : i32
  %102 = llvm.icmp "ne" %100, %101 : i32
  llvm.cond_br %102, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %103 = llvm.mlir.constant(0 : i32) : i32
  %104 = llvm.call @strcmp(%87, %20) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %105 = llvm.icmp "eq" %104, %103 : i32
  llvm.br ^bb3(%105 : i1)
^bb2:  // pred: ^bb0
  %106 = llvm.icmp "eq" %90, %91 : i64
  llvm.br ^bb3(%106 : i1)
^bb3(%107: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %108 = "ts.StringCompare"(%87, %20) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %109 = ts.LogicalBinary %88(34) %21 : !ts.string, !ts.string -> !ts.boolean
  %110 = ts.Cast %109 : !ts.boolean to i1
  cond_br %110, ^bb5, ^bb6
^bb5:  // pred: ^bb4
  %111 = ts.Load(%31) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %112 = ts.GetValueFromUnionOp %111 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %113 = ts.Cast %112 : !ts.number to !ts.string
  ts.Print(%25, %113) : !ts.string, !ts.string
  br ^bb6
^bb6:  // 2 preds: ^bb4, ^bb5
  ts.Print(%29) : !ts.string
  ts.ReturnInternal
}


    } -> SUCCESS
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "number"} : !ts.string
  %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "b number: "} : !ts.string
  %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %27 = llvm.mlir.constant(0 : i64) : i64
  %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %29 = ts.Constant {value = "done."} : !ts.string
  %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %40 = llvm.mlir.constant(1 : i64) : i64
  %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %45 = llvm.mlir.constant(1 : i64) : i64
  %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %49 = llvm.icmp "ult" %43, %48 : i64
  %50 = llvm.select %49, %43, %48 : i1, i64
  %51 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  llvm.store %63, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %64 = ts.Variable(%63) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %65 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %66 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %67 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %68 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %69 = llvm.mlir.constant(1 : i64) : i64
  %70 = llvm.getelementptr %68[%69] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %71 = llvm.ptrtoint %70 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %72 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %73 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %74 = llvm.mlir.constant(1 : i64) : i64
  %75 = llvm.getelementptr %73[%74] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %76 = llvm.ptrtoint %75 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %77 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %78 = llvm.icmp "ult" %72, %77 : i64
  %79 = llvm.select %78, %72, %77 : i1, i64
  %80 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%66, %67, %79, %80) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%65, %64) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %81 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %82 = ts.Load(%65) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %83 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
  %84 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  llvm.store %81, %9 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  ts.Store %84, %31 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %85 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %86 = ts.Load(%31) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %87 = llvm.extractvalue %85[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
  %88 = ts.GetTypeInfoFromUnionOp %86 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %89 = llvm.mlir.constant(0 : i64) : i64
  %90 = llvm.ptrtoint %87 : !llvm.ptr<i8> to i64
  %91 = llvm.ptrtoint %20 : !llvm.ptr<i8> to i64
  %92 = llvm.icmp "ne" %90, %89 : i64
  %93 = llvm.icmp "ne" %91, %89 : i64
  %94 = llvm.zext %92 : i1 to i32
  %95 = zexti %92 : i1 to i32
  %96 = ts.Cast %92 : i1 to i32
  %97 = llvm.zext %93 : i1 to i32
  %98 = zexti %93 : i1 to i32
  %99 = ts.Cast %93 : i1 to i32
  %100 = llvm.and %96, %99  : i32
  %101 = llvm.mlir.constant(0 : i32) : i32
  %102 = llvm.icmp "ne" %100, %101 : i32
  llvm.cond_br %102, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %103 = llvm.mlir.constant(0 : i32) : i32
  %104 = llvm.call @strcmp(%87, %20) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %105 = llvm.icmp "eq" %104, %103 : i32
  llvm.br ^bb3(%105 : i1)
^bb2:  // pred: ^bb0
  %106 = llvm.icmp "eq" %90, %91 : i64
  llvm.br ^bb3(%106 : i1)
^bb3(%107: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %108 = "ts.StringCompare"(%87, %20) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %109 = ts.LogicalBinary %88(34) %21 : !ts.string, !ts.string -> !ts.boolean
  %110 = ts.Cast %109 : !ts.boolean to i1
  cond_br %110, ^bb5, ^bb6
^bb5:  // pred: ^bb4
  %111 = ts.Load(%31) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %112 = ts.GetValueFromUnionOp %111 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %113 = ts.Cast %112 : !ts.number to !ts.string
  ts.Print(%25, %113) : !ts.string, !ts.string
  br ^bb6
^bb6:  // 2 preds: ^bb4, ^bb5
  ts.Print(%29) : !ts.string
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Cast'(0x278e942eac0) {
  %111 = "ts.Cast"(%110) : (!ts.boolean) -> i1

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.Cast -> ()' {
Trying to match "`anonymous-namespace'::CastOpLowering"
    ** Replace : 'ts.Cast'(0x278e942eac0)
"`anonymous-namespace'::CastOpLowering" result 1
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "number"} : !ts.string
  %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "b number: "} : !ts.string
  %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %27 = llvm.mlir.constant(0 : i64) : i64
  %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %29 = ts.Constant {value = "done."} : !ts.string
  %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %40 = llvm.mlir.constant(1 : i64) : i64
  %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %45 = llvm.mlir.constant(1 : i64) : i64
  %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %49 = llvm.icmp "ult" %43, %48 : i64
  %50 = llvm.select %49, %43, %48 : i1, i64
  %51 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  llvm.store %63, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %64 = ts.Variable(%63) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %65 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %66 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %67 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %68 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %69 = llvm.mlir.constant(1 : i64) : i64
  %70 = llvm.getelementptr %68[%69] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %71 = llvm.ptrtoint %70 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %72 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %73 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %74 = llvm.mlir.constant(1 : i64) : i64
  %75 = llvm.getelementptr %73[%74] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %76 = llvm.ptrtoint %75 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %77 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %78 = llvm.icmp "ult" %72, %77 : i64
  %79 = llvm.select %78, %72, %77 : i1, i64
  %80 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%66, %67, %79, %80) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%65, %64) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %81 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %82 = ts.Load(%65) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %83 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
  %84 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  llvm.store %81, %9 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  ts.Store %84, %31 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %85 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %86 = ts.Load(%31) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %87 = llvm.extractvalue %85[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
  %88 = ts.GetTypeInfoFromUnionOp %86 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %89 = llvm.mlir.constant(0 : i64) : i64
  %90 = llvm.ptrtoint %87 : !llvm.ptr<i8> to i64
  %91 = llvm.ptrtoint %20 : !llvm.ptr<i8> to i64
  %92 = llvm.icmp "ne" %90, %89 : i64
  %93 = llvm.icmp "ne" %91, %89 : i64
  %94 = llvm.zext %92 : i1 to i32
  %95 = zexti %92 : i1 to i32
  %96 = ts.Cast %92 : i1 to i32
  %97 = llvm.zext %93 : i1 to i32
  %98 = zexti %93 : i1 to i32
  %99 = ts.Cast %93 : i1 to i32
  %100 = llvm.and %96, %99  : i32
  %101 = llvm.mlir.constant(0 : i32) : i32
  %102 = llvm.icmp "ne" %100, %101 : i32
  llvm.cond_br %102, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %103 = llvm.mlir.constant(0 : i32) : i32
  %104 = llvm.call @strcmp(%87, %20) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %105 = llvm.icmp "eq" %104, %103 : i32
  llvm.br ^bb3(%105 : i1)
^bb2:  // pred: ^bb0
  %106 = llvm.icmp "eq" %90, %91 : i64
  llvm.br ^bb3(%106 : i1)
^bb3(%107: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %108 = "ts.StringCompare"(%87, %20) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %109 = ts.LogicalBinary %88(34) %21 : !ts.string, !ts.string -> !ts.boolean
  %110 = ts.Cast %109 : !ts.boolean to i1
  cond_br %110, ^bb5, ^bb6
^bb5:  // pred: ^bb4
  %111 = ts.Load(%31) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %112 = ts.GetValueFromUnionOp %111 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %113 = ts.Cast %112 : !ts.number to !ts.string
  ts.Print(%25, %113) : !ts.string, !ts.string
  br ^bb6
^bb6:  // 2 preds: ^bb4, ^bb5
  ts.Print(%29) : !ts.string
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'std.cond_br'(0x278e94b0a70) {
  "std.cond_br"(%111)[^bb5, ^bb6] {operand_segment_sizes = dense<[1, 0, 0]> : vector<3xi32>} : (i1) -> ()

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'std.cond_br -> ()' {
Trying to match "`anonymous-namespace'::CondBranchOpLowering"
    ** Insert  : 'llvm.cond_br'(0x278e94b02f0)
    ** Replace : 'std.cond_br'(0x278e94b0a70)
"`anonymous-namespace'::CondBranchOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.cond_br'(0x278e94b02f0) {
      "llvm.cond_br"(%108)[^bb5, ^bb6] {operand_segment_sizes = dense<[1, 0, 0]> : vector<3xi32>} : (i1) -> ()

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "number"} : !ts.string
  %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "b number: "} : !ts.string
  %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %27 = llvm.mlir.constant(0 : i64) : i64
  %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %29 = ts.Constant {value = "done."} : !ts.string
  %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %40 = llvm.mlir.constant(1 : i64) : i64
  %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %45 = llvm.mlir.constant(1 : i64) : i64
  %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %49 = llvm.icmp "ult" %43, %48 : i64
  %50 = llvm.select %49, %43, %48 : i1, i64
  %51 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  llvm.store %63, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %64 = ts.Variable(%63) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %65 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %66 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %67 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %68 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %69 = llvm.mlir.constant(1 : i64) : i64
  %70 = llvm.getelementptr %68[%69] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %71 = llvm.ptrtoint %70 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %72 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %73 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %74 = llvm.mlir.constant(1 : i64) : i64
  %75 = llvm.getelementptr %73[%74] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %76 = llvm.ptrtoint %75 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %77 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %78 = llvm.icmp "ult" %72, %77 : i64
  %79 = llvm.select %78, %72, %77 : i1, i64
  %80 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%66, %67, %79, %80) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%65, %64) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %81 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %82 = ts.Load(%65) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %83 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
  %84 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  llvm.store %81, %9 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  ts.Store %84, %31 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %85 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %86 = ts.Load(%31) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %87 = llvm.extractvalue %85[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
  %88 = ts.GetTypeInfoFromUnionOp %86 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %89 = llvm.mlir.constant(0 : i64) : i64
  %90 = llvm.ptrtoint %87 : !llvm.ptr<i8> to i64
  %91 = llvm.ptrtoint %20 : !llvm.ptr<i8> to i64
  %92 = llvm.icmp "ne" %90, %89 : i64
  %93 = llvm.icmp "ne" %91, %89 : i64
  %94 = llvm.zext %92 : i1 to i32
  %95 = zexti %92 : i1 to i32
  %96 = ts.Cast %92 : i1 to i32
  %97 = llvm.zext %93 : i1 to i32
  %98 = zexti %93 : i1 to i32
  %99 = ts.Cast %93 : i1 to i32
  %100 = llvm.and %96, %99  : i32
  %101 = llvm.mlir.constant(0 : i32) : i32
  %102 = llvm.icmp "ne" %100, %101 : i32
  llvm.cond_br %102, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %103 = llvm.mlir.constant(0 : i32) : i32
  %104 = llvm.call @strcmp(%87, %20) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %105 = llvm.icmp "eq" %104, %103 : i32
  llvm.br ^bb3(%105 : i1)
^bb2:  // pred: ^bb0
  %106 = llvm.icmp "eq" %90, %91 : i64
  llvm.br ^bb3(%106 : i1)
^bb3(%107: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %108 = "ts.StringCompare"(%87, %20) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %109 = ts.LogicalBinary %88(34) %21 : !ts.string, !ts.string -> !ts.boolean
  %110 = ts.Cast %109 : !ts.boolean to i1
  llvm.cond_br %107, ^bb5, ^bb6
  cond_br %110, ^bb5, ^bb6
^bb5:  // 2 preds: ^bb4, ^bb4
  %111 = ts.Load(%31) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %112 = ts.GetValueFromUnionOp %111 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %113 = ts.Cast %112 : !ts.number to !ts.string
  ts.Print(%25, %113) : !ts.string, !ts.string
  br ^bb6
^bb6:  // 3 preds: ^bb4, ^bb4, ^bb5
  ts.Print(%29) : !ts.string
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Print'(0x278e950abb0) {
  "ts.Print"(%30) : (!ts.string) -> ()

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.Print -> ()' {
Trying to match "`anonymous-namespace'::PrintOpLowering"
    ** Insert  : 'llvm.func'(0x278e9514d40)
    ** Insert  : 'llvm.call'(0x278e942e880)
    ** Erase   : 'ts.Print'(0x278e950abb0)
"`anonymous-namespace'::PrintOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x278e9514d40) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.call'(0x278e942e880) {
      %115 = "llvm.call"(%29) {callee = @puts} : (!llvm.ptr<i8>) -> i32

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "number"} : !ts.string
  %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "b number: "} : !ts.string
  %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %27 = llvm.mlir.constant(0 : i64) : i64
  %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %29 = ts.Constant {value = "done."} : !ts.string
  %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %40 = llvm.mlir.constant(1 : i64) : i64
  %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %45 = llvm.mlir.constant(1 : i64) : i64
  %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %49 = llvm.icmp "ult" %43, %48 : i64
  %50 = llvm.select %49, %43, %48 : i1, i64
  %51 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  llvm.store %63, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %64 = ts.Variable(%63) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %65 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %66 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %67 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %68 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %69 = llvm.mlir.constant(1 : i64) : i64
  %70 = llvm.getelementptr %68[%69] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %71 = llvm.ptrtoint %70 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %72 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %73 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %74 = llvm.mlir.constant(1 : i64) : i64
  %75 = llvm.getelementptr %73[%74] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %76 = llvm.ptrtoint %75 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %77 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %78 = llvm.icmp "ult" %72, %77 : i64
  %79 = llvm.select %78, %72, %77 : i1, i64
  %80 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%66, %67, %79, %80) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%65, %64) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %81 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %82 = ts.Load(%65) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %83 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
  %84 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  llvm.store %81, %9 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  ts.Store %84, %31 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %85 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %86 = ts.Load(%31) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %87 = llvm.extractvalue %85[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
  %88 = ts.GetTypeInfoFromUnionOp %86 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %89 = llvm.mlir.constant(0 : i64) : i64
  %90 = llvm.ptrtoint %87 : !llvm.ptr<i8> to i64
  %91 = llvm.ptrtoint %20 : !llvm.ptr<i8> to i64
  %92 = llvm.icmp "ne" %90, %89 : i64
  %93 = llvm.icmp "ne" %91, %89 : i64
  %94 = llvm.zext %92 : i1 to i32
  %95 = zexti %92 : i1 to i32
  %96 = ts.Cast %92 : i1 to i32
  %97 = llvm.zext %93 : i1 to i32
  %98 = zexti %93 : i1 to i32
  %99 = ts.Cast %93 : i1 to i32
  %100 = llvm.and %96, %99  : i32
  %101 = llvm.mlir.constant(0 : i32) : i32
  %102 = llvm.icmp "ne" %100, %101 : i32
  llvm.cond_br %102, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %103 = llvm.mlir.constant(0 : i32) : i32
  %104 = llvm.call @strcmp(%87, %20) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %105 = llvm.icmp "eq" %104, %103 : i32
  llvm.br ^bb3(%105 : i1)
^bb2:  // pred: ^bb0
  %106 = llvm.icmp "eq" %90, %91 : i64
  llvm.br ^bb3(%106 : i1)
^bb3(%107: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %108 = "ts.StringCompare"(%87, %20) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %109 = ts.LogicalBinary %88(34) %21 : !ts.string, !ts.string -> !ts.boolean
  %110 = ts.Cast %109 : !ts.boolean to i1
  llvm.cond_br %107, ^bb5, ^bb6
  cond_br %110, ^bb5, ^bb6
^bb5:  // 2 preds: ^bb4, ^bb4
  %111 = ts.Load(%31) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %112 = ts.GetValueFromUnionOp %111 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %113 = ts.Cast %112 : !ts.number to !ts.string
  ts.Print(%25, %113) : !ts.string, !ts.string
  br ^bb6
^bb6:  // 3 preds: ^bb4, ^bb4, ^bb5
  %114 = llvm.call @puts(%28) : (!llvm.ptr<i8>) -> i32
  ts.Print(%29) : !ts.string
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.ReturnInternal'(0x278e95f0ce0) {
  "ts.ReturnInternal"() : () -> ()

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.ReturnInternal -> ()' {
Trying to match "`anonymous-namespace'::ReturnInternalOpLowering"
    ** Insert  : 'llvm.return'(0x278e95f0980)
    ** Replace : 'ts.ReturnInternal'(0x278e95f0ce0)
"`anonymous-namespace'::ReturnInternalOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.return'(0x278e95f0980) {
      "llvm.return"() : () -> ()

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "number"} : !ts.string
  %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "b number: "} : !ts.string
  %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %27 = llvm.mlir.constant(0 : i64) : i64
  %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %29 = ts.Constant {value = "done."} : !ts.string
  %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %40 = llvm.mlir.constant(1 : i64) : i64
  %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %45 = llvm.mlir.constant(1 : i64) : i64
  %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %49 = llvm.icmp "ult" %43, %48 : i64
  %50 = llvm.select %49, %43, %48 : i1, i64
  %51 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  llvm.store %63, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %64 = ts.Variable(%63) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %65 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %66 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %67 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %68 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %69 = llvm.mlir.constant(1 : i64) : i64
  %70 = llvm.getelementptr %68[%69] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %71 = llvm.ptrtoint %70 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %72 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %73 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %74 = llvm.mlir.constant(1 : i64) : i64
  %75 = llvm.getelementptr %73[%74] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %76 = llvm.ptrtoint %75 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %77 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %78 = llvm.icmp "ult" %72, %77 : i64
  %79 = llvm.select %78, %72, %77 : i1, i64
  %80 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%66, %67, %79, %80) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%65, %64) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %81 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %82 = ts.Load(%65) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %83 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
  %84 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  llvm.store %81, %9 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  ts.Store %84, %31 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %85 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %86 = ts.Load(%31) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %87 = llvm.extractvalue %85[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
  %88 = ts.GetTypeInfoFromUnionOp %86 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %89 = llvm.mlir.constant(0 : i64) : i64
  %90 = llvm.ptrtoint %87 : !llvm.ptr<i8> to i64
  %91 = llvm.ptrtoint %20 : !llvm.ptr<i8> to i64
  %92 = llvm.icmp "ne" %90, %89 : i64
  %93 = llvm.icmp "ne" %91, %89 : i64
  %94 = llvm.zext %92 : i1 to i32
  %95 = zexti %92 : i1 to i32
  %96 = ts.Cast %92 : i1 to i32
  %97 = llvm.zext %93 : i1 to i32
  %98 = zexti %93 : i1 to i32
  %99 = ts.Cast %93 : i1 to i32
  %100 = llvm.and %96, %99  : i32
  %101 = llvm.mlir.constant(0 : i32) : i32
  %102 = llvm.icmp "ne" %100, %101 : i32
  llvm.cond_br %102, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %103 = llvm.mlir.constant(0 : i32) : i32
  %104 = llvm.call @strcmp(%87, %20) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %105 = llvm.icmp "eq" %104, %103 : i32
  llvm.br ^bb3(%105 : i1)
^bb2:  // pred: ^bb0
  %106 = llvm.icmp "eq" %90, %91 : i64
  llvm.br ^bb3(%106 : i1)
^bb3(%107: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %108 = "ts.StringCompare"(%87, %20) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %109 = ts.LogicalBinary %88(34) %21 : !ts.string, !ts.string -> !ts.boolean
  %110 = ts.Cast %109 : !ts.boolean to i1
  llvm.cond_br %107, ^bb5, ^bb6
  cond_br %110, ^bb5, ^bb6
^bb5:  // 2 preds: ^bb4, ^bb4
  %111 = ts.Load(%31) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %112 = ts.GetValueFromUnionOp %111 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %113 = ts.Cast %112 : !ts.number to !ts.string
  ts.Print(%25, %113) : !ts.string, !ts.string
  br ^bb6
^bb6:  // 3 preds: ^bb4, ^bb4, ^bb5
  %114 = llvm.call @puts(%28) : (!llvm.ptr<i8>) -> i32
  ts.Print(%29) : !ts.string
  llvm.return
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Load'(0x278e9430140) {
  %112 = "ts.Load"(%32) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>) -> !ts.union<!ts.string,!ts.number,!ts.boolean>

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.Load -> ()' {
Trying to match "`anonymous-namespace'::LoadOpLowering"
    ** Insert  : 'llvm.load'(0x278e942f0c0)
    ** Replace : 'ts.Load'(0x278e9430140)
"`anonymous-namespace'::LoadOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.load'(0x278e942f0c0) {
      %112 = "llvm.load"(%9) : (!llvm.ptr<struct<(ptr<i8>, i1)>>) -> !llvm.struct<(ptr<i8>, i1)>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %12 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %13 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %14 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %15 = llvm.mlir.constant(0 : i64) : i64
  %16 = llvm.getelementptr %14[%15, %15] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %17 = ts.Constant {value = "number"} : !ts.string
  %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "number"} : !ts.string
  %22 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "b number: "} : !ts.string
  %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %27 = llvm.mlir.constant(0 : i64) : i64
  %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %29 = ts.Constant {value = "done."} : !ts.string
  %30 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %31 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %32 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %33 = llvm.insertvalue %17, %32[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %34 = llvm.insertvalue %13, %33[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %34, %7 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %35 = ts.Variable(%34) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %37 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %38 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %39 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %40 = llvm.mlir.constant(1 : i64) : i64
  %41 = llvm.getelementptr %39[%40] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %42 = llvm.ptrtoint %41 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %43 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %45 = llvm.mlir.constant(1 : i64) : i64
  %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %49 = llvm.icmp "ult" %43, %48 : i64
  %50 = llvm.select %49, %43, %48 : i1, i64
  %51 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%37, %38, %50, %51) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%36, %35) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %52 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %53 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %54 = ts.CreateUnionInstance %13, %17 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %52, %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %54, %30 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %55 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %56 = ts.Load(%30) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %57 = llvm.extractvalue %55[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %58 = ts.GetValueFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %59 = llvm.extractvalue %55[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.GetTypeInfoFromUnionOp %55 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %61 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %62 = llvm.insertvalue %60, %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %63 = llvm.insertvalue %58, %62[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  llvm.store %63, %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %64 = ts.Variable(%63) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %65 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %66 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %67 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %68 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %69 = llvm.mlir.constant(1 : i64) : i64
  %70 = llvm.getelementptr %68[%69] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %71 = llvm.ptrtoint %70 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %72 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %73 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %74 = llvm.mlir.constant(1 : i64) : i64
  %75 = llvm.getelementptr %73[%74] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %76 = llvm.ptrtoint %75 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %77 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %78 = llvm.icmp "ult" %72, %77 : i64
  %79 = llvm.select %78, %72, %77 : i1, i64
  %80 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%66, %67, %79, %80) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%65, %64) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %81 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %82 = ts.Load(%65) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %83 = ts.CreateUnionInstance %58, %60 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
  %84 = ts.Cast %56 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  llvm.store %81, %9 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  ts.Store %84, %31 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %85 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %86 = ts.Load(%31) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %87 = llvm.extractvalue %85[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
  %88 = ts.GetTypeInfoFromUnionOp %86 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %89 = llvm.mlir.constant(0 : i64) : i64
  %90 = llvm.ptrtoint %87 : !llvm.ptr<i8> to i64
  %91 = llvm.ptrtoint %20 : !llvm.ptr<i8> to i64
  %92 = llvm.icmp "ne" %90, %89 : i64
  %93 = llvm.icmp "ne" %91, %89 : i64
  %94 = llvm.zext %92 : i1 to i32
  %95 = zexti %92 : i1 to i32
  %96 = ts.Cast %92 : i1 to i32
  %97 = llvm.zext %93 : i1 to i32
  %98 = zexti %93 : i1 to i32
  %99 = ts.Cast %93 : i1 to i32
  %100 = llvm.and %96, %99  : i32
  %101 = llvm.mlir.constant(0 : i32) : i32
  %102 = llvm.icmp "ne" %100, %101 : i32
  llvm.cond_br %102, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %103 = llvm.mlir.constant(0 : i32) : i32
  %104 = llvm.call @strcmp(%87, %20) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %105 = llvm.icmp "eq" %104, %103 : i32
  llvm.br ^bb3(%105 : i1)
^bb2:  // pred: ^bb0
  %106 = llvm.icmp "eq" %90, %91 : i64
  llvm.br ^bb3(%106 : i1)
^bb3(%107: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %108 = "ts.StringCompare"(%87, %20) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %109 = ts.LogicalBinary %88(34) %21 : !ts.string, !ts.string -> !ts.boolean
  %110 = ts.Cast %109 : !ts.boolean to i1
  llvm.cond_br %107, ^bb5, ^bb6
  cond_br %110, ^bb5, ^bb6
^bb5:  // 2 preds: ^bb4, ^bb4
  %111 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %112 = ts.Load(%31) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %113 = ts.GetValueFromUnionOp %112 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %114 = ts.Cast %113 : !ts.number to !ts.string
  ts.Print(%25, %114) : !ts.string, !ts.string
  br ^bb6
^bb6:  // 3 preds: ^bb4, ^bb4, ^bb5
  %115 = llvm.call @puts(%28) : (!llvm.ptr<i8>) -> i32
  ts.Print(%29) : !ts.string
  llvm.return
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.GetValueFromUnionOp'(0x278e9430380) {
  %114 = "ts.GetValueFromUnionOp"(%113) : (!ts.union<!ts.string,!ts.number,!ts.boolean>) -> !ts.number

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.GetValueFromUnionOp -> ()' {
Trying to match "`anonymous-namespace'::GetValueFromUnionOpLowering"
    ** Insert  : 'ts.Variable'(0x278e942fa80)
    ** Insert  : 'ts.Variable'(0x278e94d7e20)
    ** Insert  : 'ts.MemoryCopy'(0x278e9476250)
    ** Insert  : 'ts.Load'(0x278e942fcc0)
    ** Insert  : 'llvm.extractvalue'(0x278e9430a40)
    ** Replace : 'ts.GetValueFromUnionOp'(0x278e9430380)
"`anonymous-namespace'::GetValueFromUnionOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'ts.Variable'(0x278e942fa80) {
      %114 = "ts.Variable"(%112) {captured = false} : (!llvm.struct<(ptr<i8>, i1)>) -> !ts.ref<!llvm.struct<(ptr<i8>, i1)>>

      * Fold {
      } -> FAILURE : unable to fold

      * Pattern : 'ts.Variable -> ()' {
Trying to match "`anonymous-namespace'::VariableOpLowering"

!! variable allocation: !llvm.struct<(ptr<i8>, i1)> is captured: 0
        ** Insert  : 'llvm.mlir.constant'(0x278e94d7560)
        ** Insert  : 'llvm.alloca'(0x278e942fd80)
        ** Insert  : 'llvm.store'(0x278e9476660)
        ** Replace : 'ts.Variable'(0x278e942fa80)
"`anonymous-namespace'::VariableOpLowering" result 1

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.mlir.constant'(0x278e94d7560) {
          %0 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.alloca'(0x278e942fd80) {
          %1 = "llvm.alloca"(%0) : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.store'(0x278e9476660) {
          "llvm.store"(%114, %1) : (!llvm.struct<(ptr<i8>, i1)>, !llvm.ptr<struct<(ptr<i8>, i1)>>) -> ()

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//
      } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %12 = llvm.mlir.constant(1 : i32) : i32
  %13 = llvm.alloca %12 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %14 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %15 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %16 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %17 = llvm.mlir.constant(0 : i64) : i64
  %18 = llvm.getelementptr %16[%17, %17] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %19 = ts.Constant {value = "number"} : !ts.string
  %20 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %21 = llvm.mlir.constant(0 : i64) : i64
  %22 = llvm.getelementptr %20[%21, %21] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %23 = ts.Constant {value = "number"} : !ts.string
  %24 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %25 = llvm.mlir.constant(0 : i64) : i64
  %26 = llvm.getelementptr %24[%25, %25] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %27 = ts.Constant {value = "b number: "} : !ts.string
  %28 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %29 = llvm.mlir.constant(0 : i64) : i64
  %30 = llvm.getelementptr %28[%29, %29] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %31 = ts.Constant {value = "done."} : !ts.string
  %32 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %33 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %34 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %35 = llvm.insertvalue %19, %34[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %36 = llvm.insertvalue %15, %35[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %36, %9 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %37 = ts.Variable(%36) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %38 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %39 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %40 = llvm.bitcast %9 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %41 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %42 = llvm.mlir.constant(1 : i64) : i64
  %43 = llvm.getelementptr %41[%42] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %44 = llvm.ptrtoint %43 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %45 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %46 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %47 = llvm.mlir.constant(1 : i64) : i64
  %48 = llvm.getelementptr %46[%47] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %49 = llvm.ptrtoint %48 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %50 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %51 = llvm.icmp "ult" %45, %50 : i64
  %52 = llvm.select %51, %45, %50 : i1, i64
  %53 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%39, %40, %52, %53) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%38, %37) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %54 = llvm.load %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %55 = ts.Load(%38) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %56 = ts.CreateUnionInstance %15, %19 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %54, %13 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %56, %32 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %57 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %58 = ts.Load(%32) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %59 = llvm.extractvalue %57[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %60 = ts.GetValueFromUnionOp %57 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %61 = llvm.extractvalue %57[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %62 = ts.GetTypeInfoFromUnionOp %57 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %63 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %64 = llvm.insertvalue %62, %63[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %65 = llvm.insertvalue %60, %64[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  llvm.store %65, %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %66 = ts.Variable(%65) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %67 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %68 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %69 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %70 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %71 = llvm.mlir.constant(1 : i64) : i64
  %72 = llvm.getelementptr %70[%71] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %73 = llvm.ptrtoint %72 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %74 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %75 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %76 = llvm.mlir.constant(1 : i64) : i64
  %77 = llvm.getelementptr %75[%76] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %78 = llvm.ptrtoint %77 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %79 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %80 = llvm.icmp "ult" %74, %79 : i64
  %81 = llvm.select %80, %74, %79 : i1, i64
  %82 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%68, %69, %81, %82) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%67, %66) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %83 = llvm.load %3 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %84 = ts.Load(%67) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %85 = ts.CreateUnionInstance %60, %62 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
  %86 = ts.Cast %58 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  llvm.store %83, %11 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  ts.Store %86, %33 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %87 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %88 = ts.Load(%33) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %89 = llvm.extractvalue %87[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
  %90 = ts.GetTypeInfoFromUnionOp %88 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %91 = llvm.mlir.constant(0 : i64) : i64
  %92 = llvm.ptrtoint %89 : !llvm.ptr<i8> to i64
  %93 = llvm.ptrtoint %22 : !llvm.ptr<i8> to i64
  %94 = llvm.icmp "ne" %92, %91 : i64
  %95 = llvm.icmp "ne" %93, %91 : i64
  %96 = llvm.zext %94 : i1 to i32
  %97 = zexti %94 : i1 to i32
  %98 = ts.Cast %94 : i1 to i32
  %99 = llvm.zext %95 : i1 to i32
  %100 = zexti %95 : i1 to i32
  %101 = ts.Cast %95 : i1 to i32
  %102 = llvm.and %98, %101  : i32
  %103 = llvm.mlir.constant(0 : i32) : i32
  %104 = llvm.icmp "ne" %102, %103 : i32
  llvm.cond_br %104, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %105 = llvm.mlir.constant(0 : i32) : i32
  %106 = llvm.call @strcmp(%89, %22) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %107 = llvm.icmp "eq" %106, %105 : i32
  llvm.br ^bb3(%107 : i1)
^bb2:  // pred: ^bb0
  %108 = llvm.icmp "eq" %92, %93 : i64
  llvm.br ^bb3(%108 : i1)
^bb3(%109: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %110 = "ts.StringCompare"(%89, %22) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %111 = ts.LogicalBinary %90(34) %23 : !ts.string, !ts.string -> !ts.boolean
  %112 = ts.Cast %111 : !ts.boolean to i1
  llvm.cond_br %109, ^bb5, ^bb6
  cond_br %112, ^bb5, ^bb6
^bb5:  // 2 preds: ^bb4, ^bb4
  %113 = llvm.load %11 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %114 = ts.Load(%33) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  llvm.store %113, %1 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %115 = ts.Variable(%113) {false} : !llvm.struct<(ptr<i8>, i1)> -> !ts.ref<!llvm.struct<(ptr<i8>, i1)>>
  %116 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  "ts.MemoryCopy"(%116, %115) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, i1)>>) -> ()
  %117 = ts.Load(%116) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
  %118 = llvm.extractvalue %117[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %119 = ts.GetValueFromUnionOp %114 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %120 = ts.Cast %119 : !ts.number to !ts.string
  ts.Print(%27, %120) : !ts.string, !ts.string
  br ^bb6
^bb6:  // 3 preds: ^bb4, ^bb4, ^bb5
  %121 = llvm.call @puts(%30) : (!llvm.ptr<i8>) -> i32
  ts.Print(%31) : !ts.string
  llvm.return
  ts.ReturnInternal
}


    } -> SUCCESS
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'ts.Variable'(0x278e94d7e20) {
      %117 = "ts.Variable"() {captured = false} : () -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>

      * Fold {
      } -> FAILURE : unable to fold

      * Pattern : 'ts.Variable -> ()' {
Trying to match "`anonymous-namespace'::VariableOpLowering"

!! variable allocation: !llvm.struct<(ptr<i8>, f64)> is captured: 0
        ** Insert  : 'llvm.mlir.constant'(0x278e94d7ce0)
        ** Insert  : 'llvm.alloca'(0x278e9430b00)
        ** Replace : 'ts.Variable'(0x278e94d7e20)
"`anonymous-namespace'::VariableOpLowering" result 1

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.mlir.constant'(0x278e94d7ce0) {
          %0 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.alloca'(0x278e9430b00) {
          %1 = "llvm.alloca"(%0) : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//
      } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %12 = llvm.mlir.constant(1 : i32) : i32
  %13 = llvm.alloca %12 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %14 = llvm.mlir.constant(1 : i32) : i32
  %15 = llvm.alloca %14 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %16 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %17 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "number"} : !ts.string
  %22 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "number"} : !ts.string
  %26 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %27 = llvm.mlir.constant(0 : i64) : i64
  %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %29 = ts.Constant {value = "b number: "} : !ts.string
  %30 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %31 = llvm.mlir.constant(0 : i64) : i64
  %32 = llvm.getelementptr %30[%31, %31] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %33 = ts.Constant {value = "done."} : !ts.string
  %34 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %35 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %36 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %37 = llvm.insertvalue %21, %36[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %38 = llvm.insertvalue %17, %37[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %38, %11 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %39 = ts.Variable(%38) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %40 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %41 = llvm.bitcast %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %42 = llvm.bitcast %11 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %43 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %44 = llvm.mlir.constant(1 : i64) : i64
  %45 = llvm.getelementptr %43[%44] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %46 = llvm.ptrtoint %45 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %47 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %48 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %49 = llvm.mlir.constant(1 : i64) : i64
  %50 = llvm.getelementptr %48[%49] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %51 = llvm.ptrtoint %50 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %52 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %53 = llvm.icmp "ult" %47, %52 : i64
  %54 = llvm.select %53, %47, %52 : i1, i64
  %55 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%41, %42, %54, %55) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%40, %39) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %56 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %57 = ts.Load(%40) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %58 = ts.CreateUnionInstance %17, %21 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %56, %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %58, %34 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %59 = llvm.load %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %60 = ts.Load(%34) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %61 = llvm.extractvalue %59[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %62 = ts.GetValueFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %63 = llvm.extractvalue %59[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %64 = ts.GetTypeInfoFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %65 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %66 = llvm.insertvalue %64, %65[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %67 = llvm.insertvalue %62, %66[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  llvm.store %67, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %68 = ts.Variable(%67) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %69 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %70 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %71 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %72 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %73 = llvm.mlir.constant(1 : i64) : i64
  %74 = llvm.getelementptr %72[%73] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %75 = llvm.ptrtoint %74 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %76 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %77 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %78 = llvm.mlir.constant(1 : i64) : i64
  %79 = llvm.getelementptr %77[%78] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %80 = llvm.ptrtoint %79 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %81 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %82 = llvm.icmp "ult" %76, %81 : i64
  %83 = llvm.select %82, %76, %81 : i1, i64
  %84 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%70, %71, %83, %84) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%69, %68) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %85 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %86 = ts.Load(%69) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %87 = ts.CreateUnionInstance %62, %64 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
  %88 = ts.Cast %60 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  llvm.store %85, %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  ts.Store %88, %35 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %89 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %90 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %91 = llvm.extractvalue %89[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
  %92 = ts.GetTypeInfoFromUnionOp %90 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %93 = llvm.mlir.constant(0 : i64) : i64
  %94 = llvm.ptrtoint %91 : !llvm.ptr<i8> to i64
  %95 = llvm.ptrtoint %24 : !llvm.ptr<i8> to i64
  %96 = llvm.icmp "ne" %94, %93 : i64
  %97 = llvm.icmp "ne" %95, %93 : i64
  %98 = llvm.zext %96 : i1 to i32
  %99 = zexti %96 : i1 to i32
  %100 = ts.Cast %96 : i1 to i32
  %101 = llvm.zext %97 : i1 to i32
  %102 = zexti %97 : i1 to i32
  %103 = ts.Cast %97 : i1 to i32
  %104 = llvm.and %100, %103  : i32
  %105 = llvm.mlir.constant(0 : i32) : i32
  %106 = llvm.icmp "ne" %104, %105 : i32
  llvm.cond_br %106, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %107 = llvm.mlir.constant(0 : i32) : i32
  %108 = llvm.call @strcmp(%91, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %109 = llvm.icmp "eq" %108, %107 : i32
  llvm.br ^bb3(%109 : i1)
^bb2:  // pred: ^bb0
  %110 = llvm.icmp "eq" %94, %95 : i64
  llvm.br ^bb3(%110 : i1)
^bb3(%111: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %112 = "ts.StringCompare"(%91, %24) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %113 = ts.LogicalBinary %92(34) %25 : !ts.string, !ts.string -> !ts.boolean
  %114 = ts.Cast %113 : !ts.boolean to i1
  llvm.cond_br %111, ^bb5, ^bb6
  cond_br %114, ^bb5, ^bb6
^bb5:  // 2 preds: ^bb4, ^bb4
  %115 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %116 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  llvm.store %115, %3 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %117 = ts.Variable(%115) {false} : !llvm.struct<(ptr<i8>, i1)> -> !ts.ref<!llvm.struct<(ptr<i8>, i1)>>
  %118 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  "ts.MemoryCopy"(%118, %117) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, i1)>>) -> ()
  %119 = ts.Load(%118) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
  %120 = llvm.extractvalue %119[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %121 = ts.GetValueFromUnionOp %116 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %122 = ts.Cast %121 : !ts.number to !ts.string
  ts.Print(%29, %122) : !ts.string, !ts.string
  br ^bb6
^bb6:  // 3 preds: ^bb4, ^bb4, ^bb5
  %123 = llvm.call @puts(%32) : (!llvm.ptr<i8>) -> i32
  ts.Print(%33) : !ts.string
  llvm.return
  ts.ReturnInternal
}


    } -> SUCCESS
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'ts.MemoryCopy'(0x278e9476250) {
      "ts.MemoryCopy"(%119, %118) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, i1)>>) -> ()

      * Fold {
      } -> FAILURE : unable to fold

      * Pattern : 'ts.MemoryCopy -> ()' {
Trying to match "`anonymous-namespace'::MemoryCopyOpLowering"
        ** Insert  : 'llvm.bitcast'(0x278e942e100)
        ** Insert  : 'llvm.bitcast'(0x278e942e280)
        ** Insert  : 'ts.SizeOf'(0x278e94d6700)
        ** Insert  : 'ts.SizeOf'(0x278e94d5ee0)
        ** Insert  : 'llvm.icmp'(0x278e9546e40)
        ** Insert  : 'llvm.select'(0x278e9392f30)
        ** Insert  : 'llvm.mlir.constant'(0x278e94d6340)
        ** Insert  : 'llvm.call'(0x278e9458ba0)
        ** Erase   : 'ts.MemoryCopy'(0x278e9476250)
"`anonymous-namespace'::MemoryCopyOpLowering" result 1

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.bitcast'(0x278e942e100) {
          %120 = "llvm.bitcast"(%1) : (!llvm.ptr<struct<(ptr<i8>, f64)>>) -> !llvm.ptr<i8>

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.bitcast'(0x278e942e280) {
          %121 = "llvm.bitcast"(%3) : (!llvm.ptr<struct<(ptr<i8>, i1)>>) -> !llvm.ptr<i8>

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'ts.SizeOf'(0x278e94d6700) {
          %122 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64

          * Fold {
          } -> FAILURE : unable to fold

          * Pattern : 'ts.SizeOf -> ()' {
Trying to match "`anonymous-namespace'::SizeOfOpLowering"
            ** Insert  : 'llvm.mlir.null'(0x278e94d7b00)

!! size of - storage type: [!llvm.struct<(ptr<i8>, i1)>] llvm storage type: [!llvm.struct<(ptr<i8>, i1)>] llvm ptr: [!llvm.ptr<struct<(ptr<i8>, i1)>>] value: [%121 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>]
            ** Insert  : 'llvm.mlir.constant'(0x278e94d7ec0)
            ** Insert  : 'llvm.getelementptr'(0x278e9544a60)
            ** Insert  : 'llvm.ptrtoint'(0x278e942e340)
            ** Replace : 'ts.SizeOf'(0x278e94d6700)
"`anonymous-namespace'::SizeOfOpLowering" result 1

            //===-------------------------------------------===//
            Legalizing operation : 'llvm.mlir.null'(0x278e94d7b00) {
              %122 = "llvm.mlir.null"() : () -> !llvm.ptr<struct<(ptr<i8>, i1)>>

            } -> SUCCESS : operation marked legal by the target
            //===-------------------------------------------===//

            //===-------------------------------------------===//
            Legalizing operation : 'llvm.mlir.constant'(0x278e94d7ec0) {
              %123 = "llvm.mlir.constant"() {value = 1 : i64} : () -> i64

            } -> SUCCESS : operation marked legal by the target
            //===-------------------------------------------===//

            //===-------------------------------------------===//
            Legalizing operation : 'llvm.getelementptr'(0x278e9544a60) {
              %124 = "llvm.getelementptr"(%122, %123) : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>

            } -> SUCCESS : operation marked legal by the target
            //===-------------------------------------------===//

            //===-------------------------------------------===//
            Legalizing operation : 'llvm.ptrtoint'(0x278e942e340) {
              %125 = "llvm.ptrtoint"(%124) : (!llvm.ptr<struct<(ptr<i8>, i1)>>) -> i64

            } -> SUCCESS : operation marked legal by the target
            //===-------------------------------------------===//
          } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %12 = llvm.mlir.constant(1 : i32) : i32
  %13 = llvm.alloca %12 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %14 = llvm.mlir.constant(1 : i32) : i32
  %15 = llvm.alloca %14 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %16 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %17 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "number"} : !ts.string
  %22 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "number"} : !ts.string
  %26 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %27 = llvm.mlir.constant(0 : i64) : i64
  %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %29 = ts.Constant {value = "b number: "} : !ts.string
  %30 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %31 = llvm.mlir.constant(0 : i64) : i64
  %32 = llvm.getelementptr %30[%31, %31] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %33 = ts.Constant {value = "done."} : !ts.string
  %34 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %35 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %36 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %37 = llvm.insertvalue %21, %36[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %38 = llvm.insertvalue %17, %37[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %38, %11 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %39 = ts.Variable(%38) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %40 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %41 = llvm.bitcast %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %42 = llvm.bitcast %11 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %43 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %44 = llvm.mlir.constant(1 : i64) : i64
  %45 = llvm.getelementptr %43[%44] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %46 = llvm.ptrtoint %45 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %47 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %48 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %49 = llvm.mlir.constant(1 : i64) : i64
  %50 = llvm.getelementptr %48[%49] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %51 = llvm.ptrtoint %50 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %52 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %53 = llvm.icmp "ult" %47, %52 : i64
  %54 = llvm.select %53, %47, %52 : i1, i64
  %55 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%41, %42, %54, %55) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%40, %39) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %56 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %57 = ts.Load(%40) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %58 = ts.CreateUnionInstance %17, %21 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %56, %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %58, %34 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %59 = llvm.load %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %60 = ts.Load(%34) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %61 = llvm.extractvalue %59[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %62 = ts.GetValueFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %63 = llvm.extractvalue %59[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %64 = ts.GetTypeInfoFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %65 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %66 = llvm.insertvalue %64, %65[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %67 = llvm.insertvalue %62, %66[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  llvm.store %67, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %68 = ts.Variable(%67) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %69 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %70 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %71 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %72 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %73 = llvm.mlir.constant(1 : i64) : i64
  %74 = llvm.getelementptr %72[%73] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %75 = llvm.ptrtoint %74 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %76 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %77 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %78 = llvm.mlir.constant(1 : i64) : i64
  %79 = llvm.getelementptr %77[%78] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %80 = llvm.ptrtoint %79 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %81 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %82 = llvm.icmp "ult" %76, %81 : i64
  %83 = llvm.select %82, %76, %81 : i1, i64
  %84 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%70, %71, %83, %84) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%69, %68) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %85 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %86 = ts.Load(%69) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %87 = ts.CreateUnionInstance %62, %64 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
  %88 = ts.Cast %60 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  llvm.store %85, %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  ts.Store %88, %35 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %89 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %90 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %91 = llvm.extractvalue %89[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
  %92 = ts.GetTypeInfoFromUnionOp %90 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %93 = llvm.mlir.constant(0 : i64) : i64
  %94 = llvm.ptrtoint %91 : !llvm.ptr<i8> to i64
  %95 = llvm.ptrtoint %24 : !llvm.ptr<i8> to i64
  %96 = llvm.icmp "ne" %94, %93 : i64
  %97 = llvm.icmp "ne" %95, %93 : i64
  %98 = llvm.zext %96 : i1 to i32
  %99 = zexti %96 : i1 to i32
  %100 = ts.Cast %96 : i1 to i32
  %101 = llvm.zext %97 : i1 to i32
  %102 = zexti %97 : i1 to i32
  %103 = ts.Cast %97 : i1 to i32
  %104 = llvm.and %100, %103  : i32
  %105 = llvm.mlir.constant(0 : i32) : i32
  %106 = llvm.icmp "ne" %104, %105 : i32
  llvm.cond_br %106, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %107 = llvm.mlir.constant(0 : i32) : i32
  %108 = llvm.call @strcmp(%91, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %109 = llvm.icmp "eq" %108, %107 : i32
  llvm.br ^bb3(%109 : i1)
^bb2:  // pred: ^bb0
  %110 = llvm.icmp "eq" %94, %95 : i64
  llvm.br ^bb3(%110 : i1)
^bb3(%111: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %112 = "ts.StringCompare"(%91, %24) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %113 = ts.LogicalBinary %92(34) %25 : !ts.string, !ts.string -> !ts.boolean
  %114 = ts.Cast %113 : !ts.boolean to i1
  llvm.cond_br %111, ^bb5, ^bb6
  cond_br %114, ^bb5, ^bb6
^bb5:  // 2 preds: ^bb4, ^bb4
  %115 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %116 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  llvm.store %115, %3 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %117 = ts.Variable(%115) {false} : !llvm.struct<(ptr<i8>, i1)> -> !ts.ref<!llvm.struct<(ptr<i8>, i1)>>
  %118 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %119 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %120 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %121 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %122 = llvm.mlir.constant(1 : i64) : i64
  %123 = llvm.getelementptr %121[%122] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %124 = llvm.ptrtoint %123 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %125 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %126 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %127 = llvm.icmp "ult" %125, %126 : i64
  %128 = llvm.select %127, %125, %126 : i1, i64
  %129 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%119, %120, %128, %129) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%118, %117) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, i1)>>) -> ()
  %130 = ts.Load(%118) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
  %131 = llvm.extractvalue %130[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %132 = ts.GetValueFromUnionOp %116 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %133 = ts.Cast %132 : !ts.number to !ts.string
  ts.Print(%29, %133) : !ts.string, !ts.string
  br ^bb6
^bb6:  // 3 preds: ^bb4, ^bb4, ^bb5
  %134 = llvm.call @puts(%32) : (!llvm.ptr<i8>) -> i32
  ts.Print(%33) : !ts.string
  llvm.return
  ts.ReturnInternal
}


        } -> SUCCESS
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'ts.SizeOf'(0x278e94d5ee0) {
          %127 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64

          * Fold {
          } -> FAILURE : unable to fold

          * Pattern : 'ts.SizeOf -> ()' {
Trying to match "`anonymous-namespace'::SizeOfOpLowering"
            ** Insert  : 'llvm.mlir.null'(0x278e94d6980)

!! size of - storage type: [!llvm.struct<(ptr<i8>, f64)>] llvm storage type: [!llvm.struct<(ptr<i8>, f64)>] llvm ptr: [!llvm.ptr<struct<(ptr<i8>, f64)>>] value: [%126 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>]
            ** Insert  : 'llvm.mlir.constant'(0x278e94d7d80)
            ** Insert  : 'llvm.getelementptr'(0x278e95440c0)
            ** Insert  : 'llvm.ptrtoint'(0x278e942ffc0)
            ** Replace : 'ts.SizeOf'(0x278e94d5ee0)
"`anonymous-namespace'::SizeOfOpLowering" result 1

            //===-------------------------------------------===//
            Legalizing operation : 'llvm.mlir.null'(0x278e94d6980) {
              %127 = "llvm.mlir.null"() : () -> !llvm.ptr<struct<(ptr<i8>, f64)>>

            } -> SUCCESS : operation marked legal by the target
            //===-------------------------------------------===//

            //===-------------------------------------------===//
            Legalizing operation : 'llvm.mlir.constant'(0x278e94d7d80) {
              %128 = "llvm.mlir.constant"() {value = 1 : i64} : () -> i64

            } -> SUCCESS : operation marked legal by the target
            //===-------------------------------------------===//

            //===-------------------------------------------===//
            Legalizing operation : 'llvm.getelementptr'(0x278e95440c0) {
              %129 = "llvm.getelementptr"(%127, %128) : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>

            } -> SUCCESS : operation marked legal by the target
            //===-------------------------------------------===//

            //===-------------------------------------------===//
            Legalizing operation : 'llvm.ptrtoint'(0x278e942ffc0) {
              %130 = "llvm.ptrtoint"(%129) : (!llvm.ptr<struct<(ptr<i8>, f64)>>) -> i64

            } -> SUCCESS : operation marked legal by the target
            //===-------------------------------------------===//
          } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %12 = llvm.mlir.constant(1 : i32) : i32
  %13 = llvm.alloca %12 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %14 = llvm.mlir.constant(1 : i32) : i32
  %15 = llvm.alloca %14 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %16 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %17 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "number"} : !ts.string
  %22 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "number"} : !ts.string
  %26 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %27 = llvm.mlir.constant(0 : i64) : i64
  %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %29 = ts.Constant {value = "b number: "} : !ts.string
  %30 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %31 = llvm.mlir.constant(0 : i64) : i64
  %32 = llvm.getelementptr %30[%31, %31] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %33 = ts.Constant {value = "done."} : !ts.string
  %34 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %35 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %36 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %37 = llvm.insertvalue %21, %36[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %38 = llvm.insertvalue %17, %37[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %38, %11 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %39 = ts.Variable(%38) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %40 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %41 = llvm.bitcast %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %42 = llvm.bitcast %11 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %43 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %44 = llvm.mlir.constant(1 : i64) : i64
  %45 = llvm.getelementptr %43[%44] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %46 = llvm.ptrtoint %45 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %47 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %48 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %49 = llvm.mlir.constant(1 : i64) : i64
  %50 = llvm.getelementptr %48[%49] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %51 = llvm.ptrtoint %50 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %52 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %53 = llvm.icmp "ult" %47, %52 : i64
  %54 = llvm.select %53, %47, %52 : i1, i64
  %55 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%41, %42, %54, %55) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%40, %39) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %56 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %57 = ts.Load(%40) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %58 = ts.CreateUnionInstance %17, %21 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %56, %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %58, %34 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %59 = llvm.load %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %60 = ts.Load(%34) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %61 = llvm.extractvalue %59[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %62 = ts.GetValueFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %63 = llvm.extractvalue %59[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %64 = ts.GetTypeInfoFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %65 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %66 = llvm.insertvalue %64, %65[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %67 = llvm.insertvalue %62, %66[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  llvm.store %67, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %68 = ts.Variable(%67) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %69 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %70 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %71 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %72 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %73 = llvm.mlir.constant(1 : i64) : i64
  %74 = llvm.getelementptr %72[%73] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %75 = llvm.ptrtoint %74 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %76 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %77 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %78 = llvm.mlir.constant(1 : i64) : i64
  %79 = llvm.getelementptr %77[%78] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %80 = llvm.ptrtoint %79 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %81 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %82 = llvm.icmp "ult" %76, %81 : i64
  %83 = llvm.select %82, %76, %81 : i1, i64
  %84 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%70, %71, %83, %84) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%69, %68) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %85 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %86 = ts.Load(%69) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %87 = ts.CreateUnionInstance %62, %64 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
  %88 = ts.Cast %60 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  llvm.store %85, %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  ts.Store %88, %35 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %89 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %90 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %91 = llvm.extractvalue %89[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
  %92 = ts.GetTypeInfoFromUnionOp %90 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %93 = llvm.mlir.constant(0 : i64) : i64
  %94 = llvm.ptrtoint %91 : !llvm.ptr<i8> to i64
  %95 = llvm.ptrtoint %24 : !llvm.ptr<i8> to i64
  %96 = llvm.icmp "ne" %94, %93 : i64
  %97 = llvm.icmp "ne" %95, %93 : i64
  %98 = llvm.zext %96 : i1 to i32
  %99 = zexti %96 : i1 to i32
  %100 = ts.Cast %96 : i1 to i32
  %101 = llvm.zext %97 : i1 to i32
  %102 = zexti %97 : i1 to i32
  %103 = ts.Cast %97 : i1 to i32
  %104 = llvm.and %100, %103  : i32
  %105 = llvm.mlir.constant(0 : i32) : i32
  %106 = llvm.icmp "ne" %104, %105 : i32
  llvm.cond_br %106, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %107 = llvm.mlir.constant(0 : i32) : i32
  %108 = llvm.call @strcmp(%91, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %109 = llvm.icmp "eq" %108, %107 : i32
  llvm.br ^bb3(%109 : i1)
^bb2:  // pred: ^bb0
  %110 = llvm.icmp "eq" %94, %95 : i64
  llvm.br ^bb3(%110 : i1)
^bb3(%111: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %112 = "ts.StringCompare"(%91, %24) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %113 = ts.LogicalBinary %92(34) %25 : !ts.string, !ts.string -> !ts.boolean
  %114 = ts.Cast %113 : !ts.boolean to i1
  llvm.cond_br %111, ^bb5, ^bb6
  cond_br %114, ^bb5, ^bb6
^bb5:  // 2 preds: ^bb4, ^bb4
  %115 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %116 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  llvm.store %115, %3 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %117 = ts.Variable(%115) {false} : !llvm.struct<(ptr<i8>, i1)> -> !ts.ref<!llvm.struct<(ptr<i8>, i1)>>
  %118 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %119 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %120 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %121 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %122 = llvm.mlir.constant(1 : i64) : i64
  %123 = llvm.getelementptr %121[%122] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %124 = llvm.ptrtoint %123 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %125 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %126 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %127 = llvm.mlir.constant(1 : i64) : i64
  %128 = llvm.getelementptr %126[%127] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %129 = llvm.ptrtoint %128 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %130 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %131 = llvm.icmp "ult" %125, %130 : i64
  %132 = llvm.select %131, %125, %130 : i1, i64
  %133 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%119, %120, %132, %133) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%118, %117) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, i1)>>) -> ()
  %134 = ts.Load(%118) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
  %135 = llvm.extractvalue %134[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %136 = ts.GetValueFromUnionOp %116 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %137 = ts.Cast %136 : !ts.number to !ts.string
  ts.Print(%29, %137) : !ts.string, !ts.string
  br ^bb6
^bb6:  // 3 preds: ^bb4, ^bb4, ^bb5
  %138 = llvm.call @puts(%32) : (!llvm.ptr<i8>) -> i32
  ts.Print(%33) : !ts.string
  llvm.return
  ts.ReturnInternal
}


        } -> SUCCESS
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.icmp'(0x278e9546e40) {
          %132 = "llvm.icmp"(%126, %131) {predicate = 6 : i64} : (i64, i64) -> i1

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.select'(0x278e9392f30) {
          %133 = "llvm.select"(%132, %126, %131) : (i1, i64, i64) -> i64

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.mlir.constant'(0x278e94d6340) {
          %134 = "llvm.mlir.constant"() {value = false} : () -> i1

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.call'(0x278e9458ba0) {
          "llvm.call"(%120, %121, %133, %134) {callee = @llvm.memcpy.p0i8.p0i8.i64} : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//
      } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %12 = llvm.mlir.constant(1 : i32) : i32
  %13 = llvm.alloca %12 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %14 = llvm.mlir.constant(1 : i32) : i32
  %15 = llvm.alloca %14 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %16 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %17 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "number"} : !ts.string
  %22 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "number"} : !ts.string
  %26 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %27 = llvm.mlir.constant(0 : i64) : i64
  %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %29 = ts.Constant {value = "b number: "} : !ts.string
  %30 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %31 = llvm.mlir.constant(0 : i64) : i64
  %32 = llvm.getelementptr %30[%31, %31] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %33 = ts.Constant {value = "done."} : !ts.string
  %34 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %35 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %36 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %37 = llvm.insertvalue %21, %36[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %38 = llvm.insertvalue %17, %37[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %38, %11 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %39 = ts.Variable(%38) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %40 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %41 = llvm.bitcast %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %42 = llvm.bitcast %11 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %43 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %44 = llvm.mlir.constant(1 : i64) : i64
  %45 = llvm.getelementptr %43[%44] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %46 = llvm.ptrtoint %45 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %47 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %48 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %49 = llvm.mlir.constant(1 : i64) : i64
  %50 = llvm.getelementptr %48[%49] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %51 = llvm.ptrtoint %50 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %52 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %53 = llvm.icmp "ult" %47, %52 : i64
  %54 = llvm.select %53, %47, %52 : i1, i64
  %55 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%41, %42, %54, %55) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%40, %39) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %56 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %57 = ts.Load(%40) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %58 = ts.CreateUnionInstance %17, %21 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %56, %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %58, %34 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %59 = llvm.load %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %60 = ts.Load(%34) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %61 = llvm.extractvalue %59[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %62 = ts.GetValueFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %63 = llvm.extractvalue %59[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %64 = ts.GetTypeInfoFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %65 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %66 = llvm.insertvalue %64, %65[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %67 = llvm.insertvalue %62, %66[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  llvm.store %67, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %68 = ts.Variable(%67) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %69 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %70 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %71 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %72 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %73 = llvm.mlir.constant(1 : i64) : i64
  %74 = llvm.getelementptr %72[%73] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %75 = llvm.ptrtoint %74 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %76 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %77 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %78 = llvm.mlir.constant(1 : i64) : i64
  %79 = llvm.getelementptr %77[%78] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %80 = llvm.ptrtoint %79 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %81 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %82 = llvm.icmp "ult" %76, %81 : i64
  %83 = llvm.select %82, %76, %81 : i1, i64
  %84 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%70, %71, %83, %84) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%69, %68) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %85 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %86 = ts.Load(%69) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %87 = ts.CreateUnionInstance %62, %64 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
  %88 = ts.Cast %60 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  llvm.store %85, %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  ts.Store %88, %35 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %89 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %90 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %91 = llvm.extractvalue %89[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
  %92 = ts.GetTypeInfoFromUnionOp %90 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %93 = llvm.mlir.constant(0 : i64) : i64
  %94 = llvm.ptrtoint %91 : !llvm.ptr<i8> to i64
  %95 = llvm.ptrtoint %24 : !llvm.ptr<i8> to i64
  %96 = llvm.icmp "ne" %94, %93 : i64
  %97 = llvm.icmp "ne" %95, %93 : i64
  %98 = llvm.zext %96 : i1 to i32
  %99 = zexti %96 : i1 to i32
  %100 = ts.Cast %96 : i1 to i32
  %101 = llvm.zext %97 : i1 to i32
  %102 = zexti %97 : i1 to i32
  %103 = ts.Cast %97 : i1 to i32
  %104 = llvm.and %100, %103  : i32
  %105 = llvm.mlir.constant(0 : i32) : i32
  %106 = llvm.icmp "ne" %104, %105 : i32
  llvm.cond_br %106, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %107 = llvm.mlir.constant(0 : i32) : i32
  %108 = llvm.call @strcmp(%91, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %109 = llvm.icmp "eq" %108, %107 : i32
  llvm.br ^bb3(%109 : i1)
^bb2:  // pred: ^bb0
  %110 = llvm.icmp "eq" %94, %95 : i64
  llvm.br ^bb3(%110 : i1)
^bb3(%111: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %112 = "ts.StringCompare"(%91, %24) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %113 = ts.LogicalBinary %92(34) %25 : !ts.string, !ts.string -> !ts.boolean
  %114 = ts.Cast %113 : !ts.boolean to i1
  llvm.cond_br %111, ^bb5, ^bb6
  cond_br %114, ^bb5, ^bb6
^bb5:  // 2 preds: ^bb4, ^bb4
  %115 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %116 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  llvm.store %115, %3 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %117 = ts.Variable(%115) {false} : !llvm.struct<(ptr<i8>, i1)> -> !ts.ref<!llvm.struct<(ptr<i8>, i1)>>
  %118 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %119 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %120 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %121 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %122 = llvm.mlir.constant(1 : i64) : i64
  %123 = llvm.getelementptr %121[%122] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %124 = llvm.ptrtoint %123 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %125 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %126 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %127 = llvm.mlir.constant(1 : i64) : i64
  %128 = llvm.getelementptr %126[%127] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %129 = llvm.ptrtoint %128 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %130 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %131 = llvm.icmp "ult" %125, %130 : i64
  %132 = llvm.select %131, %125, %130 : i1, i64
  %133 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%119, %120, %132, %133) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%118, %117) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, i1)>>) -> ()
  %134 = ts.Load(%118) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
  %135 = llvm.extractvalue %134[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %136 = ts.GetValueFromUnionOp %116 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %137 = ts.Cast %136 : !ts.number to !ts.string
  ts.Print(%29, %137) : !ts.string, !ts.string
  br ^bb6
^bb6:  // 3 preds: ^bb4, ^bb4, ^bb5
  %138 = llvm.call @puts(%32) : (!llvm.ptr<i8>) -> i32
  ts.Print(%33) : !ts.string
  llvm.return
  ts.ReturnInternal
}


    } -> SUCCESS
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'ts.Load'(0x278e942fcc0) {
      %135 = "ts.Load"(%119) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> !llvm.struct<(ptr<i8>, f64)>

      * Fold {
      } -> FAILURE : unable to fold

      * Pattern : 'ts.Load -> ()' {
Trying to match "`anonymous-namespace'::LoadOpLowering"
        ** Insert  : 'llvm.load'(0x278e9430200)
        ** Replace : 'ts.Load'(0x278e942fcc0)
"`anonymous-namespace'::LoadOpLowering" result 1

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.load'(0x278e9430200) {
          %135 = "llvm.load"(%1) : (!llvm.ptr<struct<(ptr<i8>, f64)>>) -> !llvm.struct<(ptr<i8>, f64)>

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//
      } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %12 = llvm.mlir.constant(1 : i32) : i32
  %13 = llvm.alloca %12 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %14 = llvm.mlir.constant(1 : i32) : i32
  %15 = llvm.alloca %14 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %16 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %17 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "number"} : !ts.string
  %22 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "number"} : !ts.string
  %26 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %27 = llvm.mlir.constant(0 : i64) : i64
  %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %29 = ts.Constant {value = "b number: "} : !ts.string
  %30 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %31 = llvm.mlir.constant(0 : i64) : i64
  %32 = llvm.getelementptr %30[%31, %31] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %33 = ts.Constant {value = "done."} : !ts.string
  %34 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %35 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %36 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %37 = llvm.insertvalue %21, %36[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %38 = llvm.insertvalue %17, %37[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %38, %11 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %39 = ts.Variable(%38) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %40 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %41 = llvm.bitcast %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %42 = llvm.bitcast %11 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %43 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %44 = llvm.mlir.constant(1 : i64) : i64
  %45 = llvm.getelementptr %43[%44] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %46 = llvm.ptrtoint %45 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %47 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %48 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %49 = llvm.mlir.constant(1 : i64) : i64
  %50 = llvm.getelementptr %48[%49] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %51 = llvm.ptrtoint %50 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %52 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %53 = llvm.icmp "ult" %47, %52 : i64
  %54 = llvm.select %53, %47, %52 : i1, i64
  %55 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%41, %42, %54, %55) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%40, %39) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %56 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %57 = ts.Load(%40) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %58 = ts.CreateUnionInstance %17, %21 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %56, %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %58, %34 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %59 = llvm.load %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %60 = ts.Load(%34) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %61 = llvm.extractvalue %59[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %62 = ts.GetValueFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %63 = llvm.extractvalue %59[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %64 = ts.GetTypeInfoFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %65 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %66 = llvm.insertvalue %64, %65[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %67 = llvm.insertvalue %62, %66[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  llvm.store %67, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %68 = ts.Variable(%67) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %69 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %70 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %71 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %72 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %73 = llvm.mlir.constant(1 : i64) : i64
  %74 = llvm.getelementptr %72[%73] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %75 = llvm.ptrtoint %74 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %76 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %77 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %78 = llvm.mlir.constant(1 : i64) : i64
  %79 = llvm.getelementptr %77[%78] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %80 = llvm.ptrtoint %79 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %81 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %82 = llvm.icmp "ult" %76, %81 : i64
  %83 = llvm.select %82, %76, %81 : i1, i64
  %84 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%70, %71, %83, %84) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%69, %68) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %85 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %86 = ts.Load(%69) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %87 = ts.CreateUnionInstance %62, %64 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
  %88 = ts.Cast %60 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  llvm.store %85, %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  ts.Store %88, %35 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %89 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %90 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %91 = llvm.extractvalue %89[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
  %92 = ts.GetTypeInfoFromUnionOp %90 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %93 = llvm.mlir.constant(0 : i64) : i64
  %94 = llvm.ptrtoint %91 : !llvm.ptr<i8> to i64
  %95 = llvm.ptrtoint %24 : !llvm.ptr<i8> to i64
  %96 = llvm.icmp "ne" %94, %93 : i64
  %97 = llvm.icmp "ne" %95, %93 : i64
  %98 = llvm.zext %96 : i1 to i32
  %99 = zexti %96 : i1 to i32
  %100 = ts.Cast %96 : i1 to i32
  %101 = llvm.zext %97 : i1 to i32
  %102 = zexti %97 : i1 to i32
  %103 = ts.Cast %97 : i1 to i32
  %104 = llvm.and %100, %103  : i32
  %105 = llvm.mlir.constant(0 : i32) : i32
  %106 = llvm.icmp "ne" %104, %105 : i32
  llvm.cond_br %106, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %107 = llvm.mlir.constant(0 : i32) : i32
  %108 = llvm.call @strcmp(%91, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %109 = llvm.icmp "eq" %108, %107 : i32
  llvm.br ^bb3(%109 : i1)
^bb2:  // pred: ^bb0
  %110 = llvm.icmp "eq" %94, %95 : i64
  llvm.br ^bb3(%110 : i1)
^bb3(%111: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %112 = "ts.StringCompare"(%91, %24) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %113 = ts.LogicalBinary %92(34) %25 : !ts.string, !ts.string -> !ts.boolean
  %114 = ts.Cast %113 : !ts.boolean to i1
  llvm.cond_br %111, ^bb5, ^bb6
  cond_br %114, ^bb5, ^bb6
^bb5:  // 2 preds: ^bb4, ^bb4
  %115 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %116 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  llvm.store %115, %3 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %117 = ts.Variable(%115) {false} : !llvm.struct<(ptr<i8>, i1)> -> !ts.ref<!llvm.struct<(ptr<i8>, i1)>>
  %118 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %119 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %120 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %121 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %122 = llvm.mlir.constant(1 : i64) : i64
  %123 = llvm.getelementptr %121[%122] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %124 = llvm.ptrtoint %123 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %125 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %126 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %127 = llvm.mlir.constant(1 : i64) : i64
  %128 = llvm.getelementptr %126[%127] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %129 = llvm.ptrtoint %128 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %130 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %131 = llvm.icmp "ult" %125, %130 : i64
  %132 = llvm.select %131, %125, %130 : i1, i64
  %133 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%119, %120, %132, %133) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%118, %117) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, i1)>>) -> ()
  %134 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %135 = ts.Load(%118) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
  %136 = llvm.extractvalue %135[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %137 = ts.GetValueFromUnionOp %116 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %138 = ts.Cast %137 : !ts.number to !ts.string
  ts.Print(%29, %138) : !ts.string, !ts.string
  br ^bb6
^bb6:  // 3 preds: ^bb4, ^bb4, ^bb5
  %139 = llvm.call @puts(%32) : (!llvm.ptr<i8>) -> i32
  ts.Print(%33) : !ts.string
  llvm.return
  ts.ReturnInternal
}


    } -> SUCCESS
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.extractvalue'(0x278e9430a40) {
      %137 = "llvm.extractvalue"(%136) {position = [1 : i32]} : (!llvm.struct<(ptr<i8>, f64)>) -> f64

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %12 = llvm.mlir.constant(1 : i32) : i32
  %13 = llvm.alloca %12 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %14 = llvm.mlir.constant(1 : i32) : i32
  %15 = llvm.alloca %14 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %16 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %17 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "number"} : !ts.string
  %22 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "number"} : !ts.string
  %26 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %27 = llvm.mlir.constant(0 : i64) : i64
  %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %29 = ts.Constant {value = "b number: "} : !ts.string
  %30 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %31 = llvm.mlir.constant(0 : i64) : i64
  %32 = llvm.getelementptr %30[%31, %31] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %33 = ts.Constant {value = "done."} : !ts.string
  %34 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %35 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %36 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %37 = llvm.insertvalue %21, %36[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %38 = llvm.insertvalue %17, %37[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %38, %11 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %39 = ts.Variable(%38) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %40 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %41 = llvm.bitcast %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %42 = llvm.bitcast %11 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %43 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %44 = llvm.mlir.constant(1 : i64) : i64
  %45 = llvm.getelementptr %43[%44] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %46 = llvm.ptrtoint %45 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %47 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %48 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %49 = llvm.mlir.constant(1 : i64) : i64
  %50 = llvm.getelementptr %48[%49] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %51 = llvm.ptrtoint %50 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %52 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %53 = llvm.icmp "ult" %47, %52 : i64
  %54 = llvm.select %53, %47, %52 : i1, i64
  %55 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%41, %42, %54, %55) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%40, %39) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %56 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %57 = ts.Load(%40) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %58 = ts.CreateUnionInstance %17, %21 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %56, %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %58, %34 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %59 = llvm.load %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %60 = ts.Load(%34) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %61 = llvm.extractvalue %59[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %62 = ts.GetValueFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %63 = llvm.extractvalue %59[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %64 = ts.GetTypeInfoFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %65 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %66 = llvm.insertvalue %64, %65[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %67 = llvm.insertvalue %62, %66[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  llvm.store %67, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %68 = ts.Variable(%67) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %69 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %70 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %71 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %72 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %73 = llvm.mlir.constant(1 : i64) : i64
  %74 = llvm.getelementptr %72[%73] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %75 = llvm.ptrtoint %74 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %76 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %77 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %78 = llvm.mlir.constant(1 : i64) : i64
  %79 = llvm.getelementptr %77[%78] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %80 = llvm.ptrtoint %79 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %81 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %82 = llvm.icmp "ult" %76, %81 : i64
  %83 = llvm.select %82, %76, %81 : i1, i64
  %84 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%70, %71, %83, %84) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%69, %68) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %85 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %86 = ts.Load(%69) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %87 = ts.CreateUnionInstance %62, %64 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
  %88 = ts.Cast %60 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  llvm.store %85, %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  ts.Store %88, %35 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %89 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %90 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %91 = llvm.extractvalue %89[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
  %92 = ts.GetTypeInfoFromUnionOp %90 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %93 = llvm.mlir.constant(0 : i64) : i64
  %94 = llvm.ptrtoint %91 : !llvm.ptr<i8> to i64
  %95 = llvm.ptrtoint %24 : !llvm.ptr<i8> to i64
  %96 = llvm.icmp "ne" %94, %93 : i64
  %97 = llvm.icmp "ne" %95, %93 : i64
  %98 = llvm.zext %96 : i1 to i32
  %99 = zexti %96 : i1 to i32
  %100 = ts.Cast %96 : i1 to i32
  %101 = llvm.zext %97 : i1 to i32
  %102 = zexti %97 : i1 to i32
  %103 = ts.Cast %97 : i1 to i32
  %104 = llvm.and %100, %103  : i32
  %105 = llvm.mlir.constant(0 : i32) : i32
  %106 = llvm.icmp "ne" %104, %105 : i32
  llvm.cond_br %106, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %107 = llvm.mlir.constant(0 : i32) : i32
  %108 = llvm.call @strcmp(%91, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %109 = llvm.icmp "eq" %108, %107 : i32
  llvm.br ^bb3(%109 : i1)
^bb2:  // pred: ^bb0
  %110 = llvm.icmp "eq" %94, %95 : i64
  llvm.br ^bb3(%110 : i1)
^bb3(%111: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %112 = "ts.StringCompare"(%91, %24) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %113 = ts.LogicalBinary %92(34) %25 : !ts.string, !ts.string -> !ts.boolean
  %114 = ts.Cast %113 : !ts.boolean to i1
  llvm.cond_br %111, ^bb5, ^bb6
  cond_br %114, ^bb5, ^bb6
^bb5:  // 2 preds: ^bb4, ^bb4
  %115 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %116 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  llvm.store %115, %3 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %117 = ts.Variable(%115) {false} : !llvm.struct<(ptr<i8>, i1)> -> !ts.ref<!llvm.struct<(ptr<i8>, i1)>>
  %118 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %119 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %120 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %121 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %122 = llvm.mlir.constant(1 : i64) : i64
  %123 = llvm.getelementptr %121[%122] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %124 = llvm.ptrtoint %123 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %125 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %126 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %127 = llvm.mlir.constant(1 : i64) : i64
  %128 = llvm.getelementptr %126[%127] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %129 = llvm.ptrtoint %128 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %130 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %131 = llvm.icmp "ult" %125, %130 : i64
  %132 = llvm.select %131, %125, %130 : i1, i64
  %133 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%119, %120, %132, %133) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%118, %117) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, i1)>>) -> ()
  %134 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %135 = ts.Load(%118) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
  %136 = llvm.extractvalue %135[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %137 = ts.GetValueFromUnionOp %116 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %138 = ts.Cast %137 : !ts.number to !ts.string
  ts.Print(%29, %138) : !ts.string, !ts.string
  br ^bb6
^bb6:  // 3 preds: ^bb4, ^bb4, ^bb5
  %139 = llvm.call @puts(%32) : (!llvm.ptr<i8>) -> i32
  ts.Print(%33) : !ts.string
  llvm.return
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Cast'(0x278e942e4c0) {
  %139 = "ts.Cast"(%138) : (!ts.number) -> !ts.string

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.Cast -> ()' {
Trying to match "`anonymous-namespace'::CastOpLowering"
    ** Insert  : 'llvm.func'(0x278e9513d70)
    ** Insert  : 'llvm.mlir.constant'(0x278e94d71a0)
    ** Insert  : 'std.zexti'(0x278e94302c0)
    ** Insert  : 'llvm.call'(0x278e9430bc0)
    ** Insert  : 'llvm.bitcast'(0x278e9430c80)
    ** Insert  : 'llvm.mlir.global'(0x278e9514f50)
    ** Insert  : 'llvm.mlir.addressof'(0x278e94d7600)
    ** Insert  : 'llvm.mlir.constant'(0x278e94d60c0)
    ** Insert  : 'llvm.getelementptr'(0x278e9393130)
    ** Insert  : 'llvm.call'(0x278e9412db0)
    ** Replace : 'ts.Cast'(0x278e942e4c0)
"`anonymous-namespace'::CastOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x278e9513d70) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.mlir.constant'(0x278e94d71a0) {
      %139 = "llvm.mlir.constant"() {value = 50 : i32} : () -> i32

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'std.zexti'(0x278e94302c0) {
      %140 = "std.zexti"(%139) : (i32) -> i64

      * Fold {
      } -> FAILURE : unable to fold

      * Pattern : 'std.zexti -> ()' {
Trying to match "mlir::VectorConvertToLLVMPattern<class mlir::ZeroExtendIOp,class mlir::LLVM::ZExtOp>"
        ** Insert  : 'llvm.zext'(0x278e9430e00)
        ** Replace : 'std.zexti'(0x278e94302c0)
"mlir::VectorConvertToLLVMPattern<class mlir::ZeroExtendIOp,class mlir::LLVM::ZExtOp>" result 1

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.zext'(0x278e9430e00) {
          %140 = "llvm.zext"(%139) : (i32) -> i64

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//
      } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %12 = llvm.mlir.constant(1 : i32) : i32
  %13 = llvm.alloca %12 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %14 = llvm.mlir.constant(1 : i32) : i32
  %15 = llvm.alloca %14 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %16 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %17 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "number"} : !ts.string
  %22 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "number"} : !ts.string
  %26 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %27 = llvm.mlir.constant(0 : i64) : i64
  %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %29 = ts.Constant {value = "b number: "} : !ts.string
  %30 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %31 = llvm.mlir.constant(0 : i64) : i64
  %32 = llvm.getelementptr %30[%31, %31] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %33 = ts.Constant {value = "done."} : !ts.string
  %34 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %35 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %36 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %37 = llvm.insertvalue %21, %36[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %38 = llvm.insertvalue %17, %37[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %38, %11 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %39 = ts.Variable(%38) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %40 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %41 = llvm.bitcast %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %42 = llvm.bitcast %11 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %43 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %44 = llvm.mlir.constant(1 : i64) : i64
  %45 = llvm.getelementptr %43[%44] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %46 = llvm.ptrtoint %45 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %47 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %48 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %49 = llvm.mlir.constant(1 : i64) : i64
  %50 = llvm.getelementptr %48[%49] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %51 = llvm.ptrtoint %50 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %52 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %53 = llvm.icmp "ult" %47, %52 : i64
  %54 = llvm.select %53, %47, %52 : i1, i64
  %55 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%41, %42, %54, %55) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%40, %39) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %56 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %57 = ts.Load(%40) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %58 = ts.CreateUnionInstance %17, %21 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %56, %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %58, %34 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %59 = llvm.load %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %60 = ts.Load(%34) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %61 = llvm.extractvalue %59[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %62 = ts.GetValueFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %63 = llvm.extractvalue %59[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %64 = ts.GetTypeInfoFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %65 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %66 = llvm.insertvalue %64, %65[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %67 = llvm.insertvalue %62, %66[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  llvm.store %67, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %68 = ts.Variable(%67) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %69 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %70 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %71 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %72 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %73 = llvm.mlir.constant(1 : i64) : i64
  %74 = llvm.getelementptr %72[%73] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %75 = llvm.ptrtoint %74 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %76 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %77 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %78 = llvm.mlir.constant(1 : i64) : i64
  %79 = llvm.getelementptr %77[%78] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %80 = llvm.ptrtoint %79 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %81 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %82 = llvm.icmp "ult" %76, %81 : i64
  %83 = llvm.select %82, %76, %81 : i1, i64
  %84 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%70, %71, %83, %84) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%69, %68) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %85 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %86 = ts.Load(%69) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %87 = ts.CreateUnionInstance %62, %64 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
  %88 = ts.Cast %60 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  llvm.store %85, %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  ts.Store %88, %35 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %89 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %90 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %91 = llvm.extractvalue %89[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
  %92 = ts.GetTypeInfoFromUnionOp %90 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %93 = llvm.mlir.constant(0 : i64) : i64
  %94 = llvm.ptrtoint %91 : !llvm.ptr<i8> to i64
  %95 = llvm.ptrtoint %24 : !llvm.ptr<i8> to i64
  %96 = llvm.icmp "ne" %94, %93 : i64
  %97 = llvm.icmp "ne" %95, %93 : i64
  %98 = llvm.zext %96 : i1 to i32
  %99 = zexti %96 : i1 to i32
  %100 = ts.Cast %96 : i1 to i32
  %101 = llvm.zext %97 : i1 to i32
  %102 = zexti %97 : i1 to i32
  %103 = ts.Cast %97 : i1 to i32
  %104 = llvm.and %100, %103  : i32
  %105 = llvm.mlir.constant(0 : i32) : i32
  %106 = llvm.icmp "ne" %104, %105 : i32
  llvm.cond_br %106, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %107 = llvm.mlir.constant(0 : i32) : i32
  %108 = llvm.call @strcmp(%91, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %109 = llvm.icmp "eq" %108, %107 : i32
  llvm.br ^bb3(%109 : i1)
^bb2:  // pred: ^bb0
  %110 = llvm.icmp "eq" %94, %95 : i64
  llvm.br ^bb3(%110 : i1)
^bb3(%111: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %112 = "ts.StringCompare"(%91, %24) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %113 = ts.LogicalBinary %92(34) %25 : !ts.string, !ts.string -> !ts.boolean
  %114 = ts.Cast %113 : !ts.boolean to i1
  llvm.cond_br %111, ^bb5, ^bb6
  cond_br %114, ^bb5, ^bb6
^bb5:  // 2 preds: ^bb4, ^bb4
  %115 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %116 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  llvm.store %115, %3 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %117 = ts.Variable(%115) {false} : !llvm.struct<(ptr<i8>, i1)> -> !ts.ref<!llvm.struct<(ptr<i8>, i1)>>
  %118 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %119 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %120 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %121 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %122 = llvm.mlir.constant(1 : i64) : i64
  %123 = llvm.getelementptr %121[%122] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %124 = llvm.ptrtoint %123 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %125 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %126 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %127 = llvm.mlir.constant(1 : i64) : i64
  %128 = llvm.getelementptr %126[%127] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %129 = llvm.ptrtoint %128 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %130 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %131 = llvm.icmp "ult" %125, %130 : i64
  %132 = llvm.select %131, %125, %130 : i1, i64
  %133 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%119, %120, %132, %133) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%118, %117) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, i1)>>) -> ()
  %134 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %135 = ts.Load(%118) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
  %136 = llvm.extractvalue %135[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %137 = ts.GetValueFromUnionOp %116 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %138 = llvm.mlir.constant(50 : i32) : i32
  %139 = llvm.zext %138 : i32 to i64
  %140 = zexti %138 : i32 to i64
  %141 = llvm.call @malloc(%140) : (i64) -> !llvm.ptr<i8>
  %142 = llvm.bitcast %141 : !llvm.ptr<i8> to !llvm.ptr<i8>
  %143 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
  %144 = llvm.mlir.constant(0 : i64) : i64
  %145 = llvm.getelementptr %143[%144, %144] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %146 = llvm.call @sprintf_s(%142, %138, %145, %136) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
  %147 = ts.Cast %137 : !ts.number to !ts.string
  ts.Print(%29, %147) : !ts.string, !ts.string
  br ^bb6
^bb6:  // 3 preds: ^bb4, ^bb4, ^bb5
  %148 = llvm.call @puts(%32) : (!llvm.ptr<i8>) -> i32
  ts.Print(%33) : !ts.string
  llvm.return
  ts.ReturnInternal
}


    } -> SUCCESS
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.call'(0x278e9430bc0) {
      %142 = "llvm.call"(%141) {callee = @malloc} : (i64) -> !llvm.ptr<i8>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.bitcast'(0x278e9430c80) {
      %143 = "llvm.bitcast"(%142) : (!llvm.ptr<i8>) -> !llvm.ptr<i8>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.mlir.global'(0x278e9514f50) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.mlir.addressof'(0x278e94d7600) {
      %144 = "llvm.mlir.addressof"() {global_name = @frmt_555404038213028357} : () -> !llvm.ptr<array<3 x i8>>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.mlir.constant'(0x278e94d60c0) {
      %145 = "llvm.mlir.constant"() {value = 0 : i64} : () -> i64

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.getelementptr'(0x278e9393130) {
      %146 = "llvm.getelementptr"(%144, %145, %145) : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.call'(0x278e9412db0) {
      %147 = "llvm.call"(%143, %139, %146, %137) {callee = @sprintf_s} : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %12 = llvm.mlir.constant(1 : i32) : i32
  %13 = llvm.alloca %12 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %14 = llvm.mlir.constant(1 : i32) : i32
  %15 = llvm.alloca %14 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %16 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %17 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "number"} : !ts.string
  %22 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "number"} : !ts.string
  %26 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %27 = llvm.mlir.constant(0 : i64) : i64
  %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %29 = ts.Constant {value = "b number: "} : !ts.string
  %30 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %31 = llvm.mlir.constant(0 : i64) : i64
  %32 = llvm.getelementptr %30[%31, %31] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %33 = ts.Constant {value = "done."} : !ts.string
  %34 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %35 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %36 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %37 = llvm.insertvalue %21, %36[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %38 = llvm.insertvalue %17, %37[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %38, %11 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %39 = ts.Variable(%38) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %40 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %41 = llvm.bitcast %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %42 = llvm.bitcast %11 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %43 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %44 = llvm.mlir.constant(1 : i64) : i64
  %45 = llvm.getelementptr %43[%44] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %46 = llvm.ptrtoint %45 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %47 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %48 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %49 = llvm.mlir.constant(1 : i64) : i64
  %50 = llvm.getelementptr %48[%49] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %51 = llvm.ptrtoint %50 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %52 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %53 = llvm.icmp "ult" %47, %52 : i64
  %54 = llvm.select %53, %47, %52 : i1, i64
  %55 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%41, %42, %54, %55) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%40, %39) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %56 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %57 = ts.Load(%40) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %58 = ts.CreateUnionInstance %17, %21 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %56, %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %58, %34 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %59 = llvm.load %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %60 = ts.Load(%34) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %61 = llvm.extractvalue %59[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %62 = ts.GetValueFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %63 = llvm.extractvalue %59[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %64 = ts.GetTypeInfoFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %65 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %66 = llvm.insertvalue %64, %65[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %67 = llvm.insertvalue %62, %66[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  llvm.store %67, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %68 = ts.Variable(%67) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %69 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %70 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %71 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %72 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %73 = llvm.mlir.constant(1 : i64) : i64
  %74 = llvm.getelementptr %72[%73] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %75 = llvm.ptrtoint %74 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %76 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %77 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %78 = llvm.mlir.constant(1 : i64) : i64
  %79 = llvm.getelementptr %77[%78] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %80 = llvm.ptrtoint %79 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %81 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %82 = llvm.icmp "ult" %76, %81 : i64
  %83 = llvm.select %82, %76, %81 : i1, i64
  %84 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%70, %71, %83, %84) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%69, %68) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %85 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %86 = ts.Load(%69) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %87 = ts.CreateUnionInstance %62, %64 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
  %88 = ts.Cast %60 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  llvm.store %85, %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  ts.Store %88, %35 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %89 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %90 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %91 = llvm.extractvalue %89[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
  %92 = ts.GetTypeInfoFromUnionOp %90 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %93 = llvm.mlir.constant(0 : i64) : i64
  %94 = llvm.ptrtoint %91 : !llvm.ptr<i8> to i64
  %95 = llvm.ptrtoint %24 : !llvm.ptr<i8> to i64
  %96 = llvm.icmp "ne" %94, %93 : i64
  %97 = llvm.icmp "ne" %95, %93 : i64
  %98 = llvm.zext %96 : i1 to i32
  %99 = zexti %96 : i1 to i32
  %100 = ts.Cast %96 : i1 to i32
  %101 = llvm.zext %97 : i1 to i32
  %102 = zexti %97 : i1 to i32
  %103 = ts.Cast %97 : i1 to i32
  %104 = llvm.and %100, %103  : i32
  %105 = llvm.mlir.constant(0 : i32) : i32
  %106 = llvm.icmp "ne" %104, %105 : i32
  llvm.cond_br %106, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %107 = llvm.mlir.constant(0 : i32) : i32
  %108 = llvm.call @strcmp(%91, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %109 = llvm.icmp "eq" %108, %107 : i32
  llvm.br ^bb3(%109 : i1)
^bb2:  // pred: ^bb0
  %110 = llvm.icmp "eq" %94, %95 : i64
  llvm.br ^bb3(%110 : i1)
^bb3(%111: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %112 = "ts.StringCompare"(%91, %24) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %113 = ts.LogicalBinary %92(34) %25 : !ts.string, !ts.string -> !ts.boolean
  %114 = ts.Cast %113 : !ts.boolean to i1
  llvm.cond_br %111, ^bb5, ^bb6
  cond_br %114, ^bb5, ^bb6
^bb5:  // 2 preds: ^bb4, ^bb4
  %115 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %116 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  llvm.store %115, %3 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %117 = ts.Variable(%115) {false} : !llvm.struct<(ptr<i8>, i1)> -> !ts.ref<!llvm.struct<(ptr<i8>, i1)>>
  %118 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %119 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %120 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %121 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %122 = llvm.mlir.constant(1 : i64) : i64
  %123 = llvm.getelementptr %121[%122] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %124 = llvm.ptrtoint %123 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %125 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %126 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %127 = llvm.mlir.constant(1 : i64) : i64
  %128 = llvm.getelementptr %126[%127] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %129 = llvm.ptrtoint %128 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %130 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %131 = llvm.icmp "ult" %125, %130 : i64
  %132 = llvm.select %131, %125, %130 : i1, i64
  %133 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%119, %120, %132, %133) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%118, %117) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, i1)>>) -> ()
  %134 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %135 = ts.Load(%118) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
  %136 = llvm.extractvalue %135[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %137 = ts.GetValueFromUnionOp %116 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %138 = llvm.mlir.constant(50 : i32) : i32
  %139 = llvm.zext %138 : i32 to i64
  %140 = zexti %138 : i32 to i64
  %141 = llvm.call @malloc(%140) : (i64) -> !llvm.ptr<i8>
  %142 = llvm.bitcast %141 : !llvm.ptr<i8> to !llvm.ptr<i8>
  %143 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
  %144 = llvm.mlir.constant(0 : i64) : i64
  %145 = llvm.getelementptr %143[%144, %144] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %146 = llvm.call @sprintf_s(%142, %138, %145, %136) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
  %147 = ts.Cast %137 : !ts.number to !ts.string
  ts.Print(%29, %147) : !ts.string, !ts.string
  br ^bb6
^bb6:  // 3 preds: ^bb4, ^bb4, ^bb5
  %148 = llvm.call @puts(%32) : (!llvm.ptr<i8>) -> i32
  ts.Print(%33) : !ts.string
  llvm.return
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'ts.Print'(0x278e9475fe0) {
  "ts.Print"(%30, %148) : (!ts.string, !ts.string) -> ()

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.Print -> ()' {
Trying to match "`anonymous-namespace'::PrintOpLowering"
    ** Insert  : 'ts.Constant'(0x278e94d63e0)
    ** Insert  : 'llvm.intr.stacksave'(0x278e94d7380)
    ** Insert  : 'ts.StringConcat'(0x278e9393a30)
    ** Insert  : 'llvm.call'(0x278e9433500)
    ** Insert  : 'llvm.intr.stackrestore'(0x278e9514df0)
    ** Erase   : 'ts.Print'(0x278e9475fe0)
"`anonymous-namespace'::PrintOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'ts.Constant'(0x278e94d63e0) {
      %149 = "ts.Constant"() {value = " "} : () -> !ts.string

      * Fold {
      } -> FAILURE : unable to fold

      * Pattern : 'ts.Constant -> ()' {
Trying to match "`anonymous-namespace'::ConstantOpLowering"
        ** Insert  : 'llvm.mlir.global'(0x278e9512ae0)
        ** Insert  : 'llvm.mlir.addressof'(0x278e94d5c60)
        ** Insert  : 'llvm.mlir.constant'(0x278e94d7240)
        ** Insert  : 'llvm.getelementptr'(0x278e9391630)
        ** Replace : 'ts.Constant'(0x278e94d63e0)
"`anonymous-namespace'::ConstantOpLowering" result 1

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.mlir.global'(0x278e9512ae0) {
        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.mlir.addressof'(0x278e94d5c60) {
          %149 = "llvm.mlir.addressof"() {global_name = @s_12638117931323064703} : () -> !llvm.ptr<array<2 x i8>>

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.mlir.constant'(0x278e94d7240) {
          %150 = "llvm.mlir.constant"() {value = 0 : i64} : () -> i64

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.getelementptr'(0x278e9391630) {
          %151 = "llvm.getelementptr"(%149, %150, %150) : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//
      } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %12 = llvm.mlir.constant(1 : i32) : i32
  %13 = llvm.alloca %12 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %14 = llvm.mlir.constant(1 : i32) : i32
  %15 = llvm.alloca %14 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %16 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %17 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "number"} : !ts.string
  %22 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "number"} : !ts.string
  %26 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %27 = llvm.mlir.constant(0 : i64) : i64
  %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %29 = ts.Constant {value = "b number: "} : !ts.string
  %30 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %31 = llvm.mlir.constant(0 : i64) : i64
  %32 = llvm.getelementptr %30[%31, %31] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %33 = ts.Constant {value = "done."} : !ts.string
  %34 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %35 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %36 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %37 = llvm.insertvalue %21, %36[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %38 = llvm.insertvalue %17, %37[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %38, %11 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %39 = ts.Variable(%38) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %40 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %41 = llvm.bitcast %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %42 = llvm.bitcast %11 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %43 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %44 = llvm.mlir.constant(1 : i64) : i64
  %45 = llvm.getelementptr %43[%44] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %46 = llvm.ptrtoint %45 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %47 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %48 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %49 = llvm.mlir.constant(1 : i64) : i64
  %50 = llvm.getelementptr %48[%49] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %51 = llvm.ptrtoint %50 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %52 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %53 = llvm.icmp "ult" %47, %52 : i64
  %54 = llvm.select %53, %47, %52 : i1, i64
  %55 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%41, %42, %54, %55) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%40, %39) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %56 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %57 = ts.Load(%40) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %58 = ts.CreateUnionInstance %17, %21 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %56, %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %58, %34 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %59 = llvm.load %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %60 = ts.Load(%34) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %61 = llvm.extractvalue %59[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %62 = ts.GetValueFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %63 = llvm.extractvalue %59[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %64 = ts.GetTypeInfoFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %65 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %66 = llvm.insertvalue %64, %65[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %67 = llvm.insertvalue %62, %66[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  llvm.store %67, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %68 = ts.Variable(%67) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %69 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %70 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %71 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %72 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %73 = llvm.mlir.constant(1 : i64) : i64
  %74 = llvm.getelementptr %72[%73] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %75 = llvm.ptrtoint %74 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %76 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %77 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %78 = llvm.mlir.constant(1 : i64) : i64
  %79 = llvm.getelementptr %77[%78] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %80 = llvm.ptrtoint %79 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %81 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %82 = llvm.icmp "ult" %76, %81 : i64
  %83 = llvm.select %82, %76, %81 : i1, i64
  %84 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%70, %71, %83, %84) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%69, %68) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %85 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %86 = ts.Load(%69) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %87 = ts.CreateUnionInstance %62, %64 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
  %88 = ts.Cast %60 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  llvm.store %85, %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  ts.Store %88, %35 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %89 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %90 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %91 = llvm.extractvalue %89[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
  %92 = ts.GetTypeInfoFromUnionOp %90 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %93 = llvm.mlir.constant(0 : i64) : i64
  %94 = llvm.ptrtoint %91 : !llvm.ptr<i8> to i64
  %95 = llvm.ptrtoint %24 : !llvm.ptr<i8> to i64
  %96 = llvm.icmp "ne" %94, %93 : i64
  %97 = llvm.icmp "ne" %95, %93 : i64
  %98 = llvm.zext %96 : i1 to i32
  %99 = zexti %96 : i1 to i32
  %100 = ts.Cast %96 : i1 to i32
  %101 = llvm.zext %97 : i1 to i32
  %102 = zexti %97 : i1 to i32
  %103 = ts.Cast %97 : i1 to i32
  %104 = llvm.and %100, %103  : i32
  %105 = llvm.mlir.constant(0 : i32) : i32
  %106 = llvm.icmp "ne" %104, %105 : i32
  llvm.cond_br %106, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %107 = llvm.mlir.constant(0 : i32) : i32
  %108 = llvm.call @strcmp(%91, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %109 = llvm.icmp "eq" %108, %107 : i32
  llvm.br ^bb3(%109 : i1)
^bb2:  // pred: ^bb0
  %110 = llvm.icmp "eq" %94, %95 : i64
  llvm.br ^bb3(%110 : i1)
^bb3(%111: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %112 = "ts.StringCompare"(%91, %24) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %113 = ts.LogicalBinary %92(34) %25 : !ts.string, !ts.string -> !ts.boolean
  %114 = ts.Cast %113 : !ts.boolean to i1
  llvm.cond_br %111, ^bb5, ^bb6
  cond_br %114, ^bb5, ^bb6
^bb5:  // 2 preds: ^bb4, ^bb4
  %115 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %116 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  llvm.store %115, %3 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %117 = ts.Variable(%115) {false} : !llvm.struct<(ptr<i8>, i1)> -> !ts.ref<!llvm.struct<(ptr<i8>, i1)>>
  %118 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %119 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %120 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %121 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %122 = llvm.mlir.constant(1 : i64) : i64
  %123 = llvm.getelementptr %121[%122] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %124 = llvm.ptrtoint %123 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %125 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %126 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %127 = llvm.mlir.constant(1 : i64) : i64
  %128 = llvm.getelementptr %126[%127] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %129 = llvm.ptrtoint %128 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %130 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %131 = llvm.icmp "ult" %125, %130 : i64
  %132 = llvm.select %131, %125, %130 : i1, i64
  %133 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%119, %120, %132, %133) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%118, %117) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, i1)>>) -> ()
  %134 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %135 = ts.Load(%118) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
  %136 = llvm.extractvalue %135[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %137 = ts.GetValueFromUnionOp %116 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %138 = llvm.mlir.constant(50 : i32) : i32
  %139 = llvm.zext %138 : i32 to i64
  %140 = zexti %138 : i32 to i64
  %141 = llvm.call @malloc(%140) : (i64) -> !llvm.ptr<i8>
  %142 = llvm.bitcast %141 : !llvm.ptr<i8> to !llvm.ptr<i8>
  %143 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
  %144 = llvm.mlir.constant(0 : i64) : i64
  %145 = llvm.getelementptr %143[%144, %144] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %146 = llvm.call @sprintf_s(%142, %138, %145, %136) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
  %147 = ts.Cast %137 : !ts.number to !ts.string
  %148 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
  %149 = llvm.mlir.constant(0 : i64) : i64
  %150 = llvm.getelementptr %148[%149, %149] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %151 = ts.Constant {value = " "} : !ts.string
  %152 = llvm.intr.stacksave : !llvm.ptr<i8>
  %153 = "ts.StringConcat"(%28, %151, %142) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
  %154 = llvm.call @puts(%153) : (!ts.string) -> i32
  llvm.intr.stackrestore %152
  ts.Print(%29, %147) : !ts.string, !ts.string
  br ^bb6
^bb6:  // 3 preds: ^bb4, ^bb4, ^bb5
  %155 = llvm.call @puts(%32) : (!llvm.ptr<i8>) -> i32
  ts.Print(%33) : !ts.string
  llvm.return
  ts.ReturnInternal
}


    } -> SUCCESS
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.intr.stacksave'(0x278e94d7380) {
      %153 = "llvm.intr.stacksave"() : () -> !llvm.ptr<i8>

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'ts.StringConcat'(0x278e9393a30) {
      %154 = "ts.StringConcat"(%29, %152, %143) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string

      * Fold {
      } -> FAILURE : unable to fold

      * Pattern : 'ts.StringConcat -> ()' {
Trying to match "`anonymous-namespace'::StringConcatOpLowering"
        ** Insert  : 'llvm.func'(0x278e9514870)
        ** Insert  : 'llvm.func'(0x278e9513c10)
        ** Insert  : 'llvm.func'(0x278e9513530)
        ** Insert  : 'llvm.mlir.constant'(0x278e94d7420)
        ** Insert  : 'llvm.call'(0x278e9433980)
        ** Insert  : 'llvm.add'(0x278e9546c80)
        ** Insert  : 'llvm.call'(0x278e9433740)
        ** Insert  : 'llvm.add'(0x278e9544ec0)
        ** Insert  : 'llvm.call'(0x278e9433440)
        ** Insert  : 'llvm.add'(0x278e9546740)
        ** Insert  : 'llvm.alloca'(0x278e9432240)
        ** Insert  : 'llvm.call'(0x278e95470e0)
        ** Insert  : 'llvm.call'(0x278e95472a0)
        ** Insert  : 'llvm.call'(0x278e9547380)
        ** Replace : 'ts.StringConcat'(0x278e9393a30)
"`anonymous-namespace'::StringConcatOpLowering" result 1

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.func'(0x278e9514870) {
        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.func'(0x278e9513c10) {
        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.func'(0x278e9513530) {
        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.mlir.constant'(0x278e94d7420) {
          %154 = "llvm.mlir.constant"() {value = 1 : i64} : () -> i64

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.call'(0x278e9433980) {
          %155 = "llvm.call"(%29) {callee = @strlen} : (!llvm.ptr<i8>) -> i64

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.add'(0x278e9546c80) {
          %156 = "llvm.add"(%154, %155) : (i64, i64) -> i64

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.call'(0x278e9433740) {
          %157 = "llvm.call"(%151) {callee = @strlen} : (!llvm.ptr<i8>) -> i64

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.add'(0x278e9544ec0) {
          %158 = "llvm.add"(%156, %157) : (i64, i64) -> i64

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.call'(0x278e9433440) {
          %159 = "llvm.call"(%143) {callee = @strlen} : (!llvm.ptr<i8>) -> i64

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.add'(0x278e9546740) {
          %160 = "llvm.add"(%158, %159) : (i64, i64) -> i64

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.alloca'(0x278e9432240) {
          %161 = "llvm.alloca"(%160) {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.call'(0x278e95470e0) {
          %162 = "llvm.call"(%161, %29) {callee = @strcpy} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.call'(0x278e95472a0) {
          %163 = "llvm.call"(%162, %151) {callee = @strcat} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//

        //===-------------------------------------------===//
        Legalizing operation : 'llvm.call'(0x278e9547380) {
          %164 = "llvm.call"(%163, %143) {callee = @strcat} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>

        } -> SUCCESS : operation marked legal by the target
        //===-------------------------------------------===//
      } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %12 = llvm.mlir.constant(1 : i32) : i32
  %13 = llvm.alloca %12 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %14 = llvm.mlir.constant(1 : i32) : i32
  %15 = llvm.alloca %14 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %16 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %17 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "number"} : !ts.string
  %22 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "number"} : !ts.string
  %26 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %27 = llvm.mlir.constant(0 : i64) : i64
  %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %29 = ts.Constant {value = "b number: "} : !ts.string
  %30 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %31 = llvm.mlir.constant(0 : i64) : i64
  %32 = llvm.getelementptr %30[%31, %31] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %33 = ts.Constant {value = "done."} : !ts.string
  %34 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %35 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %36 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %37 = llvm.insertvalue %21, %36[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %38 = llvm.insertvalue %17, %37[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %38, %11 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %39 = ts.Variable(%38) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %40 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %41 = llvm.bitcast %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %42 = llvm.bitcast %11 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %43 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %44 = llvm.mlir.constant(1 : i64) : i64
  %45 = llvm.getelementptr %43[%44] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %46 = llvm.ptrtoint %45 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %47 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %48 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %49 = llvm.mlir.constant(1 : i64) : i64
  %50 = llvm.getelementptr %48[%49] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %51 = llvm.ptrtoint %50 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %52 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %53 = llvm.icmp "ult" %47, %52 : i64
  %54 = llvm.select %53, %47, %52 : i1, i64
  %55 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%41, %42, %54, %55) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%40, %39) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %56 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %57 = ts.Load(%40) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %58 = ts.CreateUnionInstance %17, %21 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %56, %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %58, %34 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %59 = llvm.load %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %60 = ts.Load(%34) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %61 = llvm.extractvalue %59[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %62 = ts.GetValueFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %63 = llvm.extractvalue %59[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %64 = ts.GetTypeInfoFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %65 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %66 = llvm.insertvalue %64, %65[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %67 = llvm.insertvalue %62, %66[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  llvm.store %67, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %68 = ts.Variable(%67) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %69 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %70 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %71 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %72 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %73 = llvm.mlir.constant(1 : i64) : i64
  %74 = llvm.getelementptr %72[%73] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %75 = llvm.ptrtoint %74 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %76 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %77 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %78 = llvm.mlir.constant(1 : i64) : i64
  %79 = llvm.getelementptr %77[%78] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %80 = llvm.ptrtoint %79 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %81 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %82 = llvm.icmp "ult" %76, %81 : i64
  %83 = llvm.select %82, %76, %81 : i1, i64
  %84 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%70, %71, %83, %84) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%69, %68) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %85 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %86 = ts.Load(%69) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %87 = ts.CreateUnionInstance %62, %64 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
  %88 = ts.Cast %60 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  llvm.store %85, %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  ts.Store %88, %35 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %89 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %90 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %91 = llvm.extractvalue %89[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
  %92 = ts.GetTypeInfoFromUnionOp %90 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %93 = llvm.mlir.constant(0 : i64) : i64
  %94 = llvm.ptrtoint %91 : !llvm.ptr<i8> to i64
  %95 = llvm.ptrtoint %24 : !llvm.ptr<i8> to i64
  %96 = llvm.icmp "ne" %94, %93 : i64
  %97 = llvm.icmp "ne" %95, %93 : i64
  %98 = llvm.zext %96 : i1 to i32
  %99 = zexti %96 : i1 to i32
  %100 = ts.Cast %96 : i1 to i32
  %101 = llvm.zext %97 : i1 to i32
  %102 = zexti %97 : i1 to i32
  %103 = ts.Cast %97 : i1 to i32
  %104 = llvm.and %100, %103  : i32
  %105 = llvm.mlir.constant(0 : i32) : i32
  %106 = llvm.icmp "ne" %104, %105 : i32
  llvm.cond_br %106, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %107 = llvm.mlir.constant(0 : i32) : i32
  %108 = llvm.call @strcmp(%91, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %109 = llvm.icmp "eq" %108, %107 : i32
  llvm.br ^bb3(%109 : i1)
^bb2:  // pred: ^bb0
  %110 = llvm.icmp "eq" %94, %95 : i64
  llvm.br ^bb3(%110 : i1)
^bb3(%111: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %112 = "ts.StringCompare"(%91, %24) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %113 = ts.LogicalBinary %92(34) %25 : !ts.string, !ts.string -> !ts.boolean
  %114 = ts.Cast %113 : !ts.boolean to i1
  llvm.cond_br %111, ^bb5, ^bb6
  cond_br %114, ^bb5, ^bb6
^bb5:  // 2 preds: ^bb4, ^bb4
  %115 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %116 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  llvm.store %115, %3 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %117 = ts.Variable(%115) {false} : !llvm.struct<(ptr<i8>, i1)> -> !ts.ref<!llvm.struct<(ptr<i8>, i1)>>
  %118 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %119 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %120 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %121 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %122 = llvm.mlir.constant(1 : i64) : i64
  %123 = llvm.getelementptr %121[%122] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %124 = llvm.ptrtoint %123 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %125 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %126 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %127 = llvm.mlir.constant(1 : i64) : i64
  %128 = llvm.getelementptr %126[%127] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %129 = llvm.ptrtoint %128 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %130 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %131 = llvm.icmp "ult" %125, %130 : i64
  %132 = llvm.select %131, %125, %130 : i1, i64
  %133 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%119, %120, %132, %133) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%118, %117) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, i1)>>) -> ()
  %134 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %135 = ts.Load(%118) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
  %136 = llvm.extractvalue %135[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %137 = ts.GetValueFromUnionOp %116 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %138 = llvm.mlir.constant(50 : i32) : i32
  %139 = llvm.zext %138 : i32 to i64
  %140 = zexti %138 : i32 to i64
  %141 = llvm.call @malloc(%140) : (i64) -> !llvm.ptr<i8>
  %142 = llvm.bitcast %141 : !llvm.ptr<i8> to !llvm.ptr<i8>
  %143 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
  %144 = llvm.mlir.constant(0 : i64) : i64
  %145 = llvm.getelementptr %143[%144, %144] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %146 = llvm.call @sprintf_s(%142, %138, %145, %136) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
  %147 = ts.Cast %137 : !ts.number to !ts.string
  %148 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
  %149 = llvm.mlir.constant(0 : i64) : i64
  %150 = llvm.getelementptr %148[%149, %149] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %151 = ts.Constant {value = " "} : !ts.string
  %152 = llvm.intr.stacksave : !llvm.ptr<i8>
  %153 = llvm.mlir.constant(1 : i64) : i64
  %154 = llvm.call @strlen(%28) : (!llvm.ptr<i8>) -> i64
  %155 = llvm.add %153, %154  : i64
  %156 = llvm.call @strlen(%150) : (!llvm.ptr<i8>) -> i64
  %157 = llvm.add %155, %156  : i64
  %158 = llvm.call @strlen(%142) : (!llvm.ptr<i8>) -> i64
  %159 = llvm.add %157, %158  : i64
  %160 = llvm.alloca %159 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
  %161 = llvm.call @strcpy(%160, %28) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  %162 = llvm.call @strcat(%161, %150) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  %163 = llvm.call @strcat(%162, %142) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  %164 = "ts.StringConcat"(%28, %151, %142) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
  %165 = llvm.call @puts(%164) : (!ts.string) -> i32
  llvm.intr.stackrestore %152
  ts.Print(%29, %147) : !ts.string, !ts.string
  br ^bb6
^bb6:  // 3 preds: ^bb4, ^bb4, ^bb5
  %166 = llvm.call @puts(%32) : (!llvm.ptr<i8>) -> i32
  ts.Print(%33) : !ts.string
  llvm.return
  ts.ReturnInternal
}


    } -> SUCCESS
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.call'(0x278e9433500) {
      %166 = "llvm.call"(%165) {callee = @puts} : (!ts.string) -> i32

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.intr.stackrestore'(0x278e9514df0) {
      "llvm.intr.stackrestore"(%153) : (!llvm.ptr<i8>) -> ()

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %12 = llvm.mlir.constant(1 : i32) : i32
  %13 = llvm.alloca %12 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %14 = llvm.mlir.constant(1 : i32) : i32
  %15 = llvm.alloca %14 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %16 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %17 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "number"} : !ts.string
  %22 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "number"} : !ts.string
  %26 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %27 = llvm.mlir.constant(0 : i64) : i64
  %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %29 = ts.Constant {value = "b number: "} : !ts.string
  %30 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %31 = llvm.mlir.constant(0 : i64) : i64
  %32 = llvm.getelementptr %30[%31, %31] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %33 = ts.Constant {value = "done."} : !ts.string
  %34 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %35 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %36 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %37 = llvm.insertvalue %21, %36[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %38 = llvm.insertvalue %17, %37[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %38, %11 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %39 = ts.Variable(%38) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %40 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %41 = llvm.bitcast %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %42 = llvm.bitcast %11 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %43 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %44 = llvm.mlir.constant(1 : i64) : i64
  %45 = llvm.getelementptr %43[%44] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %46 = llvm.ptrtoint %45 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %47 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %48 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %49 = llvm.mlir.constant(1 : i64) : i64
  %50 = llvm.getelementptr %48[%49] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %51 = llvm.ptrtoint %50 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %52 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %53 = llvm.icmp "ult" %47, %52 : i64
  %54 = llvm.select %53, %47, %52 : i1, i64
  %55 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%41, %42, %54, %55) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%40, %39) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %56 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %57 = ts.Load(%40) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %58 = ts.CreateUnionInstance %17, %21 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %56, %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %58, %34 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %59 = llvm.load %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %60 = ts.Load(%34) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %61 = llvm.extractvalue %59[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %62 = ts.GetValueFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %63 = llvm.extractvalue %59[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %64 = ts.GetTypeInfoFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %65 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %66 = llvm.insertvalue %64, %65[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %67 = llvm.insertvalue %62, %66[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  llvm.store %67, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %68 = ts.Variable(%67) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %69 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %70 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %71 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %72 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %73 = llvm.mlir.constant(1 : i64) : i64
  %74 = llvm.getelementptr %72[%73] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %75 = llvm.ptrtoint %74 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %76 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %77 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %78 = llvm.mlir.constant(1 : i64) : i64
  %79 = llvm.getelementptr %77[%78] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %80 = llvm.ptrtoint %79 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %81 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %82 = llvm.icmp "ult" %76, %81 : i64
  %83 = llvm.select %82, %76, %81 : i1, i64
  %84 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%70, %71, %83, %84) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%69, %68) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %85 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %86 = ts.Load(%69) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %87 = ts.CreateUnionInstance %62, %64 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
  %88 = ts.Cast %60 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  llvm.store %85, %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  ts.Store %88, %35 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %89 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %90 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %91 = llvm.extractvalue %89[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
  %92 = ts.GetTypeInfoFromUnionOp %90 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %93 = llvm.mlir.constant(0 : i64) : i64
  %94 = llvm.ptrtoint %91 : !llvm.ptr<i8> to i64
  %95 = llvm.ptrtoint %24 : !llvm.ptr<i8> to i64
  %96 = llvm.icmp "ne" %94, %93 : i64
  %97 = llvm.icmp "ne" %95, %93 : i64
  %98 = llvm.zext %96 : i1 to i32
  %99 = zexti %96 : i1 to i32
  %100 = ts.Cast %96 : i1 to i32
  %101 = llvm.zext %97 : i1 to i32
  %102 = zexti %97 : i1 to i32
  %103 = ts.Cast %97 : i1 to i32
  %104 = llvm.and %100, %103  : i32
  %105 = llvm.mlir.constant(0 : i32) : i32
  %106 = llvm.icmp "ne" %104, %105 : i32
  llvm.cond_br %106, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %107 = llvm.mlir.constant(0 : i32) : i32
  %108 = llvm.call @strcmp(%91, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %109 = llvm.icmp "eq" %108, %107 : i32
  llvm.br ^bb3(%109 : i1)
^bb2:  // pred: ^bb0
  %110 = llvm.icmp "eq" %94, %95 : i64
  llvm.br ^bb3(%110 : i1)
^bb3(%111: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %112 = "ts.StringCompare"(%91, %24) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %113 = ts.LogicalBinary %92(34) %25 : !ts.string, !ts.string -> !ts.boolean
  %114 = ts.Cast %113 : !ts.boolean to i1
  llvm.cond_br %111, ^bb5, ^bb6
  cond_br %114, ^bb5, ^bb6
^bb5:  // 2 preds: ^bb4, ^bb4
  %115 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %116 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  llvm.store %115, %3 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %117 = ts.Variable(%115) {false} : !llvm.struct<(ptr<i8>, i1)> -> !ts.ref<!llvm.struct<(ptr<i8>, i1)>>
  %118 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %119 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %120 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %121 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %122 = llvm.mlir.constant(1 : i64) : i64
  %123 = llvm.getelementptr %121[%122] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %124 = llvm.ptrtoint %123 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %125 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %126 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %127 = llvm.mlir.constant(1 : i64) : i64
  %128 = llvm.getelementptr %126[%127] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %129 = llvm.ptrtoint %128 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %130 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %131 = llvm.icmp "ult" %125, %130 : i64
  %132 = llvm.select %131, %125, %130 : i1, i64
  %133 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%119, %120, %132, %133) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%118, %117) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, i1)>>) -> ()
  %134 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %135 = ts.Load(%118) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
  %136 = llvm.extractvalue %135[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %137 = ts.GetValueFromUnionOp %116 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %138 = llvm.mlir.constant(50 : i32) : i32
  %139 = llvm.zext %138 : i32 to i64
  %140 = zexti %138 : i32 to i64
  %141 = llvm.call @malloc(%140) : (i64) -> !llvm.ptr<i8>
  %142 = llvm.bitcast %141 : !llvm.ptr<i8> to !llvm.ptr<i8>
  %143 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
  %144 = llvm.mlir.constant(0 : i64) : i64
  %145 = llvm.getelementptr %143[%144, %144] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %146 = llvm.call @sprintf_s(%142, %138, %145, %136) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
  %147 = ts.Cast %137 : !ts.number to !ts.string
  %148 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
  %149 = llvm.mlir.constant(0 : i64) : i64
  %150 = llvm.getelementptr %148[%149, %149] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %151 = ts.Constant {value = " "} : !ts.string
  %152 = llvm.intr.stacksave : !llvm.ptr<i8>
  %153 = llvm.mlir.constant(1 : i64) : i64
  %154 = llvm.call @strlen(%28) : (!llvm.ptr<i8>) -> i64
  %155 = llvm.add %153, %154  : i64
  %156 = llvm.call @strlen(%150) : (!llvm.ptr<i8>) -> i64
  %157 = llvm.add %155, %156  : i64
  %158 = llvm.call @strlen(%142) : (!llvm.ptr<i8>) -> i64
  %159 = llvm.add %157, %158  : i64
  %160 = llvm.alloca %159 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
  %161 = llvm.call @strcpy(%160, %28) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  %162 = llvm.call @strcat(%161, %150) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  %163 = llvm.call @strcat(%162, %142) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  %164 = "ts.StringConcat"(%28, %151, %142) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
  %165 = llvm.call @puts(%164) : (!ts.string) -> i32
  llvm.intr.stackrestore %152
  ts.Print(%29, %147) : !ts.string, !ts.string
  br ^bb6
^bb6:  // 3 preds: ^bb4, ^bb4, ^bb5
  %166 = llvm.call @puts(%32) : (!llvm.ptr<i8>) -> i32
  ts.Print(%33) : !ts.string
  llvm.return
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'std.br'(0x278e950ec50) {
  "std.br"()[^bb6] : () -> ()

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'std.br -> ()' {
Trying to match "`anonymous-namespace'::BranchOpLowering"
    ** Insert  : 'llvm.br'(0x278e9513f80)
    ** Replace : 'std.br'(0x278e950ec50)
"`anonymous-namespace'::BranchOpLowering" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.br'(0x278e9513f80) {
      "llvm.br"()[^bb6] : () -> ()

    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %12 = llvm.mlir.constant(1 : i32) : i32
  %13 = llvm.alloca %12 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %14 = llvm.mlir.constant(1 : i32) : i32
  %15 = llvm.alloca %14 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %16 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %17 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %19 = llvm.mlir.constant(0 : i64) : i64
  %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %21 = ts.Constant {value = "number"} : !ts.string
  %22 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %23 = llvm.mlir.constant(0 : i64) : i64
  %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %25 = ts.Constant {value = "number"} : !ts.string
  %26 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %27 = llvm.mlir.constant(0 : i64) : i64
  %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %29 = ts.Constant {value = "b number: "} : !ts.string
  %30 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %31 = llvm.mlir.constant(0 : i64) : i64
  %32 = llvm.getelementptr %30[%31, %31] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %33 = ts.Constant {value = "done."} : !ts.string
  %34 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %35 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %36 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %37 = llvm.insertvalue %21, %36[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %38 = llvm.insertvalue %17, %37[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %38, %11 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %39 = ts.Variable(%38) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %40 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %41 = llvm.bitcast %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %42 = llvm.bitcast %11 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %43 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %44 = llvm.mlir.constant(1 : i64) : i64
  %45 = llvm.getelementptr %43[%44] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %46 = llvm.ptrtoint %45 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %47 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %48 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %49 = llvm.mlir.constant(1 : i64) : i64
  %50 = llvm.getelementptr %48[%49] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %51 = llvm.ptrtoint %50 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %52 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %53 = llvm.icmp "ult" %47, %52 : i64
  %54 = llvm.select %53, %47, %52 : i1, i64
  %55 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%41, %42, %54, %55) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%40, %39) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %56 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %57 = ts.Load(%40) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %58 = ts.CreateUnionInstance %17, %21 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %56, %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %58, %34 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %59 = llvm.load %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %60 = ts.Load(%34) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %61 = llvm.extractvalue %59[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %62 = ts.GetValueFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %63 = llvm.extractvalue %59[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %64 = ts.GetTypeInfoFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %65 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %66 = llvm.insertvalue %64, %65[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %67 = llvm.insertvalue %62, %66[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  llvm.store %67, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %68 = ts.Variable(%67) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %69 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %70 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %71 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %72 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %73 = llvm.mlir.constant(1 : i64) : i64
  %74 = llvm.getelementptr %72[%73] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %75 = llvm.ptrtoint %74 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %76 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %77 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %78 = llvm.mlir.constant(1 : i64) : i64
  %79 = llvm.getelementptr %77[%78] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %80 = llvm.ptrtoint %79 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %81 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %82 = llvm.icmp "ult" %76, %81 : i64
  %83 = llvm.select %82, %76, %81 : i1, i64
  %84 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%70, %71, %83, %84) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%69, %68) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %85 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %86 = ts.Load(%69) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %87 = ts.CreateUnionInstance %62, %64 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
  %88 = ts.Cast %60 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  llvm.store %85, %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  ts.Store %88, %35 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %89 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %90 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %91 = llvm.extractvalue %89[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
  %92 = ts.GetTypeInfoFromUnionOp %90 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %93 = llvm.mlir.constant(0 : i64) : i64
  %94 = llvm.ptrtoint %91 : !llvm.ptr<i8> to i64
  %95 = llvm.ptrtoint %24 : !llvm.ptr<i8> to i64
  %96 = llvm.icmp "ne" %94, %93 : i64
  %97 = llvm.icmp "ne" %95, %93 : i64
  %98 = llvm.zext %96 : i1 to i32
  %99 = zexti %96 : i1 to i32
  %100 = ts.Cast %96 : i1 to i32
  %101 = llvm.zext %97 : i1 to i32
  %102 = zexti %97 : i1 to i32
  %103 = ts.Cast %97 : i1 to i32
  %104 = llvm.and %100, %103  : i32
  %105 = llvm.mlir.constant(0 : i32) : i32
  %106 = llvm.icmp "ne" %104, %105 : i32
  llvm.cond_br %106, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %107 = llvm.mlir.constant(0 : i32) : i32
  %108 = llvm.call @strcmp(%91, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %109 = llvm.icmp "eq" %108, %107 : i32
  llvm.br ^bb3(%109 : i1)
^bb2:  // pred: ^bb0
  %110 = llvm.icmp "eq" %94, %95 : i64
  llvm.br ^bb3(%110 : i1)
^bb3(%111: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %112 = "ts.StringCompare"(%91, %24) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %113 = ts.LogicalBinary %92(34) %25 : !ts.string, !ts.string -> !ts.boolean
  %114 = ts.Cast %113 : !ts.boolean to i1
  llvm.cond_br %111, ^bb5, ^bb6
  cond_br %114, ^bb5, ^bb6
^bb5:  // 2 preds: ^bb4, ^bb4
  %115 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %116 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  llvm.store %115, %3 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %117 = ts.Variable(%115) {false} : !llvm.struct<(ptr<i8>, i1)> -> !ts.ref<!llvm.struct<(ptr<i8>, i1)>>
  %118 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %119 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %120 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %121 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %122 = llvm.mlir.constant(1 : i64) : i64
  %123 = llvm.getelementptr %121[%122] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %124 = llvm.ptrtoint %123 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %125 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %126 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %127 = llvm.mlir.constant(1 : i64) : i64
  %128 = llvm.getelementptr %126[%127] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %129 = llvm.ptrtoint %128 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %130 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %131 = llvm.icmp "ult" %125, %130 : i64
  %132 = llvm.select %131, %125, %130 : i1, i64
  %133 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%119, %120, %132, %133) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%118, %117) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, i1)>>) -> ()
  %134 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %135 = ts.Load(%118) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
  %136 = llvm.extractvalue %135[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %137 = ts.GetValueFromUnionOp %116 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %138 = llvm.mlir.constant(50 : i32) : i32
  %139 = llvm.zext %138 : i32 to i64
  %140 = zexti %138 : i32 to i64
  %141 = llvm.call @malloc(%140) : (i64) -> !llvm.ptr<i8>
  %142 = llvm.bitcast %141 : !llvm.ptr<i8> to !llvm.ptr<i8>
  %143 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
  %144 = llvm.mlir.constant(0 : i64) : i64
  %145 = llvm.getelementptr %143[%144, %144] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %146 = llvm.call @sprintf_s(%142, %138, %145, %136) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
  %147 = ts.Cast %137 : !ts.number to !ts.string
  %148 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
  %149 = llvm.mlir.constant(0 : i64) : i64
  %150 = llvm.getelementptr %148[%149, %149] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %151 = ts.Constant {value = " "} : !ts.string
  %152 = llvm.intr.stacksave : !llvm.ptr<i8>
  %153 = llvm.mlir.constant(1 : i64) : i64
  %154 = llvm.call @strlen(%28) : (!llvm.ptr<i8>) -> i64
  %155 = llvm.add %153, %154  : i64
  %156 = llvm.call @strlen(%150) : (!llvm.ptr<i8>) -> i64
  %157 = llvm.add %155, %156  : i64
  %158 = llvm.call @strlen(%142) : (!llvm.ptr<i8>) -> i64
  %159 = llvm.add %157, %158  : i64
  %160 = llvm.alloca %159 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
  %161 = llvm.call @strcpy(%160, %28) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  %162 = llvm.call @strcat(%161, %150) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  %163 = llvm.call @strcat(%162, %142) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  %164 = "ts.StringConcat"(%28, %151, %142) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
  %165 = llvm.call @puts(%164) : (!ts.string) -> i32
  llvm.intr.stackrestore %152
  ts.Print(%29, %147) : !ts.string, !ts.string
  llvm.br ^bb6
  br ^bb6
^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
  %166 = llvm.call @puts(%32) : (!llvm.ptr<i8>) -> i32
  ts.Print(%33) : !ts.string
  llvm.return
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x278e950caa0) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FuncOpConversion"
    ** Insert  : 'llvm.func'(0x278e95149d0)
    ** Erase   : 'func'(0x278e950caa0)
"`anonymous-namespace'::FuncOpConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x278e95149d0) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  llvm.func @strcat(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strcpy(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strlen(!llvm.ptr<i8>) -> i64
  llvm.func @sprintf_s(!llvm.ptr<i8>, i32, !llvm.ptr<i8>, ...) -> i32
  llvm.func @puts(!llvm.ptr<i8>) -> i32
  llvm.func @strcmp(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  llvm.func @llvm.memcpy.p0i8.p0i8.i64(!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1)
  llvm.mlir.global internal constant @s_9237349086447201248("number\00")
  llvm.mlir.global internal constant @s_13617892236937420068("b number: \00")
  llvm.mlir.global internal constant @s_6682479467004374669("done.\00")
  llvm.mlir.global internal constant @frmt_555404038213028357("%g\00")
  llvm.mlir.global internal constant @s_12638117931323064703(" \00")
  llvm.func @main() {
    %0 = llvm.mlir.constant(1 : i32) : i32
    %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %2 = llvm.mlir.constant(1 : i32) : i32
    %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %4 = llvm.mlir.constant(1 : i32) : i32
    %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %6 = llvm.mlir.constant(1 : i32) : i32
    %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %8 = llvm.mlir.constant(1 : i32) : i32
    %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %10 = llvm.mlir.constant(1 : i32) : i32
    %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %12 = llvm.mlir.constant(1 : i32) : i32
    %13 = llvm.alloca %12 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %14 = llvm.mlir.constant(1 : i32) : i32
    %15 = llvm.alloca %14 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %16 = llvm.mlir.constant(1.000000e+01 : f64) : f64
    %cst = constant 1.000000e+01 : f64
    %17 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %19 = llvm.mlir.constant(0 : i64) : i64
    %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %21 = ts.Constant {value = "number"} : !ts.string
    %22 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %23 = llvm.mlir.constant(0 : i64) : i64
    %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %25 = ts.Constant {value = "number"} : !ts.string
    %26 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
    %27 = llvm.mlir.constant(0 : i64) : i64
    %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %29 = ts.Constant {value = "b number: "} : !ts.string
    %30 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
    %31 = llvm.mlir.constant(0 : i64) : i64
    %32 = llvm.getelementptr %30[%31, %31] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %33 = ts.Constant {value = "done."} : !ts.string
    %34 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %35 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %36 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
    %37 = llvm.insertvalue %21, %36[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %38 = llvm.insertvalue %17, %37[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    llvm.store %38, %11 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %39 = ts.Variable(%38) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %40 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %41 = llvm.bitcast %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %42 = llvm.bitcast %11 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %43 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %44 = llvm.mlir.constant(1 : i64) : i64
    %45 = llvm.getelementptr %43[%44] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %46 = llvm.ptrtoint %45 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %47 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %48 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %49 = llvm.mlir.constant(1 : i64) : i64
    %50 = llvm.getelementptr %48[%49] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %51 = llvm.ptrtoint %50 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %52 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %53 = llvm.icmp "ult" %47, %52 : i64
    %54 = llvm.select %53, %47, %52 : i1, i64
    %55 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%41, %42, %54, %55) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%40, %39) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
    %56 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %57 = ts.Load(%40) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %58 = ts.CreateUnionInstance %17, %21 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    llvm.store %56, %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %58, %34 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %59 = llvm.load %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %60 = ts.Load(%34) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %61 = llvm.extractvalue %59[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %62 = ts.GetValueFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
    %63 = llvm.extractvalue %59[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %64 = ts.GetTypeInfoFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
    %65 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %66 = llvm.insertvalue %64, %65[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %67 = llvm.insertvalue %62, %66[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    llvm.store %67, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %68 = ts.Variable(%67) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
    %69 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %70 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
    %71 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %72 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %73 = llvm.mlir.constant(1 : i64) : i64
    %74 = llvm.getelementptr %72[%73] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %75 = llvm.ptrtoint %74 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %76 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %77 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %78 = llvm.mlir.constant(1 : i64) : i64
    %79 = llvm.getelementptr %77[%78] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %80 = llvm.ptrtoint %79 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
    %81 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
    %82 = llvm.icmp "ult" %76, %81 : i64
    %83 = llvm.select %82, %76, %81 : i1, i64
    %84 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%70, %71, %83, %84) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%69, %68) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
    %85 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %86 = ts.Load(%69) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %87 = ts.CreateUnionInstance %62, %64 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
    %88 = ts.Cast %60 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
    llvm.store %85, %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    ts.Store %88, %35 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %89 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %90 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %91 = llvm.extractvalue %89[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
    %92 = ts.GetTypeInfoFromUnionOp %90 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
    %93 = llvm.mlir.constant(0 : i64) : i64
    %94 = llvm.ptrtoint %91 : !llvm.ptr<i8> to i64
    %95 = llvm.ptrtoint %24 : !llvm.ptr<i8> to i64
    %96 = llvm.icmp "ne" %94, %93 : i64
    %97 = llvm.icmp "ne" %95, %93 : i64
    %98 = llvm.zext %96 : i1 to i32
    %99 = zexti %96 : i1 to i32
    %100 = ts.Cast %96 : i1 to i32
    %101 = llvm.zext %97 : i1 to i32
    %102 = zexti %97 : i1 to i32
    %103 = ts.Cast %97 : i1 to i32
    %104 = llvm.and %100, %103  : i32
    %105 = llvm.mlir.constant(0 : i32) : i32
    %106 = llvm.icmp "ne" %104, %105 : i32
    llvm.cond_br %106, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %107 = llvm.mlir.constant(0 : i32) : i32
    %108 = llvm.call @strcmp(%91, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
    %109 = llvm.icmp "eq" %108, %107 : i32
    llvm.br ^bb3(%109 : i1)
  ^bb2:  // pred: ^bb0
    %110 = llvm.icmp "eq" %94, %95 : i64
    llvm.br ^bb3(%110 : i1)
  ^bb3(%111: i1):  // 2 preds: ^bb1, ^bb2
    llvm.br ^bb4
  ^bb4:  // pred: ^bb3
    %112 = "ts.StringCompare"(%91, %24) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
    %113 = ts.LogicalBinary %92(34) %25 : !ts.string, !ts.string -> !ts.boolean
    %114 = ts.Cast %113 : !ts.boolean to i1
    llvm.cond_br %111, ^bb5, ^bb6
    cond_br %114, ^bb5, ^bb6
  ^bb5:  // 2 preds: ^bb4, ^bb4
    %115 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %116 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    llvm.store %115, %3 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %117 = ts.Variable(%115) {false} : !llvm.struct<(ptr<i8>, i1)> -> !ts.ref<!llvm.struct<(ptr<i8>, i1)>>
    %118 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %119 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %120 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
    %121 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %122 = llvm.mlir.constant(1 : i64) : i64
    %123 = llvm.getelementptr %121[%122] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %124 = llvm.ptrtoint %123 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
    %125 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
    %126 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %127 = llvm.mlir.constant(1 : i64) : i64
    %128 = llvm.getelementptr %126[%127] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %129 = llvm.ptrtoint %128 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %130 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %131 = llvm.icmp "ult" %125, %130 : i64
    %132 = llvm.select %131, %125, %130 : i1, i64
    %133 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%119, %120, %132, %133) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%118, %117) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, i1)>>) -> ()
    %134 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %135 = ts.Load(%118) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
    %136 = llvm.extractvalue %135[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %137 = ts.GetValueFromUnionOp %116 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %138 = llvm.mlir.constant(50 : i32) : i32
    %139 = llvm.zext %138 : i32 to i64
    %140 = zexti %138 : i32 to i64
    %141 = llvm.call @malloc(%140) : (i64) -> !llvm.ptr<i8>
    %142 = llvm.bitcast %141 : !llvm.ptr<i8> to !llvm.ptr<i8>
    %143 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
    %144 = llvm.mlir.constant(0 : i64) : i64
    %145 = llvm.getelementptr %143[%144, %144] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %146 = llvm.call @sprintf_s(%142, %138, %145, %136) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
    %147 = ts.Cast %137 : !ts.number to !ts.string
    %148 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
    %149 = llvm.mlir.constant(0 : i64) : i64
    %150 = llvm.getelementptr %148[%149, %149] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %151 = ts.Constant {value = " "} : !ts.string
    %152 = llvm.intr.stacksave : !llvm.ptr<i8>
    %153 = llvm.mlir.constant(1 : i64) : i64
    %154 = llvm.call @strlen(%28) : (!llvm.ptr<i8>) -> i64
    %155 = llvm.add %153, %154  : i64
    %156 = llvm.call @strlen(%150) : (!llvm.ptr<i8>) -> i64
    %157 = llvm.add %155, %156  : i64
    %158 = llvm.call @strlen(%142) : (!llvm.ptr<i8>) -> i64
    %159 = llvm.add %157, %158  : i64
    %160 = llvm.alloca %159 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
    %161 = llvm.call @strcpy(%160, %28) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %162 = llvm.call @strcat(%161, %150) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %163 = llvm.call @strcat(%162, %142) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %164 = "ts.StringConcat"(%28, %151, %142) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
    %165 = llvm.call @puts(%164) : (!ts.string) -> i32
    llvm.intr.stackrestore %152
    ts.Print(%29, %147) : !ts.string, !ts.string
    llvm.br ^bb6
    br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
    %166 = llvm.call @puts(%32) : (!llvm.ptr<i8>) -> i32
    ts.Print(%33) : !ts.string
    llvm.return
    ts.ReturnInternal
  }
  func @main()
  ts.Func @main () -> ()  {
  }
  llvm.func @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x278e950ccb0) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FuncOpConversion"
    ** Insert  : 'llvm.func'(0x278e9512980)
    ** Erase   : 'func'(0x278e950ccb0)
"`anonymous-namespace'::FuncOpConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x278e9512980) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  llvm.func @strcat(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strcpy(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strlen(!llvm.ptr<i8>) -> i64
  llvm.func @sprintf_s(!llvm.ptr<i8>, i32, !llvm.ptr<i8>, ...) -> i32
  llvm.func @puts(!llvm.ptr<i8>) -> i32
  llvm.func @strcmp(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  llvm.func @llvm.memcpy.p0i8.p0i8.i64(!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1)
  llvm.mlir.global internal constant @s_9237349086447201248("number\00")
  llvm.mlir.global internal constant @s_13617892236937420068("b number: \00")
  llvm.mlir.global internal constant @s_6682479467004374669("done.\00")
  llvm.mlir.global internal constant @frmt_555404038213028357("%g\00")
  llvm.mlir.global internal constant @s_12638117931323064703(" \00")
  llvm.func @main() {
    %0 = llvm.mlir.constant(1 : i32) : i32
    %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %2 = llvm.mlir.constant(1 : i32) : i32
    %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %4 = llvm.mlir.constant(1 : i32) : i32
    %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %6 = llvm.mlir.constant(1 : i32) : i32
    %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %8 = llvm.mlir.constant(1 : i32) : i32
    %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %10 = llvm.mlir.constant(1 : i32) : i32
    %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %12 = llvm.mlir.constant(1 : i32) : i32
    %13 = llvm.alloca %12 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %14 = llvm.mlir.constant(1 : i32) : i32
    %15 = llvm.alloca %14 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %16 = llvm.mlir.constant(1.000000e+01 : f64) : f64
    %cst = constant 1.000000e+01 : f64
    %17 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %19 = llvm.mlir.constant(0 : i64) : i64
    %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %21 = ts.Constant {value = "number"} : !ts.string
    %22 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %23 = llvm.mlir.constant(0 : i64) : i64
    %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %25 = ts.Constant {value = "number"} : !ts.string
    %26 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
    %27 = llvm.mlir.constant(0 : i64) : i64
    %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %29 = ts.Constant {value = "b number: "} : !ts.string
    %30 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
    %31 = llvm.mlir.constant(0 : i64) : i64
    %32 = llvm.getelementptr %30[%31, %31] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %33 = ts.Constant {value = "done."} : !ts.string
    %34 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %35 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %36 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
    %37 = llvm.insertvalue %21, %36[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %38 = llvm.insertvalue %17, %37[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    llvm.store %38, %11 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %39 = ts.Variable(%38) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %40 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %41 = llvm.bitcast %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %42 = llvm.bitcast %11 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %43 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %44 = llvm.mlir.constant(1 : i64) : i64
    %45 = llvm.getelementptr %43[%44] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %46 = llvm.ptrtoint %45 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %47 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %48 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %49 = llvm.mlir.constant(1 : i64) : i64
    %50 = llvm.getelementptr %48[%49] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %51 = llvm.ptrtoint %50 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %52 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %53 = llvm.icmp "ult" %47, %52 : i64
    %54 = llvm.select %53, %47, %52 : i1, i64
    %55 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%41, %42, %54, %55) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%40, %39) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
    %56 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %57 = ts.Load(%40) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %58 = ts.CreateUnionInstance %17, %21 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    llvm.store %56, %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %58, %34 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %59 = llvm.load %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %60 = ts.Load(%34) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %61 = llvm.extractvalue %59[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %62 = ts.GetValueFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
    %63 = llvm.extractvalue %59[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %64 = ts.GetTypeInfoFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
    %65 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %66 = llvm.insertvalue %64, %65[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %67 = llvm.insertvalue %62, %66[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    llvm.store %67, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %68 = ts.Variable(%67) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
    %69 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %70 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
    %71 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %72 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %73 = llvm.mlir.constant(1 : i64) : i64
    %74 = llvm.getelementptr %72[%73] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %75 = llvm.ptrtoint %74 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %76 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %77 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %78 = llvm.mlir.constant(1 : i64) : i64
    %79 = llvm.getelementptr %77[%78] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %80 = llvm.ptrtoint %79 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
    %81 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
    %82 = llvm.icmp "ult" %76, %81 : i64
    %83 = llvm.select %82, %76, %81 : i1, i64
    %84 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%70, %71, %83, %84) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%69, %68) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
    %85 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %86 = ts.Load(%69) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %87 = ts.CreateUnionInstance %62, %64 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
    %88 = ts.Cast %60 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
    llvm.store %85, %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    ts.Store %88, %35 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %89 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %90 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %91 = llvm.extractvalue %89[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
    %92 = ts.GetTypeInfoFromUnionOp %90 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
    %93 = llvm.mlir.constant(0 : i64) : i64
    %94 = llvm.ptrtoint %91 : !llvm.ptr<i8> to i64
    %95 = llvm.ptrtoint %24 : !llvm.ptr<i8> to i64
    %96 = llvm.icmp "ne" %94, %93 : i64
    %97 = llvm.icmp "ne" %95, %93 : i64
    %98 = llvm.zext %96 : i1 to i32
    %99 = zexti %96 : i1 to i32
    %100 = ts.Cast %96 : i1 to i32
    %101 = llvm.zext %97 : i1 to i32
    %102 = zexti %97 : i1 to i32
    %103 = ts.Cast %97 : i1 to i32
    %104 = llvm.and %100, %103  : i32
    %105 = llvm.mlir.constant(0 : i32) : i32
    %106 = llvm.icmp "ne" %104, %105 : i32
    llvm.cond_br %106, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %107 = llvm.mlir.constant(0 : i32) : i32
    %108 = llvm.call @strcmp(%91, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
    %109 = llvm.icmp "eq" %108, %107 : i32
    llvm.br ^bb3(%109 : i1)
  ^bb2:  // pred: ^bb0
    %110 = llvm.icmp "eq" %94, %95 : i64
    llvm.br ^bb3(%110 : i1)
  ^bb3(%111: i1):  // 2 preds: ^bb1, ^bb2
    llvm.br ^bb4
  ^bb4:  // pred: ^bb3
    %112 = "ts.StringCompare"(%91, %24) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
    %113 = ts.LogicalBinary %92(34) %25 : !ts.string, !ts.string -> !ts.boolean
    %114 = ts.Cast %113 : !ts.boolean to i1
    llvm.cond_br %111, ^bb5, ^bb6
    cond_br %114, ^bb5, ^bb6
  ^bb5:  // 2 preds: ^bb4, ^bb4
    %115 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %116 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    llvm.store %115, %3 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %117 = ts.Variable(%115) {false} : !llvm.struct<(ptr<i8>, i1)> -> !ts.ref<!llvm.struct<(ptr<i8>, i1)>>
    %118 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %119 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %120 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
    %121 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %122 = llvm.mlir.constant(1 : i64) : i64
    %123 = llvm.getelementptr %121[%122] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %124 = llvm.ptrtoint %123 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
    %125 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
    %126 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %127 = llvm.mlir.constant(1 : i64) : i64
    %128 = llvm.getelementptr %126[%127] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %129 = llvm.ptrtoint %128 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %130 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %131 = llvm.icmp "ult" %125, %130 : i64
    %132 = llvm.select %131, %125, %130 : i1, i64
    %133 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%119, %120, %132, %133) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%118, %117) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, i1)>>) -> ()
    %134 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %135 = ts.Load(%118) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
    %136 = llvm.extractvalue %135[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %137 = ts.GetValueFromUnionOp %116 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %138 = llvm.mlir.constant(50 : i32) : i32
    %139 = llvm.zext %138 : i32 to i64
    %140 = zexti %138 : i32 to i64
    %141 = llvm.call @malloc(%140) : (i64) -> !llvm.ptr<i8>
    %142 = llvm.bitcast %141 : !llvm.ptr<i8> to !llvm.ptr<i8>
    %143 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
    %144 = llvm.mlir.constant(0 : i64) : i64
    %145 = llvm.getelementptr %143[%144, %144] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %146 = llvm.call @sprintf_s(%142, %138, %145, %136) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
    %147 = ts.Cast %137 : !ts.number to !ts.string
    %148 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
    %149 = llvm.mlir.constant(0 : i64) : i64
    %150 = llvm.getelementptr %148[%149, %149] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %151 = ts.Constant {value = " "} : !ts.string
    %152 = llvm.intr.stacksave : !llvm.ptr<i8>
    %153 = llvm.mlir.constant(1 : i64) : i64
    %154 = llvm.call @strlen(%28) : (!llvm.ptr<i8>) -> i64
    %155 = llvm.add %153, %154  : i64
    %156 = llvm.call @strlen(%150) : (!llvm.ptr<i8>) -> i64
    %157 = llvm.add %155, %156  : i64
    %158 = llvm.call @strlen(%142) : (!llvm.ptr<i8>) -> i64
    %159 = llvm.add %157, %158  : i64
    %160 = llvm.alloca %159 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
    %161 = llvm.call @strcpy(%160, %28) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %162 = llvm.call @strcat(%161, %150) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %163 = llvm.call @strcat(%162, %142) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %164 = "ts.StringConcat"(%28, %151, %142) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
    %165 = llvm.call @puts(%164) : (!ts.string) -> i32
    llvm.intr.stackrestore %152
    ts.Print(%29, %147) : !ts.string, !ts.string
    llvm.br ^bb6
    br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
    %166 = llvm.call @puts(%32) : (!llvm.ptr<i8>) -> i32
    ts.Print(%33) : !ts.string
    llvm.return
    ts.ReturnInternal
  }
  func @main()
  ts.Func @main () -> ()  {
  }
  llvm.func @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x278e950bc30) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FuncOpConversion"
    ** Insert  : 'llvm.func'(0x278e9514500)
    ** Erase   : 'func'(0x278e950bc30)
"`anonymous-namespace'::FuncOpConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x278e9514500) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  llvm.func @strcat(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strcpy(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strlen(!llvm.ptr<i8>) -> i64
  llvm.func @sprintf_s(!llvm.ptr<i8>, i32, !llvm.ptr<i8>, ...) -> i32
  llvm.func @puts(!llvm.ptr<i8>) -> i32
  llvm.func @strcmp(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  llvm.func @llvm.memcpy.p0i8.p0i8.i64(!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1)
  llvm.mlir.global internal constant @s_9237349086447201248("number\00")
  llvm.mlir.global internal constant @s_13617892236937420068("b number: \00")
  llvm.mlir.global internal constant @s_6682479467004374669("done.\00")
  llvm.mlir.global internal constant @frmt_555404038213028357("%g\00")
  llvm.mlir.global internal constant @s_12638117931323064703(" \00")
  llvm.func @main() {
    %0 = llvm.mlir.constant(1 : i32) : i32
    %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %2 = llvm.mlir.constant(1 : i32) : i32
    %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %4 = llvm.mlir.constant(1 : i32) : i32
    %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %6 = llvm.mlir.constant(1 : i32) : i32
    %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %8 = llvm.mlir.constant(1 : i32) : i32
    %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %10 = llvm.mlir.constant(1 : i32) : i32
    %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %12 = llvm.mlir.constant(1 : i32) : i32
    %13 = llvm.alloca %12 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %14 = llvm.mlir.constant(1 : i32) : i32
    %15 = llvm.alloca %14 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %16 = llvm.mlir.constant(1.000000e+01 : f64) : f64
    %cst = constant 1.000000e+01 : f64
    %17 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %19 = llvm.mlir.constant(0 : i64) : i64
    %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %21 = ts.Constant {value = "number"} : !ts.string
    %22 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %23 = llvm.mlir.constant(0 : i64) : i64
    %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %25 = ts.Constant {value = "number"} : !ts.string
    %26 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
    %27 = llvm.mlir.constant(0 : i64) : i64
    %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %29 = ts.Constant {value = "b number: "} : !ts.string
    %30 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
    %31 = llvm.mlir.constant(0 : i64) : i64
    %32 = llvm.getelementptr %30[%31, %31] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %33 = ts.Constant {value = "done."} : !ts.string
    %34 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %35 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %36 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
    %37 = llvm.insertvalue %21, %36[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %38 = llvm.insertvalue %17, %37[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    llvm.store %38, %11 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %39 = ts.Variable(%38) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %40 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %41 = llvm.bitcast %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %42 = llvm.bitcast %11 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %43 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %44 = llvm.mlir.constant(1 : i64) : i64
    %45 = llvm.getelementptr %43[%44] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %46 = llvm.ptrtoint %45 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %47 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %48 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %49 = llvm.mlir.constant(1 : i64) : i64
    %50 = llvm.getelementptr %48[%49] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %51 = llvm.ptrtoint %50 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %52 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %53 = llvm.icmp "ult" %47, %52 : i64
    %54 = llvm.select %53, %47, %52 : i1, i64
    %55 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%41, %42, %54, %55) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%40, %39) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
    %56 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %57 = ts.Load(%40) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %58 = ts.CreateUnionInstance %17, %21 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    llvm.store %56, %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %58, %34 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %59 = llvm.load %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %60 = ts.Load(%34) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %61 = llvm.extractvalue %59[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %62 = ts.GetValueFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
    %63 = llvm.extractvalue %59[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %64 = ts.GetTypeInfoFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
    %65 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %66 = llvm.insertvalue %64, %65[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %67 = llvm.insertvalue %62, %66[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    llvm.store %67, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %68 = ts.Variable(%67) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
    %69 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %70 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
    %71 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %72 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %73 = llvm.mlir.constant(1 : i64) : i64
    %74 = llvm.getelementptr %72[%73] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %75 = llvm.ptrtoint %74 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %76 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %77 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %78 = llvm.mlir.constant(1 : i64) : i64
    %79 = llvm.getelementptr %77[%78] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %80 = llvm.ptrtoint %79 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
    %81 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
    %82 = llvm.icmp "ult" %76, %81 : i64
    %83 = llvm.select %82, %76, %81 : i1, i64
    %84 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%70, %71, %83, %84) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%69, %68) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
    %85 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %86 = ts.Load(%69) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %87 = ts.CreateUnionInstance %62, %64 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
    %88 = ts.Cast %60 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
    llvm.store %85, %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    ts.Store %88, %35 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %89 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %90 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %91 = llvm.extractvalue %89[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
    %92 = ts.GetTypeInfoFromUnionOp %90 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
    %93 = llvm.mlir.constant(0 : i64) : i64
    %94 = llvm.ptrtoint %91 : !llvm.ptr<i8> to i64
    %95 = llvm.ptrtoint %24 : !llvm.ptr<i8> to i64
    %96 = llvm.icmp "ne" %94, %93 : i64
    %97 = llvm.icmp "ne" %95, %93 : i64
    %98 = llvm.zext %96 : i1 to i32
    %99 = zexti %96 : i1 to i32
    %100 = ts.Cast %96 : i1 to i32
    %101 = llvm.zext %97 : i1 to i32
    %102 = zexti %97 : i1 to i32
    %103 = ts.Cast %97 : i1 to i32
    %104 = llvm.and %100, %103  : i32
    %105 = llvm.mlir.constant(0 : i32) : i32
    %106 = llvm.icmp "ne" %104, %105 : i32
    llvm.cond_br %106, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %107 = llvm.mlir.constant(0 : i32) : i32
    %108 = llvm.call @strcmp(%91, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
    %109 = llvm.icmp "eq" %108, %107 : i32
    llvm.br ^bb3(%109 : i1)
  ^bb2:  // pred: ^bb0
    %110 = llvm.icmp "eq" %94, %95 : i64
    llvm.br ^bb3(%110 : i1)
  ^bb3(%111: i1):  // 2 preds: ^bb1, ^bb2
    llvm.br ^bb4
  ^bb4:  // pred: ^bb3
    %112 = "ts.StringCompare"(%91, %24) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
    %113 = ts.LogicalBinary %92(34) %25 : !ts.string, !ts.string -> !ts.boolean
    %114 = ts.Cast %113 : !ts.boolean to i1
    llvm.cond_br %111, ^bb5, ^bb6
    cond_br %114, ^bb5, ^bb6
  ^bb5:  // 2 preds: ^bb4, ^bb4
    %115 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %116 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    llvm.store %115, %3 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %117 = ts.Variable(%115) {false} : !llvm.struct<(ptr<i8>, i1)> -> !ts.ref<!llvm.struct<(ptr<i8>, i1)>>
    %118 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %119 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %120 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
    %121 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %122 = llvm.mlir.constant(1 : i64) : i64
    %123 = llvm.getelementptr %121[%122] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %124 = llvm.ptrtoint %123 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
    %125 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
    %126 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %127 = llvm.mlir.constant(1 : i64) : i64
    %128 = llvm.getelementptr %126[%127] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %129 = llvm.ptrtoint %128 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %130 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %131 = llvm.icmp "ult" %125, %130 : i64
    %132 = llvm.select %131, %125, %130 : i1, i64
    %133 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%119, %120, %132, %133) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%118, %117) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, i1)>>) -> ()
    %134 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %135 = ts.Load(%118) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
    %136 = llvm.extractvalue %135[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %137 = ts.GetValueFromUnionOp %116 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %138 = llvm.mlir.constant(50 : i32) : i32
    %139 = llvm.zext %138 : i32 to i64
    %140 = zexti %138 : i32 to i64
    %141 = llvm.call @malloc(%140) : (i64) -> !llvm.ptr<i8>
    %142 = llvm.bitcast %141 : !llvm.ptr<i8> to !llvm.ptr<i8>
    %143 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
    %144 = llvm.mlir.constant(0 : i64) : i64
    %145 = llvm.getelementptr %143[%144, %144] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %146 = llvm.call @sprintf_s(%142, %138, %145, %136) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
    %147 = ts.Cast %137 : !ts.number to !ts.string
    %148 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
    %149 = llvm.mlir.constant(0 : i64) : i64
    %150 = llvm.getelementptr %148[%149, %149] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %151 = ts.Constant {value = " "} : !ts.string
    %152 = llvm.intr.stacksave : !llvm.ptr<i8>
    %153 = llvm.mlir.constant(1 : i64) : i64
    %154 = llvm.call @strlen(%28) : (!llvm.ptr<i8>) -> i64
    %155 = llvm.add %153, %154  : i64
    %156 = llvm.call @strlen(%150) : (!llvm.ptr<i8>) -> i64
    %157 = llvm.add %155, %156  : i64
    %158 = llvm.call @strlen(%142) : (!llvm.ptr<i8>) -> i64
    %159 = llvm.add %157, %158  : i64
    %160 = llvm.alloca %159 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
    %161 = llvm.call @strcpy(%160, %28) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %162 = llvm.call @strcat(%161, %150) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %163 = llvm.call @strcat(%162, %142) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %164 = "ts.StringConcat"(%28, %151, %142) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
    %165 = llvm.call @puts(%164) : (!ts.string) -> i32
    llvm.intr.stackrestore %152
    ts.Print(%29, %147) : !ts.string, !ts.string
    llvm.br ^bb6
    br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
    %166 = llvm.call @puts(%32) : (!llvm.ptr<i8>) -> i32
    ts.Print(%33) : !ts.string
    llvm.return
    ts.ReturnInternal
  }
  func @main()
  ts.Func @main () -> ()  {
  }
  llvm.func @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x278e950b130) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FuncOpConversion"
    ** Insert  : 'llvm.func'(0x278e9512c40)
    ** Erase   : 'func'(0x278e950b130)
"`anonymous-namespace'::FuncOpConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x278e9512c40) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  llvm.func @strcat(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strcpy(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strlen(!llvm.ptr<i8>) -> i64
  llvm.func @sprintf_s(!llvm.ptr<i8>, i32, !llvm.ptr<i8>, ...) -> i32
  llvm.func @puts(!llvm.ptr<i8>) -> i32
  llvm.func @strcmp(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  llvm.func @llvm.memcpy.p0i8.p0i8.i64(!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1)
  llvm.mlir.global internal constant @s_9237349086447201248("number\00")
  llvm.mlir.global internal constant @s_13617892236937420068("b number: \00")
  llvm.mlir.global internal constant @s_6682479467004374669("done.\00")
  llvm.mlir.global internal constant @frmt_555404038213028357("%g\00")
  llvm.mlir.global internal constant @s_12638117931323064703(" \00")
  llvm.func @main() {
    %0 = llvm.mlir.constant(1 : i32) : i32
    %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %2 = llvm.mlir.constant(1 : i32) : i32
    %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %4 = llvm.mlir.constant(1 : i32) : i32
    %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %6 = llvm.mlir.constant(1 : i32) : i32
    %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %8 = llvm.mlir.constant(1 : i32) : i32
    %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %10 = llvm.mlir.constant(1 : i32) : i32
    %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %12 = llvm.mlir.constant(1 : i32) : i32
    %13 = llvm.alloca %12 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %14 = llvm.mlir.constant(1 : i32) : i32
    %15 = llvm.alloca %14 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %16 = llvm.mlir.constant(1.000000e+01 : f64) : f64
    %cst = constant 1.000000e+01 : f64
    %17 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %19 = llvm.mlir.constant(0 : i64) : i64
    %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %21 = ts.Constant {value = "number"} : !ts.string
    %22 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %23 = llvm.mlir.constant(0 : i64) : i64
    %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %25 = ts.Constant {value = "number"} : !ts.string
    %26 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
    %27 = llvm.mlir.constant(0 : i64) : i64
    %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %29 = ts.Constant {value = "b number: "} : !ts.string
    %30 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
    %31 = llvm.mlir.constant(0 : i64) : i64
    %32 = llvm.getelementptr %30[%31, %31] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %33 = ts.Constant {value = "done."} : !ts.string
    %34 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %35 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %36 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
    %37 = llvm.insertvalue %21, %36[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %38 = llvm.insertvalue %17, %37[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    llvm.store %38, %11 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %39 = ts.Variable(%38) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %40 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %41 = llvm.bitcast %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %42 = llvm.bitcast %11 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %43 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %44 = llvm.mlir.constant(1 : i64) : i64
    %45 = llvm.getelementptr %43[%44] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %46 = llvm.ptrtoint %45 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %47 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %48 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %49 = llvm.mlir.constant(1 : i64) : i64
    %50 = llvm.getelementptr %48[%49] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %51 = llvm.ptrtoint %50 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %52 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %53 = llvm.icmp "ult" %47, %52 : i64
    %54 = llvm.select %53, %47, %52 : i1, i64
    %55 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%41, %42, %54, %55) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%40, %39) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
    %56 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %57 = ts.Load(%40) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %58 = ts.CreateUnionInstance %17, %21 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    llvm.store %56, %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %58, %34 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %59 = llvm.load %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %60 = ts.Load(%34) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %61 = llvm.extractvalue %59[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %62 = ts.GetValueFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
    %63 = llvm.extractvalue %59[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %64 = ts.GetTypeInfoFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
    %65 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %66 = llvm.insertvalue %64, %65[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %67 = llvm.insertvalue %62, %66[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    llvm.store %67, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %68 = ts.Variable(%67) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
    %69 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %70 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
    %71 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %72 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %73 = llvm.mlir.constant(1 : i64) : i64
    %74 = llvm.getelementptr %72[%73] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %75 = llvm.ptrtoint %74 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %76 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %77 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %78 = llvm.mlir.constant(1 : i64) : i64
    %79 = llvm.getelementptr %77[%78] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %80 = llvm.ptrtoint %79 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
    %81 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
    %82 = llvm.icmp "ult" %76, %81 : i64
    %83 = llvm.select %82, %76, %81 : i1, i64
    %84 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%70, %71, %83, %84) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%69, %68) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
    %85 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %86 = ts.Load(%69) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %87 = ts.CreateUnionInstance %62, %64 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
    %88 = ts.Cast %60 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
    llvm.store %85, %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    ts.Store %88, %35 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %89 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %90 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %91 = llvm.extractvalue %89[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
    %92 = ts.GetTypeInfoFromUnionOp %90 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
    %93 = llvm.mlir.constant(0 : i64) : i64
    %94 = llvm.ptrtoint %91 : !llvm.ptr<i8> to i64
    %95 = llvm.ptrtoint %24 : !llvm.ptr<i8> to i64
    %96 = llvm.icmp "ne" %94, %93 : i64
    %97 = llvm.icmp "ne" %95, %93 : i64
    %98 = llvm.zext %96 : i1 to i32
    %99 = zexti %96 : i1 to i32
    %100 = ts.Cast %96 : i1 to i32
    %101 = llvm.zext %97 : i1 to i32
    %102 = zexti %97 : i1 to i32
    %103 = ts.Cast %97 : i1 to i32
    %104 = llvm.and %100, %103  : i32
    %105 = llvm.mlir.constant(0 : i32) : i32
    %106 = llvm.icmp "ne" %104, %105 : i32
    llvm.cond_br %106, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %107 = llvm.mlir.constant(0 : i32) : i32
    %108 = llvm.call @strcmp(%91, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
    %109 = llvm.icmp "eq" %108, %107 : i32
    llvm.br ^bb3(%109 : i1)
  ^bb2:  // pred: ^bb0
    %110 = llvm.icmp "eq" %94, %95 : i64
    llvm.br ^bb3(%110 : i1)
  ^bb3(%111: i1):  // 2 preds: ^bb1, ^bb2
    llvm.br ^bb4
  ^bb4:  // pred: ^bb3
    %112 = "ts.StringCompare"(%91, %24) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
    %113 = ts.LogicalBinary %92(34) %25 : !ts.string, !ts.string -> !ts.boolean
    %114 = ts.Cast %113 : !ts.boolean to i1
    llvm.cond_br %111, ^bb5, ^bb6
    cond_br %114, ^bb5, ^bb6
  ^bb5:  // 2 preds: ^bb4, ^bb4
    %115 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %116 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    llvm.store %115, %3 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %117 = ts.Variable(%115) {false} : !llvm.struct<(ptr<i8>, i1)> -> !ts.ref<!llvm.struct<(ptr<i8>, i1)>>
    %118 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %119 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %120 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
    %121 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %122 = llvm.mlir.constant(1 : i64) : i64
    %123 = llvm.getelementptr %121[%122] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %124 = llvm.ptrtoint %123 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
    %125 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
    %126 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %127 = llvm.mlir.constant(1 : i64) : i64
    %128 = llvm.getelementptr %126[%127] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %129 = llvm.ptrtoint %128 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %130 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %131 = llvm.icmp "ult" %125, %130 : i64
    %132 = llvm.select %131, %125, %130 : i1, i64
    %133 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%119, %120, %132, %133) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%118, %117) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, i1)>>) -> ()
    %134 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %135 = ts.Load(%118) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
    %136 = llvm.extractvalue %135[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %137 = ts.GetValueFromUnionOp %116 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %138 = llvm.mlir.constant(50 : i32) : i32
    %139 = llvm.zext %138 : i32 to i64
    %140 = zexti %138 : i32 to i64
    %141 = llvm.call @malloc(%140) : (i64) -> !llvm.ptr<i8>
    %142 = llvm.bitcast %141 : !llvm.ptr<i8> to !llvm.ptr<i8>
    %143 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
    %144 = llvm.mlir.constant(0 : i64) : i64
    %145 = llvm.getelementptr %143[%144, %144] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %146 = llvm.call @sprintf_s(%142, %138, %145, %136) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
    %147 = ts.Cast %137 : !ts.number to !ts.string
    %148 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
    %149 = llvm.mlir.constant(0 : i64) : i64
    %150 = llvm.getelementptr %148[%149, %149] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %151 = ts.Constant {value = " "} : !ts.string
    %152 = llvm.intr.stacksave : !llvm.ptr<i8>
    %153 = llvm.mlir.constant(1 : i64) : i64
    %154 = llvm.call @strlen(%28) : (!llvm.ptr<i8>) -> i64
    %155 = llvm.add %153, %154  : i64
    %156 = llvm.call @strlen(%150) : (!llvm.ptr<i8>) -> i64
    %157 = llvm.add %155, %156  : i64
    %158 = llvm.call @strlen(%142) : (!llvm.ptr<i8>) -> i64
    %159 = llvm.add %157, %158  : i64
    %160 = llvm.alloca %159 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
    %161 = llvm.call @strcpy(%160, %28) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %162 = llvm.call @strcat(%161, %150) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %163 = llvm.call @strcat(%162, %142) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %164 = "ts.StringConcat"(%28, %151, %142) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
    %165 = llvm.call @puts(%164) : (!ts.string) -> i32
    llvm.intr.stackrestore %152
    ts.Print(%29, %147) : !ts.string, !ts.string
    llvm.br ^bb6
    br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
    %166 = llvm.call @puts(%32) : (!llvm.ptr<i8>) -> i32
    ts.Print(%33) : !ts.string
    llvm.return
    ts.ReturnInternal
  }
  func @main()
  ts.Func @main () -> ()  {
  }
  llvm.func @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x278e950bce0) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FuncOpConversion"
    ** Insert  : 'llvm.func'(0x278e9513950)
    ** Erase   : 'func'(0x278e950bce0)
"`anonymous-namespace'::FuncOpConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x278e9513950) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  llvm.func @strcat(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strcpy(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strlen(!llvm.ptr<i8>) -> i64
  llvm.func @sprintf_s(!llvm.ptr<i8>, i32, !llvm.ptr<i8>, ...) -> i32
  llvm.func @puts(!llvm.ptr<i8>) -> i32
  llvm.func @strcmp(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  llvm.func @llvm.memcpy.p0i8.p0i8.i64(!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1)
  llvm.mlir.global internal constant @s_9237349086447201248("number\00")
  llvm.mlir.global internal constant @s_13617892236937420068("b number: \00")
  llvm.mlir.global internal constant @s_6682479467004374669("done.\00")
  llvm.mlir.global internal constant @frmt_555404038213028357("%g\00")
  llvm.mlir.global internal constant @s_12638117931323064703(" \00")
  llvm.func @main() {
    %0 = llvm.mlir.constant(1 : i32) : i32
    %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %2 = llvm.mlir.constant(1 : i32) : i32
    %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %4 = llvm.mlir.constant(1 : i32) : i32
    %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %6 = llvm.mlir.constant(1 : i32) : i32
    %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %8 = llvm.mlir.constant(1 : i32) : i32
    %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %10 = llvm.mlir.constant(1 : i32) : i32
    %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %12 = llvm.mlir.constant(1 : i32) : i32
    %13 = llvm.alloca %12 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %14 = llvm.mlir.constant(1 : i32) : i32
    %15 = llvm.alloca %14 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %16 = llvm.mlir.constant(1.000000e+01 : f64) : f64
    %cst = constant 1.000000e+01 : f64
    %17 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %19 = llvm.mlir.constant(0 : i64) : i64
    %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %21 = ts.Constant {value = "number"} : !ts.string
    %22 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %23 = llvm.mlir.constant(0 : i64) : i64
    %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %25 = ts.Constant {value = "number"} : !ts.string
    %26 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
    %27 = llvm.mlir.constant(0 : i64) : i64
    %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %29 = ts.Constant {value = "b number: "} : !ts.string
    %30 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
    %31 = llvm.mlir.constant(0 : i64) : i64
    %32 = llvm.getelementptr %30[%31, %31] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %33 = ts.Constant {value = "done."} : !ts.string
    %34 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %35 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %36 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
    %37 = llvm.insertvalue %21, %36[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %38 = llvm.insertvalue %17, %37[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    llvm.store %38, %11 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %39 = ts.Variable(%38) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %40 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %41 = llvm.bitcast %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %42 = llvm.bitcast %11 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %43 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %44 = llvm.mlir.constant(1 : i64) : i64
    %45 = llvm.getelementptr %43[%44] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %46 = llvm.ptrtoint %45 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %47 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %48 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %49 = llvm.mlir.constant(1 : i64) : i64
    %50 = llvm.getelementptr %48[%49] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %51 = llvm.ptrtoint %50 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %52 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %53 = llvm.icmp "ult" %47, %52 : i64
    %54 = llvm.select %53, %47, %52 : i1, i64
    %55 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%41, %42, %54, %55) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%40, %39) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
    %56 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %57 = ts.Load(%40) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %58 = ts.CreateUnionInstance %17, %21 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    llvm.store %56, %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %58, %34 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %59 = llvm.load %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %60 = ts.Load(%34) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %61 = llvm.extractvalue %59[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %62 = ts.GetValueFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
    %63 = llvm.extractvalue %59[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %64 = ts.GetTypeInfoFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
    %65 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %66 = llvm.insertvalue %64, %65[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %67 = llvm.insertvalue %62, %66[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    llvm.store %67, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %68 = ts.Variable(%67) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
    %69 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %70 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
    %71 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %72 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %73 = llvm.mlir.constant(1 : i64) : i64
    %74 = llvm.getelementptr %72[%73] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %75 = llvm.ptrtoint %74 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %76 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %77 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %78 = llvm.mlir.constant(1 : i64) : i64
    %79 = llvm.getelementptr %77[%78] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %80 = llvm.ptrtoint %79 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
    %81 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
    %82 = llvm.icmp "ult" %76, %81 : i64
    %83 = llvm.select %82, %76, %81 : i1, i64
    %84 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%70, %71, %83, %84) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%69, %68) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
    %85 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %86 = ts.Load(%69) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %87 = ts.CreateUnionInstance %62, %64 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
    %88 = ts.Cast %60 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
    llvm.store %85, %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    ts.Store %88, %35 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %89 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %90 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %91 = llvm.extractvalue %89[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
    %92 = ts.GetTypeInfoFromUnionOp %90 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
    %93 = llvm.mlir.constant(0 : i64) : i64
    %94 = llvm.ptrtoint %91 : !llvm.ptr<i8> to i64
    %95 = llvm.ptrtoint %24 : !llvm.ptr<i8> to i64
    %96 = llvm.icmp "ne" %94, %93 : i64
    %97 = llvm.icmp "ne" %95, %93 : i64
    %98 = llvm.zext %96 : i1 to i32
    %99 = zexti %96 : i1 to i32
    %100 = ts.Cast %96 : i1 to i32
    %101 = llvm.zext %97 : i1 to i32
    %102 = zexti %97 : i1 to i32
    %103 = ts.Cast %97 : i1 to i32
    %104 = llvm.and %100, %103  : i32
    %105 = llvm.mlir.constant(0 : i32) : i32
    %106 = llvm.icmp "ne" %104, %105 : i32
    llvm.cond_br %106, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %107 = llvm.mlir.constant(0 : i32) : i32
    %108 = llvm.call @strcmp(%91, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
    %109 = llvm.icmp "eq" %108, %107 : i32
    llvm.br ^bb3(%109 : i1)
  ^bb2:  // pred: ^bb0
    %110 = llvm.icmp "eq" %94, %95 : i64
    llvm.br ^bb3(%110 : i1)
  ^bb3(%111: i1):  // 2 preds: ^bb1, ^bb2
    llvm.br ^bb4
  ^bb4:  // pred: ^bb3
    %112 = "ts.StringCompare"(%91, %24) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
    %113 = ts.LogicalBinary %92(34) %25 : !ts.string, !ts.string -> !ts.boolean
    %114 = ts.Cast %113 : !ts.boolean to i1
    llvm.cond_br %111, ^bb5, ^bb6
    cond_br %114, ^bb5, ^bb6
  ^bb5:  // 2 preds: ^bb4, ^bb4
    %115 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %116 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    llvm.store %115, %3 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %117 = ts.Variable(%115) {false} : !llvm.struct<(ptr<i8>, i1)> -> !ts.ref<!llvm.struct<(ptr<i8>, i1)>>
    %118 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %119 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %120 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
    %121 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %122 = llvm.mlir.constant(1 : i64) : i64
    %123 = llvm.getelementptr %121[%122] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %124 = llvm.ptrtoint %123 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
    %125 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
    %126 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %127 = llvm.mlir.constant(1 : i64) : i64
    %128 = llvm.getelementptr %126[%127] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %129 = llvm.ptrtoint %128 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %130 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %131 = llvm.icmp "ult" %125, %130 : i64
    %132 = llvm.select %131, %125, %130 : i1, i64
    %133 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%119, %120, %132, %133) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%118, %117) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, i1)>>) -> ()
    %134 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %135 = ts.Load(%118) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
    %136 = llvm.extractvalue %135[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %137 = ts.GetValueFromUnionOp %116 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %138 = llvm.mlir.constant(50 : i32) : i32
    %139 = llvm.zext %138 : i32 to i64
    %140 = zexti %138 : i32 to i64
    %141 = llvm.call @malloc(%140) : (i64) -> !llvm.ptr<i8>
    %142 = llvm.bitcast %141 : !llvm.ptr<i8> to !llvm.ptr<i8>
    %143 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
    %144 = llvm.mlir.constant(0 : i64) : i64
    %145 = llvm.getelementptr %143[%144, %144] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %146 = llvm.call @sprintf_s(%142, %138, %145, %136) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
    %147 = ts.Cast %137 : !ts.number to !ts.string
    %148 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
    %149 = llvm.mlir.constant(0 : i64) : i64
    %150 = llvm.getelementptr %148[%149, %149] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %151 = ts.Constant {value = " "} : !ts.string
    %152 = llvm.intr.stacksave : !llvm.ptr<i8>
    %153 = llvm.mlir.constant(1 : i64) : i64
    %154 = llvm.call @strlen(%28) : (!llvm.ptr<i8>) -> i64
    %155 = llvm.add %153, %154  : i64
    %156 = llvm.call @strlen(%150) : (!llvm.ptr<i8>) -> i64
    %157 = llvm.add %155, %156  : i64
    %158 = llvm.call @strlen(%142) : (!llvm.ptr<i8>) -> i64
    %159 = llvm.add %157, %158  : i64
    %160 = llvm.alloca %159 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
    %161 = llvm.call @strcpy(%160, %28) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %162 = llvm.call @strcat(%161, %150) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %163 = llvm.call @strcat(%162, %142) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %164 = "ts.StringConcat"(%28, %151, %142) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
    %165 = llvm.call @puts(%164) : (!ts.string) -> i32
    llvm.intr.stackrestore %152
    ts.Print(%29, %147) : !ts.string, !ts.string
    llvm.br ^bb6
    br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
    %166 = llvm.call @puts(%32) : (!llvm.ptr<i8>) -> i32
    ts.Print(%33) : !ts.string
    llvm.return
    ts.ReturnInternal
  }
  func @main()
  ts.Func @main () -> ()  {
  }
  llvm.func @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x278e950cec0) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FuncOpConversion"
    ** Insert  : 'llvm.func'(0x278e9513e20)
    ** Erase   : 'func'(0x278e950cec0)
"`anonymous-namespace'::FuncOpConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x278e9513e20) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  llvm.func @strcat(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strcpy(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strlen(!llvm.ptr<i8>) -> i64
  llvm.func @sprintf_s(!llvm.ptr<i8>, i32, !llvm.ptr<i8>, ...) -> i32
  llvm.func @puts(!llvm.ptr<i8>) -> i32
  llvm.func @strcmp(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  llvm.func @llvm.memcpy.p0i8.p0i8.i64(!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1)
  llvm.mlir.global internal constant @s_9237349086447201248("number\00")
  llvm.mlir.global internal constant @s_13617892236937420068("b number: \00")
  llvm.mlir.global internal constant @s_6682479467004374669("done.\00")
  llvm.mlir.global internal constant @frmt_555404038213028357("%g\00")
  llvm.mlir.global internal constant @s_12638117931323064703(" \00")
  llvm.func @main() {
    %0 = llvm.mlir.constant(1 : i32) : i32
    %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %2 = llvm.mlir.constant(1 : i32) : i32
    %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %4 = llvm.mlir.constant(1 : i32) : i32
    %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %6 = llvm.mlir.constant(1 : i32) : i32
    %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %8 = llvm.mlir.constant(1 : i32) : i32
    %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %10 = llvm.mlir.constant(1 : i32) : i32
    %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %12 = llvm.mlir.constant(1 : i32) : i32
    %13 = llvm.alloca %12 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %14 = llvm.mlir.constant(1 : i32) : i32
    %15 = llvm.alloca %14 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %16 = llvm.mlir.constant(1.000000e+01 : f64) : f64
    %cst = constant 1.000000e+01 : f64
    %17 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %19 = llvm.mlir.constant(0 : i64) : i64
    %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %21 = ts.Constant {value = "number"} : !ts.string
    %22 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %23 = llvm.mlir.constant(0 : i64) : i64
    %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %25 = ts.Constant {value = "number"} : !ts.string
    %26 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
    %27 = llvm.mlir.constant(0 : i64) : i64
    %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %29 = ts.Constant {value = "b number: "} : !ts.string
    %30 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
    %31 = llvm.mlir.constant(0 : i64) : i64
    %32 = llvm.getelementptr %30[%31, %31] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %33 = ts.Constant {value = "done."} : !ts.string
    %34 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %35 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %36 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
    %37 = llvm.insertvalue %21, %36[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %38 = llvm.insertvalue %17, %37[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    llvm.store %38, %11 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %39 = ts.Variable(%38) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %40 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %41 = llvm.bitcast %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %42 = llvm.bitcast %11 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %43 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %44 = llvm.mlir.constant(1 : i64) : i64
    %45 = llvm.getelementptr %43[%44] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %46 = llvm.ptrtoint %45 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %47 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %48 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %49 = llvm.mlir.constant(1 : i64) : i64
    %50 = llvm.getelementptr %48[%49] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %51 = llvm.ptrtoint %50 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %52 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %53 = llvm.icmp "ult" %47, %52 : i64
    %54 = llvm.select %53, %47, %52 : i1, i64
    %55 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%41, %42, %54, %55) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%40, %39) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
    %56 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %57 = ts.Load(%40) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %58 = ts.CreateUnionInstance %17, %21 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    llvm.store %56, %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %58, %34 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %59 = llvm.load %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %60 = ts.Load(%34) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %61 = llvm.extractvalue %59[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %62 = ts.GetValueFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
    %63 = llvm.extractvalue %59[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %64 = ts.GetTypeInfoFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
    %65 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %66 = llvm.insertvalue %64, %65[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %67 = llvm.insertvalue %62, %66[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    llvm.store %67, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %68 = ts.Variable(%67) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
    %69 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %70 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
    %71 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %72 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %73 = llvm.mlir.constant(1 : i64) : i64
    %74 = llvm.getelementptr %72[%73] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %75 = llvm.ptrtoint %74 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %76 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %77 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %78 = llvm.mlir.constant(1 : i64) : i64
    %79 = llvm.getelementptr %77[%78] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %80 = llvm.ptrtoint %79 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
    %81 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
    %82 = llvm.icmp "ult" %76, %81 : i64
    %83 = llvm.select %82, %76, %81 : i1, i64
    %84 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%70, %71, %83, %84) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%69, %68) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
    %85 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %86 = ts.Load(%69) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %87 = ts.CreateUnionInstance %62, %64 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
    %88 = ts.Cast %60 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
    llvm.store %85, %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    ts.Store %88, %35 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %89 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %90 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %91 = llvm.extractvalue %89[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
    %92 = ts.GetTypeInfoFromUnionOp %90 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
    %93 = llvm.mlir.constant(0 : i64) : i64
    %94 = llvm.ptrtoint %91 : !llvm.ptr<i8> to i64
    %95 = llvm.ptrtoint %24 : !llvm.ptr<i8> to i64
    %96 = llvm.icmp "ne" %94, %93 : i64
    %97 = llvm.icmp "ne" %95, %93 : i64
    %98 = llvm.zext %96 : i1 to i32
    %99 = zexti %96 : i1 to i32
    %100 = ts.Cast %96 : i1 to i32
    %101 = llvm.zext %97 : i1 to i32
    %102 = zexti %97 : i1 to i32
    %103 = ts.Cast %97 : i1 to i32
    %104 = llvm.and %100, %103  : i32
    %105 = llvm.mlir.constant(0 : i32) : i32
    %106 = llvm.icmp "ne" %104, %105 : i32
    llvm.cond_br %106, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %107 = llvm.mlir.constant(0 : i32) : i32
    %108 = llvm.call @strcmp(%91, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
    %109 = llvm.icmp "eq" %108, %107 : i32
    llvm.br ^bb3(%109 : i1)
  ^bb2:  // pred: ^bb0
    %110 = llvm.icmp "eq" %94, %95 : i64
    llvm.br ^bb3(%110 : i1)
  ^bb3(%111: i1):  // 2 preds: ^bb1, ^bb2
    llvm.br ^bb4
  ^bb4:  // pred: ^bb3
    %112 = "ts.StringCompare"(%91, %24) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
    %113 = ts.LogicalBinary %92(34) %25 : !ts.string, !ts.string -> !ts.boolean
    %114 = ts.Cast %113 : !ts.boolean to i1
    llvm.cond_br %111, ^bb5, ^bb6
    cond_br %114, ^bb5, ^bb6
  ^bb5:  // 2 preds: ^bb4, ^bb4
    %115 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %116 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    llvm.store %115, %3 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %117 = ts.Variable(%115) {false} : !llvm.struct<(ptr<i8>, i1)> -> !ts.ref<!llvm.struct<(ptr<i8>, i1)>>
    %118 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %119 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %120 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
    %121 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %122 = llvm.mlir.constant(1 : i64) : i64
    %123 = llvm.getelementptr %121[%122] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %124 = llvm.ptrtoint %123 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
    %125 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
    %126 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %127 = llvm.mlir.constant(1 : i64) : i64
    %128 = llvm.getelementptr %126[%127] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %129 = llvm.ptrtoint %128 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %130 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %131 = llvm.icmp "ult" %125, %130 : i64
    %132 = llvm.select %131, %125, %130 : i1, i64
    %133 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%119, %120, %132, %133) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%118, %117) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, i1)>>) -> ()
    %134 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %135 = ts.Load(%118) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
    %136 = llvm.extractvalue %135[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %137 = ts.GetValueFromUnionOp %116 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %138 = llvm.mlir.constant(50 : i32) : i32
    %139 = llvm.zext %138 : i32 to i64
    %140 = zexti %138 : i32 to i64
    %141 = llvm.call @malloc(%140) : (i64) -> !llvm.ptr<i8>
    %142 = llvm.bitcast %141 : !llvm.ptr<i8> to !llvm.ptr<i8>
    %143 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
    %144 = llvm.mlir.constant(0 : i64) : i64
    %145 = llvm.getelementptr %143[%144, %144] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %146 = llvm.call @sprintf_s(%142, %138, %145, %136) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
    %147 = ts.Cast %137 : !ts.number to !ts.string
    %148 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
    %149 = llvm.mlir.constant(0 : i64) : i64
    %150 = llvm.getelementptr %148[%149, %149] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %151 = ts.Constant {value = " "} : !ts.string
    %152 = llvm.intr.stacksave : !llvm.ptr<i8>
    %153 = llvm.mlir.constant(1 : i64) : i64
    %154 = llvm.call @strlen(%28) : (!llvm.ptr<i8>) -> i64
    %155 = llvm.add %153, %154  : i64
    %156 = llvm.call @strlen(%150) : (!llvm.ptr<i8>) -> i64
    %157 = llvm.add %155, %156  : i64
    %158 = llvm.call @strlen(%142) : (!llvm.ptr<i8>) -> i64
    %159 = llvm.add %157, %158  : i64
    %160 = llvm.alloca %159 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
    %161 = llvm.call @strcpy(%160, %28) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %162 = llvm.call @strcat(%161, %150) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %163 = llvm.call @strcat(%162, %142) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %164 = "ts.StringConcat"(%28, %151, %142) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
    %165 = llvm.call @puts(%164) : (!ts.string) -> i32
    llvm.intr.stackrestore %152
    ts.Print(%29, %147) : !ts.string, !ts.string
    llvm.br ^bb6
    br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
    %166 = llvm.call @puts(%32) : (!llvm.ptr<i8>) -> i32
    ts.Print(%33) : !ts.string
    llvm.return
    ts.ReturnInternal
  }
  func @main()
  ts.Func @main () -> ()  {
  }
  llvm.func @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x278e950a630) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FuncOpConversion"
    ** Insert  : 'llvm.func'(0x278e9513690)
    ** Erase   : 'func'(0x278e950a630)
"`anonymous-namespace'::FuncOpConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x278e9513690) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  llvm.func @strcat(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strcpy(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strlen(!llvm.ptr<i8>) -> i64
  llvm.func @sprintf_s(!llvm.ptr<i8>, i32, !llvm.ptr<i8>, ...) -> i32
  llvm.func @puts(!llvm.ptr<i8>) -> i32
  llvm.func @strcmp(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  llvm.func @llvm.memcpy.p0i8.p0i8.i64(!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1)
  llvm.mlir.global internal constant @s_9237349086447201248("number\00")
  llvm.mlir.global internal constant @s_13617892236937420068("b number: \00")
  llvm.mlir.global internal constant @s_6682479467004374669("done.\00")
  llvm.mlir.global internal constant @frmt_555404038213028357("%g\00")
  llvm.mlir.global internal constant @s_12638117931323064703(" \00")
  llvm.func @main() {
    %0 = llvm.mlir.constant(1 : i32) : i32
    %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %2 = llvm.mlir.constant(1 : i32) : i32
    %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %4 = llvm.mlir.constant(1 : i32) : i32
    %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %6 = llvm.mlir.constant(1 : i32) : i32
    %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %8 = llvm.mlir.constant(1 : i32) : i32
    %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %10 = llvm.mlir.constant(1 : i32) : i32
    %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %12 = llvm.mlir.constant(1 : i32) : i32
    %13 = llvm.alloca %12 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %14 = llvm.mlir.constant(1 : i32) : i32
    %15 = llvm.alloca %14 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %16 = llvm.mlir.constant(1.000000e+01 : f64) : f64
    %cst = constant 1.000000e+01 : f64
    %17 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %19 = llvm.mlir.constant(0 : i64) : i64
    %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %21 = ts.Constant {value = "number"} : !ts.string
    %22 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %23 = llvm.mlir.constant(0 : i64) : i64
    %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %25 = ts.Constant {value = "number"} : !ts.string
    %26 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
    %27 = llvm.mlir.constant(0 : i64) : i64
    %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %29 = ts.Constant {value = "b number: "} : !ts.string
    %30 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
    %31 = llvm.mlir.constant(0 : i64) : i64
    %32 = llvm.getelementptr %30[%31, %31] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %33 = ts.Constant {value = "done."} : !ts.string
    %34 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %35 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %36 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
    %37 = llvm.insertvalue %21, %36[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %38 = llvm.insertvalue %17, %37[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    llvm.store %38, %11 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %39 = ts.Variable(%38) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %40 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %41 = llvm.bitcast %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %42 = llvm.bitcast %11 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %43 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %44 = llvm.mlir.constant(1 : i64) : i64
    %45 = llvm.getelementptr %43[%44] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %46 = llvm.ptrtoint %45 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %47 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %48 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %49 = llvm.mlir.constant(1 : i64) : i64
    %50 = llvm.getelementptr %48[%49] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %51 = llvm.ptrtoint %50 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %52 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %53 = llvm.icmp "ult" %47, %52 : i64
    %54 = llvm.select %53, %47, %52 : i1, i64
    %55 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%41, %42, %54, %55) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%40, %39) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
    %56 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %57 = ts.Load(%40) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %58 = ts.CreateUnionInstance %17, %21 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    llvm.store %56, %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %58, %34 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %59 = llvm.load %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %60 = ts.Load(%34) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %61 = llvm.extractvalue %59[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %62 = ts.GetValueFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
    %63 = llvm.extractvalue %59[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %64 = ts.GetTypeInfoFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
    %65 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %66 = llvm.insertvalue %64, %65[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %67 = llvm.insertvalue %62, %66[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    llvm.store %67, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %68 = ts.Variable(%67) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
    %69 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %70 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
    %71 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %72 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %73 = llvm.mlir.constant(1 : i64) : i64
    %74 = llvm.getelementptr %72[%73] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %75 = llvm.ptrtoint %74 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %76 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %77 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %78 = llvm.mlir.constant(1 : i64) : i64
    %79 = llvm.getelementptr %77[%78] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %80 = llvm.ptrtoint %79 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
    %81 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
    %82 = llvm.icmp "ult" %76, %81 : i64
    %83 = llvm.select %82, %76, %81 : i1, i64
    %84 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%70, %71, %83, %84) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%69, %68) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
    %85 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %86 = ts.Load(%69) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %87 = ts.CreateUnionInstance %62, %64 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
    %88 = ts.Cast %60 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
    llvm.store %85, %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    ts.Store %88, %35 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %89 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %90 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %91 = llvm.extractvalue %89[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
    %92 = ts.GetTypeInfoFromUnionOp %90 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
    %93 = llvm.mlir.constant(0 : i64) : i64
    %94 = llvm.ptrtoint %91 : !llvm.ptr<i8> to i64
    %95 = llvm.ptrtoint %24 : !llvm.ptr<i8> to i64
    %96 = llvm.icmp "ne" %94, %93 : i64
    %97 = llvm.icmp "ne" %95, %93 : i64
    %98 = llvm.zext %96 : i1 to i32
    %99 = zexti %96 : i1 to i32
    %100 = ts.Cast %96 : i1 to i32
    %101 = llvm.zext %97 : i1 to i32
    %102 = zexti %97 : i1 to i32
    %103 = ts.Cast %97 : i1 to i32
    %104 = llvm.and %100, %103  : i32
    %105 = llvm.mlir.constant(0 : i32) : i32
    %106 = llvm.icmp "ne" %104, %105 : i32
    llvm.cond_br %106, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %107 = llvm.mlir.constant(0 : i32) : i32
    %108 = llvm.call @strcmp(%91, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
    %109 = llvm.icmp "eq" %108, %107 : i32
    llvm.br ^bb3(%109 : i1)
  ^bb2:  // pred: ^bb0
    %110 = llvm.icmp "eq" %94, %95 : i64
    llvm.br ^bb3(%110 : i1)
  ^bb3(%111: i1):  // 2 preds: ^bb1, ^bb2
    llvm.br ^bb4
  ^bb4:  // pred: ^bb3
    %112 = "ts.StringCompare"(%91, %24) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
    %113 = ts.LogicalBinary %92(34) %25 : !ts.string, !ts.string -> !ts.boolean
    %114 = ts.Cast %113 : !ts.boolean to i1
    llvm.cond_br %111, ^bb5, ^bb6
    cond_br %114, ^bb5, ^bb6
  ^bb5:  // 2 preds: ^bb4, ^bb4
    %115 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %116 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    llvm.store %115, %3 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %117 = ts.Variable(%115) {false} : !llvm.struct<(ptr<i8>, i1)> -> !ts.ref<!llvm.struct<(ptr<i8>, i1)>>
    %118 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %119 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %120 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
    %121 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %122 = llvm.mlir.constant(1 : i64) : i64
    %123 = llvm.getelementptr %121[%122] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %124 = llvm.ptrtoint %123 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
    %125 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
    %126 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %127 = llvm.mlir.constant(1 : i64) : i64
    %128 = llvm.getelementptr %126[%127] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %129 = llvm.ptrtoint %128 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %130 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %131 = llvm.icmp "ult" %125, %130 : i64
    %132 = llvm.select %131, %125, %130 : i1, i64
    %133 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%119, %120, %132, %133) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%118, %117) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, i1)>>) -> ()
    %134 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %135 = ts.Load(%118) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
    %136 = llvm.extractvalue %135[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %137 = ts.GetValueFromUnionOp %116 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %138 = llvm.mlir.constant(50 : i32) : i32
    %139 = llvm.zext %138 : i32 to i64
    %140 = zexti %138 : i32 to i64
    %141 = llvm.call @malloc(%140) : (i64) -> !llvm.ptr<i8>
    %142 = llvm.bitcast %141 : !llvm.ptr<i8> to !llvm.ptr<i8>
    %143 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
    %144 = llvm.mlir.constant(0 : i64) : i64
    %145 = llvm.getelementptr %143[%144, %144] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %146 = llvm.call @sprintf_s(%142, %138, %145, %136) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
    %147 = ts.Cast %137 : !ts.number to !ts.string
    %148 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
    %149 = llvm.mlir.constant(0 : i64) : i64
    %150 = llvm.getelementptr %148[%149, %149] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %151 = ts.Constant {value = " "} : !ts.string
    %152 = llvm.intr.stacksave : !llvm.ptr<i8>
    %153 = llvm.mlir.constant(1 : i64) : i64
    %154 = llvm.call @strlen(%28) : (!llvm.ptr<i8>) -> i64
    %155 = llvm.add %153, %154  : i64
    %156 = llvm.call @strlen(%150) : (!llvm.ptr<i8>) -> i64
    %157 = llvm.add %155, %156  : i64
    %158 = llvm.call @strlen(%142) : (!llvm.ptr<i8>) -> i64
    %159 = llvm.add %157, %158  : i64
    %160 = llvm.alloca %159 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
    %161 = llvm.call @strcpy(%160, %28) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %162 = llvm.call @strcat(%161, %150) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %163 = llvm.call @strcat(%162, %142) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %164 = "ts.StringConcat"(%28, %151, %142) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
    %165 = llvm.call @puts(%164) : (!ts.string) -> i32
    llvm.intr.stackrestore %152
    ts.Print(%29, %147) : !ts.string, !ts.string
    llvm.br ^bb6
    br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
    %166 = llvm.call @puts(%32) : (!llvm.ptr<i8>) -> i32
    ts.Print(%33) : !ts.string
    llvm.return
    ts.ReturnInternal
  }
  func @main()
  ts.Func @main () -> ()  {
  }
  llvm.func @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x278e950be40) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FuncOpConversion"
    ** Insert  : 'llvm.func'(0x278e95140e0)
    ** Erase   : 'func'(0x278e950be40)
"`anonymous-namespace'::FuncOpConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x278e95140e0) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  llvm.func @strcat(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strcpy(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strlen(!llvm.ptr<i8>) -> i64
  llvm.func @sprintf_s(!llvm.ptr<i8>, i32, !llvm.ptr<i8>, ...) -> i32
  llvm.func @puts(!llvm.ptr<i8>) -> i32
  llvm.func @strcmp(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  llvm.func @llvm.memcpy.p0i8.p0i8.i64(!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1)
  llvm.mlir.global internal constant @s_9237349086447201248("number\00")
  llvm.mlir.global internal constant @s_13617892236937420068("b number: \00")
  llvm.mlir.global internal constant @s_6682479467004374669("done.\00")
  llvm.mlir.global internal constant @frmt_555404038213028357("%g\00")
  llvm.mlir.global internal constant @s_12638117931323064703(" \00")
  llvm.func @main() {
    %0 = llvm.mlir.constant(1 : i32) : i32
    %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %2 = llvm.mlir.constant(1 : i32) : i32
    %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %4 = llvm.mlir.constant(1 : i32) : i32
    %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %6 = llvm.mlir.constant(1 : i32) : i32
    %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %8 = llvm.mlir.constant(1 : i32) : i32
    %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %10 = llvm.mlir.constant(1 : i32) : i32
    %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %12 = llvm.mlir.constant(1 : i32) : i32
    %13 = llvm.alloca %12 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %14 = llvm.mlir.constant(1 : i32) : i32
    %15 = llvm.alloca %14 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %16 = llvm.mlir.constant(1.000000e+01 : f64) : f64
    %cst = constant 1.000000e+01 : f64
    %17 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %19 = llvm.mlir.constant(0 : i64) : i64
    %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %21 = ts.Constant {value = "number"} : !ts.string
    %22 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %23 = llvm.mlir.constant(0 : i64) : i64
    %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %25 = ts.Constant {value = "number"} : !ts.string
    %26 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
    %27 = llvm.mlir.constant(0 : i64) : i64
    %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %29 = ts.Constant {value = "b number: "} : !ts.string
    %30 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
    %31 = llvm.mlir.constant(0 : i64) : i64
    %32 = llvm.getelementptr %30[%31, %31] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %33 = ts.Constant {value = "done."} : !ts.string
    %34 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %35 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %36 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
    %37 = llvm.insertvalue %21, %36[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %38 = llvm.insertvalue %17, %37[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    llvm.store %38, %11 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %39 = ts.Variable(%38) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %40 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %41 = llvm.bitcast %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %42 = llvm.bitcast %11 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %43 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %44 = llvm.mlir.constant(1 : i64) : i64
    %45 = llvm.getelementptr %43[%44] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %46 = llvm.ptrtoint %45 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %47 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %48 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %49 = llvm.mlir.constant(1 : i64) : i64
    %50 = llvm.getelementptr %48[%49] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %51 = llvm.ptrtoint %50 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %52 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %53 = llvm.icmp "ult" %47, %52 : i64
    %54 = llvm.select %53, %47, %52 : i1, i64
    %55 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%41, %42, %54, %55) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%40, %39) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
    %56 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %57 = ts.Load(%40) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %58 = ts.CreateUnionInstance %17, %21 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    llvm.store %56, %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %58, %34 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %59 = llvm.load %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %60 = ts.Load(%34) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %61 = llvm.extractvalue %59[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %62 = ts.GetValueFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
    %63 = llvm.extractvalue %59[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %64 = ts.GetTypeInfoFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
    %65 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %66 = llvm.insertvalue %64, %65[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %67 = llvm.insertvalue %62, %66[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    llvm.store %67, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %68 = ts.Variable(%67) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
    %69 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %70 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
    %71 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %72 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %73 = llvm.mlir.constant(1 : i64) : i64
    %74 = llvm.getelementptr %72[%73] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %75 = llvm.ptrtoint %74 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %76 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %77 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %78 = llvm.mlir.constant(1 : i64) : i64
    %79 = llvm.getelementptr %77[%78] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %80 = llvm.ptrtoint %79 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
    %81 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
    %82 = llvm.icmp "ult" %76, %81 : i64
    %83 = llvm.select %82, %76, %81 : i1, i64
    %84 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%70, %71, %83, %84) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%69, %68) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
    %85 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %86 = ts.Load(%69) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %87 = ts.CreateUnionInstance %62, %64 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
    %88 = ts.Cast %60 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
    llvm.store %85, %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    ts.Store %88, %35 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %89 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %90 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %91 = llvm.extractvalue %89[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
    %92 = ts.GetTypeInfoFromUnionOp %90 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
    %93 = llvm.mlir.constant(0 : i64) : i64
    %94 = llvm.ptrtoint %91 : !llvm.ptr<i8> to i64
    %95 = llvm.ptrtoint %24 : !llvm.ptr<i8> to i64
    %96 = llvm.icmp "ne" %94, %93 : i64
    %97 = llvm.icmp "ne" %95, %93 : i64
    %98 = llvm.zext %96 : i1 to i32
    %99 = zexti %96 : i1 to i32
    %100 = ts.Cast %96 : i1 to i32
    %101 = llvm.zext %97 : i1 to i32
    %102 = zexti %97 : i1 to i32
    %103 = ts.Cast %97 : i1 to i32
    %104 = llvm.and %100, %103  : i32
    %105 = llvm.mlir.constant(0 : i32) : i32
    %106 = llvm.icmp "ne" %104, %105 : i32
    llvm.cond_br %106, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %107 = llvm.mlir.constant(0 : i32) : i32
    %108 = llvm.call @strcmp(%91, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
    %109 = llvm.icmp "eq" %108, %107 : i32
    llvm.br ^bb3(%109 : i1)
  ^bb2:  // pred: ^bb0
    %110 = llvm.icmp "eq" %94, %95 : i64
    llvm.br ^bb3(%110 : i1)
  ^bb3(%111: i1):  // 2 preds: ^bb1, ^bb2
    llvm.br ^bb4
  ^bb4:  // pred: ^bb3
    %112 = "ts.StringCompare"(%91, %24) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
    %113 = ts.LogicalBinary %92(34) %25 : !ts.string, !ts.string -> !ts.boolean
    %114 = ts.Cast %113 : !ts.boolean to i1
    llvm.cond_br %111, ^bb5, ^bb6
    cond_br %114, ^bb5, ^bb6
  ^bb5:  // 2 preds: ^bb4, ^bb4
    %115 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %116 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    llvm.store %115, %3 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %117 = ts.Variable(%115) {false} : !llvm.struct<(ptr<i8>, i1)> -> !ts.ref<!llvm.struct<(ptr<i8>, i1)>>
    %118 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %119 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %120 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
    %121 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %122 = llvm.mlir.constant(1 : i64) : i64
    %123 = llvm.getelementptr %121[%122] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %124 = llvm.ptrtoint %123 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
    %125 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
    %126 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %127 = llvm.mlir.constant(1 : i64) : i64
    %128 = llvm.getelementptr %126[%127] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %129 = llvm.ptrtoint %128 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %130 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %131 = llvm.icmp "ult" %125, %130 : i64
    %132 = llvm.select %131, %125, %130 : i1, i64
    %133 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%119, %120, %132, %133) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%118, %117) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, i1)>>) -> ()
    %134 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %135 = ts.Load(%118) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
    %136 = llvm.extractvalue %135[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %137 = ts.GetValueFromUnionOp %116 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %138 = llvm.mlir.constant(50 : i32) : i32
    %139 = llvm.zext %138 : i32 to i64
    %140 = zexti %138 : i32 to i64
    %141 = llvm.call @malloc(%140) : (i64) -> !llvm.ptr<i8>
    %142 = llvm.bitcast %141 : !llvm.ptr<i8> to !llvm.ptr<i8>
    %143 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
    %144 = llvm.mlir.constant(0 : i64) : i64
    %145 = llvm.getelementptr %143[%144, %144] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %146 = llvm.call @sprintf_s(%142, %138, %145, %136) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
    %147 = ts.Cast %137 : !ts.number to !ts.string
    %148 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
    %149 = llvm.mlir.constant(0 : i64) : i64
    %150 = llvm.getelementptr %148[%149, %149] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %151 = ts.Constant {value = " "} : !ts.string
    %152 = llvm.intr.stacksave : !llvm.ptr<i8>
    %153 = llvm.mlir.constant(1 : i64) : i64
    %154 = llvm.call @strlen(%28) : (!llvm.ptr<i8>) -> i64
    %155 = llvm.add %153, %154  : i64
    %156 = llvm.call @strlen(%150) : (!llvm.ptr<i8>) -> i64
    %157 = llvm.add %155, %156  : i64
    %158 = llvm.call @strlen(%142) : (!llvm.ptr<i8>) -> i64
    %159 = llvm.add %157, %158  : i64
    %160 = llvm.alloca %159 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
    %161 = llvm.call @strcpy(%160, %28) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %162 = llvm.call @strcat(%161, %150) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %163 = llvm.call @strcat(%162, %142) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %164 = "ts.StringConcat"(%28, %151, %142) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
    %165 = llvm.call @puts(%164) : (!ts.string) -> i32
    llvm.intr.stackrestore %152
    ts.Print(%29, %147) : !ts.string, !ts.string
    llvm.br ^bb6
    br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
    %166 = llvm.call @puts(%32) : (!llvm.ptr<i8>) -> i32
    ts.Print(%33) : !ts.string
    llvm.return
    ts.ReturnInternal
  }
  func @main()
  ts.Func @main () -> ()  {
  }
  llvm.func @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x278e950bef0) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FuncOpConversion"
    ** Insert  : 'llvm.func'(0x278e9514920)
    ** Erase   : 'func'(0x278e950bef0)
"`anonymous-namespace'::FuncOpConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x278e9514920) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  llvm.func @strcat(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strcpy(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strlen(!llvm.ptr<i8>) -> i64
  llvm.func @sprintf_s(!llvm.ptr<i8>, i32, !llvm.ptr<i8>, ...) -> i32
  llvm.func @puts(!llvm.ptr<i8>) -> i32
  llvm.func @strcmp(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  llvm.func @llvm.memcpy.p0i8.p0i8.i64(!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1)
  llvm.mlir.global internal constant @s_9237349086447201248("number\00")
  llvm.mlir.global internal constant @s_13617892236937420068("b number: \00")
  llvm.mlir.global internal constant @s_6682479467004374669("done.\00")
  llvm.mlir.global internal constant @frmt_555404038213028357("%g\00")
  llvm.mlir.global internal constant @s_12638117931323064703(" \00")
  llvm.func @main() {
    %0 = llvm.mlir.constant(1 : i32) : i32
    %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %2 = llvm.mlir.constant(1 : i32) : i32
    %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %4 = llvm.mlir.constant(1 : i32) : i32
    %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %6 = llvm.mlir.constant(1 : i32) : i32
    %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %8 = llvm.mlir.constant(1 : i32) : i32
    %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %10 = llvm.mlir.constant(1 : i32) : i32
    %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %12 = llvm.mlir.constant(1 : i32) : i32
    %13 = llvm.alloca %12 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %14 = llvm.mlir.constant(1 : i32) : i32
    %15 = llvm.alloca %14 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %16 = llvm.mlir.constant(1.000000e+01 : f64) : f64
    %cst = constant 1.000000e+01 : f64
    %17 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %19 = llvm.mlir.constant(0 : i64) : i64
    %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %21 = ts.Constant {value = "number"} : !ts.string
    %22 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %23 = llvm.mlir.constant(0 : i64) : i64
    %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %25 = ts.Constant {value = "number"} : !ts.string
    %26 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
    %27 = llvm.mlir.constant(0 : i64) : i64
    %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %29 = ts.Constant {value = "b number: "} : !ts.string
    %30 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
    %31 = llvm.mlir.constant(0 : i64) : i64
    %32 = llvm.getelementptr %30[%31, %31] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %33 = ts.Constant {value = "done."} : !ts.string
    %34 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %35 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %36 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
    %37 = llvm.insertvalue %21, %36[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %38 = llvm.insertvalue %17, %37[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    llvm.store %38, %11 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %39 = ts.Variable(%38) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %40 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %41 = llvm.bitcast %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %42 = llvm.bitcast %11 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %43 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %44 = llvm.mlir.constant(1 : i64) : i64
    %45 = llvm.getelementptr %43[%44] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %46 = llvm.ptrtoint %45 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %47 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %48 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %49 = llvm.mlir.constant(1 : i64) : i64
    %50 = llvm.getelementptr %48[%49] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %51 = llvm.ptrtoint %50 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %52 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %53 = llvm.icmp "ult" %47, %52 : i64
    %54 = llvm.select %53, %47, %52 : i1, i64
    %55 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%41, %42, %54, %55) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%40, %39) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
    %56 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %57 = ts.Load(%40) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %58 = ts.CreateUnionInstance %17, %21 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    llvm.store %56, %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %58, %34 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %59 = llvm.load %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %60 = ts.Load(%34) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %61 = llvm.extractvalue %59[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %62 = ts.GetValueFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
    %63 = llvm.extractvalue %59[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %64 = ts.GetTypeInfoFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
    %65 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %66 = llvm.insertvalue %64, %65[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %67 = llvm.insertvalue %62, %66[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    llvm.store %67, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %68 = ts.Variable(%67) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
    %69 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %70 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
    %71 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %72 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %73 = llvm.mlir.constant(1 : i64) : i64
    %74 = llvm.getelementptr %72[%73] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %75 = llvm.ptrtoint %74 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %76 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %77 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %78 = llvm.mlir.constant(1 : i64) : i64
    %79 = llvm.getelementptr %77[%78] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %80 = llvm.ptrtoint %79 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
    %81 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
    %82 = llvm.icmp "ult" %76, %81 : i64
    %83 = llvm.select %82, %76, %81 : i1, i64
    %84 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%70, %71, %83, %84) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%69, %68) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
    %85 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %86 = ts.Load(%69) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %87 = ts.CreateUnionInstance %62, %64 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
    %88 = ts.Cast %60 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
    llvm.store %85, %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    ts.Store %88, %35 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %89 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %90 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %91 = llvm.extractvalue %89[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
    %92 = ts.GetTypeInfoFromUnionOp %90 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
    %93 = llvm.mlir.constant(0 : i64) : i64
    %94 = llvm.ptrtoint %91 : !llvm.ptr<i8> to i64
    %95 = llvm.ptrtoint %24 : !llvm.ptr<i8> to i64
    %96 = llvm.icmp "ne" %94, %93 : i64
    %97 = llvm.icmp "ne" %95, %93 : i64
    %98 = llvm.zext %96 : i1 to i32
    %99 = zexti %96 : i1 to i32
    %100 = ts.Cast %96 : i1 to i32
    %101 = llvm.zext %97 : i1 to i32
    %102 = zexti %97 : i1 to i32
    %103 = ts.Cast %97 : i1 to i32
    %104 = llvm.and %100, %103  : i32
    %105 = llvm.mlir.constant(0 : i32) : i32
    %106 = llvm.icmp "ne" %104, %105 : i32
    llvm.cond_br %106, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %107 = llvm.mlir.constant(0 : i32) : i32
    %108 = llvm.call @strcmp(%91, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
    %109 = llvm.icmp "eq" %108, %107 : i32
    llvm.br ^bb3(%109 : i1)
  ^bb2:  // pred: ^bb0
    %110 = llvm.icmp "eq" %94, %95 : i64
    llvm.br ^bb3(%110 : i1)
  ^bb3(%111: i1):  // 2 preds: ^bb1, ^bb2
    llvm.br ^bb4
  ^bb4:  // pred: ^bb3
    %112 = "ts.StringCompare"(%91, %24) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
    %113 = ts.LogicalBinary %92(34) %25 : !ts.string, !ts.string -> !ts.boolean
    %114 = ts.Cast %113 : !ts.boolean to i1
    llvm.cond_br %111, ^bb5, ^bb6
    cond_br %114, ^bb5, ^bb6
  ^bb5:  // 2 preds: ^bb4, ^bb4
    %115 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %116 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    llvm.store %115, %3 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %117 = ts.Variable(%115) {false} : !llvm.struct<(ptr<i8>, i1)> -> !ts.ref<!llvm.struct<(ptr<i8>, i1)>>
    %118 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %119 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %120 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
    %121 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %122 = llvm.mlir.constant(1 : i64) : i64
    %123 = llvm.getelementptr %121[%122] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %124 = llvm.ptrtoint %123 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
    %125 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
    %126 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %127 = llvm.mlir.constant(1 : i64) : i64
    %128 = llvm.getelementptr %126[%127] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %129 = llvm.ptrtoint %128 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %130 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %131 = llvm.icmp "ult" %125, %130 : i64
    %132 = llvm.select %131, %125, %130 : i1, i64
    %133 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%119, %120, %132, %133) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%118, %117) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, i1)>>) -> ()
    %134 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %135 = ts.Load(%118) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
    %136 = llvm.extractvalue %135[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %137 = ts.GetValueFromUnionOp %116 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %138 = llvm.mlir.constant(50 : i32) : i32
    %139 = llvm.zext %138 : i32 to i64
    %140 = zexti %138 : i32 to i64
    %141 = llvm.call @malloc(%140) : (i64) -> !llvm.ptr<i8>
    %142 = llvm.bitcast %141 : !llvm.ptr<i8> to !llvm.ptr<i8>
    %143 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
    %144 = llvm.mlir.constant(0 : i64) : i64
    %145 = llvm.getelementptr %143[%144, %144] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %146 = llvm.call @sprintf_s(%142, %138, %145, %136) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
    %147 = ts.Cast %137 : !ts.number to !ts.string
    %148 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
    %149 = llvm.mlir.constant(0 : i64) : i64
    %150 = llvm.getelementptr %148[%149, %149] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %151 = ts.Constant {value = " "} : !ts.string
    %152 = llvm.intr.stacksave : !llvm.ptr<i8>
    %153 = llvm.mlir.constant(1 : i64) : i64
    %154 = llvm.call @strlen(%28) : (!llvm.ptr<i8>) -> i64
    %155 = llvm.add %153, %154  : i64
    %156 = llvm.call @strlen(%150) : (!llvm.ptr<i8>) -> i64
    %157 = llvm.add %155, %156  : i64
    %158 = llvm.call @strlen(%142) : (!llvm.ptr<i8>) -> i64
    %159 = llvm.add %157, %158  : i64
    %160 = llvm.alloca %159 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
    %161 = llvm.call @strcpy(%160, %28) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %162 = llvm.call @strcat(%161, %150) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %163 = llvm.call @strcat(%162, %142) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %164 = "ts.StringConcat"(%28, %151, %142) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
    %165 = llvm.call @puts(%164) : (!ts.string) -> i32
    llvm.intr.stackrestore %152
    ts.Print(%29, %147) : !ts.string, !ts.string
    llvm.br ^bb6
    br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
    %166 = llvm.call @puts(%32) : (!llvm.ptr<i8>) -> i32
    ts.Print(%33) : !ts.string
    llvm.return
    ts.ReturnInternal
  }
  func @main()
  ts.Func @main () -> ()  {
  }
  llvm.func @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x278e950c100) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FuncOpConversion"
    ** Insert  : 'llvm.func'(0x278e9512fb0)
    ** Erase   : 'func'(0x278e950c100)
"`anonymous-namespace'::FuncOpConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x278e9512fb0) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  llvm.func @strcat(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strcpy(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strlen(!llvm.ptr<i8>) -> i64
  llvm.func @sprintf_s(!llvm.ptr<i8>, i32, !llvm.ptr<i8>, ...) -> i32
  llvm.func @puts(!llvm.ptr<i8>) -> i32
  llvm.func @strcmp(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  llvm.func @llvm.memcpy.p0i8.p0i8.i64(!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1)
  llvm.mlir.global internal constant @s_9237349086447201248("number\00")
  llvm.mlir.global internal constant @s_13617892236937420068("b number: \00")
  llvm.mlir.global internal constant @s_6682479467004374669("done.\00")
  llvm.mlir.global internal constant @frmt_555404038213028357("%g\00")
  llvm.mlir.global internal constant @s_12638117931323064703(" \00")
  llvm.func @main() {
    %0 = llvm.mlir.constant(1 : i32) : i32
    %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %2 = llvm.mlir.constant(1 : i32) : i32
    %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %4 = llvm.mlir.constant(1 : i32) : i32
    %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %6 = llvm.mlir.constant(1 : i32) : i32
    %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %8 = llvm.mlir.constant(1 : i32) : i32
    %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %10 = llvm.mlir.constant(1 : i32) : i32
    %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %12 = llvm.mlir.constant(1 : i32) : i32
    %13 = llvm.alloca %12 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %14 = llvm.mlir.constant(1 : i32) : i32
    %15 = llvm.alloca %14 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %16 = llvm.mlir.constant(1.000000e+01 : f64) : f64
    %cst = constant 1.000000e+01 : f64
    %17 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %19 = llvm.mlir.constant(0 : i64) : i64
    %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %21 = ts.Constant {value = "number"} : !ts.string
    %22 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %23 = llvm.mlir.constant(0 : i64) : i64
    %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %25 = ts.Constant {value = "number"} : !ts.string
    %26 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
    %27 = llvm.mlir.constant(0 : i64) : i64
    %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %29 = ts.Constant {value = "b number: "} : !ts.string
    %30 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
    %31 = llvm.mlir.constant(0 : i64) : i64
    %32 = llvm.getelementptr %30[%31, %31] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %33 = ts.Constant {value = "done."} : !ts.string
    %34 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %35 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %36 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
    %37 = llvm.insertvalue %21, %36[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %38 = llvm.insertvalue %17, %37[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    llvm.store %38, %11 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %39 = ts.Variable(%38) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %40 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %41 = llvm.bitcast %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %42 = llvm.bitcast %11 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %43 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %44 = llvm.mlir.constant(1 : i64) : i64
    %45 = llvm.getelementptr %43[%44] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %46 = llvm.ptrtoint %45 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %47 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %48 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %49 = llvm.mlir.constant(1 : i64) : i64
    %50 = llvm.getelementptr %48[%49] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %51 = llvm.ptrtoint %50 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %52 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %53 = llvm.icmp "ult" %47, %52 : i64
    %54 = llvm.select %53, %47, %52 : i1, i64
    %55 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%41, %42, %54, %55) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%40, %39) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
    %56 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %57 = ts.Load(%40) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %58 = ts.CreateUnionInstance %17, %21 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    llvm.store %56, %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %58, %34 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %59 = llvm.load %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %60 = ts.Load(%34) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %61 = llvm.extractvalue %59[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %62 = ts.GetValueFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
    %63 = llvm.extractvalue %59[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %64 = ts.GetTypeInfoFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
    %65 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %66 = llvm.insertvalue %64, %65[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %67 = llvm.insertvalue %62, %66[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    llvm.store %67, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %68 = ts.Variable(%67) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
    %69 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %70 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
    %71 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %72 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %73 = llvm.mlir.constant(1 : i64) : i64
    %74 = llvm.getelementptr %72[%73] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %75 = llvm.ptrtoint %74 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %76 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %77 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %78 = llvm.mlir.constant(1 : i64) : i64
    %79 = llvm.getelementptr %77[%78] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %80 = llvm.ptrtoint %79 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
    %81 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
    %82 = llvm.icmp "ult" %76, %81 : i64
    %83 = llvm.select %82, %76, %81 : i1, i64
    %84 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%70, %71, %83, %84) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%69, %68) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
    %85 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %86 = ts.Load(%69) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %87 = ts.CreateUnionInstance %62, %64 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
    %88 = ts.Cast %60 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
    llvm.store %85, %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    ts.Store %88, %35 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %89 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %90 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %91 = llvm.extractvalue %89[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
    %92 = ts.GetTypeInfoFromUnionOp %90 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
    %93 = llvm.mlir.constant(0 : i64) : i64
    %94 = llvm.ptrtoint %91 : !llvm.ptr<i8> to i64
    %95 = llvm.ptrtoint %24 : !llvm.ptr<i8> to i64
    %96 = llvm.icmp "ne" %94, %93 : i64
    %97 = llvm.icmp "ne" %95, %93 : i64
    %98 = llvm.zext %96 : i1 to i32
    %99 = zexti %96 : i1 to i32
    %100 = ts.Cast %96 : i1 to i32
    %101 = llvm.zext %97 : i1 to i32
    %102 = zexti %97 : i1 to i32
    %103 = ts.Cast %97 : i1 to i32
    %104 = llvm.and %100, %103  : i32
    %105 = llvm.mlir.constant(0 : i32) : i32
    %106 = llvm.icmp "ne" %104, %105 : i32
    llvm.cond_br %106, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %107 = llvm.mlir.constant(0 : i32) : i32
    %108 = llvm.call @strcmp(%91, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
    %109 = llvm.icmp "eq" %108, %107 : i32
    llvm.br ^bb3(%109 : i1)
  ^bb2:  // pred: ^bb0
    %110 = llvm.icmp "eq" %94, %95 : i64
    llvm.br ^bb3(%110 : i1)
  ^bb3(%111: i1):  // 2 preds: ^bb1, ^bb2
    llvm.br ^bb4
  ^bb4:  // pred: ^bb3
    %112 = "ts.StringCompare"(%91, %24) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
    %113 = ts.LogicalBinary %92(34) %25 : !ts.string, !ts.string -> !ts.boolean
    %114 = ts.Cast %113 : !ts.boolean to i1
    llvm.cond_br %111, ^bb5, ^bb6
    cond_br %114, ^bb5, ^bb6
  ^bb5:  // 2 preds: ^bb4, ^bb4
    %115 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %116 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    llvm.store %115, %3 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %117 = ts.Variable(%115) {false} : !llvm.struct<(ptr<i8>, i1)> -> !ts.ref<!llvm.struct<(ptr<i8>, i1)>>
    %118 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %119 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %120 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
    %121 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %122 = llvm.mlir.constant(1 : i64) : i64
    %123 = llvm.getelementptr %121[%122] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %124 = llvm.ptrtoint %123 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
    %125 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
    %126 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %127 = llvm.mlir.constant(1 : i64) : i64
    %128 = llvm.getelementptr %126[%127] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %129 = llvm.ptrtoint %128 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %130 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %131 = llvm.icmp "ult" %125, %130 : i64
    %132 = llvm.select %131, %125, %130 : i1, i64
    %133 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%119, %120, %132, %133) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%118, %117) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, i1)>>) -> ()
    %134 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %135 = ts.Load(%118) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
    %136 = llvm.extractvalue %135[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %137 = ts.GetValueFromUnionOp %116 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %138 = llvm.mlir.constant(50 : i32) : i32
    %139 = llvm.zext %138 : i32 to i64
    %140 = zexti %138 : i32 to i64
    %141 = llvm.call @malloc(%140) : (i64) -> !llvm.ptr<i8>
    %142 = llvm.bitcast %141 : !llvm.ptr<i8> to !llvm.ptr<i8>
    %143 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
    %144 = llvm.mlir.constant(0 : i64) : i64
    %145 = llvm.getelementptr %143[%144, %144] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %146 = llvm.call @sprintf_s(%142, %138, %145, %136) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
    %147 = ts.Cast %137 : !ts.number to !ts.string
    %148 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
    %149 = llvm.mlir.constant(0 : i64) : i64
    %150 = llvm.getelementptr %148[%149, %149] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %151 = ts.Constant {value = " "} : !ts.string
    %152 = llvm.intr.stacksave : !llvm.ptr<i8>
    %153 = llvm.mlir.constant(1 : i64) : i64
    %154 = llvm.call @strlen(%28) : (!llvm.ptr<i8>) -> i64
    %155 = llvm.add %153, %154  : i64
    %156 = llvm.call @strlen(%150) : (!llvm.ptr<i8>) -> i64
    %157 = llvm.add %155, %156  : i64
    %158 = llvm.call @strlen(%142) : (!llvm.ptr<i8>) -> i64
    %159 = llvm.add %157, %158  : i64
    %160 = llvm.alloca %159 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
    %161 = llvm.call @strcpy(%160, %28) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %162 = llvm.call @strcat(%161, %150) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %163 = llvm.call @strcat(%162, %142) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %164 = "ts.StringConcat"(%28, %151, %142) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
    %165 = llvm.call @puts(%164) : (!ts.string) -> i32
    llvm.intr.stackrestore %152
    ts.Print(%29, %147) : !ts.string, !ts.string
    llvm.br ^bb6
    br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
    %166 = llvm.call @puts(%32) : (!llvm.ptr<i8>) -> i32
    ts.Print(%33) : !ts.string
    llvm.return
    ts.ReturnInternal
  }
  func @main()
  ts.Func @main () -> ()  {
  }
  llvm.func @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x278e950ae70) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FuncOpConversion"
    ** Insert  : 'llvm.func'(0x278e9515000)
    ** Erase   : 'func'(0x278e950ae70)
"`anonymous-namespace'::FuncOpConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x278e9515000) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  llvm.func @strcat(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strcpy(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strlen(!llvm.ptr<i8>) -> i64
  llvm.func @sprintf_s(!llvm.ptr<i8>, i32, !llvm.ptr<i8>, ...) -> i32
  llvm.func @puts(!llvm.ptr<i8>) -> i32
  llvm.func @strcmp(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  llvm.func @llvm.memcpy.p0i8.p0i8.i64(!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1)
  llvm.mlir.global internal constant @s_9237349086447201248("number\00")
  llvm.mlir.global internal constant @s_13617892236937420068("b number: \00")
  llvm.mlir.global internal constant @s_6682479467004374669("done.\00")
  llvm.mlir.global internal constant @frmt_555404038213028357("%g\00")
  llvm.mlir.global internal constant @s_12638117931323064703(" \00")
  llvm.func @main() {
    %0 = llvm.mlir.constant(1 : i32) : i32
    %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %2 = llvm.mlir.constant(1 : i32) : i32
    %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %4 = llvm.mlir.constant(1 : i32) : i32
    %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %6 = llvm.mlir.constant(1 : i32) : i32
    %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %8 = llvm.mlir.constant(1 : i32) : i32
    %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %10 = llvm.mlir.constant(1 : i32) : i32
    %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %12 = llvm.mlir.constant(1 : i32) : i32
    %13 = llvm.alloca %12 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %14 = llvm.mlir.constant(1 : i32) : i32
    %15 = llvm.alloca %14 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %16 = llvm.mlir.constant(1.000000e+01 : f64) : f64
    %cst = constant 1.000000e+01 : f64
    %17 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %19 = llvm.mlir.constant(0 : i64) : i64
    %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %21 = ts.Constant {value = "number"} : !ts.string
    %22 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %23 = llvm.mlir.constant(0 : i64) : i64
    %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %25 = ts.Constant {value = "number"} : !ts.string
    %26 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
    %27 = llvm.mlir.constant(0 : i64) : i64
    %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %29 = ts.Constant {value = "b number: "} : !ts.string
    %30 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
    %31 = llvm.mlir.constant(0 : i64) : i64
    %32 = llvm.getelementptr %30[%31, %31] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %33 = ts.Constant {value = "done."} : !ts.string
    %34 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %35 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %36 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
    %37 = llvm.insertvalue %21, %36[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %38 = llvm.insertvalue %17, %37[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    llvm.store %38, %11 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %39 = ts.Variable(%38) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %40 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %41 = llvm.bitcast %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %42 = llvm.bitcast %11 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %43 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %44 = llvm.mlir.constant(1 : i64) : i64
    %45 = llvm.getelementptr %43[%44] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %46 = llvm.ptrtoint %45 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %47 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %48 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %49 = llvm.mlir.constant(1 : i64) : i64
    %50 = llvm.getelementptr %48[%49] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %51 = llvm.ptrtoint %50 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %52 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %53 = llvm.icmp "ult" %47, %52 : i64
    %54 = llvm.select %53, %47, %52 : i1, i64
    %55 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%41, %42, %54, %55) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%40, %39) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
    %56 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %57 = ts.Load(%40) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %58 = ts.CreateUnionInstance %17, %21 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    llvm.store %56, %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %58, %34 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %59 = llvm.load %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %60 = ts.Load(%34) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %61 = llvm.extractvalue %59[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %62 = ts.GetValueFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
    %63 = llvm.extractvalue %59[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %64 = ts.GetTypeInfoFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
    %65 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %66 = llvm.insertvalue %64, %65[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %67 = llvm.insertvalue %62, %66[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    llvm.store %67, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %68 = ts.Variable(%67) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
    %69 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %70 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
    %71 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %72 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %73 = llvm.mlir.constant(1 : i64) : i64
    %74 = llvm.getelementptr %72[%73] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %75 = llvm.ptrtoint %74 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %76 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %77 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %78 = llvm.mlir.constant(1 : i64) : i64
    %79 = llvm.getelementptr %77[%78] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %80 = llvm.ptrtoint %79 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
    %81 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
    %82 = llvm.icmp "ult" %76, %81 : i64
    %83 = llvm.select %82, %76, %81 : i1, i64
    %84 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%70, %71, %83, %84) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%69, %68) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
    %85 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %86 = ts.Load(%69) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %87 = ts.CreateUnionInstance %62, %64 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
    %88 = ts.Cast %60 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
    llvm.store %85, %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    ts.Store %88, %35 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %89 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %90 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %91 = llvm.extractvalue %89[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
    %92 = ts.GetTypeInfoFromUnionOp %90 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
    %93 = llvm.mlir.constant(0 : i64) : i64
    %94 = llvm.ptrtoint %91 : !llvm.ptr<i8> to i64
    %95 = llvm.ptrtoint %24 : !llvm.ptr<i8> to i64
    %96 = llvm.icmp "ne" %94, %93 : i64
    %97 = llvm.icmp "ne" %95, %93 : i64
    %98 = llvm.zext %96 : i1 to i32
    %99 = zexti %96 : i1 to i32
    %100 = ts.Cast %96 : i1 to i32
    %101 = llvm.zext %97 : i1 to i32
    %102 = zexti %97 : i1 to i32
    %103 = ts.Cast %97 : i1 to i32
    %104 = llvm.and %100, %103  : i32
    %105 = llvm.mlir.constant(0 : i32) : i32
    %106 = llvm.icmp "ne" %104, %105 : i32
    llvm.cond_br %106, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %107 = llvm.mlir.constant(0 : i32) : i32
    %108 = llvm.call @strcmp(%91, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
    %109 = llvm.icmp "eq" %108, %107 : i32
    llvm.br ^bb3(%109 : i1)
  ^bb2:  // pred: ^bb0
    %110 = llvm.icmp "eq" %94, %95 : i64
    llvm.br ^bb3(%110 : i1)
  ^bb3(%111: i1):  // 2 preds: ^bb1, ^bb2
    llvm.br ^bb4
  ^bb4:  // pred: ^bb3
    %112 = "ts.StringCompare"(%91, %24) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
    %113 = ts.LogicalBinary %92(34) %25 : !ts.string, !ts.string -> !ts.boolean
    %114 = ts.Cast %113 : !ts.boolean to i1
    llvm.cond_br %111, ^bb5, ^bb6
    cond_br %114, ^bb5, ^bb6
  ^bb5:  // 2 preds: ^bb4, ^bb4
    %115 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %116 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    llvm.store %115, %3 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %117 = ts.Variable(%115) {false} : !llvm.struct<(ptr<i8>, i1)> -> !ts.ref<!llvm.struct<(ptr<i8>, i1)>>
    %118 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %119 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %120 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
    %121 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %122 = llvm.mlir.constant(1 : i64) : i64
    %123 = llvm.getelementptr %121[%122] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %124 = llvm.ptrtoint %123 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
    %125 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
    %126 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %127 = llvm.mlir.constant(1 : i64) : i64
    %128 = llvm.getelementptr %126[%127] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %129 = llvm.ptrtoint %128 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %130 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %131 = llvm.icmp "ult" %125, %130 : i64
    %132 = llvm.select %131, %125, %130 : i1, i64
    %133 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%119, %120, %132, %133) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%118, %117) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, i1)>>) -> ()
    %134 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %135 = ts.Load(%118) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
    %136 = llvm.extractvalue %135[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %137 = ts.GetValueFromUnionOp %116 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %138 = llvm.mlir.constant(50 : i32) : i32
    %139 = llvm.zext %138 : i32 to i64
    %140 = zexti %138 : i32 to i64
    %141 = llvm.call @malloc(%140) : (i64) -> !llvm.ptr<i8>
    %142 = llvm.bitcast %141 : !llvm.ptr<i8> to !llvm.ptr<i8>
    %143 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
    %144 = llvm.mlir.constant(0 : i64) : i64
    %145 = llvm.getelementptr %143[%144, %144] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %146 = llvm.call @sprintf_s(%142, %138, %145, %136) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
    %147 = ts.Cast %137 : !ts.number to !ts.string
    %148 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
    %149 = llvm.mlir.constant(0 : i64) : i64
    %150 = llvm.getelementptr %148[%149, %149] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %151 = ts.Constant {value = " "} : !ts.string
    %152 = llvm.intr.stacksave : !llvm.ptr<i8>
    %153 = llvm.mlir.constant(1 : i64) : i64
    %154 = llvm.call @strlen(%28) : (!llvm.ptr<i8>) -> i64
    %155 = llvm.add %153, %154  : i64
    %156 = llvm.call @strlen(%150) : (!llvm.ptr<i8>) -> i64
    %157 = llvm.add %155, %156  : i64
    %158 = llvm.call @strlen(%142) : (!llvm.ptr<i8>) -> i64
    %159 = llvm.add %157, %158  : i64
    %160 = llvm.alloca %159 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
    %161 = llvm.call @strcpy(%160, %28) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %162 = llvm.call @strcat(%161, %150) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %163 = llvm.call @strcat(%162, %142) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %164 = "ts.StringConcat"(%28, %151, %142) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
    %165 = llvm.call @puts(%164) : (!ts.string) -> i32
    llvm.intr.stackrestore %152
    ts.Print(%29, %147) : !ts.string, !ts.string
    llvm.br ^bb6
    br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
    %166 = llvm.call @puts(%32) : (!llvm.ptr<i8>) -> i32
    ts.Print(%33) : !ts.string
    llvm.return
    ts.ReturnInternal
  }
  func @main()
  ts.Func @main () -> ()  {
  }
  llvm.func @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x278e950afd0) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FuncOpConversion"
    ** Insert  : 'llvm.func'(0x278e95150b0)
    ** Erase   : 'func'(0x278e950afd0)
"`anonymous-namespace'::FuncOpConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x278e95150b0) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  llvm.func @strcat(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strcpy(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strlen(!llvm.ptr<i8>) -> i64
  llvm.func @sprintf_s(!llvm.ptr<i8>, i32, !llvm.ptr<i8>, ...) -> i32
  llvm.func @puts(!llvm.ptr<i8>) -> i32
  llvm.func @strcmp(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  llvm.func @llvm.memcpy.p0i8.p0i8.i64(!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1)
  llvm.mlir.global internal constant @s_9237349086447201248("number\00")
  llvm.mlir.global internal constant @s_13617892236937420068("b number: \00")
  llvm.mlir.global internal constant @s_6682479467004374669("done.\00")
  llvm.mlir.global internal constant @frmt_555404038213028357("%g\00")
  llvm.mlir.global internal constant @s_12638117931323064703(" \00")
  llvm.func @main() {
    %0 = llvm.mlir.constant(1 : i32) : i32
    %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %2 = llvm.mlir.constant(1 : i32) : i32
    %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %4 = llvm.mlir.constant(1 : i32) : i32
    %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %6 = llvm.mlir.constant(1 : i32) : i32
    %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %8 = llvm.mlir.constant(1 : i32) : i32
    %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %10 = llvm.mlir.constant(1 : i32) : i32
    %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %12 = llvm.mlir.constant(1 : i32) : i32
    %13 = llvm.alloca %12 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %14 = llvm.mlir.constant(1 : i32) : i32
    %15 = llvm.alloca %14 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %16 = llvm.mlir.constant(1.000000e+01 : f64) : f64
    %cst = constant 1.000000e+01 : f64
    %17 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %19 = llvm.mlir.constant(0 : i64) : i64
    %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %21 = ts.Constant {value = "number"} : !ts.string
    %22 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %23 = llvm.mlir.constant(0 : i64) : i64
    %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %25 = ts.Constant {value = "number"} : !ts.string
    %26 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
    %27 = llvm.mlir.constant(0 : i64) : i64
    %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %29 = ts.Constant {value = "b number: "} : !ts.string
    %30 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
    %31 = llvm.mlir.constant(0 : i64) : i64
    %32 = llvm.getelementptr %30[%31, %31] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %33 = ts.Constant {value = "done."} : !ts.string
    %34 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %35 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %36 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
    %37 = llvm.insertvalue %21, %36[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %38 = llvm.insertvalue %17, %37[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    llvm.store %38, %11 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %39 = ts.Variable(%38) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %40 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %41 = llvm.bitcast %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %42 = llvm.bitcast %11 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %43 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %44 = llvm.mlir.constant(1 : i64) : i64
    %45 = llvm.getelementptr %43[%44] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %46 = llvm.ptrtoint %45 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %47 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %48 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %49 = llvm.mlir.constant(1 : i64) : i64
    %50 = llvm.getelementptr %48[%49] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %51 = llvm.ptrtoint %50 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %52 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %53 = llvm.icmp "ult" %47, %52 : i64
    %54 = llvm.select %53, %47, %52 : i1, i64
    %55 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%41, %42, %54, %55) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%40, %39) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
    %56 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %57 = ts.Load(%40) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %58 = ts.CreateUnionInstance %17, %21 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    llvm.store %56, %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %58, %34 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %59 = llvm.load %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %60 = ts.Load(%34) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %61 = llvm.extractvalue %59[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %62 = ts.GetValueFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
    %63 = llvm.extractvalue %59[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %64 = ts.GetTypeInfoFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
    %65 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %66 = llvm.insertvalue %64, %65[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %67 = llvm.insertvalue %62, %66[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    llvm.store %67, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %68 = ts.Variable(%67) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
    %69 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %70 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
    %71 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %72 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %73 = llvm.mlir.constant(1 : i64) : i64
    %74 = llvm.getelementptr %72[%73] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %75 = llvm.ptrtoint %74 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %76 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %77 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %78 = llvm.mlir.constant(1 : i64) : i64
    %79 = llvm.getelementptr %77[%78] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %80 = llvm.ptrtoint %79 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
    %81 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
    %82 = llvm.icmp "ult" %76, %81 : i64
    %83 = llvm.select %82, %76, %81 : i1, i64
    %84 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%70, %71, %83, %84) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%69, %68) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
    %85 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %86 = ts.Load(%69) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %87 = ts.CreateUnionInstance %62, %64 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
    %88 = ts.Cast %60 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
    llvm.store %85, %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    ts.Store %88, %35 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %89 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %90 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %91 = llvm.extractvalue %89[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
    %92 = ts.GetTypeInfoFromUnionOp %90 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
    %93 = llvm.mlir.constant(0 : i64) : i64
    %94 = llvm.ptrtoint %91 : !llvm.ptr<i8> to i64
    %95 = llvm.ptrtoint %24 : !llvm.ptr<i8> to i64
    %96 = llvm.icmp "ne" %94, %93 : i64
    %97 = llvm.icmp "ne" %95, %93 : i64
    %98 = llvm.zext %96 : i1 to i32
    %99 = zexti %96 : i1 to i32
    %100 = ts.Cast %96 : i1 to i32
    %101 = llvm.zext %97 : i1 to i32
    %102 = zexti %97 : i1 to i32
    %103 = ts.Cast %97 : i1 to i32
    %104 = llvm.and %100, %103  : i32
    %105 = llvm.mlir.constant(0 : i32) : i32
    %106 = llvm.icmp "ne" %104, %105 : i32
    llvm.cond_br %106, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %107 = llvm.mlir.constant(0 : i32) : i32
    %108 = llvm.call @strcmp(%91, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
    %109 = llvm.icmp "eq" %108, %107 : i32
    llvm.br ^bb3(%109 : i1)
  ^bb2:  // pred: ^bb0
    %110 = llvm.icmp "eq" %94, %95 : i64
    llvm.br ^bb3(%110 : i1)
  ^bb3(%111: i1):  // 2 preds: ^bb1, ^bb2
    llvm.br ^bb4
  ^bb4:  // pred: ^bb3
    %112 = "ts.StringCompare"(%91, %24) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
    %113 = ts.LogicalBinary %92(34) %25 : !ts.string, !ts.string -> !ts.boolean
    %114 = ts.Cast %113 : !ts.boolean to i1
    llvm.cond_br %111, ^bb5, ^bb6
    cond_br %114, ^bb5, ^bb6
  ^bb5:  // 2 preds: ^bb4, ^bb4
    %115 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %116 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    llvm.store %115, %3 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %117 = ts.Variable(%115) {false} : !llvm.struct<(ptr<i8>, i1)> -> !ts.ref<!llvm.struct<(ptr<i8>, i1)>>
    %118 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %119 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %120 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
    %121 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %122 = llvm.mlir.constant(1 : i64) : i64
    %123 = llvm.getelementptr %121[%122] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %124 = llvm.ptrtoint %123 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
    %125 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
    %126 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %127 = llvm.mlir.constant(1 : i64) : i64
    %128 = llvm.getelementptr %126[%127] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %129 = llvm.ptrtoint %128 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %130 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %131 = llvm.icmp "ult" %125, %130 : i64
    %132 = llvm.select %131, %125, %130 : i1, i64
    %133 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%119, %120, %132, %133) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%118, %117) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, i1)>>) -> ()
    %134 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %135 = ts.Load(%118) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
    %136 = llvm.extractvalue %135[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %137 = ts.GetValueFromUnionOp %116 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %138 = llvm.mlir.constant(50 : i32) : i32
    %139 = llvm.zext %138 : i32 to i64
    %140 = zexti %138 : i32 to i64
    %141 = llvm.call @malloc(%140) : (i64) -> !llvm.ptr<i8>
    %142 = llvm.bitcast %141 : !llvm.ptr<i8> to !llvm.ptr<i8>
    %143 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
    %144 = llvm.mlir.constant(0 : i64) : i64
    %145 = llvm.getelementptr %143[%144, %144] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %146 = llvm.call @sprintf_s(%142, %138, %145, %136) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
    %147 = ts.Cast %137 : !ts.number to !ts.string
    %148 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
    %149 = llvm.mlir.constant(0 : i64) : i64
    %150 = llvm.getelementptr %148[%149, %149] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %151 = ts.Constant {value = " "} : !ts.string
    %152 = llvm.intr.stacksave : !llvm.ptr<i8>
    %153 = llvm.mlir.constant(1 : i64) : i64
    %154 = llvm.call @strlen(%28) : (!llvm.ptr<i8>) -> i64
    %155 = llvm.add %153, %154  : i64
    %156 = llvm.call @strlen(%150) : (!llvm.ptr<i8>) -> i64
    %157 = llvm.add %155, %156  : i64
    %158 = llvm.call @strlen(%142) : (!llvm.ptr<i8>) -> i64
    %159 = llvm.add %157, %158  : i64
    %160 = llvm.alloca %159 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
    %161 = llvm.call @strcpy(%160, %28) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %162 = llvm.call @strcat(%161, %150) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %163 = llvm.call @strcat(%162, %142) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %164 = "ts.StringConcat"(%28, %151, %142) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
    %165 = llvm.call @puts(%164) : (!ts.string) -> i32
    llvm.intr.stackrestore %152
    ts.Print(%29, %147) : !ts.string, !ts.string
    llvm.br ^bb6
    br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
    %166 = llvm.call @puts(%32) : (!llvm.ptr<i8>) -> i32
    ts.Print(%33) : !ts.string
    llvm.return
    ts.ReturnInternal
  }
  func @main()
  ts.Func @main () -> ()  {
  }
  llvm.func @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x278e950b080) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FuncOpConversion"
    ** Insert  : 'llvm.func'(0x278e9515160)
    ** Erase   : 'func'(0x278e950b080)
"`anonymous-namespace'::FuncOpConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x278e9515160) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  llvm.func @strcat(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strcpy(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strlen(!llvm.ptr<i8>) -> i64
  llvm.func @sprintf_s(!llvm.ptr<i8>, i32, !llvm.ptr<i8>, ...) -> i32
  llvm.func @puts(!llvm.ptr<i8>) -> i32
  llvm.func @strcmp(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  llvm.func @llvm.memcpy.p0i8.p0i8.i64(!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1)
  llvm.mlir.global internal constant @s_9237349086447201248("number\00")
  llvm.mlir.global internal constant @s_13617892236937420068("b number: \00")
  llvm.mlir.global internal constant @s_6682479467004374669("done.\00")
  llvm.mlir.global internal constant @frmt_555404038213028357("%g\00")
  llvm.mlir.global internal constant @s_12638117931323064703(" \00")
  llvm.func @main() {
    %0 = llvm.mlir.constant(1 : i32) : i32
    %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %2 = llvm.mlir.constant(1 : i32) : i32
    %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %4 = llvm.mlir.constant(1 : i32) : i32
    %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %6 = llvm.mlir.constant(1 : i32) : i32
    %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %8 = llvm.mlir.constant(1 : i32) : i32
    %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %10 = llvm.mlir.constant(1 : i32) : i32
    %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %12 = llvm.mlir.constant(1 : i32) : i32
    %13 = llvm.alloca %12 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %14 = llvm.mlir.constant(1 : i32) : i32
    %15 = llvm.alloca %14 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %16 = llvm.mlir.constant(1.000000e+01 : f64) : f64
    %cst = constant 1.000000e+01 : f64
    %17 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %19 = llvm.mlir.constant(0 : i64) : i64
    %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %21 = ts.Constant {value = "number"} : !ts.string
    %22 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %23 = llvm.mlir.constant(0 : i64) : i64
    %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %25 = ts.Constant {value = "number"} : !ts.string
    %26 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
    %27 = llvm.mlir.constant(0 : i64) : i64
    %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %29 = ts.Constant {value = "b number: "} : !ts.string
    %30 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
    %31 = llvm.mlir.constant(0 : i64) : i64
    %32 = llvm.getelementptr %30[%31, %31] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %33 = ts.Constant {value = "done."} : !ts.string
    %34 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %35 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %36 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
    %37 = llvm.insertvalue %21, %36[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %38 = llvm.insertvalue %17, %37[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    llvm.store %38, %11 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %39 = ts.Variable(%38) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %40 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %41 = llvm.bitcast %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %42 = llvm.bitcast %11 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %43 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %44 = llvm.mlir.constant(1 : i64) : i64
    %45 = llvm.getelementptr %43[%44] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %46 = llvm.ptrtoint %45 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %47 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %48 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %49 = llvm.mlir.constant(1 : i64) : i64
    %50 = llvm.getelementptr %48[%49] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %51 = llvm.ptrtoint %50 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %52 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %53 = llvm.icmp "ult" %47, %52 : i64
    %54 = llvm.select %53, %47, %52 : i1, i64
    %55 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%41, %42, %54, %55) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%40, %39) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
    %56 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %57 = ts.Load(%40) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %58 = ts.CreateUnionInstance %17, %21 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    llvm.store %56, %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %58, %34 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %59 = llvm.load %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %60 = ts.Load(%34) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %61 = llvm.extractvalue %59[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %62 = ts.GetValueFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
    %63 = llvm.extractvalue %59[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %64 = ts.GetTypeInfoFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
    %65 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %66 = llvm.insertvalue %64, %65[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %67 = llvm.insertvalue %62, %66[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    llvm.store %67, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %68 = ts.Variable(%67) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
    %69 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %70 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
    %71 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %72 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %73 = llvm.mlir.constant(1 : i64) : i64
    %74 = llvm.getelementptr %72[%73] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %75 = llvm.ptrtoint %74 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %76 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %77 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %78 = llvm.mlir.constant(1 : i64) : i64
    %79 = llvm.getelementptr %77[%78] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %80 = llvm.ptrtoint %79 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
    %81 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
    %82 = llvm.icmp "ult" %76, %81 : i64
    %83 = llvm.select %82, %76, %81 : i1, i64
    %84 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%70, %71, %83, %84) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%69, %68) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
    %85 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %86 = ts.Load(%69) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %87 = ts.CreateUnionInstance %62, %64 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
    %88 = ts.Cast %60 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
    llvm.store %85, %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    ts.Store %88, %35 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %89 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %90 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %91 = llvm.extractvalue %89[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
    %92 = ts.GetTypeInfoFromUnionOp %90 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
    %93 = llvm.mlir.constant(0 : i64) : i64
    %94 = llvm.ptrtoint %91 : !llvm.ptr<i8> to i64
    %95 = llvm.ptrtoint %24 : !llvm.ptr<i8> to i64
    %96 = llvm.icmp "ne" %94, %93 : i64
    %97 = llvm.icmp "ne" %95, %93 : i64
    %98 = llvm.zext %96 : i1 to i32
    %99 = zexti %96 : i1 to i32
    %100 = ts.Cast %96 : i1 to i32
    %101 = llvm.zext %97 : i1 to i32
    %102 = zexti %97 : i1 to i32
    %103 = ts.Cast %97 : i1 to i32
    %104 = llvm.and %100, %103  : i32
    %105 = llvm.mlir.constant(0 : i32) : i32
    %106 = llvm.icmp "ne" %104, %105 : i32
    llvm.cond_br %106, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %107 = llvm.mlir.constant(0 : i32) : i32
    %108 = llvm.call @strcmp(%91, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
    %109 = llvm.icmp "eq" %108, %107 : i32
    llvm.br ^bb3(%109 : i1)
  ^bb2:  // pred: ^bb0
    %110 = llvm.icmp "eq" %94, %95 : i64
    llvm.br ^bb3(%110 : i1)
  ^bb3(%111: i1):  // 2 preds: ^bb1, ^bb2
    llvm.br ^bb4
  ^bb4:  // pred: ^bb3
    %112 = "ts.StringCompare"(%91, %24) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
    %113 = ts.LogicalBinary %92(34) %25 : !ts.string, !ts.string -> !ts.boolean
    %114 = ts.Cast %113 : !ts.boolean to i1
    llvm.cond_br %111, ^bb5, ^bb6
    cond_br %114, ^bb5, ^bb6
  ^bb5:  // 2 preds: ^bb4, ^bb4
    %115 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %116 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    llvm.store %115, %3 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %117 = ts.Variable(%115) {false} : !llvm.struct<(ptr<i8>, i1)> -> !ts.ref<!llvm.struct<(ptr<i8>, i1)>>
    %118 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %119 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %120 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
    %121 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %122 = llvm.mlir.constant(1 : i64) : i64
    %123 = llvm.getelementptr %121[%122] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %124 = llvm.ptrtoint %123 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
    %125 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
    %126 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %127 = llvm.mlir.constant(1 : i64) : i64
    %128 = llvm.getelementptr %126[%127] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %129 = llvm.ptrtoint %128 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %130 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %131 = llvm.icmp "ult" %125, %130 : i64
    %132 = llvm.select %131, %125, %130 : i1, i64
    %133 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%119, %120, %132, %133) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%118, %117) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, i1)>>) -> ()
    %134 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %135 = ts.Load(%118) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
    %136 = llvm.extractvalue %135[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %137 = ts.GetValueFromUnionOp %116 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %138 = llvm.mlir.constant(50 : i32) : i32
    %139 = llvm.zext %138 : i32 to i64
    %140 = zexti %138 : i32 to i64
    %141 = llvm.call @malloc(%140) : (i64) -> !llvm.ptr<i8>
    %142 = llvm.bitcast %141 : !llvm.ptr<i8> to !llvm.ptr<i8>
    %143 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
    %144 = llvm.mlir.constant(0 : i64) : i64
    %145 = llvm.getelementptr %143[%144, %144] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %146 = llvm.call @sprintf_s(%142, %138, %145, %136) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
    %147 = ts.Cast %137 : !ts.number to !ts.string
    %148 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
    %149 = llvm.mlir.constant(0 : i64) : i64
    %150 = llvm.getelementptr %148[%149, %149] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %151 = ts.Constant {value = " "} : !ts.string
    %152 = llvm.intr.stacksave : !llvm.ptr<i8>
    %153 = llvm.mlir.constant(1 : i64) : i64
    %154 = llvm.call @strlen(%28) : (!llvm.ptr<i8>) -> i64
    %155 = llvm.add %153, %154  : i64
    %156 = llvm.call @strlen(%150) : (!llvm.ptr<i8>) -> i64
    %157 = llvm.add %155, %156  : i64
    %158 = llvm.call @strlen(%142) : (!llvm.ptr<i8>) -> i64
    %159 = llvm.add %157, %158  : i64
    %160 = llvm.alloca %159 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
    %161 = llvm.call @strcpy(%160, %28) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %162 = llvm.call @strcat(%161, %150) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %163 = llvm.call @strcat(%162, %142) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %164 = "ts.StringConcat"(%28, %151, %142) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
    %165 = llvm.call @puts(%164) : (!ts.string) -> i32
    llvm.intr.stackrestore %152
    ts.Print(%29, %147) : !ts.string, !ts.string
    llvm.br ^bb6
    br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
    %166 = llvm.call @puts(%32) : (!llvm.ptr<i8>) -> i32
    ts.Print(%33) : !ts.string
    llvm.return
    ts.ReturnInternal
  }
  func @main()
  ts.Func @main () -> ()  {
  }
  llvm.func @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x278e950b1e0) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FuncOpConversion"
    ** Insert  : 'llvm.func'(0x278e9513740)
    ** Erase   : 'func'(0x278e950b1e0)
"`anonymous-namespace'::FuncOpConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x278e9513740) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  llvm.func @strcat(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strcpy(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strlen(!llvm.ptr<i8>) -> i64
  llvm.func @sprintf_s(!llvm.ptr<i8>, i32, !llvm.ptr<i8>, ...) -> i32
  llvm.func @puts(!llvm.ptr<i8>) -> i32
  llvm.func @strcmp(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  llvm.func @llvm.memcpy.p0i8.p0i8.i64(!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1)
  llvm.mlir.global internal constant @s_9237349086447201248("number\00")
  llvm.mlir.global internal constant @s_13617892236937420068("b number: \00")
  llvm.mlir.global internal constant @s_6682479467004374669("done.\00")
  llvm.mlir.global internal constant @frmt_555404038213028357("%g\00")
  llvm.mlir.global internal constant @s_12638117931323064703(" \00")
  llvm.func @main() {
    %0 = llvm.mlir.constant(1 : i32) : i32
    %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %2 = llvm.mlir.constant(1 : i32) : i32
    %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %4 = llvm.mlir.constant(1 : i32) : i32
    %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %6 = llvm.mlir.constant(1 : i32) : i32
    %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %8 = llvm.mlir.constant(1 : i32) : i32
    %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %10 = llvm.mlir.constant(1 : i32) : i32
    %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %12 = llvm.mlir.constant(1 : i32) : i32
    %13 = llvm.alloca %12 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %14 = llvm.mlir.constant(1 : i32) : i32
    %15 = llvm.alloca %14 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %16 = llvm.mlir.constant(1.000000e+01 : f64) : f64
    %cst = constant 1.000000e+01 : f64
    %17 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %19 = llvm.mlir.constant(0 : i64) : i64
    %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %21 = ts.Constant {value = "number"} : !ts.string
    %22 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %23 = llvm.mlir.constant(0 : i64) : i64
    %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %25 = ts.Constant {value = "number"} : !ts.string
    %26 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
    %27 = llvm.mlir.constant(0 : i64) : i64
    %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %29 = ts.Constant {value = "b number: "} : !ts.string
    %30 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
    %31 = llvm.mlir.constant(0 : i64) : i64
    %32 = llvm.getelementptr %30[%31, %31] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %33 = ts.Constant {value = "done."} : !ts.string
    %34 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %35 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %36 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
    %37 = llvm.insertvalue %21, %36[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %38 = llvm.insertvalue %17, %37[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    llvm.store %38, %11 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %39 = ts.Variable(%38) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %40 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %41 = llvm.bitcast %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %42 = llvm.bitcast %11 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %43 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %44 = llvm.mlir.constant(1 : i64) : i64
    %45 = llvm.getelementptr %43[%44] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %46 = llvm.ptrtoint %45 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %47 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %48 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %49 = llvm.mlir.constant(1 : i64) : i64
    %50 = llvm.getelementptr %48[%49] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %51 = llvm.ptrtoint %50 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %52 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %53 = llvm.icmp "ult" %47, %52 : i64
    %54 = llvm.select %53, %47, %52 : i1, i64
    %55 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%41, %42, %54, %55) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%40, %39) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
    %56 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %57 = ts.Load(%40) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %58 = ts.CreateUnionInstance %17, %21 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    llvm.store %56, %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %58, %34 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %59 = llvm.load %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %60 = ts.Load(%34) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %61 = llvm.extractvalue %59[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %62 = ts.GetValueFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
    %63 = llvm.extractvalue %59[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %64 = ts.GetTypeInfoFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
    %65 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %66 = llvm.insertvalue %64, %65[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %67 = llvm.insertvalue %62, %66[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    llvm.store %67, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %68 = ts.Variable(%67) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
    %69 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %70 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
    %71 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %72 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %73 = llvm.mlir.constant(1 : i64) : i64
    %74 = llvm.getelementptr %72[%73] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %75 = llvm.ptrtoint %74 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %76 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %77 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %78 = llvm.mlir.constant(1 : i64) : i64
    %79 = llvm.getelementptr %77[%78] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %80 = llvm.ptrtoint %79 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
    %81 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
    %82 = llvm.icmp "ult" %76, %81 : i64
    %83 = llvm.select %82, %76, %81 : i1, i64
    %84 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%70, %71, %83, %84) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%69, %68) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
    %85 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %86 = ts.Load(%69) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %87 = ts.CreateUnionInstance %62, %64 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
    %88 = ts.Cast %60 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
    llvm.store %85, %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    ts.Store %88, %35 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %89 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %90 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %91 = llvm.extractvalue %89[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
    %92 = ts.GetTypeInfoFromUnionOp %90 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
    %93 = llvm.mlir.constant(0 : i64) : i64
    %94 = llvm.ptrtoint %91 : !llvm.ptr<i8> to i64
    %95 = llvm.ptrtoint %24 : !llvm.ptr<i8> to i64
    %96 = llvm.icmp "ne" %94, %93 : i64
    %97 = llvm.icmp "ne" %95, %93 : i64
    %98 = llvm.zext %96 : i1 to i32
    %99 = zexti %96 : i1 to i32
    %100 = ts.Cast %96 : i1 to i32
    %101 = llvm.zext %97 : i1 to i32
    %102 = zexti %97 : i1 to i32
    %103 = ts.Cast %97 : i1 to i32
    %104 = llvm.and %100, %103  : i32
    %105 = llvm.mlir.constant(0 : i32) : i32
    %106 = llvm.icmp "ne" %104, %105 : i32
    llvm.cond_br %106, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %107 = llvm.mlir.constant(0 : i32) : i32
    %108 = llvm.call @strcmp(%91, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
    %109 = llvm.icmp "eq" %108, %107 : i32
    llvm.br ^bb3(%109 : i1)
  ^bb2:  // pred: ^bb0
    %110 = llvm.icmp "eq" %94, %95 : i64
    llvm.br ^bb3(%110 : i1)
  ^bb3(%111: i1):  // 2 preds: ^bb1, ^bb2
    llvm.br ^bb4
  ^bb4:  // pred: ^bb3
    %112 = "ts.StringCompare"(%91, %24) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
    %113 = ts.LogicalBinary %92(34) %25 : !ts.string, !ts.string -> !ts.boolean
    %114 = ts.Cast %113 : !ts.boolean to i1
    llvm.cond_br %111, ^bb5, ^bb6
    cond_br %114, ^bb5, ^bb6
  ^bb5:  // 2 preds: ^bb4, ^bb4
    %115 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %116 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    llvm.store %115, %3 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %117 = ts.Variable(%115) {false} : !llvm.struct<(ptr<i8>, i1)> -> !ts.ref<!llvm.struct<(ptr<i8>, i1)>>
    %118 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %119 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %120 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
    %121 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %122 = llvm.mlir.constant(1 : i64) : i64
    %123 = llvm.getelementptr %121[%122] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %124 = llvm.ptrtoint %123 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
    %125 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
    %126 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %127 = llvm.mlir.constant(1 : i64) : i64
    %128 = llvm.getelementptr %126[%127] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %129 = llvm.ptrtoint %128 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %130 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %131 = llvm.icmp "ult" %125, %130 : i64
    %132 = llvm.select %131, %125, %130 : i1, i64
    %133 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%119, %120, %132, %133) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%118, %117) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, i1)>>) -> ()
    %134 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %135 = ts.Load(%118) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
    %136 = llvm.extractvalue %135[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %137 = ts.GetValueFromUnionOp %116 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %138 = llvm.mlir.constant(50 : i32) : i32
    %139 = llvm.zext %138 : i32 to i64
    %140 = zexti %138 : i32 to i64
    %141 = llvm.call @malloc(%140) : (i64) -> !llvm.ptr<i8>
    %142 = llvm.bitcast %141 : !llvm.ptr<i8> to !llvm.ptr<i8>
    %143 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
    %144 = llvm.mlir.constant(0 : i64) : i64
    %145 = llvm.getelementptr %143[%144, %144] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %146 = llvm.call @sprintf_s(%142, %138, %145, %136) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
    %147 = ts.Cast %137 : !ts.number to !ts.string
    %148 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
    %149 = llvm.mlir.constant(0 : i64) : i64
    %150 = llvm.getelementptr %148[%149, %149] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %151 = ts.Constant {value = " "} : !ts.string
    %152 = llvm.intr.stacksave : !llvm.ptr<i8>
    %153 = llvm.mlir.constant(1 : i64) : i64
    %154 = llvm.call @strlen(%28) : (!llvm.ptr<i8>) -> i64
    %155 = llvm.add %153, %154  : i64
    %156 = llvm.call @strlen(%150) : (!llvm.ptr<i8>) -> i64
    %157 = llvm.add %155, %156  : i64
    %158 = llvm.call @strlen(%142) : (!llvm.ptr<i8>) -> i64
    %159 = llvm.add %157, %158  : i64
    %160 = llvm.alloca %159 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
    %161 = llvm.call @strcpy(%160, %28) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %162 = llvm.call @strcat(%161, %150) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %163 = llvm.call @strcat(%162, %142) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %164 = "ts.StringConcat"(%28, %151, %142) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
    %165 = llvm.call @puts(%164) : (!ts.string) -> i32
    llvm.intr.stackrestore %152
    ts.Print(%29, %147) : !ts.string, !ts.string
    llvm.br ^bb6
    br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
    %166 = llvm.call @puts(%32) : (!llvm.ptr<i8>) -> i32
    ts.Print(%33) : !ts.string
    llvm.return
    ts.ReturnInternal
  }
  func @main()
  ts.Func @main () -> ()  {
  }
  llvm.func @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x278e950a790) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FuncOpConversion"
    ** Insert  : 'llvm.func'(0x278e95142f0)
    ** Erase   : 'func'(0x278e950a790)
"`anonymous-namespace'::FuncOpConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x278e95142f0) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  llvm.func @strcat(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strcpy(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strlen(!llvm.ptr<i8>) -> i64
  llvm.func @sprintf_s(!llvm.ptr<i8>, i32, !llvm.ptr<i8>, ...) -> i32
  llvm.func @puts(!llvm.ptr<i8>) -> i32
  llvm.func @strcmp(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  llvm.func @llvm.memcpy.p0i8.p0i8.i64(!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1)
  llvm.mlir.global internal constant @s_9237349086447201248("number\00")
  llvm.mlir.global internal constant @s_13617892236937420068("b number: \00")
  llvm.mlir.global internal constant @s_6682479467004374669("done.\00")
  llvm.mlir.global internal constant @frmt_555404038213028357("%g\00")
  llvm.mlir.global internal constant @s_12638117931323064703(" \00")
  llvm.func @main() {
    %0 = llvm.mlir.constant(1 : i32) : i32
    %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %2 = llvm.mlir.constant(1 : i32) : i32
    %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %4 = llvm.mlir.constant(1 : i32) : i32
    %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %6 = llvm.mlir.constant(1 : i32) : i32
    %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %8 = llvm.mlir.constant(1 : i32) : i32
    %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %10 = llvm.mlir.constant(1 : i32) : i32
    %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %12 = llvm.mlir.constant(1 : i32) : i32
    %13 = llvm.alloca %12 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %14 = llvm.mlir.constant(1 : i32) : i32
    %15 = llvm.alloca %14 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %16 = llvm.mlir.constant(1.000000e+01 : f64) : f64
    %cst = constant 1.000000e+01 : f64
    %17 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %19 = llvm.mlir.constant(0 : i64) : i64
    %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %21 = ts.Constant {value = "number"} : !ts.string
    %22 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %23 = llvm.mlir.constant(0 : i64) : i64
    %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %25 = ts.Constant {value = "number"} : !ts.string
    %26 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
    %27 = llvm.mlir.constant(0 : i64) : i64
    %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %29 = ts.Constant {value = "b number: "} : !ts.string
    %30 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
    %31 = llvm.mlir.constant(0 : i64) : i64
    %32 = llvm.getelementptr %30[%31, %31] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %33 = ts.Constant {value = "done."} : !ts.string
    %34 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %35 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %36 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
    %37 = llvm.insertvalue %21, %36[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %38 = llvm.insertvalue %17, %37[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    llvm.store %38, %11 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %39 = ts.Variable(%38) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %40 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %41 = llvm.bitcast %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %42 = llvm.bitcast %11 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %43 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %44 = llvm.mlir.constant(1 : i64) : i64
    %45 = llvm.getelementptr %43[%44] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %46 = llvm.ptrtoint %45 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %47 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %48 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %49 = llvm.mlir.constant(1 : i64) : i64
    %50 = llvm.getelementptr %48[%49] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %51 = llvm.ptrtoint %50 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %52 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %53 = llvm.icmp "ult" %47, %52 : i64
    %54 = llvm.select %53, %47, %52 : i1, i64
    %55 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%41, %42, %54, %55) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%40, %39) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
    %56 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %57 = ts.Load(%40) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %58 = ts.CreateUnionInstance %17, %21 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    llvm.store %56, %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %58, %34 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %59 = llvm.load %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %60 = ts.Load(%34) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %61 = llvm.extractvalue %59[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %62 = ts.GetValueFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
    %63 = llvm.extractvalue %59[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %64 = ts.GetTypeInfoFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
    %65 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %66 = llvm.insertvalue %64, %65[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %67 = llvm.insertvalue %62, %66[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    llvm.store %67, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %68 = ts.Variable(%67) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
    %69 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %70 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
    %71 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %72 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %73 = llvm.mlir.constant(1 : i64) : i64
    %74 = llvm.getelementptr %72[%73] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %75 = llvm.ptrtoint %74 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %76 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %77 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %78 = llvm.mlir.constant(1 : i64) : i64
    %79 = llvm.getelementptr %77[%78] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %80 = llvm.ptrtoint %79 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
    %81 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
    %82 = llvm.icmp "ult" %76, %81 : i64
    %83 = llvm.select %82, %76, %81 : i1, i64
    %84 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%70, %71, %83, %84) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%69, %68) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
    %85 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %86 = ts.Load(%69) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %87 = ts.CreateUnionInstance %62, %64 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
    %88 = ts.Cast %60 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
    llvm.store %85, %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    ts.Store %88, %35 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %89 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %90 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %91 = llvm.extractvalue %89[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
    %92 = ts.GetTypeInfoFromUnionOp %90 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
    %93 = llvm.mlir.constant(0 : i64) : i64
    %94 = llvm.ptrtoint %91 : !llvm.ptr<i8> to i64
    %95 = llvm.ptrtoint %24 : !llvm.ptr<i8> to i64
    %96 = llvm.icmp "ne" %94, %93 : i64
    %97 = llvm.icmp "ne" %95, %93 : i64
    %98 = llvm.zext %96 : i1 to i32
    %99 = zexti %96 : i1 to i32
    %100 = ts.Cast %96 : i1 to i32
    %101 = llvm.zext %97 : i1 to i32
    %102 = zexti %97 : i1 to i32
    %103 = ts.Cast %97 : i1 to i32
    %104 = llvm.and %100, %103  : i32
    %105 = llvm.mlir.constant(0 : i32) : i32
    %106 = llvm.icmp "ne" %104, %105 : i32
    llvm.cond_br %106, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %107 = llvm.mlir.constant(0 : i32) : i32
    %108 = llvm.call @strcmp(%91, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
    %109 = llvm.icmp "eq" %108, %107 : i32
    llvm.br ^bb3(%109 : i1)
  ^bb2:  // pred: ^bb0
    %110 = llvm.icmp "eq" %94, %95 : i64
    llvm.br ^bb3(%110 : i1)
  ^bb3(%111: i1):  // 2 preds: ^bb1, ^bb2
    llvm.br ^bb4
  ^bb4:  // pred: ^bb3
    %112 = "ts.StringCompare"(%91, %24) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
    %113 = ts.LogicalBinary %92(34) %25 : !ts.string, !ts.string -> !ts.boolean
    %114 = ts.Cast %113 : !ts.boolean to i1
    llvm.cond_br %111, ^bb5, ^bb6
    cond_br %114, ^bb5, ^bb6
  ^bb5:  // 2 preds: ^bb4, ^bb4
    %115 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %116 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    llvm.store %115, %3 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %117 = ts.Variable(%115) {false} : !llvm.struct<(ptr<i8>, i1)> -> !ts.ref<!llvm.struct<(ptr<i8>, i1)>>
    %118 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %119 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %120 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
    %121 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %122 = llvm.mlir.constant(1 : i64) : i64
    %123 = llvm.getelementptr %121[%122] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %124 = llvm.ptrtoint %123 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
    %125 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
    %126 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %127 = llvm.mlir.constant(1 : i64) : i64
    %128 = llvm.getelementptr %126[%127] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %129 = llvm.ptrtoint %128 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %130 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %131 = llvm.icmp "ult" %125, %130 : i64
    %132 = llvm.select %131, %125, %130 : i1, i64
    %133 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%119, %120, %132, %133) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%118, %117) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, i1)>>) -> ()
    %134 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %135 = ts.Load(%118) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
    %136 = llvm.extractvalue %135[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %137 = ts.GetValueFromUnionOp %116 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %138 = llvm.mlir.constant(50 : i32) : i32
    %139 = llvm.zext %138 : i32 to i64
    %140 = zexti %138 : i32 to i64
    %141 = llvm.call @malloc(%140) : (i64) -> !llvm.ptr<i8>
    %142 = llvm.bitcast %141 : !llvm.ptr<i8> to !llvm.ptr<i8>
    %143 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
    %144 = llvm.mlir.constant(0 : i64) : i64
    %145 = llvm.getelementptr %143[%144, %144] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %146 = llvm.call @sprintf_s(%142, %138, %145, %136) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
    %147 = ts.Cast %137 : !ts.number to !ts.string
    %148 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
    %149 = llvm.mlir.constant(0 : i64) : i64
    %150 = llvm.getelementptr %148[%149, %149] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %151 = ts.Constant {value = " "} : !ts.string
    %152 = llvm.intr.stacksave : !llvm.ptr<i8>
    %153 = llvm.mlir.constant(1 : i64) : i64
    %154 = llvm.call @strlen(%28) : (!llvm.ptr<i8>) -> i64
    %155 = llvm.add %153, %154  : i64
    %156 = llvm.call @strlen(%150) : (!llvm.ptr<i8>) -> i64
    %157 = llvm.add %155, %156  : i64
    %158 = llvm.call @strlen(%142) : (!llvm.ptr<i8>) -> i64
    %159 = llvm.add %157, %158  : i64
    %160 = llvm.alloca %159 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
    %161 = llvm.call @strcpy(%160, %28) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %162 = llvm.call @strcat(%161, %150) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %163 = llvm.call @strcat(%162, %142) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %164 = "ts.StringConcat"(%28, %151, %142) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
    %165 = llvm.call @puts(%164) : (!ts.string) -> i32
    llvm.intr.stackrestore %152
    ts.Print(%29, %147) : !ts.string, !ts.string
    llvm.br ^bb6
    br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
    %166 = llvm.call @puts(%32) : (!llvm.ptr<i8>) -> i32
    ts.Print(%33) : !ts.string
    llvm.return
    ts.ReturnInternal
  }
  func @main()
  ts.Func @main () -> ()  {
  }
  llvm.func @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x278e950cd60) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FuncOpConversion"
    ** Insert  : 'llvm.func'(0x278e95137f0)
    ** Erase   : 'func'(0x278e950cd60)
"`anonymous-namespace'::FuncOpConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x278e95137f0) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  llvm.func @strcat(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strcpy(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strlen(!llvm.ptr<i8>) -> i64
  llvm.func @sprintf_s(!llvm.ptr<i8>, i32, !llvm.ptr<i8>, ...) -> i32
  llvm.func @puts(!llvm.ptr<i8>) -> i32
  llvm.func @strcmp(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  llvm.func @llvm.memcpy.p0i8.p0i8.i64(!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1)
  llvm.mlir.global internal constant @s_9237349086447201248("number\00")
  llvm.mlir.global internal constant @s_13617892236937420068("b number: \00")
  llvm.mlir.global internal constant @s_6682479467004374669("done.\00")
  llvm.mlir.global internal constant @frmt_555404038213028357("%g\00")
  llvm.mlir.global internal constant @s_12638117931323064703(" \00")
  llvm.func @main() {
    %0 = llvm.mlir.constant(1 : i32) : i32
    %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %2 = llvm.mlir.constant(1 : i32) : i32
    %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %4 = llvm.mlir.constant(1 : i32) : i32
    %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %6 = llvm.mlir.constant(1 : i32) : i32
    %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %8 = llvm.mlir.constant(1 : i32) : i32
    %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %10 = llvm.mlir.constant(1 : i32) : i32
    %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %12 = llvm.mlir.constant(1 : i32) : i32
    %13 = llvm.alloca %12 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %14 = llvm.mlir.constant(1 : i32) : i32
    %15 = llvm.alloca %14 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %16 = llvm.mlir.constant(1.000000e+01 : f64) : f64
    %cst = constant 1.000000e+01 : f64
    %17 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %19 = llvm.mlir.constant(0 : i64) : i64
    %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %21 = ts.Constant {value = "number"} : !ts.string
    %22 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %23 = llvm.mlir.constant(0 : i64) : i64
    %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %25 = ts.Constant {value = "number"} : !ts.string
    %26 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
    %27 = llvm.mlir.constant(0 : i64) : i64
    %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %29 = ts.Constant {value = "b number: "} : !ts.string
    %30 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
    %31 = llvm.mlir.constant(0 : i64) : i64
    %32 = llvm.getelementptr %30[%31, %31] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %33 = ts.Constant {value = "done."} : !ts.string
    %34 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %35 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %36 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
    %37 = llvm.insertvalue %21, %36[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %38 = llvm.insertvalue %17, %37[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    llvm.store %38, %11 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %39 = ts.Variable(%38) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %40 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %41 = llvm.bitcast %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %42 = llvm.bitcast %11 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %43 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %44 = llvm.mlir.constant(1 : i64) : i64
    %45 = llvm.getelementptr %43[%44] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %46 = llvm.ptrtoint %45 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %47 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %48 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %49 = llvm.mlir.constant(1 : i64) : i64
    %50 = llvm.getelementptr %48[%49] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %51 = llvm.ptrtoint %50 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %52 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %53 = llvm.icmp "ult" %47, %52 : i64
    %54 = llvm.select %53, %47, %52 : i1, i64
    %55 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%41, %42, %54, %55) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%40, %39) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
    %56 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %57 = ts.Load(%40) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %58 = ts.CreateUnionInstance %17, %21 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    llvm.store %56, %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %58, %34 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %59 = llvm.load %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %60 = ts.Load(%34) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %61 = llvm.extractvalue %59[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %62 = ts.GetValueFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
    %63 = llvm.extractvalue %59[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %64 = ts.GetTypeInfoFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
    %65 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %66 = llvm.insertvalue %64, %65[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %67 = llvm.insertvalue %62, %66[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    llvm.store %67, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %68 = ts.Variable(%67) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
    %69 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %70 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
    %71 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %72 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %73 = llvm.mlir.constant(1 : i64) : i64
    %74 = llvm.getelementptr %72[%73] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %75 = llvm.ptrtoint %74 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %76 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %77 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %78 = llvm.mlir.constant(1 : i64) : i64
    %79 = llvm.getelementptr %77[%78] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %80 = llvm.ptrtoint %79 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
    %81 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
    %82 = llvm.icmp "ult" %76, %81 : i64
    %83 = llvm.select %82, %76, %81 : i1, i64
    %84 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%70, %71, %83, %84) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%69, %68) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
    %85 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %86 = ts.Load(%69) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %87 = ts.CreateUnionInstance %62, %64 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
    %88 = ts.Cast %60 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
    llvm.store %85, %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    ts.Store %88, %35 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %89 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %90 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %91 = llvm.extractvalue %89[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
    %92 = ts.GetTypeInfoFromUnionOp %90 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
    %93 = llvm.mlir.constant(0 : i64) : i64
    %94 = llvm.ptrtoint %91 : !llvm.ptr<i8> to i64
    %95 = llvm.ptrtoint %24 : !llvm.ptr<i8> to i64
    %96 = llvm.icmp "ne" %94, %93 : i64
    %97 = llvm.icmp "ne" %95, %93 : i64
    %98 = llvm.zext %96 : i1 to i32
    %99 = zexti %96 : i1 to i32
    %100 = ts.Cast %96 : i1 to i32
    %101 = llvm.zext %97 : i1 to i32
    %102 = zexti %97 : i1 to i32
    %103 = ts.Cast %97 : i1 to i32
    %104 = llvm.and %100, %103  : i32
    %105 = llvm.mlir.constant(0 : i32) : i32
    %106 = llvm.icmp "ne" %104, %105 : i32
    llvm.cond_br %106, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %107 = llvm.mlir.constant(0 : i32) : i32
    %108 = llvm.call @strcmp(%91, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
    %109 = llvm.icmp "eq" %108, %107 : i32
    llvm.br ^bb3(%109 : i1)
  ^bb2:  // pred: ^bb0
    %110 = llvm.icmp "eq" %94, %95 : i64
    llvm.br ^bb3(%110 : i1)
  ^bb3(%111: i1):  // 2 preds: ^bb1, ^bb2
    llvm.br ^bb4
  ^bb4:  // pred: ^bb3
    %112 = "ts.StringCompare"(%91, %24) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
    %113 = ts.LogicalBinary %92(34) %25 : !ts.string, !ts.string -> !ts.boolean
    %114 = ts.Cast %113 : !ts.boolean to i1
    llvm.cond_br %111, ^bb5, ^bb6
    cond_br %114, ^bb5, ^bb6
  ^bb5:  // 2 preds: ^bb4, ^bb4
    %115 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %116 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    llvm.store %115, %3 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %117 = ts.Variable(%115) {false} : !llvm.struct<(ptr<i8>, i1)> -> !ts.ref<!llvm.struct<(ptr<i8>, i1)>>
    %118 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %119 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %120 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
    %121 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %122 = llvm.mlir.constant(1 : i64) : i64
    %123 = llvm.getelementptr %121[%122] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %124 = llvm.ptrtoint %123 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
    %125 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
    %126 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %127 = llvm.mlir.constant(1 : i64) : i64
    %128 = llvm.getelementptr %126[%127] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %129 = llvm.ptrtoint %128 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %130 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %131 = llvm.icmp "ult" %125, %130 : i64
    %132 = llvm.select %131, %125, %130 : i1, i64
    %133 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%119, %120, %132, %133) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%118, %117) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, i1)>>) -> ()
    %134 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %135 = ts.Load(%118) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
    %136 = llvm.extractvalue %135[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %137 = ts.GetValueFromUnionOp %116 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %138 = llvm.mlir.constant(50 : i32) : i32
    %139 = llvm.zext %138 : i32 to i64
    %140 = zexti %138 : i32 to i64
    %141 = llvm.call @malloc(%140) : (i64) -> !llvm.ptr<i8>
    %142 = llvm.bitcast %141 : !llvm.ptr<i8> to !llvm.ptr<i8>
    %143 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
    %144 = llvm.mlir.constant(0 : i64) : i64
    %145 = llvm.getelementptr %143[%144, %144] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %146 = llvm.call @sprintf_s(%142, %138, %145, %136) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
    %147 = ts.Cast %137 : !ts.number to !ts.string
    %148 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
    %149 = llvm.mlir.constant(0 : i64) : i64
    %150 = llvm.getelementptr %148[%149, %149] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %151 = ts.Constant {value = " "} : !ts.string
    %152 = llvm.intr.stacksave : !llvm.ptr<i8>
    %153 = llvm.mlir.constant(1 : i64) : i64
    %154 = llvm.call @strlen(%28) : (!llvm.ptr<i8>) -> i64
    %155 = llvm.add %153, %154  : i64
    %156 = llvm.call @strlen(%150) : (!llvm.ptr<i8>) -> i64
    %157 = llvm.add %155, %156  : i64
    %158 = llvm.call @strlen(%142) : (!llvm.ptr<i8>) -> i64
    %159 = llvm.add %157, %158  : i64
    %160 = llvm.alloca %159 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
    %161 = llvm.call @strcpy(%160, %28) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %162 = llvm.call @strcat(%161, %150) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %163 = llvm.call @strcat(%162, %142) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %164 = "ts.StringConcat"(%28, %151, %142) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
    %165 = llvm.call @puts(%164) : (!ts.string) -> i32
    llvm.intr.stackrestore %152
    ts.Print(%29, %147) : !ts.string, !ts.string
    llvm.br ^bb6
    br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
    %166 = llvm.call @puts(%32) : (!llvm.ptr<i8>) -> i32
    ts.Print(%33) : !ts.string
    llvm.return
    ts.ReturnInternal
  }
  func @main()
  ts.Func @main () -> ()  {
  }
  llvm.func @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x278e950b4a0) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FuncOpConversion"
    ** Insert  : 'llvm.func'(0x278e9515210)
    ** Erase   : 'func'(0x278e950b4a0)
"`anonymous-namespace'::FuncOpConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x278e9515210) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  llvm.func @strcat(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strcpy(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strlen(!llvm.ptr<i8>) -> i64
  llvm.func @sprintf_s(!llvm.ptr<i8>, i32, !llvm.ptr<i8>, ...) -> i32
  llvm.func @puts(!llvm.ptr<i8>) -> i32
  llvm.func @strcmp(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  llvm.func @llvm.memcpy.p0i8.p0i8.i64(!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1)
  llvm.mlir.global internal constant @s_9237349086447201248("number\00")
  llvm.mlir.global internal constant @s_13617892236937420068("b number: \00")
  llvm.mlir.global internal constant @s_6682479467004374669("done.\00")
  llvm.mlir.global internal constant @frmt_555404038213028357("%g\00")
  llvm.mlir.global internal constant @s_12638117931323064703(" \00")
  llvm.func @main() {
    %0 = llvm.mlir.constant(1 : i32) : i32
    %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %2 = llvm.mlir.constant(1 : i32) : i32
    %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %4 = llvm.mlir.constant(1 : i32) : i32
    %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %6 = llvm.mlir.constant(1 : i32) : i32
    %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %8 = llvm.mlir.constant(1 : i32) : i32
    %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %10 = llvm.mlir.constant(1 : i32) : i32
    %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %12 = llvm.mlir.constant(1 : i32) : i32
    %13 = llvm.alloca %12 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %14 = llvm.mlir.constant(1 : i32) : i32
    %15 = llvm.alloca %14 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %16 = llvm.mlir.constant(1.000000e+01 : f64) : f64
    %cst = constant 1.000000e+01 : f64
    %17 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %19 = llvm.mlir.constant(0 : i64) : i64
    %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %21 = ts.Constant {value = "number"} : !ts.string
    %22 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %23 = llvm.mlir.constant(0 : i64) : i64
    %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %25 = ts.Constant {value = "number"} : !ts.string
    %26 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
    %27 = llvm.mlir.constant(0 : i64) : i64
    %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %29 = ts.Constant {value = "b number: "} : !ts.string
    %30 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
    %31 = llvm.mlir.constant(0 : i64) : i64
    %32 = llvm.getelementptr %30[%31, %31] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %33 = ts.Constant {value = "done."} : !ts.string
    %34 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %35 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %36 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
    %37 = llvm.insertvalue %21, %36[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %38 = llvm.insertvalue %17, %37[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    llvm.store %38, %11 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %39 = ts.Variable(%38) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %40 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %41 = llvm.bitcast %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %42 = llvm.bitcast %11 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %43 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %44 = llvm.mlir.constant(1 : i64) : i64
    %45 = llvm.getelementptr %43[%44] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %46 = llvm.ptrtoint %45 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %47 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %48 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %49 = llvm.mlir.constant(1 : i64) : i64
    %50 = llvm.getelementptr %48[%49] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %51 = llvm.ptrtoint %50 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %52 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %53 = llvm.icmp "ult" %47, %52 : i64
    %54 = llvm.select %53, %47, %52 : i1, i64
    %55 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%41, %42, %54, %55) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%40, %39) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
    %56 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %57 = ts.Load(%40) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %58 = ts.CreateUnionInstance %17, %21 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    llvm.store %56, %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %58, %34 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %59 = llvm.load %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %60 = ts.Load(%34) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %61 = llvm.extractvalue %59[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %62 = ts.GetValueFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
    %63 = llvm.extractvalue %59[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %64 = ts.GetTypeInfoFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
    %65 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %66 = llvm.insertvalue %64, %65[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %67 = llvm.insertvalue %62, %66[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    llvm.store %67, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %68 = ts.Variable(%67) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
    %69 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %70 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
    %71 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %72 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %73 = llvm.mlir.constant(1 : i64) : i64
    %74 = llvm.getelementptr %72[%73] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %75 = llvm.ptrtoint %74 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %76 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %77 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %78 = llvm.mlir.constant(1 : i64) : i64
    %79 = llvm.getelementptr %77[%78] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %80 = llvm.ptrtoint %79 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
    %81 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
    %82 = llvm.icmp "ult" %76, %81 : i64
    %83 = llvm.select %82, %76, %81 : i1, i64
    %84 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%70, %71, %83, %84) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%69, %68) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
    %85 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %86 = ts.Load(%69) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %87 = ts.CreateUnionInstance %62, %64 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
    %88 = ts.Cast %60 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
    llvm.store %85, %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    ts.Store %88, %35 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %89 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %90 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %91 = llvm.extractvalue %89[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
    %92 = ts.GetTypeInfoFromUnionOp %90 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
    %93 = llvm.mlir.constant(0 : i64) : i64
    %94 = llvm.ptrtoint %91 : !llvm.ptr<i8> to i64
    %95 = llvm.ptrtoint %24 : !llvm.ptr<i8> to i64
    %96 = llvm.icmp "ne" %94, %93 : i64
    %97 = llvm.icmp "ne" %95, %93 : i64
    %98 = llvm.zext %96 : i1 to i32
    %99 = zexti %96 : i1 to i32
    %100 = ts.Cast %96 : i1 to i32
    %101 = llvm.zext %97 : i1 to i32
    %102 = zexti %97 : i1 to i32
    %103 = ts.Cast %97 : i1 to i32
    %104 = llvm.and %100, %103  : i32
    %105 = llvm.mlir.constant(0 : i32) : i32
    %106 = llvm.icmp "ne" %104, %105 : i32
    llvm.cond_br %106, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %107 = llvm.mlir.constant(0 : i32) : i32
    %108 = llvm.call @strcmp(%91, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
    %109 = llvm.icmp "eq" %108, %107 : i32
    llvm.br ^bb3(%109 : i1)
  ^bb2:  // pred: ^bb0
    %110 = llvm.icmp "eq" %94, %95 : i64
    llvm.br ^bb3(%110 : i1)
  ^bb3(%111: i1):  // 2 preds: ^bb1, ^bb2
    llvm.br ^bb4
  ^bb4:  // pred: ^bb3
    %112 = "ts.StringCompare"(%91, %24) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
    %113 = ts.LogicalBinary %92(34) %25 : !ts.string, !ts.string -> !ts.boolean
    %114 = ts.Cast %113 : !ts.boolean to i1
    llvm.cond_br %111, ^bb5, ^bb6
    cond_br %114, ^bb5, ^bb6
  ^bb5:  // 2 preds: ^bb4, ^bb4
    %115 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %116 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    llvm.store %115, %3 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %117 = ts.Variable(%115) {false} : !llvm.struct<(ptr<i8>, i1)> -> !ts.ref<!llvm.struct<(ptr<i8>, i1)>>
    %118 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %119 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %120 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
    %121 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %122 = llvm.mlir.constant(1 : i64) : i64
    %123 = llvm.getelementptr %121[%122] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %124 = llvm.ptrtoint %123 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
    %125 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
    %126 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %127 = llvm.mlir.constant(1 : i64) : i64
    %128 = llvm.getelementptr %126[%127] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %129 = llvm.ptrtoint %128 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %130 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %131 = llvm.icmp "ult" %125, %130 : i64
    %132 = llvm.select %131, %125, %130 : i1, i64
    %133 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%119, %120, %132, %133) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%118, %117) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, i1)>>) -> ()
    %134 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %135 = ts.Load(%118) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
    %136 = llvm.extractvalue %135[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %137 = ts.GetValueFromUnionOp %116 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %138 = llvm.mlir.constant(50 : i32) : i32
    %139 = llvm.zext %138 : i32 to i64
    %140 = zexti %138 : i32 to i64
    %141 = llvm.call @malloc(%140) : (i64) -> !llvm.ptr<i8>
    %142 = llvm.bitcast %141 : !llvm.ptr<i8> to !llvm.ptr<i8>
    %143 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
    %144 = llvm.mlir.constant(0 : i64) : i64
    %145 = llvm.getelementptr %143[%144, %144] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %146 = llvm.call @sprintf_s(%142, %138, %145, %136) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
    %147 = ts.Cast %137 : !ts.number to !ts.string
    %148 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
    %149 = llvm.mlir.constant(0 : i64) : i64
    %150 = llvm.getelementptr %148[%149, %149] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %151 = ts.Constant {value = " "} : !ts.string
    %152 = llvm.intr.stacksave : !llvm.ptr<i8>
    %153 = llvm.mlir.constant(1 : i64) : i64
    %154 = llvm.call @strlen(%28) : (!llvm.ptr<i8>) -> i64
    %155 = llvm.add %153, %154  : i64
    %156 = llvm.call @strlen(%150) : (!llvm.ptr<i8>) -> i64
    %157 = llvm.add %155, %156  : i64
    %158 = llvm.call @strlen(%142) : (!llvm.ptr<i8>) -> i64
    %159 = llvm.add %157, %158  : i64
    %160 = llvm.alloca %159 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
    %161 = llvm.call @strcpy(%160, %28) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %162 = llvm.call @strcat(%161, %150) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %163 = llvm.call @strcat(%162, %142) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %164 = "ts.StringConcat"(%28, %151, %142) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
    %165 = llvm.call @puts(%164) : (!ts.string) -> i32
    llvm.intr.stackrestore %152
    ts.Print(%29, %147) : !ts.string, !ts.string
    llvm.br ^bb6
    br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
    %166 = llvm.call @puts(%32) : (!llvm.ptr<i8>) -> i32
    ts.Print(%33) : !ts.string
    llvm.return
    ts.ReturnInternal
  }
  func @main()
  ts.Func @main () -> ()  {
  }
  llvm.func @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x278e950c1b0) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FuncOpConversion"
    ** Insert  : 'llvm.func'(0x278e9513a00)
    ** Erase   : 'func'(0x278e950c1b0)
"`anonymous-namespace'::FuncOpConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x278e9513a00) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  llvm.func @strcat(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strcpy(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strlen(!llvm.ptr<i8>) -> i64
  llvm.func @sprintf_s(!llvm.ptr<i8>, i32, !llvm.ptr<i8>, ...) -> i32
  llvm.func @puts(!llvm.ptr<i8>) -> i32
  llvm.func @strcmp(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  llvm.func @llvm.memcpy.p0i8.p0i8.i64(!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1)
  llvm.mlir.global internal constant @s_9237349086447201248("number\00")
  llvm.mlir.global internal constant @s_13617892236937420068("b number: \00")
  llvm.mlir.global internal constant @s_6682479467004374669("done.\00")
  llvm.mlir.global internal constant @frmt_555404038213028357("%g\00")
  llvm.mlir.global internal constant @s_12638117931323064703(" \00")
  llvm.func @main() {
    %0 = llvm.mlir.constant(1 : i32) : i32
    %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %2 = llvm.mlir.constant(1 : i32) : i32
    %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %4 = llvm.mlir.constant(1 : i32) : i32
    %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %6 = llvm.mlir.constant(1 : i32) : i32
    %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %8 = llvm.mlir.constant(1 : i32) : i32
    %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %10 = llvm.mlir.constant(1 : i32) : i32
    %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %12 = llvm.mlir.constant(1 : i32) : i32
    %13 = llvm.alloca %12 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %14 = llvm.mlir.constant(1 : i32) : i32
    %15 = llvm.alloca %14 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %16 = llvm.mlir.constant(1.000000e+01 : f64) : f64
    %cst = constant 1.000000e+01 : f64
    %17 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %19 = llvm.mlir.constant(0 : i64) : i64
    %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %21 = ts.Constant {value = "number"} : !ts.string
    %22 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %23 = llvm.mlir.constant(0 : i64) : i64
    %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %25 = ts.Constant {value = "number"} : !ts.string
    %26 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
    %27 = llvm.mlir.constant(0 : i64) : i64
    %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %29 = ts.Constant {value = "b number: "} : !ts.string
    %30 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
    %31 = llvm.mlir.constant(0 : i64) : i64
    %32 = llvm.getelementptr %30[%31, %31] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %33 = ts.Constant {value = "done."} : !ts.string
    %34 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %35 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %36 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
    %37 = llvm.insertvalue %21, %36[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %38 = llvm.insertvalue %17, %37[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    llvm.store %38, %11 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %39 = ts.Variable(%38) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %40 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %41 = llvm.bitcast %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %42 = llvm.bitcast %11 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %43 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %44 = llvm.mlir.constant(1 : i64) : i64
    %45 = llvm.getelementptr %43[%44] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %46 = llvm.ptrtoint %45 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %47 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %48 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %49 = llvm.mlir.constant(1 : i64) : i64
    %50 = llvm.getelementptr %48[%49] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %51 = llvm.ptrtoint %50 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %52 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %53 = llvm.icmp "ult" %47, %52 : i64
    %54 = llvm.select %53, %47, %52 : i1, i64
    %55 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%41, %42, %54, %55) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%40, %39) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
    %56 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %57 = ts.Load(%40) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %58 = ts.CreateUnionInstance %17, %21 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    llvm.store %56, %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %58, %34 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %59 = llvm.load %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %60 = ts.Load(%34) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %61 = llvm.extractvalue %59[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %62 = ts.GetValueFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
    %63 = llvm.extractvalue %59[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %64 = ts.GetTypeInfoFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
    %65 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %66 = llvm.insertvalue %64, %65[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %67 = llvm.insertvalue %62, %66[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    llvm.store %67, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %68 = ts.Variable(%67) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
    %69 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %70 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
    %71 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %72 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %73 = llvm.mlir.constant(1 : i64) : i64
    %74 = llvm.getelementptr %72[%73] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %75 = llvm.ptrtoint %74 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %76 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %77 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %78 = llvm.mlir.constant(1 : i64) : i64
    %79 = llvm.getelementptr %77[%78] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %80 = llvm.ptrtoint %79 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
    %81 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
    %82 = llvm.icmp "ult" %76, %81 : i64
    %83 = llvm.select %82, %76, %81 : i1, i64
    %84 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%70, %71, %83, %84) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%69, %68) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
    %85 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %86 = ts.Load(%69) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %87 = ts.CreateUnionInstance %62, %64 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
    %88 = ts.Cast %60 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
    llvm.store %85, %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    ts.Store %88, %35 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %89 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %90 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %91 = llvm.extractvalue %89[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
    %92 = ts.GetTypeInfoFromUnionOp %90 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
    %93 = llvm.mlir.constant(0 : i64) : i64
    %94 = llvm.ptrtoint %91 : !llvm.ptr<i8> to i64
    %95 = llvm.ptrtoint %24 : !llvm.ptr<i8> to i64
    %96 = llvm.icmp "ne" %94, %93 : i64
    %97 = llvm.icmp "ne" %95, %93 : i64
    %98 = llvm.zext %96 : i1 to i32
    %99 = zexti %96 : i1 to i32
    %100 = ts.Cast %96 : i1 to i32
    %101 = llvm.zext %97 : i1 to i32
    %102 = zexti %97 : i1 to i32
    %103 = ts.Cast %97 : i1 to i32
    %104 = llvm.and %100, %103  : i32
    %105 = llvm.mlir.constant(0 : i32) : i32
    %106 = llvm.icmp "ne" %104, %105 : i32
    llvm.cond_br %106, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %107 = llvm.mlir.constant(0 : i32) : i32
    %108 = llvm.call @strcmp(%91, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
    %109 = llvm.icmp "eq" %108, %107 : i32
    llvm.br ^bb3(%109 : i1)
  ^bb2:  // pred: ^bb0
    %110 = llvm.icmp "eq" %94, %95 : i64
    llvm.br ^bb3(%110 : i1)
  ^bb3(%111: i1):  // 2 preds: ^bb1, ^bb2
    llvm.br ^bb4
  ^bb4:  // pred: ^bb3
    %112 = "ts.StringCompare"(%91, %24) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
    %113 = ts.LogicalBinary %92(34) %25 : !ts.string, !ts.string -> !ts.boolean
    %114 = ts.Cast %113 : !ts.boolean to i1
    llvm.cond_br %111, ^bb5, ^bb6
    cond_br %114, ^bb5, ^bb6
  ^bb5:  // 2 preds: ^bb4, ^bb4
    %115 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %116 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    llvm.store %115, %3 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %117 = ts.Variable(%115) {false} : !llvm.struct<(ptr<i8>, i1)> -> !ts.ref<!llvm.struct<(ptr<i8>, i1)>>
    %118 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %119 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %120 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
    %121 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %122 = llvm.mlir.constant(1 : i64) : i64
    %123 = llvm.getelementptr %121[%122] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %124 = llvm.ptrtoint %123 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
    %125 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
    %126 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %127 = llvm.mlir.constant(1 : i64) : i64
    %128 = llvm.getelementptr %126[%127] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %129 = llvm.ptrtoint %128 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %130 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %131 = llvm.icmp "ult" %125, %130 : i64
    %132 = llvm.select %131, %125, %130 : i1, i64
    %133 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%119, %120, %132, %133) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%118, %117) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, i1)>>) -> ()
    %134 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %135 = ts.Load(%118) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
    %136 = llvm.extractvalue %135[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %137 = ts.GetValueFromUnionOp %116 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %138 = llvm.mlir.constant(50 : i32) : i32
    %139 = llvm.zext %138 : i32 to i64
    %140 = zexti %138 : i32 to i64
    %141 = llvm.call @malloc(%140) : (i64) -> !llvm.ptr<i8>
    %142 = llvm.bitcast %141 : !llvm.ptr<i8> to !llvm.ptr<i8>
    %143 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
    %144 = llvm.mlir.constant(0 : i64) : i64
    %145 = llvm.getelementptr %143[%144, %144] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %146 = llvm.call @sprintf_s(%142, %138, %145, %136) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
    %147 = ts.Cast %137 : !ts.number to !ts.string
    %148 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
    %149 = llvm.mlir.constant(0 : i64) : i64
    %150 = llvm.getelementptr %148[%149, %149] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %151 = ts.Constant {value = " "} : !ts.string
    %152 = llvm.intr.stacksave : !llvm.ptr<i8>
    %153 = llvm.mlir.constant(1 : i64) : i64
    %154 = llvm.call @strlen(%28) : (!llvm.ptr<i8>) -> i64
    %155 = llvm.add %153, %154  : i64
    %156 = llvm.call @strlen(%150) : (!llvm.ptr<i8>) -> i64
    %157 = llvm.add %155, %156  : i64
    %158 = llvm.call @strlen(%142) : (!llvm.ptr<i8>) -> i64
    %159 = llvm.add %157, %158  : i64
    %160 = llvm.alloca %159 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
    %161 = llvm.call @strcpy(%160, %28) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %162 = llvm.call @strcat(%161, %150) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %163 = llvm.call @strcat(%162, %142) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %164 = "ts.StringConcat"(%28, %151, %142) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
    %165 = llvm.call @puts(%164) : (!ts.string) -> i32
    llvm.intr.stackrestore %152
    ts.Print(%29, %147) : !ts.string, !ts.string
    llvm.br ^bb6
    br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
    %166 = llvm.call @puts(%32) : (!llvm.ptr<i8>) -> i32
    ts.Print(%33) : !ts.string
    llvm.return
    ts.ReturnInternal
  }
  func @main()
  ts.Func @main () -> ()  {
  }
  llvm.func @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x278e950c5d0) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FuncOpConversion"
    ** Insert  : 'llvm.func'(0x278e9513ab0)
    ** Erase   : 'func'(0x278e950c5d0)
"`anonymous-namespace'::FuncOpConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x278e9513ab0) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  llvm.func @strcat(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strcpy(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strlen(!llvm.ptr<i8>) -> i64
  llvm.func @sprintf_s(!llvm.ptr<i8>, i32, !llvm.ptr<i8>, ...) -> i32
  llvm.func @puts(!llvm.ptr<i8>) -> i32
  llvm.func @strcmp(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  llvm.func @llvm.memcpy.p0i8.p0i8.i64(!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1)
  llvm.mlir.global internal constant @s_9237349086447201248("number\00")
  llvm.mlir.global internal constant @s_13617892236937420068("b number: \00")
  llvm.mlir.global internal constant @s_6682479467004374669("done.\00")
  llvm.mlir.global internal constant @frmt_555404038213028357("%g\00")
  llvm.mlir.global internal constant @s_12638117931323064703(" \00")
  llvm.func @main() {
    %0 = llvm.mlir.constant(1 : i32) : i32
    %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %2 = llvm.mlir.constant(1 : i32) : i32
    %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %4 = llvm.mlir.constant(1 : i32) : i32
    %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %6 = llvm.mlir.constant(1 : i32) : i32
    %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %8 = llvm.mlir.constant(1 : i32) : i32
    %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %10 = llvm.mlir.constant(1 : i32) : i32
    %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %12 = llvm.mlir.constant(1 : i32) : i32
    %13 = llvm.alloca %12 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %14 = llvm.mlir.constant(1 : i32) : i32
    %15 = llvm.alloca %14 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %16 = llvm.mlir.constant(1.000000e+01 : f64) : f64
    %cst = constant 1.000000e+01 : f64
    %17 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %19 = llvm.mlir.constant(0 : i64) : i64
    %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %21 = ts.Constant {value = "number"} : !ts.string
    %22 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %23 = llvm.mlir.constant(0 : i64) : i64
    %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %25 = ts.Constant {value = "number"} : !ts.string
    %26 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
    %27 = llvm.mlir.constant(0 : i64) : i64
    %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %29 = ts.Constant {value = "b number: "} : !ts.string
    %30 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
    %31 = llvm.mlir.constant(0 : i64) : i64
    %32 = llvm.getelementptr %30[%31, %31] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %33 = ts.Constant {value = "done."} : !ts.string
    %34 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %35 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %36 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
    %37 = llvm.insertvalue %21, %36[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %38 = llvm.insertvalue %17, %37[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    llvm.store %38, %11 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %39 = ts.Variable(%38) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %40 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %41 = llvm.bitcast %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %42 = llvm.bitcast %11 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %43 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %44 = llvm.mlir.constant(1 : i64) : i64
    %45 = llvm.getelementptr %43[%44] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %46 = llvm.ptrtoint %45 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %47 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %48 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %49 = llvm.mlir.constant(1 : i64) : i64
    %50 = llvm.getelementptr %48[%49] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %51 = llvm.ptrtoint %50 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %52 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %53 = llvm.icmp "ult" %47, %52 : i64
    %54 = llvm.select %53, %47, %52 : i1, i64
    %55 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%41, %42, %54, %55) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%40, %39) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
    %56 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %57 = ts.Load(%40) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %58 = ts.CreateUnionInstance %17, %21 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    llvm.store %56, %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %58, %34 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %59 = llvm.load %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %60 = ts.Load(%34) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %61 = llvm.extractvalue %59[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %62 = ts.GetValueFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
    %63 = llvm.extractvalue %59[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %64 = ts.GetTypeInfoFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
    %65 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %66 = llvm.insertvalue %64, %65[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %67 = llvm.insertvalue %62, %66[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    llvm.store %67, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %68 = ts.Variable(%67) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
    %69 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %70 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
    %71 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %72 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %73 = llvm.mlir.constant(1 : i64) : i64
    %74 = llvm.getelementptr %72[%73] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %75 = llvm.ptrtoint %74 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %76 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %77 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %78 = llvm.mlir.constant(1 : i64) : i64
    %79 = llvm.getelementptr %77[%78] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %80 = llvm.ptrtoint %79 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
    %81 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
    %82 = llvm.icmp "ult" %76, %81 : i64
    %83 = llvm.select %82, %76, %81 : i1, i64
    %84 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%70, %71, %83, %84) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%69, %68) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
    %85 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %86 = ts.Load(%69) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %87 = ts.CreateUnionInstance %62, %64 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
    %88 = ts.Cast %60 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
    llvm.store %85, %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    ts.Store %88, %35 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %89 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %90 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %91 = llvm.extractvalue %89[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
    %92 = ts.GetTypeInfoFromUnionOp %90 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
    %93 = llvm.mlir.constant(0 : i64) : i64
    %94 = llvm.ptrtoint %91 : !llvm.ptr<i8> to i64
    %95 = llvm.ptrtoint %24 : !llvm.ptr<i8> to i64
    %96 = llvm.icmp "ne" %94, %93 : i64
    %97 = llvm.icmp "ne" %95, %93 : i64
    %98 = llvm.zext %96 : i1 to i32
    %99 = zexti %96 : i1 to i32
    %100 = ts.Cast %96 : i1 to i32
    %101 = llvm.zext %97 : i1 to i32
    %102 = zexti %97 : i1 to i32
    %103 = ts.Cast %97 : i1 to i32
    %104 = llvm.and %100, %103  : i32
    %105 = llvm.mlir.constant(0 : i32) : i32
    %106 = llvm.icmp "ne" %104, %105 : i32
    llvm.cond_br %106, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %107 = llvm.mlir.constant(0 : i32) : i32
    %108 = llvm.call @strcmp(%91, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
    %109 = llvm.icmp "eq" %108, %107 : i32
    llvm.br ^bb3(%109 : i1)
  ^bb2:  // pred: ^bb0
    %110 = llvm.icmp "eq" %94, %95 : i64
    llvm.br ^bb3(%110 : i1)
  ^bb3(%111: i1):  // 2 preds: ^bb1, ^bb2
    llvm.br ^bb4
  ^bb4:  // pred: ^bb3
    %112 = "ts.StringCompare"(%91, %24) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
    %113 = ts.LogicalBinary %92(34) %25 : !ts.string, !ts.string -> !ts.boolean
    %114 = ts.Cast %113 : !ts.boolean to i1
    llvm.cond_br %111, ^bb5, ^bb6
    cond_br %114, ^bb5, ^bb6
  ^bb5:  // 2 preds: ^bb4, ^bb4
    %115 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %116 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    llvm.store %115, %3 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %117 = ts.Variable(%115) {false} : !llvm.struct<(ptr<i8>, i1)> -> !ts.ref<!llvm.struct<(ptr<i8>, i1)>>
    %118 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %119 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %120 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
    %121 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %122 = llvm.mlir.constant(1 : i64) : i64
    %123 = llvm.getelementptr %121[%122] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %124 = llvm.ptrtoint %123 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
    %125 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
    %126 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %127 = llvm.mlir.constant(1 : i64) : i64
    %128 = llvm.getelementptr %126[%127] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %129 = llvm.ptrtoint %128 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %130 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %131 = llvm.icmp "ult" %125, %130 : i64
    %132 = llvm.select %131, %125, %130 : i1, i64
    %133 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%119, %120, %132, %133) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%118, %117) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, i1)>>) -> ()
    %134 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %135 = ts.Load(%118) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
    %136 = llvm.extractvalue %135[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %137 = ts.GetValueFromUnionOp %116 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %138 = llvm.mlir.constant(50 : i32) : i32
    %139 = llvm.zext %138 : i32 to i64
    %140 = zexti %138 : i32 to i64
    %141 = llvm.call @malloc(%140) : (i64) -> !llvm.ptr<i8>
    %142 = llvm.bitcast %141 : !llvm.ptr<i8> to !llvm.ptr<i8>
    %143 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
    %144 = llvm.mlir.constant(0 : i64) : i64
    %145 = llvm.getelementptr %143[%144, %144] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %146 = llvm.call @sprintf_s(%142, %138, %145, %136) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
    %147 = ts.Cast %137 : !ts.number to !ts.string
    %148 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
    %149 = llvm.mlir.constant(0 : i64) : i64
    %150 = llvm.getelementptr %148[%149, %149] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %151 = ts.Constant {value = " "} : !ts.string
    %152 = llvm.intr.stacksave : !llvm.ptr<i8>
    %153 = llvm.mlir.constant(1 : i64) : i64
    %154 = llvm.call @strlen(%28) : (!llvm.ptr<i8>) -> i64
    %155 = llvm.add %153, %154  : i64
    %156 = llvm.call @strlen(%150) : (!llvm.ptr<i8>) -> i64
    %157 = llvm.add %155, %156  : i64
    %158 = llvm.call @strlen(%142) : (!llvm.ptr<i8>) -> i64
    %159 = llvm.add %157, %158  : i64
    %160 = llvm.alloca %159 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
    %161 = llvm.call @strcpy(%160, %28) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %162 = llvm.call @strcat(%161, %150) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %163 = llvm.call @strcat(%162, %142) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %164 = "ts.StringConcat"(%28, %151, %142) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
    %165 = llvm.call @puts(%164) : (!ts.string) -> i32
    llvm.intr.stackrestore %152
    ts.Print(%29, %147) : !ts.string, !ts.string
    llvm.br ^bb6
    br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
    %166 = llvm.call @puts(%32) : (!llvm.ptr<i8>) -> i32
    ts.Print(%33) : !ts.string
    llvm.return
    ts.ReturnInternal
  }
  func @main()
  ts.Func @main () -> ()  {
  }
  llvm.func @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  llvm.func @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x278e950c940) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FuncOpConversion"
    ** Insert  : 'llvm.func'(0x278e9513b60)
    ** Erase   : 'func'(0x278e950c940)
"`anonymous-namespace'::FuncOpConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x278e9513b60) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  llvm.func @strcat(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strcpy(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strlen(!llvm.ptr<i8>) -> i64
  llvm.func @sprintf_s(!llvm.ptr<i8>, i32, !llvm.ptr<i8>, ...) -> i32
  llvm.func @puts(!llvm.ptr<i8>) -> i32
  llvm.func @strcmp(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  llvm.func @llvm.memcpy.p0i8.p0i8.i64(!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1)
  llvm.mlir.global internal constant @s_9237349086447201248("number\00")
  llvm.mlir.global internal constant @s_13617892236937420068("b number: \00")
  llvm.mlir.global internal constant @s_6682479467004374669("done.\00")
  llvm.mlir.global internal constant @frmt_555404038213028357("%g\00")
  llvm.mlir.global internal constant @s_12638117931323064703(" \00")
  llvm.func @main() {
    %0 = llvm.mlir.constant(1 : i32) : i32
    %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %2 = llvm.mlir.constant(1 : i32) : i32
    %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %4 = llvm.mlir.constant(1 : i32) : i32
    %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %6 = llvm.mlir.constant(1 : i32) : i32
    %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %8 = llvm.mlir.constant(1 : i32) : i32
    %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %10 = llvm.mlir.constant(1 : i32) : i32
    %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %12 = llvm.mlir.constant(1 : i32) : i32
    %13 = llvm.alloca %12 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %14 = llvm.mlir.constant(1 : i32) : i32
    %15 = llvm.alloca %14 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %16 = llvm.mlir.constant(1.000000e+01 : f64) : f64
    %cst = constant 1.000000e+01 : f64
    %17 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %19 = llvm.mlir.constant(0 : i64) : i64
    %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %21 = ts.Constant {value = "number"} : !ts.string
    %22 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %23 = llvm.mlir.constant(0 : i64) : i64
    %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %25 = ts.Constant {value = "number"} : !ts.string
    %26 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
    %27 = llvm.mlir.constant(0 : i64) : i64
    %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %29 = ts.Constant {value = "b number: "} : !ts.string
    %30 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
    %31 = llvm.mlir.constant(0 : i64) : i64
    %32 = llvm.getelementptr %30[%31, %31] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %33 = ts.Constant {value = "done."} : !ts.string
    %34 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %35 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %36 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
    %37 = llvm.insertvalue %21, %36[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %38 = llvm.insertvalue %17, %37[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    llvm.store %38, %11 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %39 = ts.Variable(%38) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %40 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %41 = llvm.bitcast %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %42 = llvm.bitcast %11 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %43 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %44 = llvm.mlir.constant(1 : i64) : i64
    %45 = llvm.getelementptr %43[%44] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %46 = llvm.ptrtoint %45 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %47 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %48 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %49 = llvm.mlir.constant(1 : i64) : i64
    %50 = llvm.getelementptr %48[%49] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %51 = llvm.ptrtoint %50 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %52 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %53 = llvm.icmp "ult" %47, %52 : i64
    %54 = llvm.select %53, %47, %52 : i1, i64
    %55 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%41, %42, %54, %55) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%40, %39) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
    %56 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %57 = ts.Load(%40) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %58 = ts.CreateUnionInstance %17, %21 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    llvm.store %56, %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %58, %34 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %59 = llvm.load %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %60 = ts.Load(%34) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %61 = llvm.extractvalue %59[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %62 = ts.GetValueFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
    %63 = llvm.extractvalue %59[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %64 = ts.GetTypeInfoFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
    %65 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %66 = llvm.insertvalue %64, %65[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %67 = llvm.insertvalue %62, %66[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    llvm.store %67, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %68 = ts.Variable(%67) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
    %69 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %70 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
    %71 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %72 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %73 = llvm.mlir.constant(1 : i64) : i64
    %74 = llvm.getelementptr %72[%73] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %75 = llvm.ptrtoint %74 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %76 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %77 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %78 = llvm.mlir.constant(1 : i64) : i64
    %79 = llvm.getelementptr %77[%78] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %80 = llvm.ptrtoint %79 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
    %81 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
    %82 = llvm.icmp "ult" %76, %81 : i64
    %83 = llvm.select %82, %76, %81 : i1, i64
    %84 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%70, %71, %83, %84) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%69, %68) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
    %85 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %86 = ts.Load(%69) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %87 = ts.CreateUnionInstance %62, %64 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
    %88 = ts.Cast %60 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
    llvm.store %85, %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    ts.Store %88, %35 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %89 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %90 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %91 = llvm.extractvalue %89[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
    %92 = ts.GetTypeInfoFromUnionOp %90 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
    %93 = llvm.mlir.constant(0 : i64) : i64
    %94 = llvm.ptrtoint %91 : !llvm.ptr<i8> to i64
    %95 = llvm.ptrtoint %24 : !llvm.ptr<i8> to i64
    %96 = llvm.icmp "ne" %94, %93 : i64
    %97 = llvm.icmp "ne" %95, %93 : i64
    %98 = llvm.zext %96 : i1 to i32
    %99 = zexti %96 : i1 to i32
    %100 = ts.Cast %96 : i1 to i32
    %101 = llvm.zext %97 : i1 to i32
    %102 = zexti %97 : i1 to i32
    %103 = ts.Cast %97 : i1 to i32
    %104 = llvm.and %100, %103  : i32
    %105 = llvm.mlir.constant(0 : i32) : i32
    %106 = llvm.icmp "ne" %104, %105 : i32
    llvm.cond_br %106, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %107 = llvm.mlir.constant(0 : i32) : i32
    %108 = llvm.call @strcmp(%91, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
    %109 = llvm.icmp "eq" %108, %107 : i32
    llvm.br ^bb3(%109 : i1)
  ^bb2:  // pred: ^bb0
    %110 = llvm.icmp "eq" %94, %95 : i64
    llvm.br ^bb3(%110 : i1)
  ^bb3(%111: i1):  // 2 preds: ^bb1, ^bb2
    llvm.br ^bb4
  ^bb4:  // pred: ^bb3
    %112 = "ts.StringCompare"(%91, %24) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
    %113 = ts.LogicalBinary %92(34) %25 : !ts.string, !ts.string -> !ts.boolean
    %114 = ts.Cast %113 : !ts.boolean to i1
    llvm.cond_br %111, ^bb5, ^bb6
    cond_br %114, ^bb5, ^bb6
  ^bb5:  // 2 preds: ^bb4, ^bb4
    %115 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %116 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    llvm.store %115, %3 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %117 = ts.Variable(%115) {false} : !llvm.struct<(ptr<i8>, i1)> -> !ts.ref<!llvm.struct<(ptr<i8>, i1)>>
    %118 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %119 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %120 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
    %121 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %122 = llvm.mlir.constant(1 : i64) : i64
    %123 = llvm.getelementptr %121[%122] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %124 = llvm.ptrtoint %123 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
    %125 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
    %126 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %127 = llvm.mlir.constant(1 : i64) : i64
    %128 = llvm.getelementptr %126[%127] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %129 = llvm.ptrtoint %128 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %130 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %131 = llvm.icmp "ult" %125, %130 : i64
    %132 = llvm.select %131, %125, %130 : i1, i64
    %133 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%119, %120, %132, %133) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%118, %117) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, i1)>>) -> ()
    %134 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %135 = ts.Load(%118) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
    %136 = llvm.extractvalue %135[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %137 = ts.GetValueFromUnionOp %116 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %138 = llvm.mlir.constant(50 : i32) : i32
    %139 = llvm.zext %138 : i32 to i64
    %140 = zexti %138 : i32 to i64
    %141 = llvm.call @malloc(%140) : (i64) -> !llvm.ptr<i8>
    %142 = llvm.bitcast %141 : !llvm.ptr<i8> to !llvm.ptr<i8>
    %143 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
    %144 = llvm.mlir.constant(0 : i64) : i64
    %145 = llvm.getelementptr %143[%144, %144] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %146 = llvm.call @sprintf_s(%142, %138, %145, %136) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
    %147 = ts.Cast %137 : !ts.number to !ts.string
    %148 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
    %149 = llvm.mlir.constant(0 : i64) : i64
    %150 = llvm.getelementptr %148[%149, %149] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %151 = ts.Constant {value = " "} : !ts.string
    %152 = llvm.intr.stacksave : !llvm.ptr<i8>
    %153 = llvm.mlir.constant(1 : i64) : i64
    %154 = llvm.call @strlen(%28) : (!llvm.ptr<i8>) -> i64
    %155 = llvm.add %153, %154  : i64
    %156 = llvm.call @strlen(%150) : (!llvm.ptr<i8>) -> i64
    %157 = llvm.add %155, %156  : i64
    %158 = llvm.call @strlen(%142) : (!llvm.ptr<i8>) -> i64
    %159 = llvm.add %157, %158  : i64
    %160 = llvm.alloca %159 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
    %161 = llvm.call @strcpy(%160, %28) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %162 = llvm.call @strcat(%161, %150) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %163 = llvm.call @strcat(%162, %142) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %164 = "ts.StringConcat"(%28, %151, %142) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
    %165 = llvm.call @puts(%164) : (!ts.string) -> i32
    llvm.intr.stackrestore %152
    ts.Print(%29, %147) : !ts.string, !ts.string
    llvm.br ^bb6
    br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
    %166 = llvm.call @puts(%32) : (!llvm.ptr<i8>) -> i32
    ts.Print(%33) : !ts.string
    llvm.return
    ts.ReturnInternal
  }
  func @main()
  ts.Func @main () -> ()  {
  }
  llvm.func @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  llvm.func @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'func'(0x278e950a840) {
  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'func -> ()' {
Trying to match "`anonymous-namespace'::FuncOpConversion"
    ** Insert  : 'llvm.func'(0x278e9513ed0)
    ** Erase   : 'func'(0x278e950a840)
"`anonymous-namespace'::FuncOpConversion" result 1

    //===-------------------------------------------===//
    Legalizing operation : 'llvm.func'(0x278e9513ed0) {
    } -> SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
module @"c:\\temp\\1.ts"  {
  llvm.func @strcat(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strcpy(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strlen(!llvm.ptr<i8>) -> i64
  llvm.func @sprintf_s(!llvm.ptr<i8>, i32, !llvm.ptr<i8>, ...) -> i32
  llvm.func @puts(!llvm.ptr<i8>) -> i32
  llvm.func @strcmp(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  llvm.func @llvm.memcpy.p0i8.p0i8.i64(!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1)
  llvm.mlir.global internal constant @s_9237349086447201248("number\00")
  llvm.mlir.global internal constant @s_13617892236937420068("b number: \00")
  llvm.mlir.global internal constant @s_6682479467004374669("done.\00")
  llvm.mlir.global internal constant @frmt_555404038213028357("%g\00")
  llvm.mlir.global internal constant @s_12638117931323064703(" \00")
  llvm.func @main() {
    %0 = llvm.mlir.constant(1 : i32) : i32
    %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %2 = llvm.mlir.constant(1 : i32) : i32
    %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %4 = llvm.mlir.constant(1 : i32) : i32
    %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %6 = llvm.mlir.constant(1 : i32) : i32
    %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %8 = llvm.mlir.constant(1 : i32) : i32
    %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %10 = llvm.mlir.constant(1 : i32) : i32
    %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %12 = llvm.mlir.constant(1 : i32) : i32
    %13 = llvm.alloca %12 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %14 = llvm.mlir.constant(1 : i32) : i32
    %15 = llvm.alloca %14 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %16 = llvm.mlir.constant(1.000000e+01 : f64) : f64
    %cst = constant 1.000000e+01 : f64
    %17 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
    %18 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %19 = llvm.mlir.constant(0 : i64) : i64
    %20 = llvm.getelementptr %18[%19, %19] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %21 = ts.Constant {value = "number"} : !ts.string
    %22 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %23 = llvm.mlir.constant(0 : i64) : i64
    %24 = llvm.getelementptr %22[%23, %23] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %25 = ts.Constant {value = "number"} : !ts.string
    %26 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
    %27 = llvm.mlir.constant(0 : i64) : i64
    %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %29 = ts.Constant {value = "b number: "} : !ts.string
    %30 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
    %31 = llvm.mlir.constant(0 : i64) : i64
    %32 = llvm.getelementptr %30[%31, %31] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %33 = ts.Constant {value = "done."} : !ts.string
    %34 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %35 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %36 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
    %37 = llvm.insertvalue %21, %36[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %38 = llvm.insertvalue %17, %37[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    llvm.store %38, %11 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %39 = ts.Variable(%38) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %40 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %41 = llvm.bitcast %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %42 = llvm.bitcast %11 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %43 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %44 = llvm.mlir.constant(1 : i64) : i64
    %45 = llvm.getelementptr %43[%44] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %46 = llvm.ptrtoint %45 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %47 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %48 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %49 = llvm.mlir.constant(1 : i64) : i64
    %50 = llvm.getelementptr %48[%49] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %51 = llvm.ptrtoint %50 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %52 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %53 = llvm.icmp "ult" %47, %52 : i64
    %54 = llvm.select %53, %47, %52 : i1, i64
    %55 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%41, %42, %54, %55) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%40, %39) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
    %56 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %57 = ts.Load(%40) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %58 = ts.CreateUnionInstance %17, %21 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
    llvm.store %56, %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    ts.Store %58, %34 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
    %59 = llvm.load %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %60 = ts.Load(%34) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
    %61 = llvm.extractvalue %59[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %62 = ts.GetValueFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
    %63 = llvm.extractvalue %59[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %64 = ts.GetTypeInfoFromUnionOp %59 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
    %65 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %66 = llvm.insertvalue %64, %65[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %67 = llvm.insertvalue %62, %66[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    llvm.store %67, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %68 = ts.Variable(%67) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
    %69 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %70 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
    %71 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %72 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %73 = llvm.mlir.constant(1 : i64) : i64
    %74 = llvm.getelementptr %72[%73] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %75 = llvm.ptrtoint %74 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %76 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
    %77 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %78 = llvm.mlir.constant(1 : i64) : i64
    %79 = llvm.getelementptr %77[%78] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %80 = llvm.ptrtoint %79 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
    %81 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
    %82 = llvm.icmp "ult" %76, %81 : i64
    %83 = llvm.select %82, %76, %81 : i1, i64
    %84 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%70, %71, %83, %84) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%69, %68) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
    %85 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %86 = ts.Load(%69) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %87 = ts.CreateUnionInstance %62, %64 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
    %88 = ts.Cast %60 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
    llvm.store %85, %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    ts.Store %88, %35 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
    %89 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %90 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    %91 = llvm.extractvalue %89[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
    %92 = ts.GetTypeInfoFromUnionOp %90 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
    %93 = llvm.mlir.constant(0 : i64) : i64
    %94 = llvm.ptrtoint %91 : !llvm.ptr<i8> to i64
    %95 = llvm.ptrtoint %24 : !llvm.ptr<i8> to i64
    %96 = llvm.icmp "ne" %94, %93 : i64
    %97 = llvm.icmp "ne" %95, %93 : i64
    %98 = llvm.zext %96 : i1 to i32
    %99 = zexti %96 : i1 to i32
    %100 = ts.Cast %96 : i1 to i32
    %101 = llvm.zext %97 : i1 to i32
    %102 = zexti %97 : i1 to i32
    %103 = ts.Cast %97 : i1 to i32
    %104 = llvm.and %100, %103  : i32
    %105 = llvm.mlir.constant(0 : i32) : i32
    %106 = llvm.icmp "ne" %104, %105 : i32
    llvm.cond_br %106, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %107 = llvm.mlir.constant(0 : i32) : i32
    %108 = llvm.call @strcmp(%91, %24) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
    %109 = llvm.icmp "eq" %108, %107 : i32
    llvm.br ^bb3(%109 : i1)
  ^bb2:  // pred: ^bb0
    %110 = llvm.icmp "eq" %94, %95 : i64
    llvm.br ^bb3(%110 : i1)
  ^bb3(%111: i1):  // 2 preds: ^bb1, ^bb2
    llvm.br ^bb4
  ^bb4:  // pred: ^bb3
    %112 = "ts.StringCompare"(%91, %24) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
    %113 = ts.LogicalBinary %92(34) %25 : !ts.string, !ts.string -> !ts.boolean
    %114 = ts.Cast %113 : !ts.boolean to i1
    llvm.cond_br %111, ^bb5, ^bb6
    cond_br %114, ^bb5, ^bb6
  ^bb5:  // 2 preds: ^bb4, ^bb4
    %115 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %116 = ts.Load(%35) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
    llvm.store %115, %3 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %117 = ts.Variable(%115) {false} : !llvm.struct<(ptr<i8>, i1)> -> !ts.ref<!llvm.struct<(ptr<i8>, i1)>>
    %118 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
    %119 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %120 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
    %121 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %122 = llvm.mlir.constant(1 : i64) : i64
    %123 = llvm.getelementptr %121[%122] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %124 = llvm.ptrtoint %123 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
    %125 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
    %126 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %127 = llvm.mlir.constant(1 : i64) : i64
    %128 = llvm.getelementptr %126[%127] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %129 = llvm.ptrtoint %128 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %130 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
    %131 = llvm.icmp "ult" %125, %130 : i64
    %132 = llvm.select %131, %125, %130 : i1, i64
    %133 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%119, %120, %132, %133) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    "ts.MemoryCopy"(%118, %117) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, i1)>>) -> ()
    %134 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %135 = ts.Load(%118) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
    %136 = llvm.extractvalue %135[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %137 = ts.GetValueFromUnionOp %116 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
    %138 = llvm.mlir.constant(50 : i32) : i32
    %139 = llvm.zext %138 : i32 to i64
    %140 = zexti %138 : i32 to i64
    %141 = llvm.call @malloc(%140) : (i64) -> !llvm.ptr<i8>
    %142 = llvm.bitcast %141 : !llvm.ptr<i8> to !llvm.ptr<i8>
    %143 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
    %144 = llvm.mlir.constant(0 : i64) : i64
    %145 = llvm.getelementptr %143[%144, %144] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %146 = llvm.call @sprintf_s(%142, %138, %145, %136) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
    %147 = ts.Cast %137 : !ts.number to !ts.string
    %148 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
    %149 = llvm.mlir.constant(0 : i64) : i64
    %150 = llvm.getelementptr %148[%149, %149] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %151 = ts.Constant {value = " "} : !ts.string
    %152 = llvm.intr.stacksave : !llvm.ptr<i8>
    %153 = llvm.mlir.constant(1 : i64) : i64
    %154 = llvm.call @strlen(%28) : (!llvm.ptr<i8>) -> i64
    %155 = llvm.add %153, %154  : i64
    %156 = llvm.call @strlen(%150) : (!llvm.ptr<i8>) -> i64
    %157 = llvm.add %155, %156  : i64
    %158 = llvm.call @strlen(%142) : (!llvm.ptr<i8>) -> i64
    %159 = llvm.add %157, %158  : i64
    %160 = llvm.alloca %159 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
    %161 = llvm.call @strcpy(%160, %28) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %162 = llvm.call @strcat(%161, %150) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %163 = llvm.call @strcat(%162, %142) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %164 = "ts.StringConcat"(%28, %151, %142) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
    %165 = llvm.call @puts(%164) : (!ts.string) -> i32
    llvm.intr.stackrestore %152
    ts.Print(%29, %147) : !ts.string, !ts.string
    llvm.br ^bb6
    br ^bb6
  ^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
    %166 = llvm.call @puts(%32) : (!llvm.ptr<i8>) -> i32
    ts.Print(%33) : !ts.string
    llvm.return
    ts.ReturnInternal
  }
  func @main()
  ts.Func @main () -> ()  {
  }
  llvm.func @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32)
  llvm.func @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1
  llvm.func @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>)
  llvm.func @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64 attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64
  llvm.func @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>) attributes {sym_visibility = "private"}
  func private @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>)
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x278e950b550) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x278e950c9f0) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

!! SourceMaterialization: loc:[ loc("c:\\temp\\1.ts":5:9) ] result: [ !ts.number ]

!! SourceMaterialization value: [ %16 = llvm.mlir.constant(1.000000e+01 : f64) : f64 ]
** Insert  : 'ts.DialectCast'(0x278e9431580)

//===-------------------------------------------===//
Legalizing operation : 'ts.DialectCast'(0x278e9431580) {
  %18 = "ts.DialectCast"(%16) : (f64) -> !ts.number

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.DialectCast -> ()' {
Trying to match "`anonymous-namespace'::DialectCastOpLowering"
    ** Replace : 'ts.DialectCast'(0x278e9431580)
"`anonymous-namespace'::DialectCastOpLowering" result 1
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %12 = llvm.mlir.constant(1 : i32) : i32
  %13 = llvm.alloca %12 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %14 = llvm.mlir.constant(1 : i32) : i32
  %15 = llvm.alloca %14 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %16 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %17 = ts.DialectCast %16 : f64 to !ts.number
  %18 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %19 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %20 = llvm.mlir.constant(0 : i64) : i64
  %21 = llvm.getelementptr %19[%20, %20] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %22 = ts.Constant {value = "number"} : !ts.string
  %23 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %24 = llvm.mlir.constant(0 : i64) : i64
  %25 = llvm.getelementptr %23[%24, %24] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %26 = ts.Constant {value = "number"} : !ts.string
  %27 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %28 = llvm.mlir.constant(0 : i64) : i64
  %29 = llvm.getelementptr %27[%28, %28] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %30 = ts.Constant {value = "b number: "} : !ts.string
  %31 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %32 = llvm.mlir.constant(0 : i64) : i64
  %33 = llvm.getelementptr %31[%32, %32] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %34 = ts.Constant {value = "done."} : !ts.string
  %35 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %37 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %38 = llvm.insertvalue %22, %37[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %39 = llvm.insertvalue %18, %38[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %39, %11 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %40 = ts.Variable(%39) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %41 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %42 = llvm.bitcast %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %43 = llvm.bitcast %11 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %44 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %45 = llvm.mlir.constant(1 : i64) : i64
  %46 = llvm.getelementptr %44[%45] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %47 = llvm.ptrtoint %46 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %48 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %49 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %50 = llvm.mlir.constant(1 : i64) : i64
  %51 = llvm.getelementptr %49[%50] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %52 = llvm.ptrtoint %51 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %53 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %54 = llvm.icmp "ult" %48, %53 : i64
  %55 = llvm.select %54, %48, %53 : i1, i64
  %56 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%42, %43, %55, %56) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%41, %40) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %57 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %58 = ts.Load(%41) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %59 = ts.CreateUnionInstance %18, %22 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %57, %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %59, %35 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %60 = llvm.load %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %61 = ts.Load(%35) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %62 = llvm.extractvalue %60[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %63 = ts.GetValueFromUnionOp %60 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %64 = llvm.extractvalue %60[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %65 = ts.GetTypeInfoFromUnionOp %60 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %66 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %67 = llvm.insertvalue %65, %66[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %68 = llvm.insertvalue %63, %67[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  llvm.store %68, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %69 = ts.Variable(%68) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %70 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %71 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %72 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %73 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %74 = llvm.mlir.constant(1 : i64) : i64
  %75 = llvm.getelementptr %73[%74] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %76 = llvm.ptrtoint %75 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %77 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %78 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %79 = llvm.mlir.constant(1 : i64) : i64
  %80 = llvm.getelementptr %78[%79] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %81 = llvm.ptrtoint %80 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %82 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %83 = llvm.icmp "ult" %77, %82 : i64
  %84 = llvm.select %83, %77, %82 : i1, i64
  %85 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%71, %72, %84, %85) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%70, %69) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %86 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %87 = ts.Load(%70) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %88 = ts.CreateUnionInstance %63, %65 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
  %89 = ts.Cast %61 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  llvm.store %86, %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  ts.Store %89, %36 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %90 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %91 = ts.Load(%36) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %92 = llvm.extractvalue %90[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
  %93 = ts.GetTypeInfoFromUnionOp %91 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %94 = llvm.mlir.constant(0 : i64) : i64
  %95 = llvm.ptrtoint %92 : !llvm.ptr<i8> to i64
  %96 = llvm.ptrtoint %25 : !llvm.ptr<i8> to i64
  %97 = llvm.icmp "ne" %95, %94 : i64
  %98 = llvm.icmp "ne" %96, %94 : i64
  %99 = llvm.zext %97 : i1 to i32
  %100 = zexti %97 : i1 to i32
  %101 = ts.Cast %97 : i1 to i32
  %102 = llvm.zext %98 : i1 to i32
  %103 = zexti %98 : i1 to i32
  %104 = ts.Cast %98 : i1 to i32
  %105 = llvm.and %101, %104  : i32
  %106 = llvm.mlir.constant(0 : i32) : i32
  %107 = llvm.icmp "ne" %105, %106 : i32
  llvm.cond_br %107, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %108 = llvm.mlir.constant(0 : i32) : i32
  %109 = llvm.call @strcmp(%92, %25) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %110 = llvm.icmp "eq" %109, %108 : i32
  llvm.br ^bb3(%110 : i1)
^bb2:  // pred: ^bb0
  %111 = llvm.icmp "eq" %95, %96 : i64
  llvm.br ^bb3(%111 : i1)
^bb3(%112: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %113 = "ts.StringCompare"(%92, %25) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %114 = ts.LogicalBinary %93(34) %26 : !ts.string, !ts.string -> !ts.boolean
  %115 = ts.Cast %114 : !ts.boolean to i1
  llvm.cond_br %112, ^bb5, ^bb6
  cond_br %115, ^bb5, ^bb6
^bb5:  // 2 preds: ^bb4, ^bb4
  %116 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %117 = ts.Load(%36) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  llvm.store %116, %3 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %118 = ts.Variable(%116) {false} : !llvm.struct<(ptr<i8>, i1)> -> !ts.ref<!llvm.struct<(ptr<i8>, i1)>>
  %119 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %120 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %121 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %122 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %123 = llvm.mlir.constant(1 : i64) : i64
  %124 = llvm.getelementptr %122[%123] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %125 = llvm.ptrtoint %124 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %126 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %127 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %128 = llvm.mlir.constant(1 : i64) : i64
  %129 = llvm.getelementptr %127[%128] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %130 = llvm.ptrtoint %129 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %131 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %132 = llvm.icmp "ult" %126, %131 : i64
  %133 = llvm.select %132, %126, %131 : i1, i64
  %134 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%120, %121, %133, %134) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%119, %118) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, i1)>>) -> ()
  %135 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %136 = ts.Load(%119) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
  %137 = llvm.extractvalue %136[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %138 = ts.GetValueFromUnionOp %117 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %139 = llvm.mlir.constant(50 : i32) : i32
  %140 = llvm.zext %139 : i32 to i64
  %141 = zexti %139 : i32 to i64
  %142 = llvm.call @malloc(%141) : (i64) -> !llvm.ptr<i8>
  %143 = llvm.bitcast %142 : !llvm.ptr<i8> to !llvm.ptr<i8>
  %144 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
  %145 = llvm.mlir.constant(0 : i64) : i64
  %146 = llvm.getelementptr %144[%145, %145] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %147 = llvm.call @sprintf_s(%143, %139, %146, %137) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
  %148 = ts.Cast %138 : !ts.number to !ts.string
  %149 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
  %150 = llvm.mlir.constant(0 : i64) : i64
  %151 = llvm.getelementptr %149[%150, %150] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %152 = ts.Constant {value = " "} : !ts.string
  %153 = llvm.intr.stacksave : !llvm.ptr<i8>
  %154 = llvm.mlir.constant(1 : i64) : i64
  %155 = llvm.call @strlen(%29) : (!llvm.ptr<i8>) -> i64
  %156 = llvm.add %154, %155  : i64
  %157 = llvm.call @strlen(%151) : (!llvm.ptr<i8>) -> i64
  %158 = llvm.add %156, %157  : i64
  %159 = llvm.call @strlen(%143) : (!llvm.ptr<i8>) -> i64
  %160 = llvm.add %158, %159  : i64
  %161 = llvm.alloca %160 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
  %162 = llvm.call @strcpy(%161, %29) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  %163 = llvm.call @strcat(%162, %151) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  %164 = llvm.call @strcat(%163, %143) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  %165 = "ts.StringConcat"(%29, %152, %143) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
  %166 = llvm.call @puts(%165) : (!ts.string) -> i32
  llvm.intr.stackrestore %153
  ts.Print(%30, %148) : !ts.string, !ts.string
  llvm.br ^bb6
  br ^bb6
^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
  %167 = llvm.call @puts(%33) : (!llvm.ptr<i8>) -> i32
  ts.Print(%34) : !ts.string
  llvm.return
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

!! SourceMaterialization: loc:[ loc("c:\\temp\\1.ts":5:5) ] result: [ !ts.string ]

!! SourceMaterialization value: [ %21 = llvm.getelementptr %19[%20, %20] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8> ]
** Insert  : 'ts.DialectCast'(0x278e9432540)

//===-------------------------------------------===//
Legalizing operation : 'ts.DialectCast'(0x278e9432540) {
  %23 = "ts.DialectCast"(%22) : (!llvm.ptr<i8>) -> !ts.string

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.DialectCast -> ()' {
Trying to match "`anonymous-namespace'::DialectCastOpLowering"
    ** Replace : 'ts.DialectCast'(0x278e9432540)
"`anonymous-namespace'::DialectCastOpLowering" result 1
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %12 = llvm.mlir.constant(1 : i32) : i32
  %13 = llvm.alloca %12 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %14 = llvm.mlir.constant(1 : i32) : i32
  %15 = llvm.alloca %14 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %16 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %17 = ts.DialectCast %16 : f64 to !ts.number
  %18 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %19 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %20 = llvm.mlir.constant(0 : i64) : i64
  %21 = llvm.getelementptr %19[%20, %20] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %22 = ts.DialectCast %21 : !llvm.ptr<i8> to !ts.string
  %23 = ts.Constant {value = "number"} : !ts.string
  %24 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %25 = llvm.mlir.constant(0 : i64) : i64
  %26 = llvm.getelementptr %24[%25, %25] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %27 = ts.Constant {value = "number"} : !ts.string
  %28 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %29 = llvm.mlir.constant(0 : i64) : i64
  %30 = llvm.getelementptr %28[%29, %29] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %31 = ts.Constant {value = "b number: "} : !ts.string
  %32 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %33 = llvm.mlir.constant(0 : i64) : i64
  %34 = llvm.getelementptr %32[%33, %33] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %35 = ts.Constant {value = "done."} : !ts.string
  %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %37 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %38 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %39 = llvm.insertvalue %23, %38[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %40 = llvm.insertvalue %18, %39[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %40, %11 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %41 = ts.Variable(%40) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %42 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %43 = llvm.bitcast %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %44 = llvm.bitcast %11 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %45 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %46 = llvm.mlir.constant(1 : i64) : i64
  %47 = llvm.getelementptr %45[%46] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %48 = llvm.ptrtoint %47 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %49 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %50 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %51 = llvm.mlir.constant(1 : i64) : i64
  %52 = llvm.getelementptr %50[%51] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %53 = llvm.ptrtoint %52 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %54 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %55 = llvm.icmp "ult" %49, %54 : i64
  %56 = llvm.select %55, %49, %54 : i1, i64
  %57 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%43, %44, %56, %57) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%42, %41) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %58 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %59 = ts.Load(%42) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %60 = ts.CreateUnionInstance %18, %23 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %58, %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %60, %36 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %61 = llvm.load %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %62 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %63 = llvm.extractvalue %61[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %64 = ts.GetValueFromUnionOp %61 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %65 = llvm.extractvalue %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %66 = ts.GetTypeInfoFromUnionOp %61 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %67 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %68 = llvm.insertvalue %66, %67[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %69 = llvm.insertvalue %64, %68[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  llvm.store %69, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %70 = ts.Variable(%69) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %71 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %72 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %73 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %74 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %75 = llvm.mlir.constant(1 : i64) : i64
  %76 = llvm.getelementptr %74[%75] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %77 = llvm.ptrtoint %76 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %78 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %79 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %80 = llvm.mlir.constant(1 : i64) : i64
  %81 = llvm.getelementptr %79[%80] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %82 = llvm.ptrtoint %81 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %83 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %84 = llvm.icmp "ult" %78, %83 : i64
  %85 = llvm.select %84, %78, %83 : i1, i64
  %86 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%72, %73, %85, %86) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%71, %70) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %87 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %88 = ts.Load(%71) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %89 = ts.CreateUnionInstance %64, %66 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
  %90 = ts.Cast %62 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  llvm.store %87, %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  ts.Store %90, %37 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %91 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %92 = ts.Load(%37) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %93 = llvm.extractvalue %91[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
  %94 = ts.GetTypeInfoFromUnionOp %92 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %95 = llvm.mlir.constant(0 : i64) : i64
  %96 = llvm.ptrtoint %93 : !llvm.ptr<i8> to i64
  %97 = llvm.ptrtoint %26 : !llvm.ptr<i8> to i64
  %98 = llvm.icmp "ne" %96, %95 : i64
  %99 = llvm.icmp "ne" %97, %95 : i64
  %100 = llvm.zext %98 : i1 to i32
  %101 = zexti %98 : i1 to i32
  %102 = ts.Cast %98 : i1 to i32
  %103 = llvm.zext %99 : i1 to i32
  %104 = zexti %99 : i1 to i32
  %105 = ts.Cast %99 : i1 to i32
  %106 = llvm.and %102, %105  : i32
  %107 = llvm.mlir.constant(0 : i32) : i32
  %108 = llvm.icmp "ne" %106, %107 : i32
  llvm.cond_br %108, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %109 = llvm.mlir.constant(0 : i32) : i32
  %110 = llvm.call @strcmp(%93, %26) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %111 = llvm.icmp "eq" %110, %109 : i32
  llvm.br ^bb3(%111 : i1)
^bb2:  // pred: ^bb0
  %112 = llvm.icmp "eq" %96, %97 : i64
  llvm.br ^bb3(%112 : i1)
^bb3(%113: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %114 = "ts.StringCompare"(%93, %26) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %115 = ts.LogicalBinary %94(34) %27 : !ts.string, !ts.string -> !ts.boolean
  %116 = ts.Cast %115 : !ts.boolean to i1
  llvm.cond_br %113, ^bb5, ^bb6
  cond_br %116, ^bb5, ^bb6
^bb5:  // 2 preds: ^bb4, ^bb4
  %117 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %118 = ts.Load(%37) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  llvm.store %117, %3 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %119 = ts.Variable(%117) {false} : !llvm.struct<(ptr<i8>, i1)> -> !ts.ref<!llvm.struct<(ptr<i8>, i1)>>
  %120 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %121 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %122 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %123 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %124 = llvm.mlir.constant(1 : i64) : i64
  %125 = llvm.getelementptr %123[%124] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %126 = llvm.ptrtoint %125 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %127 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %128 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %129 = llvm.mlir.constant(1 : i64) : i64
  %130 = llvm.getelementptr %128[%129] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %131 = llvm.ptrtoint %130 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %132 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %133 = llvm.icmp "ult" %127, %132 : i64
  %134 = llvm.select %133, %127, %132 : i1, i64
  %135 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%121, %122, %134, %135) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%120, %119) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, i1)>>) -> ()
  %136 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %137 = ts.Load(%120) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
  %138 = llvm.extractvalue %137[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %139 = ts.GetValueFromUnionOp %118 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %140 = llvm.mlir.constant(50 : i32) : i32
  %141 = llvm.zext %140 : i32 to i64
  %142 = zexti %140 : i32 to i64
  %143 = llvm.call @malloc(%142) : (i64) -> !llvm.ptr<i8>
  %144 = llvm.bitcast %143 : !llvm.ptr<i8> to !llvm.ptr<i8>
  %145 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
  %146 = llvm.mlir.constant(0 : i64) : i64
  %147 = llvm.getelementptr %145[%146, %146] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %148 = llvm.call @sprintf_s(%144, %140, %147, %138) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
  %149 = ts.Cast %139 : !ts.number to !ts.string
  %150 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
  %151 = llvm.mlir.constant(0 : i64) : i64
  %152 = llvm.getelementptr %150[%151, %151] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %153 = ts.Constant {value = " "} : !ts.string
  %154 = llvm.intr.stacksave : !llvm.ptr<i8>
  %155 = llvm.mlir.constant(1 : i64) : i64
  %156 = llvm.call @strlen(%30) : (!llvm.ptr<i8>) -> i64
  %157 = llvm.add %155, %156  : i64
  %158 = llvm.call @strlen(%152) : (!llvm.ptr<i8>) -> i64
  %159 = llvm.add %157, %158  : i64
  %160 = llvm.call @strlen(%144) : (!llvm.ptr<i8>) -> i64
  %161 = llvm.add %159, %160  : i64
  %162 = llvm.alloca %161 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
  %163 = llvm.call @strcpy(%162, %30) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  %164 = llvm.call @strcat(%163, %152) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  %165 = llvm.call @strcat(%164, %144) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  %166 = "ts.StringConcat"(%30, %153, %144) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
  %167 = llvm.call @puts(%166) : (!ts.string) -> i32
  llvm.intr.stackrestore %154
  ts.Print(%31, %149) : !ts.string, !ts.string
  llvm.br ^bb6
  br ^bb6
^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
  %168 = llvm.call @puts(%34) : (!llvm.ptr<i8>) -> i32
  ts.Print(%35) : !ts.string
  llvm.return
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

!! SourceMaterialization: loc:[ loc("c:\\temp\\1.ts":7:5) ] result: [ !ts.string ]

!! SourceMaterialization value: [ %65 = llvm.extractvalue %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)> ]
** Insert  : 'ts.DialectCast'(0x278e9432300)

//===-------------------------------------------===//
Legalizing operation : 'ts.DialectCast'(0x278e9432300) {
  %67 = "ts.DialectCast"(%66) : (!llvm.ptr<i8>) -> !ts.string

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.DialectCast -> ()' {
Trying to match "`anonymous-namespace'::DialectCastOpLowering"
    ** Replace : 'ts.DialectCast'(0x278e9432300)
"`anonymous-namespace'::DialectCastOpLowering" result 1
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %12 = llvm.mlir.constant(1 : i32) : i32
  %13 = llvm.alloca %12 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %14 = llvm.mlir.constant(1 : i32) : i32
  %15 = llvm.alloca %14 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %16 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %17 = ts.DialectCast %16 : f64 to !ts.number
  %18 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %19 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %20 = llvm.mlir.constant(0 : i64) : i64
  %21 = llvm.getelementptr %19[%20, %20] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %22 = ts.DialectCast %21 : !llvm.ptr<i8> to !ts.string
  %23 = ts.Constant {value = "number"} : !ts.string
  %24 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %25 = llvm.mlir.constant(0 : i64) : i64
  %26 = llvm.getelementptr %24[%25, %25] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %27 = ts.Constant {value = "number"} : !ts.string
  %28 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %29 = llvm.mlir.constant(0 : i64) : i64
  %30 = llvm.getelementptr %28[%29, %29] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %31 = ts.Constant {value = "b number: "} : !ts.string
  %32 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %33 = llvm.mlir.constant(0 : i64) : i64
  %34 = llvm.getelementptr %32[%33, %33] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %35 = ts.Constant {value = "done."} : !ts.string
  %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %37 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %38 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %39 = llvm.insertvalue %23, %38[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %40 = llvm.insertvalue %18, %39[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %40, %11 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %41 = ts.Variable(%40) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %42 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %43 = llvm.bitcast %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %44 = llvm.bitcast %11 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %45 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %46 = llvm.mlir.constant(1 : i64) : i64
  %47 = llvm.getelementptr %45[%46] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %48 = llvm.ptrtoint %47 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %49 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %50 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %51 = llvm.mlir.constant(1 : i64) : i64
  %52 = llvm.getelementptr %50[%51] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %53 = llvm.ptrtoint %52 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %54 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %55 = llvm.icmp "ult" %49, %54 : i64
  %56 = llvm.select %55, %49, %54 : i1, i64
  %57 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%43, %44, %56, %57) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%42, %41) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %58 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %59 = ts.Load(%42) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %60 = ts.CreateUnionInstance %18, %23 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %58, %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %60, %36 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %61 = llvm.load %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %62 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %63 = llvm.extractvalue %61[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %64 = ts.GetValueFromUnionOp %61 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %65 = llvm.extractvalue %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %66 = ts.DialectCast %65 : !llvm.ptr<i8> to !ts.string
  %67 = ts.GetTypeInfoFromUnionOp %61 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %68 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %69 = llvm.insertvalue %67, %68[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %70 = llvm.insertvalue %64, %69[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  llvm.store %70, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %71 = ts.Variable(%70) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %72 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %73 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %74 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %75 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %76 = llvm.mlir.constant(1 : i64) : i64
  %77 = llvm.getelementptr %75[%76] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %78 = llvm.ptrtoint %77 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %79 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %80 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %81 = llvm.mlir.constant(1 : i64) : i64
  %82 = llvm.getelementptr %80[%81] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %83 = llvm.ptrtoint %82 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %84 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %85 = llvm.icmp "ult" %79, %84 : i64
  %86 = llvm.select %85, %79, %84 : i1, i64
  %87 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%73, %74, %86, %87) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%72, %71) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %88 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %89 = ts.Load(%72) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %90 = ts.CreateUnionInstance %64, %67 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
  %91 = ts.Cast %62 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  llvm.store %88, %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  ts.Store %91, %37 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %92 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %93 = ts.Load(%37) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %94 = llvm.extractvalue %92[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
  %95 = ts.GetTypeInfoFromUnionOp %93 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %96 = llvm.mlir.constant(0 : i64) : i64
  %97 = llvm.ptrtoint %94 : !llvm.ptr<i8> to i64
  %98 = llvm.ptrtoint %26 : !llvm.ptr<i8> to i64
  %99 = llvm.icmp "ne" %97, %96 : i64
  %100 = llvm.icmp "ne" %98, %96 : i64
  %101 = llvm.zext %99 : i1 to i32
  %102 = zexti %99 : i1 to i32
  %103 = ts.Cast %99 : i1 to i32
  %104 = llvm.zext %100 : i1 to i32
  %105 = zexti %100 : i1 to i32
  %106 = ts.Cast %100 : i1 to i32
  %107 = llvm.and %103, %106  : i32
  %108 = llvm.mlir.constant(0 : i32) : i32
  %109 = llvm.icmp "ne" %107, %108 : i32
  llvm.cond_br %109, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %110 = llvm.mlir.constant(0 : i32) : i32
  %111 = llvm.call @strcmp(%94, %26) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %112 = llvm.icmp "eq" %111, %110 : i32
  llvm.br ^bb3(%112 : i1)
^bb2:  // pred: ^bb0
  %113 = llvm.icmp "eq" %97, %98 : i64
  llvm.br ^bb3(%113 : i1)
^bb3(%114: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %115 = "ts.StringCompare"(%94, %26) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %116 = ts.LogicalBinary %95(34) %27 : !ts.string, !ts.string -> !ts.boolean
  %117 = ts.Cast %116 : !ts.boolean to i1
  llvm.cond_br %114, ^bb5, ^bb6
  cond_br %117, ^bb5, ^bb6
^bb5:  // 2 preds: ^bb4, ^bb4
  %118 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %119 = ts.Load(%37) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  llvm.store %118, %3 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %120 = ts.Variable(%118) {false} : !llvm.struct<(ptr<i8>, i1)> -> !ts.ref<!llvm.struct<(ptr<i8>, i1)>>
  %121 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %122 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %123 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %124 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %125 = llvm.mlir.constant(1 : i64) : i64
  %126 = llvm.getelementptr %124[%125] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %127 = llvm.ptrtoint %126 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %128 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %129 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %130 = llvm.mlir.constant(1 : i64) : i64
  %131 = llvm.getelementptr %129[%130] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %132 = llvm.ptrtoint %131 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %133 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %134 = llvm.icmp "ult" %128, %133 : i64
  %135 = llvm.select %134, %128, %133 : i1, i64
  %136 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%122, %123, %135, %136) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%121, %120) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, i1)>>) -> ()
  %137 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %138 = ts.Load(%121) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
  %139 = llvm.extractvalue %138[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %140 = ts.GetValueFromUnionOp %119 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %141 = llvm.mlir.constant(50 : i32) : i32
  %142 = llvm.zext %141 : i32 to i64
  %143 = zexti %141 : i32 to i64
  %144 = llvm.call @malloc(%143) : (i64) -> !llvm.ptr<i8>
  %145 = llvm.bitcast %144 : !llvm.ptr<i8> to !llvm.ptr<i8>
  %146 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
  %147 = llvm.mlir.constant(0 : i64) : i64
  %148 = llvm.getelementptr %146[%147, %147] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %149 = llvm.call @sprintf_s(%145, %141, %148, %139) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
  %150 = ts.Cast %140 : !ts.number to !ts.string
  %151 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
  %152 = llvm.mlir.constant(0 : i64) : i64
  %153 = llvm.getelementptr %151[%152, %152] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %154 = ts.Constant {value = " "} : !ts.string
  %155 = llvm.intr.stacksave : !llvm.ptr<i8>
  %156 = llvm.mlir.constant(1 : i64) : i64
  %157 = llvm.call @strlen(%30) : (!llvm.ptr<i8>) -> i64
  %158 = llvm.add %156, %157  : i64
  %159 = llvm.call @strlen(%153) : (!llvm.ptr<i8>) -> i64
  %160 = llvm.add %158, %159  : i64
  %161 = llvm.call @strlen(%145) : (!llvm.ptr<i8>) -> i64
  %162 = llvm.add %160, %161  : i64
  %163 = llvm.alloca %162 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
  %164 = llvm.call @strcpy(%163, %30) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  %165 = llvm.call @strcat(%164, %153) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  %166 = llvm.call @strcat(%165, %145) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  %167 = "ts.StringConcat"(%30, %154, %145) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
  %168 = llvm.call @puts(%167) : (!ts.string) -> i32
  llvm.intr.stackrestore %155
  ts.Print(%31, %150) : !ts.string, !ts.string
  llvm.br ^bb6
  br ^bb6
^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
  %169 = llvm.call @puts(%34) : (!llvm.ptr<i8>) -> i32
  ts.Print(%35) : !ts.string
  llvm.return
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

!! SourceMaterialization: loc:[ loc("c:\\temp\\1.ts":11:2) ] result: [ !ts.string ]

!! SourceMaterialization value: [ %163 = llvm.alloca %162 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8> ]
** Insert  : 'ts.DialectCast'(0x278e9432600)

//===-------------------------------------------===//
Legalizing operation : 'ts.DialectCast'(0x278e9432600) {
  %168 = "ts.DialectCast"(%164) : (!llvm.ptr<i8>) -> !ts.string

  * Fold {
  } -> FAILURE : unable to fold

  * Pattern : 'ts.DialectCast -> ()' {
Trying to match "`anonymous-namespace'::DialectCastOpLowering"
    ** Replace : 'ts.DialectCast'(0x278e9432600)
"`anonymous-namespace'::DialectCastOpLowering" result 1
  } -> SUCCESS : pattern applied successfully
// *** IR Dump After Pattern Application ***
llvm.func @main() {
  %0 = llvm.mlir.constant(1 : i32) : i32
  %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %2 = llvm.mlir.constant(1 : i32) : i32
  %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %4 = llvm.mlir.constant(1 : i32) : i32
  %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %6 = llvm.mlir.constant(1 : i32) : i32
  %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %8 = llvm.mlir.constant(1 : i32) : i32
  %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %10 = llvm.mlir.constant(1 : i32) : i32
  %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %12 = llvm.mlir.constant(1 : i32) : i32
  %13 = llvm.alloca %12 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %14 = llvm.mlir.constant(1 : i32) : i32
  %15 = llvm.alloca %14 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %16 = llvm.mlir.constant(1.000000e+01 : f64) : f64
  %cst = constant 1.000000e+01 : f64
  %17 = ts.DialectCast %16 : f64 to !ts.number
  %18 = ts.Constant {value = 1.000000e+01 : f64} : !ts.number
  %19 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %20 = llvm.mlir.constant(0 : i64) : i64
  %21 = llvm.getelementptr %19[%20, %20] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %22 = ts.DialectCast %21 : !llvm.ptr<i8> to !ts.string
  %23 = ts.Constant {value = "number"} : !ts.string
  %24 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
  %25 = llvm.mlir.constant(0 : i64) : i64
  %26 = llvm.getelementptr %24[%25, %25] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %27 = ts.Constant {value = "number"} : !ts.string
  %28 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
  %29 = llvm.mlir.constant(0 : i64) : i64
  %30 = llvm.getelementptr %28[%29, %29] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %31 = ts.Constant {value = "b number: "} : !ts.string
  %32 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
  %33 = llvm.mlir.constant(0 : i64) : i64
  %34 = llvm.getelementptr %32[%33, %33] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %35 = ts.Constant {value = "done."} : !ts.string
  %36 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %37 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %38 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
  %39 = llvm.insertvalue %23, %38[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %40 = llvm.insertvalue %18, %39[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  llvm.store %40, %11 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %41 = ts.Variable(%40) {false} : !llvm.struct<(ptr<i8>, f64)> -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %42 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %43 = llvm.bitcast %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %44 = llvm.bitcast %11 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %45 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %46 = llvm.mlir.constant(1 : i64) : i64
  %47 = llvm.getelementptr %45[%46] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %48 = llvm.ptrtoint %47 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %49 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %50 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %51 = llvm.mlir.constant(1 : i64) : i64
  %52 = llvm.getelementptr %50[%51] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %53 = llvm.ptrtoint %52 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %54 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %55 = llvm.icmp "ult" %49, %54 : i64
  %56 = llvm.select %55, %49, %54 : i1, i64
  %57 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%43, %44, %56, %57) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%42, %41) : (!ts.ref<!ts.union<!ts.number,!ts.string>>, !ts.ref<!llvm.struct<(ptr<i8>, f64)>>) -> ()
  %58 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %59 = ts.Load(%42) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %60 = ts.CreateUnionInstance %18, %23 : !ts.number, !ts.string to !ts.union<!ts.number,!ts.string>
  llvm.store %58, %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  ts.Store %60, %36 : !ts.union<!ts.number,!ts.string> -> !ts.ref<!ts.union<!ts.number,!ts.string>>
  %61 = llvm.load %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %62 = ts.Load(%36) : !ts.ref<!ts.union<!ts.number,!ts.string>> -> !ts.union<!ts.number,!ts.string>
  %63 = llvm.extractvalue %61[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %64 = ts.GetValueFromUnionOp %61 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !llvm.ptr<i8>
  %65 = llvm.extractvalue %61[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %66 = ts.DialectCast %65 : !llvm.ptr<i8> to !ts.string
  %67 = ts.GetTypeInfoFromUnionOp %61 : !llvm.struct<(ptr<i8>, ptr<i8>)> to !ts.string
  %68 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %69 = llvm.insertvalue %67, %68[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  %70 = llvm.insertvalue %64, %69[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
  llvm.store %70, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %71 = ts.Variable(%70) {false} : !llvm.struct<(ptr<i8>, ptr<i8>)> -> !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>
  %72 = ts.Variable() {false} :  -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %73 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %74 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
  %75 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %76 = llvm.mlir.constant(1 : i64) : i64
  %77 = llvm.getelementptr %75[%76] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
  %78 = llvm.ptrtoint %77 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
  %79 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, ptr<i8>)>} : () -> i64
  %80 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %81 = llvm.mlir.constant(1 : i64) : i64
  %82 = llvm.getelementptr %80[%81] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %83 = llvm.ptrtoint %82 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %84 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %85 = llvm.icmp "ult" %79, %84 : i64
  %86 = llvm.select %85, %79, %84 : i1, i64
  %87 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%73, %74, %86, %87) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%72, %71) : (!ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>, !ts.ref<!llvm.struct<(ptr<i8>, ptr<i8>)>>) -> ()
  %88 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %89 = ts.Load(%72) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %90 = ts.CreateUnionInstance %64, %67 : !llvm.ptr<i8>, !ts.string to !ts.union<!ts.string,!ts.number,!ts.boolean>
  %91 = ts.Cast %62 : !ts.union<!ts.number,!ts.string> to !ts.union<!ts.string,!ts.number,!ts.boolean>
  llvm.store %88, %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  ts.Store %91, %37 : !ts.union<!ts.string,!ts.number,!ts.boolean> -> !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>>
  %92 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %93 = ts.Load(%37) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  %94 = llvm.extractvalue %92[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
  %95 = ts.GetTypeInfoFromUnionOp %93 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.string
  %96 = llvm.mlir.constant(0 : i64) : i64
  %97 = llvm.ptrtoint %94 : !llvm.ptr<i8> to i64
  %98 = llvm.ptrtoint %26 : !llvm.ptr<i8> to i64
  %99 = llvm.icmp "ne" %97, %96 : i64
  %100 = llvm.icmp "ne" %98, %96 : i64
  %101 = llvm.zext %99 : i1 to i32
  %102 = zexti %99 : i1 to i32
  %103 = ts.Cast %99 : i1 to i32
  %104 = llvm.zext %100 : i1 to i32
  %105 = zexti %100 : i1 to i32
  %106 = ts.Cast %100 : i1 to i32
  %107 = llvm.and %103, %106  : i32
  %108 = llvm.mlir.constant(0 : i32) : i32
  %109 = llvm.icmp "ne" %107, %108 : i32
  llvm.cond_br %109, ^bb1, ^bb2
^bb1:  // pred: ^bb0
  %110 = llvm.mlir.constant(0 : i32) : i32
  %111 = llvm.call @strcmp(%94, %26) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  %112 = llvm.icmp "eq" %111, %110 : i32
  llvm.br ^bb3(%112 : i1)
^bb2:  // pred: ^bb0
  %113 = llvm.icmp "eq" %97, %98 : i64
  llvm.br ^bb3(%113 : i1)
^bb3(%114: i1):  // 2 preds: ^bb1, ^bb2
  llvm.br ^bb4
^bb4:  // pred: ^bb3
  %115 = "ts.StringCompare"(%94, %26) {code = 34 : i32} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !ts.boolean
  %116 = ts.LogicalBinary %95(34) %27 : !ts.string, !ts.string -> !ts.boolean
  %117 = ts.Cast %116 : !ts.boolean to i1
  llvm.cond_br %114, ^bb5, ^bb6
  cond_br %117, ^bb5, ^bb6
^bb5:  // 2 preds: ^bb4, ^bb4
  %118 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %119 = ts.Load(%37) : !ts.ref<!ts.union<!ts.string,!ts.number,!ts.boolean>> -> !ts.union<!ts.string,!ts.number,!ts.boolean>
  llvm.store %118, %3 : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %120 = ts.Variable(%118) {false} : !llvm.struct<(ptr<i8>, i1)> -> !ts.ref<!llvm.struct<(ptr<i8>, i1)>>
  %121 = ts.Variable() {false} :  -> !ts.ref<!llvm.struct<(ptr<i8>, f64)>>
  %122 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
  %123 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
  %124 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
  %125 = llvm.mlir.constant(1 : i64) : i64
  %126 = llvm.getelementptr %124[%125] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
  %127 = llvm.ptrtoint %126 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
  %128 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, i1)>} : () -> i64
  %129 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %130 = llvm.mlir.constant(1 : i64) : i64
  %131 = llvm.getelementptr %129[%130] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
  %132 = llvm.ptrtoint %131 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
  %133 = "ts.SizeOf"() {type = !llvm.struct<(ptr<i8>, f64)>} : () -> i64
  %134 = llvm.icmp "ult" %128, %133 : i64
  %135 = llvm.select %134, %128, %133 : i1, i64
  %136 = llvm.mlir.constant(false) : i1
  llvm.call @llvm.memcpy.p0i8.p0i8.i64(%122, %123, %135, %136) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
  "ts.MemoryCopy"(%121, %120) : (!ts.ref<!llvm.struct<(ptr<i8>, f64)>>, !ts.ref<!llvm.struct<(ptr<i8>, i1)>>) -> ()
  %137 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
  %138 = ts.Load(%121) : !ts.ref<!llvm.struct<(ptr<i8>, f64)>> -> !llvm.struct<(ptr<i8>, f64)>
  %139 = llvm.extractvalue %138[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
  %140 = ts.GetValueFromUnionOp %119 : !ts.union<!ts.string,!ts.number,!ts.boolean> to !ts.number
  %141 = llvm.mlir.constant(50 : i32) : i32
  %142 = llvm.zext %141 : i32 to i64
  %143 = zexti %141 : i32 to i64
  %144 = llvm.call @malloc(%143) : (i64) -> !llvm.ptr<i8>
  %145 = llvm.bitcast %144 : !llvm.ptr<i8> to !llvm.ptr<i8>
  %146 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
  %147 = llvm.mlir.constant(0 : i64) : i64
  %148 = llvm.getelementptr %146[%147, %147] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %149 = llvm.call @sprintf_s(%145, %141, %148, %139) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
  %150 = ts.Cast %140 : !ts.number to !ts.string
  %151 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
  %152 = llvm.mlir.constant(0 : i64) : i64
  %153 = llvm.getelementptr %151[%152, %152] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
  %154 = ts.Constant {value = " "} : !ts.string
  %155 = llvm.intr.stacksave : !llvm.ptr<i8>
  %156 = llvm.mlir.constant(1 : i64) : i64
  %157 = llvm.call @strlen(%30) : (!llvm.ptr<i8>) -> i64
  %158 = llvm.add %156, %157  : i64
  %159 = llvm.call @strlen(%153) : (!llvm.ptr<i8>) -> i64
  %160 = llvm.add %158, %159  : i64
  %161 = llvm.call @strlen(%145) : (!llvm.ptr<i8>) -> i64
  %162 = llvm.add %160, %161  : i64
  %163 = llvm.alloca %162 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
  %164 = llvm.call @strcpy(%163, %30) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  %165 = llvm.call @strcat(%164, %153) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  %166 = llvm.call @strcat(%165, %145) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  %167 = ts.DialectCast %163 : !llvm.ptr<i8> to !ts.string
  %168 = "ts.StringConcat"(%30, %154, %145) {allocInStack = true} : (!llvm.ptr<i8>, !ts.string, !llvm.ptr<i8>) -> !ts.string
  %169 = llvm.call @puts(%168) : (!ts.string) -> i32
  llvm.intr.stackrestore %155
  ts.Print(%31, %150) : !ts.string, !ts.string
  llvm.br ^bb6
  br ^bb6
^bb6:  // 4 preds: ^bb4, ^bb4, ^bb5, ^bb5
  %170 = llvm.call @puts(%34) : (!llvm.ptr<i8>) -> i32
  ts.Print(%35) : !ts.string
  llvm.return
  ts.ReturnInternal
}


} -> SUCCESS
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'module'(0x278e950a6e0) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x278e9513530) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x278e9513c10) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x278e9514870) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x278e9513d70) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x278e9514d40) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x278e9514ea0) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x278e9515370) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.global'(0x278e9512a30) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.global'(0x278e95135e0) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.global'(0x278e95154d0) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.global'(0x278e9514f50) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.global'(0x278e9512ae0) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x278e9513110) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x278e94d7ce0) {
  %0 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.alloca'(0x278e9430b00) {
  %1 = "llvm.alloca"(%0) : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x278e94d7560) {
  %2 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.alloca'(0x278e942fd80) {
  %3 = "llvm.alloca"(%2) : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x278e94d35a0) {
  %4 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.alloca'(0x278e942f900) {
  %5 = "llvm.alloca"(%4) : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x278e94d4040) {
  %6 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.alloca'(0x278e942ef40) {
  %7 = "llvm.alloca"(%6) : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x278e94d5260) {
  %8 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.alloca'(0x278e942f300) {
  %9 = "llvm.alloca"(%8) : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x278e94d5580) {
  %10 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.alloca'(0x278e942ff00) {
  %11 = "llvm.alloca"(%10) : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x278e94d4680) {
  %12 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.alloca'(0x278e94308c0) {
  %13 = "llvm.alloca"(%12) : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x278e94d4cc0) {
  %14 = "llvm.mlir.constant"() {value = 1 : i32} : () -> i32

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.alloca'(0x278e94305c0) {
  %15 = "llvm.alloca"(%14) : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x278e94d4ae0) {
  %16 = "llvm.mlir.constant"() {value = 1.000000e+01 : f64} : () -> f64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.addressof'(0x278e94d3640) {
  %17 = "llvm.mlir.addressof"() {global_name = @s_9237349086447201248} : () -> !llvm.ptr<array<7 x i8>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x278e94d58a0) {
  %18 = "llvm.mlir.constant"() {value = 0 : i64} : () -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x278e9396930) {
  %19 = "llvm.getelementptr"(%17, %18, %18) : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.addressof'(0x278e94d51c0) {
  %20 = "llvm.mlir.addressof"() {global_name = @s_9237349086447201248} : () -> !llvm.ptr<array<7 x i8>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x278e94d3820) {
  %21 = "llvm.mlir.constant"() {value = 0 : i64} : () -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x278e9391d30) {
  %22 = "llvm.getelementptr"(%20, %21, %21) : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.addressof'(0x278e94d4720) {
  %23 = "llvm.mlir.addressof"() {global_name = @s_13617892236937420068} : () -> !llvm.ptr<array<11 x i8>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x278e94d56c0) {
  %24 = "llvm.mlir.constant"() {value = 0 : i64} : () -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x278e9390830) {
  %25 = "llvm.getelementptr"(%23, %24, %24) : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.addressof'(0x278e94d4fe0) {
  %26 = "llvm.mlir.addressof"() {global_name = @s_6682479467004374669} : () -> !llvm.ptr<array<6 x i8>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x278e94d33c0) {
  %27 = "llvm.mlir.constant"() {value = 0 : i64} : () -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x278e9393730) {
  %28 = "llvm.getelementptr"(%26, %27, %27) : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.undef'(0x278e94d3460) {
  %29 = "llvm.mlir.undef"() : () -> !llvm.struct<(ptr<i8>, f64)>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.insertvalue'(0x278e95471c0) {
  %30 = "llvm.insertvalue"(%29, %19) {position = [0 : i32]} : (!llvm.struct<(ptr<i8>, f64)>, !llvm.ptr<i8>) -> !llvm.struct<(ptr<i8>, f64)>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.insertvalue'(0x278e9546040) {
  %31 = "llvm.insertvalue"(%30, %16) {position = [1 : i32]} : (!llvm.struct<(ptr<i8>, f64)>, f64) -> !llvm.struct<(ptr<i8>, f64)>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.store'(0x278e9476800) {
  "llvm.store"(%31, %11) : (!llvm.struct<(ptr<i8>, f64)>, !llvm.ptr<struct<(ptr<i8>, f64)>>) -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.bitcast'(0x278e9430ec0) {
  %32 = "llvm.bitcast"(%9) : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>) -> !llvm.ptr<i8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.bitcast'(0x278e942f180) {
  %33 = "llvm.bitcast"(%11) : (!llvm.ptr<struct<(ptr<i8>, f64)>>) -> !llvm.ptr<i8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.null'(0x278e94d4360) {
  %34 = "llvm.mlir.null"() : () -> !llvm.ptr<struct<(ptr<i8>, f64)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x278e94d4d60) {
  %35 = "llvm.mlir.constant"() {value = 1 : i64} : () -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x278e9545f60) {
  %36 = "llvm.getelementptr"(%34, %35) : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.ptrtoint'(0x278e942e700) {
  %37 = "llvm.ptrtoint"(%36) : (!llvm.ptr<struct<(ptr<i8>, f64)>>) -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.null'(0x278e94d3140) {
  %38 = "llvm.mlir.null"() : () -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x278e94d4400) {
  %39 = "llvm.mlir.constant"() {value = 1 : i64} : () -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x278e9545780) {
  %40 = "llvm.getelementptr"(%38, %39) : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.ptrtoint'(0x278e942edc0) {
  %41 = "llvm.ptrtoint"(%40) : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>) -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.icmp'(0x278e95446e0) {
  %42 = "llvm.icmp"(%37, %41) {predicate = 6 : i64} : (i64, i64) -> i1

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.select'(0x278e9392430) {
  %43 = "llvm.select"(%42, %37, %41) : (i1, i64, i64) -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x278e94d5760) {
  %44 = "llvm.mlir.constant"() {value = false} : () -> i1

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.call'(0x278e9457880) {
  "llvm.call"(%32, %33, %43, %44) {callee = @llvm.memcpy.p0i8.p0i8.i64} : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.load'(0x278e942eb80) {
  %45 = "llvm.load"(%9) : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>) -> !llvm.struct<(ptr<i8>, ptr<i8>)>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.store'(0x278e9476180) {
  "llvm.store"(%45, %15) : (!llvm.struct<(ptr<i8>, ptr<i8>)>, !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>) -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.load'(0x278e942fc00) {
  %46 = "llvm.load"(%15) : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>) -> !llvm.struct<(ptr<i8>, ptr<i8>)>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.extractvalue'(0x278e9430740) {
  %47 = "llvm.extractvalue"(%46) {position = [1 : i32]} : (!llvm.struct<(ptr<i8>, ptr<i8>)>) -> !llvm.ptr<i8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.extractvalue'(0x278e942ee80) {
  %48 = "llvm.extractvalue"(%46) {position = [0 : i32]} : (!llvm.struct<(ptr<i8>, ptr<i8>)>) -> !llvm.ptr<i8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.undef'(0x278e94d47c0) {
  %49 = "llvm.mlir.undef"() : () -> !llvm.struct<(ptr<i8>, ptr<i8>)>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.insertvalue'(0x278e9547540) {
  %50 = "llvm.insertvalue"(%49, %48) {position = [0 : i32]} : (!llvm.struct<(ptr<i8>, ptr<i8>)>, !llvm.ptr<i8>) -> !llvm.struct<(ptr<i8>, ptr<i8>)>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.insertvalue'(0x278e9544520) {
  %51 = "llvm.insertvalue"(%50, %47) {position = [1 : i32]} : (!llvm.struct<(ptr<i8>, ptr<i8>)>, !llvm.ptr<i8>) -> !llvm.struct<(ptr<i8>, ptr<i8>)>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.store'(0x278e94757c0) {
  "llvm.store"(%51, %7) : (!llvm.struct<(ptr<i8>, ptr<i8>)>, !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>) -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.bitcast'(0x278e942f600) {
  %52 = "llvm.bitcast"(%5) : (!llvm.ptr<struct<(ptr<i8>, i1)>>) -> !llvm.ptr<i8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.bitcast'(0x278e942f780) {
  %53 = "llvm.bitcast"(%7) : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>) -> !llvm.ptr<i8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.null'(0x278e94d3b40) {
  %54 = "llvm.mlir.null"() : () -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x278e94d3be0) {
  %55 = "llvm.mlir.constant"() {value = 1 : i64} : () -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x278e9544600) {
  %56 = "llvm.getelementptr"(%54, %55) : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.ptrtoint'(0x278e9430680) {
  %57 = "llvm.ptrtoint"(%56) : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>) -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.null'(0x278e94d3c80) {
  %58 = "llvm.mlir.null"() : () -> !llvm.ptr<struct<(ptr<i8>, i1)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x278e94d3d20) {
  %59 = "llvm.mlir.constant"() {value = 1 : i64} : () -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x278e95447c0) {
  %60 = "llvm.getelementptr"(%58, %59) : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.ptrtoint'(0x278e9430f80) {
  %61 = "llvm.ptrtoint"(%60) : (!llvm.ptr<struct<(ptr<i8>, i1)>>) -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.icmp'(0x278e95464a0) {
  %62 = "llvm.icmp"(%57, %61) {predicate = 6 : i64} : (i64, i64) -> i1

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.select'(0x278e9391530) {
  %63 = "llvm.select"(%62, %57, %61) : (i1, i64, i64) -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x278e94d3a00) {
  %64 = "llvm.mlir.constant"() {value = false} : () -> i1

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.call'(0x278e9458dc0) {
  "llvm.call"(%52, %53, %63, %64) {callee = @llvm.memcpy.p0i8.p0i8.i64} : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.load'(0x278e9431040) {
  %65 = "llvm.load"(%5) : (!llvm.ptr<struct<(ptr<i8>, i1)>>) -> !llvm.struct<(ptr<i8>, i1)>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.store'(0x278e94763f0) {
  "llvm.store"(%65, %13) : (!llvm.struct<(ptr<i8>, i1)>, !llvm.ptr<struct<(ptr<i8>, i1)>>) -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.load'(0x278e9430080) {
  %66 = "llvm.load"(%13) : (!llvm.ptr<struct<(ptr<i8>, i1)>>) -> !llvm.struct<(ptr<i8>, i1)>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.extractvalue'(0x278e942e580) {
  %67 = "llvm.extractvalue"(%66) {position = [0 : i32]} : (!llvm.struct<(ptr<i8>, i1)>) -> !llvm.ptr<i8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x278e94d3dc0) {
  %68 = "llvm.mlir.constant"() {value = 0 : i64} : () -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.ptrtoint'(0x278e9430800) {
  %69 = "llvm.ptrtoint"(%67) : (!llvm.ptr<i8>) -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.ptrtoint'(0x278e942e1c0) {
  %70 = "llvm.ptrtoint"(%22) : (!llvm.ptr<i8>) -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.icmp'(0x278e9547000) {
  %71 = "llvm.icmp"(%69, %68) {predicate = 1 : i64} : (i64, i64) -> i1

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.icmp'(0x278e95448a0) {
  %72 = "llvm.icmp"(%70, %68) {predicate = 1 : i64} : (i64, i64) -> i1

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.zext'(0x278e942e7c0) {
  %73 = "llvm.zext"(%71) : (i1) -> i32

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.zext'(0x278e942f000) {
  %74 = "llvm.zext"(%72) : (i1) -> i32

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.and'(0x278e9544b40) {
  %75 = "llvm.and"(%73, %74) : (i32, i32) -> i32

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x278e94d4540) {
  %76 = "llvm.mlir.constant"() {value = 0 : i32} : () -> i32

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.icmp'(0x278e9546200) {
  %77 = "llvm.icmp"(%75, %76) {predicate = 1 : i64} : (i32, i32) -> i1

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.cond_br'(0x278e94afc60) {
  "llvm.cond_br"(%77)[^bb1, ^bb2] {operand_segment_sizes = dense<[1, 0, 0]> : vector<3xi32>} : (i1) -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.icmp'(0x278e9545e80) {
  %81 = "llvm.icmp"(%69, %70) {predicate = 0 : i64} : (i64, i64) -> i1

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.br'(0x278e9475a30) {
  "llvm.br"(%81)[^bb3] : (i1) -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.br'(0x278e95131c0) {
  "llvm.br"()[^bb4] : () -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.cond_br'(0x278e94b02f0) {
  "llvm.cond_br"(%82)[^bb5, ^bb6] {operand_segment_sizes = dense<[1, 0, 0]> : vector<3xi32>} : (i1) -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.call'(0x278e942e880) {
  %123 = "llvm.call"(%28) {callee = @puts} : (!llvm.ptr<i8>) -> i32

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.return'(0x278e95f0980) {
  "llvm.return"() : () -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.load'(0x278e942f0c0) {
  %83 = "llvm.load"(%13) : (!llvm.ptr<struct<(ptr<i8>, i1)>>) -> !llvm.struct<(ptr<i8>, i1)>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.store'(0x278e9476660) {
  "llvm.store"(%83, %3) : (!llvm.struct<(ptr<i8>, i1)>, !llvm.ptr<struct<(ptr<i8>, i1)>>) -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.bitcast'(0x278e942e100) {
  %84 = "llvm.bitcast"(%1) : (!llvm.ptr<struct<(ptr<i8>, f64)>>) -> !llvm.ptr<i8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.bitcast'(0x278e942e280) {
  %85 = "llvm.bitcast"(%3) : (!llvm.ptr<struct<(ptr<i8>, i1)>>) -> !llvm.ptr<i8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.null'(0x278e94d7b00) {
  %86 = "llvm.mlir.null"() : () -> !llvm.ptr<struct<(ptr<i8>, i1)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x278e94d7ec0) {
  %87 = "llvm.mlir.constant"() {value = 1 : i64} : () -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x278e9544a60) {
  %88 = "llvm.getelementptr"(%86, %87) : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.ptrtoint'(0x278e942e340) {
  %89 = "llvm.ptrtoint"(%88) : (!llvm.ptr<struct<(ptr<i8>, i1)>>) -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.null'(0x278e94d6980) {
  %90 = "llvm.mlir.null"() : () -> !llvm.ptr<struct<(ptr<i8>, f64)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x278e94d7d80) {
  %91 = "llvm.mlir.constant"() {value = 1 : i64} : () -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x278e95440c0) {
  %92 = "llvm.getelementptr"(%90, %91) : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.ptrtoint'(0x278e942ffc0) {
  %93 = "llvm.ptrtoint"(%92) : (!llvm.ptr<struct<(ptr<i8>, f64)>>) -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.icmp'(0x278e9546e40) {
  %94 = "llvm.icmp"(%89, %93) {predicate = 6 : i64} : (i64, i64) -> i1

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.select'(0x278e9392f30) {
  %95 = "llvm.select"(%94, %89, %93) : (i1, i64, i64) -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x278e94d6340) {
  %96 = "llvm.mlir.constant"() {value = false} : () -> i1

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.call'(0x278e9458ba0) {
  "llvm.call"(%84, %85, %95, %96) {callee = @llvm.memcpy.p0i8.p0i8.i64} : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.load'(0x278e9430200) {
  %97 = "llvm.load"(%1) : (!llvm.ptr<struct<(ptr<i8>, f64)>>) -> !llvm.struct<(ptr<i8>, f64)>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.extractvalue'(0x278e9430a40) {
  %98 = "llvm.extractvalue"(%97) {position = [1 : i32]} : (!llvm.struct<(ptr<i8>, f64)>) -> f64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x278e94d71a0) {
  %99 = "llvm.mlir.constant"() {value = 50 : i32} : () -> i32

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.zext'(0x278e9430e00) {
  %100 = "llvm.zext"(%99) : (i32) -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.call'(0x278e9430bc0) {
  %101 = "llvm.call"(%100) {callee = @malloc} : (i64) -> !llvm.ptr<i8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.bitcast'(0x278e9430c80) {
  %102 = "llvm.bitcast"(%101) : (!llvm.ptr<i8>) -> !llvm.ptr<i8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.addressof'(0x278e94d7600) {
  %103 = "llvm.mlir.addressof"() {global_name = @frmt_555404038213028357} : () -> !llvm.ptr<array<3 x i8>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x278e94d60c0) {
  %104 = "llvm.mlir.constant"() {value = 0 : i64} : () -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x278e9393130) {
  %105 = "llvm.getelementptr"(%103, %104, %104) : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.call'(0x278e9412db0) {
  %106 = "llvm.call"(%102, %99, %105, %98) {callee = @sprintf_s} : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.addressof'(0x278e94d5c60) {
  %107 = "llvm.mlir.addressof"() {global_name = @s_12638117931323064703} : () -> !llvm.ptr<array<2 x i8>>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x278e94d7240) {
  %108 = "llvm.mlir.constant"() {value = 0 : i64} : () -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.getelementptr'(0x278e9391630) {
  %109 = "llvm.getelementptr"(%107, %108, %108) : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.intr.stacksave'(0x278e94d7380) {
  %110 = "llvm.intr.stacksave"() : () -> !llvm.ptr<i8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x278e94d7420) {
  %111 = "llvm.mlir.constant"() {value = 1 : i64} : () -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.call'(0x278e9433980) {
  %112 = "llvm.call"(%25) {callee = @strlen} : (!llvm.ptr<i8>) -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.add'(0x278e9546c80) {
  %113 = "llvm.add"(%111, %112) : (i64, i64) -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.call'(0x278e9433740) {
  %114 = "llvm.call"(%109) {callee = @strlen} : (!llvm.ptr<i8>) -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.add'(0x278e9544ec0) {
  %115 = "llvm.add"(%113, %114) : (i64, i64) -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.call'(0x278e9433440) {
  %116 = "llvm.call"(%102) {callee = @strlen} : (!llvm.ptr<i8>) -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.add'(0x278e9546740) {
  %117 = "llvm.add"(%115, %116) : (i64, i64) -> i64

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.alloca'(0x278e9432240) {
  %118 = "llvm.alloca"(%117) {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.call'(0x278e95470e0) {
  %119 = "llvm.call"(%118, %25) {callee = @strcpy} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.call'(0x278e95472a0) {
  %120 = "llvm.call"(%119, %109) {callee = @strcat} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.call'(0x278e9547380) {
  %121 = "llvm.call"(%120, %102) {callee = @strcat} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.call'(0x278e9433500) {
  %122 = "llvm.call"(%118) {callee = @puts} : (!llvm.ptr<i8>) -> i32

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.intr.stackrestore'(0x278e9514df0) {
  "llvm.intr.stackrestore"(%110) : (!llvm.ptr<i8>) -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.br'(0x278e9513f80) {
  "llvm.br"()[^bb6] : () -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.mlir.constant'(0x278e94d4860) {
  %78 = "llvm.mlir.constant"() {value = 0 : i32} : () -> i32

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.call'(0x278e9545080) {
  %79 = "llvm.call"(%67, %22) {callee = @strcmp} : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.icmp'(0x278e95456a0) {
  %80 = "llvm.icmp"(%79, %78) {predicate = 0 : i64} : (i32, i32) -> i1

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.br'(0x278e94771c0) {
  "llvm.br"(%80)[^bb3] : (i1) -> ()

} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x278e95149d0) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x278e9512980) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x278e9514500) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x278e9512c40) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x278e9513950) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x278e9513e20) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x278e9513690) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x278e95140e0) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x278e9514920) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x278e9512fb0) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x278e9515000) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x278e95150b0) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x278e9515160) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x278e9513740) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x278e95142f0) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x278e95137f0) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x278e9515210) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x278e9513a00) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x278e9513ab0) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x278e9513b60) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x278e9513ed0) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x278e950b550) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

//===-------------------------------------------===//
Legalizing operation : 'llvm.func'(0x278e950c9f0) {
} -> SUCCESS : operation marked legal by the target
//===-------------------------------------------===//

!! AFTER DUMP: 
module @"c:\\temp\\1.ts"  {
  llvm.func @strcat(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strcpy(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strlen(!llvm.ptr<i8>) -> i64
  llvm.func @sprintf_s(!llvm.ptr<i8>, i32, !llvm.ptr<i8>, ...) -> i32
  llvm.func @puts(!llvm.ptr<i8>) -> i32
  llvm.func @strcmp(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  llvm.func @llvm.memcpy.p0i8.p0i8.i64(!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1)
  llvm.mlir.global internal constant @s_9237349086447201248("number\00")
  llvm.mlir.global internal constant @s_13617892236937420068("b number: \00")
  llvm.mlir.global internal constant @s_6682479467004374669("done.\00")
  llvm.mlir.global internal constant @frmt_555404038213028357("%g\00")
  llvm.mlir.global internal constant @s_12638117931323064703(" \00")
  llvm.func @main() {
    %0 = llvm.mlir.constant(1 : i32) : i32
    %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %2 = llvm.mlir.constant(1 : i32) : i32
    %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %4 = llvm.mlir.constant(1 : i32) : i32
    %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %6 = llvm.mlir.constant(1 : i32) : i32
    %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %8 = llvm.mlir.constant(1 : i32) : i32
    %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %10 = llvm.mlir.constant(1 : i32) : i32
    %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %12 = llvm.mlir.constant(1 : i32) : i32
    %13 = llvm.alloca %12 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %14 = llvm.mlir.constant(1 : i32) : i32
    %15 = llvm.alloca %14 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %16 = llvm.mlir.constant(1.000000e+01 : f64) : f64
    %17 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %18 = llvm.mlir.constant(0 : i64) : i64
    %19 = llvm.getelementptr %17[%18, %18] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %20 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %21 = llvm.mlir.constant(0 : i64) : i64
    %22 = llvm.getelementptr %20[%21, %21] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %23 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
    %24 = llvm.mlir.constant(0 : i64) : i64
    %25 = llvm.getelementptr %23[%24, %24] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
    %27 = llvm.mlir.constant(0 : i64) : i64
    %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %29 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
    %30 = llvm.insertvalue %19, %29[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %31 = llvm.insertvalue %16, %30[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    llvm.store %31, %11 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %32 = llvm.bitcast %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %33 = llvm.bitcast %11 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %34 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %35 = llvm.mlir.constant(1 : i64) : i64
    %36 = llvm.getelementptr %34[%35] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %37 = llvm.ptrtoint %36 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %38 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %39 = llvm.mlir.constant(1 : i64) : i64
    %40 = llvm.getelementptr %38[%39] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %41 = llvm.ptrtoint %40 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %42 = llvm.icmp "ult" %37, %41 : i64
    %43 = llvm.select %42, %37, %41 : i1, i64
    %44 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%32, %33, %43, %44) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    %45 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    llvm.store %45, %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %46 = llvm.load %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %47 = llvm.extractvalue %46[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %48 = llvm.extractvalue %46[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %49 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %50 = llvm.insertvalue %48, %49[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %51 = llvm.insertvalue %47, %50[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    llvm.store %51, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %52 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
    %53 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %54 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %55 = llvm.mlir.constant(1 : i64) : i64
    %56 = llvm.getelementptr %54[%55] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %57 = llvm.ptrtoint %56 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %58 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %59 = llvm.mlir.constant(1 : i64) : i64
    %60 = llvm.getelementptr %58[%59] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %61 = llvm.ptrtoint %60 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
    %62 = llvm.icmp "ult" %57, %61 : i64
    %63 = llvm.select %62, %57, %61 : i1, i64
    %64 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%52, %53, %63, %64) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    %65 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    llvm.store %65, %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %66 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %67 = llvm.extractvalue %66[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
    %68 = llvm.mlir.constant(0 : i64) : i64
    %69 = llvm.ptrtoint %67 : !llvm.ptr<i8> to i64
    %70 = llvm.ptrtoint %22 : !llvm.ptr<i8> to i64
    %71 = llvm.icmp "ne" %69, %68 : i64
    %72 = llvm.icmp "ne" %70, %68 : i64
    %73 = llvm.zext %71 : i1 to i32
    %74 = llvm.zext %72 : i1 to i32
    %75 = llvm.and %73, %74  : i32
    %76 = llvm.mlir.constant(0 : i32) : i32
    %77 = llvm.icmp "ne" %75, %76 : i32
    llvm.cond_br %77, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %78 = llvm.mlir.constant(0 : i32) : i32
    %79 = llvm.call @strcmp(%67, %22) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
    %80 = llvm.icmp "eq" %79, %78 : i32
    llvm.br ^bb3(%80 : i1)
  ^bb2:  // pred: ^bb0
    %81 = llvm.icmp "eq" %69, %70 : i64
    llvm.br ^bb3(%81 : i1)
  ^bb3(%82: i1):  // 2 preds: ^bb1, ^bb2
    llvm.br ^bb4
  ^bb4:  // pred: ^bb3
    llvm.cond_br %82, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    %83 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    llvm.store %83, %3 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %84 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %85 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
    %86 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %87 = llvm.mlir.constant(1 : i64) : i64
    %88 = llvm.getelementptr %86[%87] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %89 = llvm.ptrtoint %88 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
    %90 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %91 = llvm.mlir.constant(1 : i64) : i64
    %92 = llvm.getelementptr %90[%91] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %93 = llvm.ptrtoint %92 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %94 = llvm.icmp "ult" %89, %93 : i64
    %95 = llvm.select %94, %89, %93 : i1, i64
    %96 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%84, %85, %95, %96) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    %97 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %98 = llvm.extractvalue %97[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %99 = llvm.mlir.constant(50 : i32) : i32
    %100 = llvm.zext %99 : i32 to i64
    %101 = llvm.call @malloc(%100) : (i64) -> !llvm.ptr<i8>
    %102 = llvm.bitcast %101 : !llvm.ptr<i8> to !llvm.ptr<i8>
    %103 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
    %104 = llvm.mlir.constant(0 : i64) : i64
    %105 = llvm.getelementptr %103[%104, %104] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %106 = llvm.call @sprintf_s(%102, %99, %105, %98) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
    %107 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
    %108 = llvm.mlir.constant(0 : i64) : i64
    %109 = llvm.getelementptr %107[%108, %108] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %110 = llvm.intr.stacksave : !llvm.ptr<i8>
    %111 = llvm.mlir.constant(1 : i64) : i64
    %112 = llvm.call @strlen(%25) : (!llvm.ptr<i8>) -> i64
    %113 = llvm.add %111, %112  : i64
    %114 = llvm.call @strlen(%109) : (!llvm.ptr<i8>) -> i64
    %115 = llvm.add %113, %114  : i64
    %116 = llvm.call @strlen(%102) : (!llvm.ptr<i8>) -> i64
    %117 = llvm.add %115, %116  : i64
    %118 = llvm.alloca %117 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
    %119 = llvm.call @strcpy(%118, %25) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %120 = llvm.call @strcat(%119, %109) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %121 = llvm.call @strcat(%120, %102) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %122 = llvm.call @puts(%118) : (!llvm.ptr<i8>) -> i32
    llvm.intr.stackrestore %110
    llvm.br ^bb6
  ^bb6:  // 2 preds: ^bb4, ^bb5
    %123 = llvm.call @puts(%28) : (!llvm.ptr<i8>) -> i32
    llvm.return
  }
  llvm.func @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>) attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64 attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>) attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>) attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>) attributes {sym_visibility = "private"}
  llvm.func @malloc(i64) -> !llvm.ptr<i8>
  llvm.func @free(!llvm.ptr<i8>)
}
** Insert  : 'llvm.func'(0x278e9514a80)
** Insert  : 'llvm.call'(0x278e95f0620)
module @"c:\\temp\\1.ts"  {
  llvm.func @GC_init()
  llvm.func @strcat(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strcpy(!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
  llvm.func @strlen(!llvm.ptr<i8>) -> i64
  llvm.func @sprintf_s(!llvm.ptr<i8>, i32, !llvm.ptr<i8>, ...) -> i32
  llvm.func @puts(!llvm.ptr<i8>) -> i32
  llvm.func @strcmp(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
  llvm.func @llvm.memcpy.p0i8.p0i8.i64(!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1)
  llvm.mlir.global internal constant @s_9237349086447201248("number\00")
  llvm.mlir.global internal constant @s_13617892236937420068("b number: \00")
  llvm.mlir.global internal constant @s_6682479467004374669("done.\00")
  llvm.mlir.global internal constant @frmt_555404038213028357("%g\00")
  llvm.mlir.global internal constant @s_12638117931323064703(" \00")
  llvm.func @main() {
    llvm.call @GC_init() : () -> ()
    %0 = llvm.mlir.constant(1 : i32) : i32
    %1 = llvm.alloca %0 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %2 = llvm.mlir.constant(1 : i32) : i32
    %3 = llvm.alloca %2 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %4 = llvm.mlir.constant(1 : i32) : i32
    %5 = llvm.alloca %4 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %6 = llvm.mlir.constant(1 : i32) : i32
    %7 = llvm.alloca %6 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %8 = llvm.mlir.constant(1 : i32) : i32
    %9 = llvm.alloca %8 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %10 = llvm.mlir.constant(1 : i32) : i32
    %11 = llvm.alloca %10 x !llvm.struct<(ptr<i8>, f64)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %12 = llvm.mlir.constant(1 : i32) : i32
    %13 = llvm.alloca %12 x !llvm.struct<(ptr<i8>, i1)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %14 = llvm.mlir.constant(1 : i32) : i32
    %15 = llvm.alloca %14 x !llvm.struct<(ptr<i8>, ptr<i8>)> : (i32) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %16 = llvm.mlir.constant(1.000000e+01 : f64) : f64
    %17 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %18 = llvm.mlir.constant(0 : i64) : i64
    %19 = llvm.getelementptr %17[%18, %18] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %20 = llvm.mlir.addressof @s_9237349086447201248 : !llvm.ptr<array<7 x i8>>
    %21 = llvm.mlir.constant(0 : i64) : i64
    %22 = llvm.getelementptr %20[%21, %21] : (!llvm.ptr<array<7 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %23 = llvm.mlir.addressof @s_13617892236937420068 : !llvm.ptr<array<11 x i8>>
    %24 = llvm.mlir.constant(0 : i64) : i64
    %25 = llvm.getelementptr %23[%24, %24] : (!llvm.ptr<array<11 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %26 = llvm.mlir.addressof @s_6682479467004374669 : !llvm.ptr<array<6 x i8>>
    %27 = llvm.mlir.constant(0 : i64) : i64
    %28 = llvm.getelementptr %26[%27, %27] : (!llvm.ptr<array<6 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %29 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, f64)>
    %30 = llvm.insertvalue %19, %29[0 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %31 = llvm.insertvalue %16, %30[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    llvm.store %31, %11 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %32 = llvm.bitcast %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %33 = llvm.bitcast %11 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %34 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %35 = llvm.mlir.constant(1 : i64) : i64
    %36 = llvm.getelementptr %34[%35] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %37 = llvm.ptrtoint %36 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %38 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %39 = llvm.mlir.constant(1 : i64) : i64
    %40 = llvm.getelementptr %38[%39] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %41 = llvm.ptrtoint %40 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %42 = llvm.icmp "ult" %37, %41 : i64
    %43 = llvm.select %42, %37, %41 : i1, i64
    %44 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%32, %33, %43, %44) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    %45 = llvm.load %9 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    llvm.store %45, %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %46 = llvm.load %15 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %47 = llvm.extractvalue %46[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %48 = llvm.extractvalue %46[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %49 = llvm.mlir.undef : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %50 = llvm.insertvalue %48, %49[0 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    %51 = llvm.insertvalue %47, %50[1 : i32] : !llvm.struct<(ptr<i8>, ptr<i8>)>
    llvm.store %51, %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %52 = llvm.bitcast %5 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
    %53 = llvm.bitcast %7 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to !llvm.ptr<i8>
    %54 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %55 = llvm.mlir.constant(1 : i64) : i64
    %56 = llvm.getelementptr %54[%55] : (!llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>>
    %57 = llvm.ptrtoint %56 : !llvm.ptr<struct<(ptr<i8>, ptr<i8>)>> to i64
    %58 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %59 = llvm.mlir.constant(1 : i64) : i64
    %60 = llvm.getelementptr %58[%59] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %61 = llvm.ptrtoint %60 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
    %62 = llvm.icmp "ult" %57, %61 : i64
    %63 = llvm.select %62, %57, %61 : i1, i64
    %64 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%52, %53, %63, %64) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    %65 = llvm.load %5 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    llvm.store %65, %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %66 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %67 = llvm.extractvalue %66[0 : i32] : !llvm.struct<(ptr<i8>, i1)>
    %68 = llvm.mlir.constant(0 : i64) : i64
    %69 = llvm.ptrtoint %67 : !llvm.ptr<i8> to i64
    %70 = llvm.ptrtoint %22 : !llvm.ptr<i8> to i64
    %71 = llvm.icmp "ne" %69, %68 : i64
    %72 = llvm.icmp "ne" %70, %68 : i64
    %73 = llvm.zext %71 : i1 to i32
    %74 = llvm.zext %72 : i1 to i32
    %75 = llvm.and %73, %74  : i32
    %76 = llvm.mlir.constant(0 : i32) : i32
    %77 = llvm.icmp "ne" %75, %76 : i32
    llvm.cond_br %77, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    %78 = llvm.mlir.constant(0 : i32) : i32
    %79 = llvm.call @strcmp(%67, %22) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> i32
    %80 = llvm.icmp "eq" %79, %78 : i32
    llvm.br ^bb3(%80 : i1)
  ^bb2:  // pred: ^bb0
    %81 = llvm.icmp "eq" %69, %70 : i64
    llvm.br ^bb3(%81 : i1)
  ^bb3(%82: i1):  // 2 preds: ^bb1, ^bb2
    llvm.br ^bb4
  ^bb4:  // pred: ^bb3
    llvm.cond_br %82, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    %83 = llvm.load %13 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    llvm.store %83, %3 : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %84 = llvm.bitcast %1 : !llvm.ptr<struct<(ptr<i8>, f64)>> to !llvm.ptr<i8>
    %85 = llvm.bitcast %3 : !llvm.ptr<struct<(ptr<i8>, i1)>> to !llvm.ptr<i8>
    %86 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, i1)>>
    %87 = llvm.mlir.constant(1 : i64) : i64
    %88 = llvm.getelementptr %86[%87] : (!llvm.ptr<struct<(ptr<i8>, i1)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, i1)>>
    %89 = llvm.ptrtoint %88 : !llvm.ptr<struct<(ptr<i8>, i1)>> to i64
    %90 = llvm.mlir.null : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %91 = llvm.mlir.constant(1 : i64) : i64
    %92 = llvm.getelementptr %90[%91] : (!llvm.ptr<struct<(ptr<i8>, f64)>>, i64) -> !llvm.ptr<struct<(ptr<i8>, f64)>>
    %93 = llvm.ptrtoint %92 : !llvm.ptr<struct<(ptr<i8>, f64)>> to i64
    %94 = llvm.icmp "ult" %89, %93 : i64
    %95 = llvm.select %94, %89, %93 : i1, i64
    %96 = llvm.mlir.constant(false) : i1
    llvm.call @llvm.memcpy.p0i8.p0i8.i64(%84, %85, %95, %96) : (!llvm.ptr<i8>, !llvm.ptr<i8>, i64, i1) -> ()
    %97 = llvm.load %1 : !llvm.ptr<struct<(ptr<i8>, f64)>>
    %98 = llvm.extractvalue %97[1 : i32] : !llvm.struct<(ptr<i8>, f64)>
    %99 = llvm.mlir.constant(50 : i32) : i32
    %100 = llvm.zext %99 : i32 to i64
    %101 = llvm.call @GC_malloc(%100) : (i64) -> !llvm.ptr<i8>
    %102 = llvm.bitcast %101 : !llvm.ptr<i8> to !llvm.ptr<i8>
    %103 = llvm.mlir.addressof @frmt_555404038213028357 : !llvm.ptr<array<3 x i8>>
    %104 = llvm.mlir.constant(0 : i64) : i64
    %105 = llvm.getelementptr %103[%104, %104] : (!llvm.ptr<array<3 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %106 = llvm.call @sprintf_s(%102, %99, %105, %98) : (!llvm.ptr<i8>, i32, !llvm.ptr<i8>, f64) -> i32
    %107 = llvm.mlir.addressof @s_12638117931323064703 : !llvm.ptr<array<2 x i8>>
    %108 = llvm.mlir.constant(0 : i64) : i64
    %109 = llvm.getelementptr %107[%108, %108] : (!llvm.ptr<array<2 x i8>>, i64, i64) -> !llvm.ptr<i8>
    %110 = llvm.intr.stacksave : !llvm.ptr<i8>
    %111 = llvm.mlir.constant(1 : i64) : i64
    %112 = llvm.call @strlen(%25) : (!llvm.ptr<i8>) -> i64
    %113 = llvm.add %111, %112  : i64
    %114 = llvm.call @strlen(%109) : (!llvm.ptr<i8>) -> i64
    %115 = llvm.add %113, %114  : i64
    %116 = llvm.call @strlen(%102) : (!llvm.ptr<i8>) -> i64
    %117 = llvm.add %115, %116  : i64
    %118 = llvm.alloca %117 x i8 {alignment = 1 : i64} : (i64) -> !llvm.ptr<i8>
    %119 = llvm.call @strcpy(%118, %25) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %120 = llvm.call @strcat(%119, %109) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %121 = llvm.call @strcat(%120, %102) : (!llvm.ptr<i8>, !llvm.ptr<i8>) -> !llvm.ptr<i8>
    %122 = llvm.call @puts(%118) : (!llvm.ptr<i8>) -> i32
    llvm.intr.stackrestore %110
    llvm.br ^bb6
  ^bb6:  // 2 preds: ^bb4, ^bb5
    %123 = llvm.call @puts(%28) : (!llvm.ptr<i8>) -> i32
    llvm.return
  }
  llvm.func @mlirAsyncRuntimeAddRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeDropRef(!llvm.ptr<i8>, i32) attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeCreateToken() -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeCreateValue(i32) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeCreateGroup(i64) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeEmplaceToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeEmplaceValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeSetTokenError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeSetValueError(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeIsTokenError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeIsValueError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeIsGroupError(!llvm.ptr<i8>) -> i1 attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeAwaitToken(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeAwaitValue(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeAwaitAllInGroup(!llvm.ptr<i8>) attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeExecute(!llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>) attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeGetValueStorage(!llvm.ptr<i8>) -> !llvm.ptr<i8> attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeAddTokenToGroup(!llvm.ptr<i8>, !llvm.ptr<i8>) -> i64 attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeAwaitTokenAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>) attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeAwaitValueAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>) attributes {sym_visibility = "private"}
  llvm.func @mlirAsyncRuntimeAwaitAllInGroupAndExecute(!llvm.ptr<i8>, !llvm.ptr<i8>, !llvm.ptr<func<void (ptr<i8>)>>) attributes {sym_visibility = "private"}
  llvm.func @GC_malloc(i64) -> !llvm.ptr<i8>
  llvm.func @GC_free(!llvm.ptr<i8>)
}
